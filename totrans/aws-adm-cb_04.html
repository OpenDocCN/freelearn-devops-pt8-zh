<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">Using AWS Compute</h1>
            </header>

            <article>
                
<p>In this chapter, we will cover:</p>
<ul>
<li>Creating a key pair</li>
<li>Launching an instance</li>
<li>Attaching storage</li>
<li>Securely accessing private instances</li>
<li>Auto scaling an application server</li>
<li>Creating machine images</li>
<li>Creating security groups</li>
<li>Creating a load balancer</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Introduction</h1>
            </header>

            <article>
                
<p><strong>Elastic Cloud Compute</strong> (<strong>EC2</strong>) is by far the most utilized and complex service in the AWS catalogue. More than <em>just virtual machines</em>, EC2 provides a framework of sub-services to help you secure and manage your instances elastically.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating a key pair</h1>
            </header>

            <article>
                
<p>A key pair is used to access your instances via SSH. This is the quickest and easiest way to access your instances.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Getting ready</h1>
            </header>

            <article>
                
<p>To perform this recipe, you must have your AWS CLI tool configured correctly.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Create the key pair, and save it to disk:</li>
</ol>
<pre>
<strong>      aws ec2 create-key-pair \</strong><br/>        <strong>--key-name MyEC2KeyPair \</strong><br/>        <strong>--query 'KeyMaterial' \</strong><br/>        <strong>--output text &gt; ec2keypair.pem</strong>
</pre>
<ol start="2">
<li>Change the permissions on the created file:</li>
</ol>
<pre>
        <strong>chmod 600 ec2keypair.pem</strong>
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>This call requests a new private key from EC2. The response is then parsed using a JMESPath query, and the private key (in the <kbd>KeyMaterial</kbd> property) is saved to a new key file with the <kbd>.pem</kbd> extension.</p>
<p>Finally, we change the permissions on the key file so that it cannot be read by other users<span><span>—</span></span>this is required before SSH will allow you to use it.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Launching an instance</h1>
            </header>

            <article>
                
<p>There will be scenarios<span><span>—</span></span>usually when testing and developing your infrastructure code<span><span>—</span></span>when you need quick access to an instance. Creating it via the AWS CLI is the quickest and most consistent way to create one-off instances.</p>
<p>There are other recipes in the book that will require a running instance. This recipe will get you started.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Getting ready</h1>
            </header>

            <article>
                
<p>For this recipe, you must have an existing key pair.</p>
<p>In this recipe, we are launching an instance of AWS Linux using an AMI ID in the <kbd>us-east-1</kbd> region. If you are working in a different region, you will need to update your <kbd>image-id</kbd> parameter.</p>
<p>You must have configured your AWS CLI tool with working credentials.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<p>Run the following AWS CLI command, using your own key-pair name:</p>
<pre>
<strong>      aws ec2 run-instances \</strong><br/>        <strong>--image-id ami-9be6f38c \</strong><br/>        <strong>--instance-type t2.micro \</strong><br/>        <strong>--key-name &lt;your-key-pair-name&gt;</strong>
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>While you can create an instance via the AWS web console, it involves many distracting options. When developing and testing, the CLI tool is the best way to provision instances.</p>
<p>While the <kbd>key-name</kbd> argument is optional, you will not be able to connect to your instance unless you have pre-configured some other way of logging in.</p>
<div class="packt_infobox">The <kbd>t2.micro</kbd> instance type used in this recipe is included in the AWS free tier. You can run one micro instance per month for free during the first 12 months of your usage. See <a href="https://aws.amazon.com/free"><span class="URLPACKT">https://aws.amazon.com/free</span></a> for more information.</div>
<p>As no VPC or security groups are specified, the instance will be launched in your account's default VPC and security group. The default security group allows access from anywhere, on all ports, and so is not suitable for long-lived instances. You can modify an instance's security groups after it is launched, without stopping it.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">There's more...</h1>
            </header>

            <article>
                
<p>If you have created your own AMI, then you can change the <kbd>image-id</kbd> argument to quickly launch your specific AMI.</p>
<p>You may also want to take note of the <kbd>InstanceId</kbd> value in the response from the API, as you may need it for future commands.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<ul>
<li>The <em>Creating a key pair</em> recipe</li>
<li>The <em>Creating machine images</em> recipe</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Attaching storage</h1>
            </header>

            <article>
                
<p>Ideally, you will have defined all your storage requirements up-front as code using a service such as CloudFormation. However, sometimes that is not possible due to application restrictions or changing requirements.</p>
<p>You can easily add additional storage to your instances while they are running by attaching a new volume.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Getting ready</h1>
            </header>

            <article>
                
<p>For this recipe, you will need the following:</p>
<ul>
<li>A running instance's ID. It will start with <kbd>i-</kbd> followed by alphanumeric characters.</li>
<li>The AZ the instance is running in. This looks like the region name with a letter after it; for example, <kbd>us-east-1a</kbd>.</li>
</ul>
<p>In this recipe, we are using an AWS Linux instance. If you are using a different operating system, the steps to mount the volume will be different. We will be running an instance in the AZ <kbd>us-east-1a</kbd>.</p>
<p>You must have configured your AWS CLI tool with working credentials.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Create a volume:</li>
</ol>
<pre>
<strong>      aws ec2 create-volume --availability-zone us-east-1a<br/></strong>
</pre>
<div class="packt_infobox">Take note of the returned <kbd>VolumeId</kbd> in the response. It will start with <kbd>vol-</kbd> followed by alphanumeric characters.</div>
<ol start="2">
<li>Attach the volume to the instance, using the volume ID noted in the last step and the instance ID you started with:</li>
</ol>
<pre>
<strong>      aws ec2 attach-volume \</strong><br/>        <strong>--volume-id &lt;your-volume-id&gt; \</strong><br/>        <strong>--instance-id &lt;your-instance-id&gt; \</strong><br/>        <strong>--device /dev/sdf</strong>
</pre>
<ol start="3">
<li>On the instance itself, mount the volume device:</li>
</ol>
<pre>
<strong>      mount /dev/xvdf /mnt/volume</strong>
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>In this recipe, we start by creating a volume. Volumes are created from snapshots. If you do not specify a snapshot ID it uses a blank snapshot, and you get a blank volume.</p>
<p>While volumes are hosted redundantly, they are only hosted in a single AZ, so must be provisioned in the same AZ the instance is running in.</p>
<p>The <kbd>create-volume</kbd> command returns a response that includes the newly created volume's <kbd>VolumeId</kbd>. We then use this ID in the next step.</p>
<div class="packt_tip">It can sometimes take a few seconds for a volume to become available. If you are scripting these commands, use the <kbd>aws ec2 wait</kbd> command to wait for the volume to become available.</div>
<p>In step 3, we attach a volume to the instance. When attaching to an instance, you must specify the name of the device that it will be presented to the operating system as. Unfortunately, this does not guarantee what the device will appear as. In the case of AWS Linux, <kbd>/dev/sdf</kbd> becomes <kbd>/dev/xvdf</kbd>.</p>
<div class="packt_infobox">Device naming is kernel-specific, so if you are using something other than AWS Linux, the device name may be different. See <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/device_naming.html"><span class="URLPACKT">http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/device_naming.html</span></a> for full details.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<ul>
<li>The <em>Launching an instance</em> recipe</li>
<li>The <em>Working with network storage</em> recipe in <a href="3061e8a1-9092-4f75-931a-8c4da66160b7.xhtml"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>Storage and Content Delivery</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Securely accessing private instances</h1>
            </header>

            <article>
                
<p>Any instance or resource living in a private subnet in your VPC will be inaccessible from the Internet. This makes good sense from a security perspective because it gives your instances a higher level of protection.</p>
<p>Of course, if they can't be accessed from the Internet, then they're not going to be easy to administer.</p>
<p>One common pattern is to use a VPN server as a single, highly controlled, entry point to your private network. This is what we're going to show you in this recipe, as pictured in the following diagram:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" src="assets/B06236_04_01.png"/></div>
<div class="packt_figure CDPAlignCenter packt_figref">Accessing private instances securely</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Getting ready</h1>
            </header>

            <article>
                
<p>We're going to use OpenVPN for this example. They provide a free (for up to two users) AMI in the AWS marketplace, which has OpenVPN already installed and configured. You'll need to accept the terms and conditions for using this AMI. You can do so by visiting the AMI's marketplace page at <a href="https://aws.amazon.com/marketplace/pp/B00MI40CAE/"><span class="URLPACKT">https://aws.amazon.com/marketplace/pp/B00MI40CAE/</span></a>.</p>
<p>You need to decide on a password, which will be your <em>temporary</em> admin password. We'll feed this password into a CloudFormation template and then change it after we create our stack.</p>
<div class="packt_tip">You can use the default VPC for this example.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Create a new CloudFormation template and add the following <kbd>Mappings</kbd>. This is a list of all the latest <kbd>OpenVPN</kbd> AMIs in each region. We're adding these to maximize region portability for our template<span><span>—</span></span>you can omit the regions you have no intention of using:</li>
</ol>
<pre>
      Mappings: <br/>        AWSRegion2AMI: # Latest OpenVPN AMI at time of publishing: 2.1.4 <br/>          us-east-1: <br/>            AMI: ami-bc3566ab <br/>          us-east-2: <br/>            AMI: ami-10306a75 <br/>          us-west-2: <br/>            AMI: ami-d3e743b3 <br/>          us-west-1: <br/>            AMI: ami-4a02492a <br/>          eu-west-1: <br/>            AMI: ami-f53d7386 <br/>          eu-central-1: <br/>            AMI: ami-ad1fe6c2 <br/>          ap-southeast-1: <br/>            AMI: ami-a859ffcb <br/>          ap-northeast-1: <br/>            AMI: ami-e9da7c88 <br/>          ap-southeast-2: <br/>            AMI: ami-89477aea <br/>          sa-east-1: <br/>            AMI: ami-0c069b60
</pre>
<ol start="2">
<li>We now need to define some <kbd>Parameters</kbd>. Firstly we'll need to know which VPC and subnet to deploy our VPN instance to. Note that you need to specify a <em>public</em> subnet here, otherwise you won't be able to access your OpenVPN server:</li>
</ol>
<pre>
      VpcId: <br/>        Type: AWS::EC2::VPC::Id <br/>        Description: VPC where load balancer and instance will launch <br/>      SubnetId: <br/>        Type: List&lt;AWS::EC2::Subnet::Id&gt; <br/>        Description: Subnet where OpenVPN server will launch <br/>         (pick at least 1)
</pre>
<ol start="3">
<li>We also need to define <kbd>InstanceType</kbd> and <kbd>KeyName</kbd>. These are the EC2 instance class and SSH key pair to use to launch our OpenVPN server:</li>
</ol>
<pre>
      InstanceType: <br/>        Type: String <br/>        Description: OpenVPN server instance type <br/>        Default: m3.medium <br/>      KeyName: <br/>        Type: AWS::EC2::KeyPair::KeyName <br/>        Description: EC2 KeyPair for SSH access
</pre>
<ol start="4">
<li>We need a parameter for <kbd>AdminPassword</kbd>. This is the temporary password which will be given to the <kbd>openvpn</kbd> user (administrator) when the server starts up:</li>
</ol>
<pre>
      AdminPassword: <br/>        Type: String <br/>        Description: Password for 'openvpn' user <br/>        Default: openvpn <br/>        NoEcho: true
</pre>
<ol start="5">
<li>The last parameter is the CIDR block, which we wish to allow to connect to our VPN server. You may wish to lock this down to the public IP range of your corporate network, for example:</li>
</ol>
<pre>
      AllowAccessFromCIDR: <br/>        Type: String <br/>        Description: IP range/address to allow VPN connections from <br/>        Default: "0.0.0.0/0"
</pre>
<ol start="6">
<li>The first <kbd>Resource</kbd> we need to define is the security group our OpenVPN server will live in. You'll also use this security group to allow access to other resources in your network. Add it to your template as follows:</li>
</ol>
<pre>
      VPNSecurityGroup: <br/>        Type: AWS::EC2::SecurityGroup <br/>        Properties: <br/>          GroupDescription: Inbound access to OpenVPN server <br/>          VpcId: !Ref VpcId <br/>          SecurityGroupIngress: <br/>          - CidrIp: !Ref AllowAccessFromCIDR <br/>            FromPort: 443 <br/>            IpProtocol: tcp <br/>            ToPort: 443 <br/>          - CidrIp: !Ref AllowAccessFromCIDR <br/>            FromPort: 22 <br/>            IpProtocol: tcp <br/>            ToPort: 22 <br/>          - CidrIp: !Ref AllowAccessFromCIDR <br/>            FromPort: 1194 <br/>            IpProtocol: udp <br/>            ToPort: 1194
</pre>
<ol start="7">
<li>We can now define the actual OpenVPN instance itself. You'll notice that we are explicitly configuring the network interface. This is required, because we want to declare that this instance must get a public IP address (otherwise you won't be able to access it). In the <kbd>UserData</kbd>, we declare some variables that the OpenVPN software will pick up when it starts so that it can configure itself:</li>
</ol>
<pre>
      OpenVPNInstance: <br/>        Type: AWS::EC2::Instance <br/>        Properties: <br/>          ImageId: !FindInMap [ AWSRegion2AMI, !Ref "AWS::Region", AMI ] <br/>          InstanceType: !Ref InstanceType <br/>          KeyName: !Ref KeyName <br/>          NetworkInterfaces: <br/>            - AssociatePublicIpAddress: true <br/>              DeviceIndex: "0" <br/>              GroupSet: <br/>                - !Ref VPNSecurityGroup <br/>              SubnetId: !Select [ 0, Ref: SubnetId ] <br/>          Tags: <br/>            - Key: Name <br/>              Value: example-openvpn-server <br/>          UserData: <br/>            Fn::Base64: !Sub <br/>              - | <br/>                public_hostname=openvpn <br/>                admin_user=openvpn <br/>                admin_pw=${admin_pw} <br/>                reroute_gw=1 <br/>                reroute_dns=1 <br/>              - admin_pw: !Ref AdminPassword
</pre>
<ol start="8">
<li>Finally, we add some helpful <kbd>Outputs</kbd>:</li>
</ol>
<pre>
      Outputs: <br/>        OpenVPNAdministration: <br/>          Value: <br/>            Fn::Join: <br/>              - "" <br/>              - - https:// <br/>                - !GetAtt OpenVPNInstance.PublicIp <br/>                - /admin/ <br/>          Description: Admin URL for OpenVPN server <br/>        OpenVPNClientLogin: <br/>          Value: <br/>            Fn::Join: <br/>              - "" <br/>              - - https:// <br/>                - !GetAtt OpenVPNInstance.PublicIp <br/>                - / <br/>          Description: Client login URL for OpenVPN server <br/>        OpenVPNServerIPAddress: <br/>          Value: !GetAtt OpenVPNInstance.PublicIp <br/>          Description: IP address for OpenVPN server
</pre>
<ol start="9">
<li>Go ahead and launch this stack in the CloudFormation web console, or via the CLI, with the following command:</li>
</ol>
<pre>
 <strong>     aws cloudformation create-stack \ <br/>        --template-body file://04-securely-access-private-instances.yaml \ <br/>        --stack-name example-vpn \ <br/>        --parameters \ <br/>        ParameterKey=KeyName,ParameterValue=&lt;key-pair-name&gt; \ <br/>        ParameterKey=VpcId,ParameterValue=&lt;your-vpc-id&gt; \ <br/>        ParameterKey=SubnetId,ParameterValue=&lt;your-public-subnet-id&gt; <br/></strong>
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Configuration</h1>
            </header>

            <article>
                
<ol>
<li>Once your stack is created, you'll want to change the password for the <kbd>openvpn</kbd> user (administrator). Go to the admin control panel and do this now: <kbd>https://&lt;ip-or-hostname-of-vpn-server&gt;/admin</kbd>. If your VPN server is operating as expected you'll be greeted with a status page after logging in, as pictured in the following screenshot:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" src="assets/B06236_04_02.png"/></div>
<p style="padding-left: 60px">While you're there, you should create a non-administrator user account. This will be the account you'll use to connect to the VPN. Add this account on the <span class="packt_screen">User Permissions</span> page as pictured in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" src="assets/B06236_04_03-1.png"/></div>
<ol start="2">
<li>Under <span class="packt_screen">Server Network Settings</span>, in the <span class="packt_screen">Hostname or IP address</span> field, enter the hostname or IP address of the server. This step is important, and when you download your OpenVPN config file from the server (next step), it will make your life much easier if it has the correct hostname or IP address in it. The next screenshot shows what you can expect to see on the <span class="packt_screen">Server Network Settings</span> page:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" src="assets/B06236_04_04.png"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>You should now be able to connect to your VPN server. Go to the user login page and log in with the credentials you gave to the previously mentioned non-administrator user:</p>
<p><kbd>https://&lt;ip-or-hostname-of-vpn-server&gt;/</kbd></p>
<p>After logging in, you will have the option to download the OpenVPN client with configuration which is specific to your account. Alternatively, if you already have a VPN client installed, you can just download the configuration on its own.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">There's more...</h1>
            </header>

            <article>
                
<p>There are a couple of important points you'll need to keep in mind now that you are up and running with an OpenVPN server:</p>
<ul>
<li>If you need to SSH to the instance, you must connect with the username <kbd>openvpnas</kbd></li>
<li>To access your other instances, you'll need to allow connections from the VPN security group created in this recipe</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Auto scaling an application server</h1>
            </header>

            <article>
                
<p><strong>Auto scaling</strong> is a fundamental component of compute in the cloud. It provides not only the ability to scale up and down in response to application load, but also redundancy, by ensuring that capacity is always available. Even in the unlikely event of an AZ outage, the auto scaling group will ensure that instances are available to run your application.</p>
<p>Auto scaling also allows you to pay for only the EC2 capacity you need, because underutilized servers can be automatically de-provisioned.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Getting ready</h1>
            </header>

            <article>
                
<p>You must supply two or more subnet IDs for this recipe to work.</p>
<p>The following example uses an AWS Linux AMI in the <kbd>us-east-1</kbd> region. Update the parameters as required if you are working in a different region.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Start by defining the template version and description:</li>
</ol>
<pre>
      AWSTemplateFormatVersion: "2010-09-09"<br/>      Description: Create an Auto Scaling Group
</pre>
<ol start="2">
<li>Add a <kbd>Parameters</kbd> section with the required parameters that will be used later in the template:</li>
</ol>
<pre>
      Parameters:<br/>        SubnetIds:<br/>          Description: Subnet IDs where instances can be launched<br/>          Type: List&lt;AWS::EC2::Subnet::Id&gt;
</pre>
<ol start="3">
<li>Still under the <kbd>Parameters</kbd> section, add the optional instance configuration parameters:</li>
</ol>
<pre>
    <strong>  </strong>AmiId: <br/>        Description: The application server's AMI ID <br/>        Type: AWS::EC2::Image::Id <br/>        Default: ami-9be6f38c # AWS Linux in us-east-1 <br/>      InstanceType: <br/>        Description: The type of instance to launch <br/>        Type: String <br/>        Default: t2.micro
</pre>
<ol start="4">
<li>Still under the <kbd>Parameters</kbd> section, add the optional auto scaling group-configuration parameters:</li>
</ol>
<pre>
      MinSize: <br/>        Description: Minimum number of instances in the group <br/>        Type: Number <br/>        Default: 1<br/>      MaxSize: <br/>        Description: Maximum number of instances in the group <br/>        Type: Number <br/>        Default: 4 <br/> <br/>      ThresholdCPUHigh: <br/>        Description: Launch new instances when CPU utilization <br/>          is over this threshold <br/>        Type: Number <br/>        Default: 60 <br/> <br/>      ThresholdCPULow: <br/>        Description: Remove instances when CPU utilization<br/>          is under this threshold <br/>        Type: Number <br/>        Default: 40 <br/> <br/>      ThresholdMinutes: <br/>        Description: Launch new instances when over the CPU <br/>          threshold for this many minutes <br/>        Type: Number <br/>        Default: 5
</pre>
<ol start="5">
<li>Add a <kbd>Resources</kbd> section, and define the auto scaling group resource:</li>
</ol>
<pre>
      Resources: <br/>        AutoScalingGroup: <br/>          Type: AWS::AutoScaling::AutoScalingGroup <br/>          Properties: <br/>            MinSize: !Ref MinSize <br/>            MaxSize: !Ref MaxSize <br/>            LaunchConfigurationName: !Ref LaunchConfiguration <br/>            Tags: <br/>              - Key: Name <br/>                Value: !Sub "${AWS::StackName} server" <br/>                PropagateAtLaunch: true <br/>            VPCZoneIdentifier: !Ref SubnetIds
</pre>
<ol start="6">
<li>Still under the <kbd>Resources</kbd> section, define the launch configuration used by the auto scaling group:</li>
</ol>
<pre>
      LaunchConfiguration: <br/>        Type: AWS::AutoScaling::LaunchConfiguration <br/>        Properties: <br/>          ImageId: !Ref AmiId <br/>          InstanceType: !Ref InstanceType <br/>          UserData: <br/>            Fn::Base64: !Sub | <br/>              #!/bin/bash -xe <br/>              # This will be run on startup, launch your application here
</pre>
<ol start="7">
<li>Next, define two scaling policy resources<span><span>—</span></span>one to scale up and the other to scale down:</li>
</ol>
<pre>
        ScaleUpPolicy: <br/>          Type: AWS::AutoScaling::ScalingPolicy <br/>          Properties: <br/>            AdjustmentType: ChangeInCapacity <br/>            AutoScalingGroupName: !Ref AutoScalingGroup <br/>            Cooldown: 60 <br/>            ScalingAdjustment: 1 <br/> <br/>        ScaleDownPolicy: <br/>          Type: AWS::AutoScaling::ScalingPolicy <br/>          Properties: <br/>            AdjustmentType: ChangeInCapacity <br/>            AutoScalingGroupName: !Ref AutoScalingGroup <br/>            Cooldown: 60 <br/>            ScalingAdjustment: -1
</pre>
<ol start="8">
<li>Define an alarm that will alert when the CPU goes <em>over</em> the <kbd>ThresholdCPUHigh</kbd> parameter:</li>
</ol>
<pre>
      CPUHighAlarm: <br/>        Type: AWS::CloudWatch::Alarm <br/>        Properties: <br/>          ActionsEnabled: true <br/>          AlarmActions: <br/>            - !Ref ScaleUpPolicy <br/>          AlarmDescription: Scale up on CPU load <br/>          ComparisonOperator: GreaterThanThreshold <br/>          Dimensions: <br/>            - Name: AutoScalingGroupName <br/>              Value: !Ref AutoScalingGroup <br/>          EvaluationPeriods: !Ref ThresholdMinutes <br/>          MetricName: CPUUtilization <br/>          Namespace: AWS/EC2 <br/>          Period: 60 <br/>          Statistic: Average <br/>          Threshold: !Ref ThresholdCPUHigh
</pre>
<ol start="9">
<li>Finally, define an alarm that will alert when the CPU goes <em>under</em> the <kbd>ThresholdCPULow</kbd> parameter:</li>
</ol>
<pre>
      CPULowAlarm: <br/>        Type: AWS::CloudWatch::Alarm <br/>        Properties: <br/>          ActionsEnabled: true <br/>          AlarmActions: <br/>            - !Ref ScaleDownPolicy <br/>          AlarmDescription: Scale down on CPU load <br/>          ComparisonOperator: LessThanThreshold <br/>          Dimensions: <br/>            - Name: AutoScalingGroupName <br/>              Value: !Ref AutoScalingGroup <br/>          EvaluationPeriods: !Ref ThresholdMinutes <br/>          MetricName: CPUUtilization <br/>          Namespace: AWS/EC2 <br/>          Period: 60 <br/>          Statistic: Average <br/>          Threshold: !Ref ThresholdCPULow
</pre>
<ol start="10">
<li>Save the template with the filename <kbd>04-auto-scaling-an-application-server.yaml</kbd>.</li>
</ol>
<ol start="11">
<li>Launch the template with the following AWS CLI command, supplying your subnet IDs:</li>
</ol>
<pre>
     <strong> aws cloudformation create-stack \ <br/>        --stack-name asg \ <br/>        --template-body file://04-auto-scaling-an-application-server.yaml \ <br/>        --parameters \ <br/>        ParameterKey=SubnetIds,ParameterValue='&lt;subnet-id-1&gt;\, \<br/>          &lt;subnet-id-2&gt;' <br/></strong>
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>This example defines an auto scaling group and the dependent resources. These include the following:</p>
<ul>
<li>A launch configuration to use when launching new instances</li>
<li>Two scaling policies, one to scale the number of instances up, and an inverse policy to scale back down</li>
<li>An alarm to alert when the CPU crosses a certain threshold, for a certain number of minutes</li>
</ul>
<p>The auto scaling group and launch-configuration resource objects in this example use mostly default values. You will need to specify your own <kbd>SecurityGroups</kbd> and a <kbd>KeyName</kbd> parameter in the <kbd>LaunchConfiguration</kbd> resource configuration if you want to be able to connect to the instances (for example, via SSH).</p>
<p>AWS will automatically take care of spreading your instances evenly over the subnets you have configured, so make sure they are in different AZs! When scaling down, the oldest instances will be removed before the newer ones.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Scaling policies</h1>
            </header>

            <article>
                
<p>The scaling policies detail how many instances to create or delete when they are triggered. It also defines a <kbd>Cooldown</kbd> value, which helps prevent <em>flapping</em> servers<span><span>—</span></span>when servers are created and deleted before they have finished starting and are useful.</p>
<div class="packt_tip">While the scaling policies in this example use equal values, you might want to change that so your application can scale <em>up</em> quickly, and scale <em>down</em> slowly for the best user experience.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Alarms</h1>
            </header>

            <article>
                
<p>The <kbd>CPUHighAlarm</kbd> parameter will alert when the average CPU utilization goes over the value set in the <kbd>ThresholdCPUHigh</kbd> parameter. This alert will be sent to the <kbd>ScaleUpPolicy</kbd> resource provisioning more instances, which will bring the average CPU utilization down across the whole auto scaling group. As the name suggests, the <kbd>CPULowAlarm</kbd> parameter does the reverse when the average CPU utilization goes under the <kbd>ThresholdCPULow</kbd> parameter.</p>
<p>This means that new instances will be launched until the CPU utilization across the auto scaling group stabilizes somewhere between 40-60% (based on the default parameter values), or the <kbd>MaxSize</kbd> of instances is reached.</p>
<div class="packt_infobox">It is very important to leave a gap between the high and low alarms thresholds. If they are too close together, the alarms will not stabilize and you will see instances created and destroyed almost continually.</div>
<p>The minimum charge for an instance is <em>one hour</em>, so creating and destroying them multiple times in one hour may result in higher than expected charges.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating machine images</h1>
            </header>

            <article>
                
<p>Creating or <em>baking</em> your own <strong>Amazon Machine Images</strong> (<strong>AMIs</strong>) is a key part of systems administration in AWS. Having a pre-baked image helps you provision your servers faster, easier, and more consistently than configuring it by hand.</p>
<p>Packer is the de facto standard tool that helps you make your own AMIs. By automating the launch, configuration, and clean-up of your instances, it makes sure you get a repeatable image every time.</p>
<p>In this recipe, we will create an image with the Apache web server pre-installed and configured. While this is a simple example, it is also a very common use-case.</p>
<p>By baking-in your web server, you can scale up your web serving layer to dynamically match the demands on your websites. Having the software already installed and configured means you get the fastest and most reliable start-up possible.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Getting ready</h1>
            </header>

            <article>
                
<p>For this recipe, you must have the Packer tool available on your system. Download and install Packer from the project's website <a href="https://www.packer.io/downloads.html"><span class="URLPACKT">https://www.packer.io/downloads.html</span></a>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Create a new Packer template file, and start by defining an <kbd>amazon-ebs</kbd> builder in the <kbd>builders</kbd> section:</li>
</ol>
<pre>
      "builders": [ <br/>        { <br/>          "type": "amazon-ebs", <br/>          "instance_type": "t2.micro", <br/>          "region": "us-east-1", <br/>          "source_ami": "ami-9be6f38c", <br/>          "ssh_username": "ec2-user", <br/>          "ami_name": "aws-linux-apache {{timestamp}}" <br/>        } <br/>      ],
</pre>
<div class="packt_infobox">The entire template file must be a valid JSON object. Remember to enclose the sections in curly braces: <kbd>{ ... }</kbd>.</div>
<ol start="2">
<li>Create a <kbd>provisioners</kbd> section, and include the following snippet to install and activate Apache:</li>
</ol>
<pre>
      "provisioners": [ <br/>        { <br/>          "type": "shell", <br/>          "inline": [ <br/>            "sudo yum install -y httpd", <br/>            "sudo chkconfig httpd on" <br/>          ] <br/>        } <br/>      ]
</pre>
<ol start="3">
<li>Save the file with a specific name, such as <kbd>04-creating-machine-images.json</kbd>.</li>
</ol>
<ol start="4">
<li>Validate the configuration file you've created with the following <kbd>packer validate</kbd> command:</li>
</ol>
<pre>
<strong>      packer validate 04-creating-machine-images.json</strong>
</pre>
<ol start="5">
<li>When valid, build the AMI with the following command:</li>
</ol>
<pre>
<strong>      packer build 04-creating-machine-images.json</strong>
</pre>
<ol start="6">
<li>Wait until the process is complete. While it is running, you will see an output similar to the following:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" src="assets/B06236_04_05.png"/></div>
<ol start="7">
<li>Take note of the AMI ID returned by Packer so that you can use it when launching instances in the future:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" src="assets/B06236_04_06.png"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>While this is a very simple recipe, there is a lot going on behind the scenes. This is why we recommend you use Packer to create your machine images.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Template</h1>
            </header>

            <article>
                
<p>In the <kbd>builders</kbd> section of the template, we define our build details.</p>
<p>We are using the most common type of AMI builder: <kbd>amazon-ebs</kbd>. There are other types of AWS builders, for instance, storage-backed instance types.</p>
<p>Next, we define the type of instance to use when baking.</p>
<div class="packt_infobox">Make sure that you can often decrease the time it takes to bake your instance by using a larger instance size. Remember that the minimum price paid for an instance is one hour of billable time.</div>
<p>The <kbd>source_ami</kbd> property in this recipe is an AWS Linux AMI ID in the <kbd>region</kbd> we have specified. The <kbd>ssh_username</kbd> allows you to set the username used to connect and run <kbd>provisioners</kbd> on the instance. This will be determined by your operating system, which in our case is <kbd>ec2-user</kbd>.</p>
<p>Finally, the <kbd>ami_name</kbd> field includes the built-in Packer variable <kbd>{{timestamp}}</kbd>. This ensures the AMI you create will always have a unique name.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Validate the template</h1>
            </header>

            <article>
                
<p>The <kbd>packer validate</kbd> command is a quick way to ensure your template is free of syntax errors before you launch any instances.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Build the AMI</h1>
            </header>

            <article>
                
<p>Once you have created and validated your template, the <kbd>packer build</kbd> command does the following for you:</p>
<ul>
<li>Creates a one-time key pair for SSH access to the instance</li>
<li>Creates a dedicated security group to control access to the instance</li>
<li>Launches an instance</li>
<li>Waits until SSH is ready to receive connections</li>
<li>Runs the provisioner steps on the instance</li>
<li>Stops the instance</li>
<li>Generates an AMI from the stopped instance</li>
<li>Terminates the instance</li>
</ul>
<div class="packt_infobox">Check the Packer documentation for more provisioners and functionality at <a href="https://www.packer.io/docs/"><span class="URLPACKT">https://www.packer.io/docs/</span></a>.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">There's more...</h1>
            </header>

            <article>
                
<p>While Packer makes the administration of images much easier on AWS, there are still a few things to watch out for.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Debugging</h1>
            </header>

            <article>
                
<p>Obviously, with so many steps being automated for you, there are many things that can potentially go wrong. Packer gives you a few different ways to debug issues with your builds.</p>
<p>One of the most useful arguments to use with Packer is the <kbd>-debug</kbd> flag. This will force you to manually confirm each step <em>before</em> it takes place. Doing this makes it easy to work out exactly which step in the command is failing, which in turn usually makes it obvious what needs to be changed.</p>
<p>Another useful thing to do is to raise the level of logging output during a Packer command. You can do this by setting the <kbd>PACKER_LOG</kbd> variable to <kbd>true</kbd>. The easiest way to do this is with <kbd>PACKER_LOG=1</kbd> at the beginning of your Packer command line. This will mean you get a lot more information printed to the console (for example, SSH logs, AWS API calls, and so on) during the command. You may even want to run with this level of logging normally in your builds, for auditing purposes.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Orphaned resources</h1>
            </header>

            <article>
                
<p>Packer does a great job of managing and cleaning up the resource it uses, but it can only do that while it is running.</p>
<p>If your Packer job aborts for any reason (most likely network issues) then there may be some resources left <strong>orphaned</strong>, or <strong>unmanaged</strong>. It is good practice to check for any Packer instances (they will have <em>Packer</em> in their name), and stop them if there are no active Packer jobs running.</p>
<p>You may also need to clean up any leftover key pairs and security groups, but this is less of an issue as there is no cost associated with them (unlike instances).</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Deregistering AMIs</h1>
            </header>

            <article>
                
<p>As it becomes easier to create AMIs, you may find you end up with more than you need!</p>
<p>AMIs are made up of EC2 snapshots, which are stored in S3. There is a cost associated with storing snapshots, so you will want to clean them up periodically. Given the size of most AMIs (usually a few GBs), it is unlikely to be one of your major costs.</p>
<p>An even greater cost is the administrative overhead of managing too many AMIs. As your images improve and fixes are applied (especially security fixes), you may want to prevent people from using them.</p>
<p>To remove an AMI, you must first <em>deregister</em> it, and then remove the underlying snapshots.</p>
<div class="packt_infobox">Make sure you do not deregister AMIs that are currently in use. For example, an auto scaling group that references a deregistered AMI will fail to launch new instances!</div>
<p>You can easily deregister snapshots through the web console or using the AWS CLI tool.</p>
<p>Once an AMI is no longer registered, you can remove the associated snapshots. Packer automatically adds the AMI ID to the snapshots' description. By searching your snapshots for the deregistered AMI ID, you can find which ones need to be deleted.</p>
<p>You will not be able to delete snapshots if the AMI has not been deregistered, or if the deregistration is still taking place (it can take a few minutes).</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Other platforms</h1>
            </header>

            <article>
                
<p>It is also worth noting that Packer can build for more platforms that just AWS. You can also build images for VMWare, Docker, and many others.</p>
<p>This means you could build almost exactly the same machine image locally (for example, using Docker) as you do in AWS. This makes it much more convenient when setting up local development environments, for example.</p>
<p>Check the <kbd>builders</kbd> section of the Packer documentation for details.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating security groups</h1>
            </header>

            <article>
                
<p>AWS describes security groups as <em>virtual firewalls</em>. While this analogy helps newcomers to the EC2 platform understand their purpose and function, it's probably more accurate to describe them as a <em>firewall-like</em> method of authorizing traffic. They don't offer all the functionality you'd find in a traditional firewall, but this simplification also makes them extremely powerful, particularly when combined with Infrastructure as Code and modern SDLC practices.</p>
<p>We're going to go through a basic scenario involving a web server and load balancer. We want the load balancer to respond to HTTP requests from everywhere, and we want to isolate the web server from everything except the load balancer.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Getting ready</h1>
            </header>

            <article>
                
<p>Before we get started there's a small list of things you'll need to have ready:</p>
<ul>
<li><kbd>AmiId</kbd> This is the ID of an AMI in your region. For this recipe, we'd recommend using an AWS Linux AMI because our instance will attempt to run some <kbd>yum</kbd> commands on startup.</li>
<li><kbd>VPCID</kbd>: This is the ID of the VPC you wish to launch the EC2 server into.</li>
<li><kbd>SubnetIDs</kbd>: These are the subnets which our EC2 instance can launch in.</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Open up your text editor and create a new CloudFormation template. We're going to start by adding a few <kbd>Parameters</kbd> as follows:</li>
</ol>
<pre>
      AWSTemplateFormatVersion: '2010-09-09' <br/>      Parameters: <br/>        AmiId: <br/>          Type: AWS::EC2::AMI::Id <br/>          Description: AMI ID to launch instances from <br/>        VPCID: <br/>          Type: AWS::EC2::VPC::Id <br/>          Description: VPC where load balancer and instance will launch <br/>        SubnetIDs: <br/>          Type: List&lt;AWS::EC2::Subnet::Id&gt; <br/>          Description: Subnets where load balancer and instance will launch <br/>            (pick at least 2)
</pre>
<ol start="2">
<li>Let's take a look at a security group we'll apply to a public load balancer:</li>
</ol>
<pre>
      ExampleELBSecurityGroup: <br/>        Type: AWS::EC2::SecurityGroup <br/>        Properties: <br/>          GroupDescription: Security Group for example ELB <br/>          SecurityGroupIngress: <br/>            - IpProtocol: tcp <br/>              CidrIp: 0.0.0.0/0 <br/>              FromPort: 80 <br/>              ToPort: 80
</pre>
<p style="padding-left: 60px">Anything which resides in this security group will allow inbound TCP connections on port <kbd>80</kbd> from anywhere (<kbd>0.0.0.0/0</kbd>). Note that a security group can contain more than one rule; we'd almost certainly want to also allow HTTPS (<kbd>443</kbd>), but we've left it out to simplify this recipe.</p>
<ol start="3">
<li>Now let's look at a security group for a web server sitting behind our load balancer:</li>
</ol>
<pre>
      ExampleEC2InstanceSecurityGroup: <br/>        Type: AWS::EC2::SecurityGroup <br/>        Properties: <br/>          GroupDescription: Security Group for example Instance <br/>          SecurityGroupIngress: <br/>            - IpProtocol: tcp <br/>              SourceSecurityGroupName: <br/>                Ref: ExampleELBSecurityGroup <br/>              FromPort: 80 <br/>              ToPort: 80
</pre>
<p style="padding-left: 60px">Here you can see we are not specifying a source IP range. Instead, we're specifying a source security group, which we will accept connections from. In this case, we're saying that we want to allow anything from our ELB security group to connect to anything in our EC2 instance security group on port <kbd>80</kbd>.<br/>
Since this is the only rule we're specifying, our web server will not accept connections from anywhere except our load balancer, to port <kbd>80</kbd> or otherwise. Our web server isn't wide open to the Internet, and it is even isolated from other instances in our VPC</p>
<div class="packt_infobox">Remember that multiple instances can reside in a security group. In a scenario where you have multiple web servers attached to this load balancer it would be unnecessary, inefficient, and somewhat of an anti-pattern to create a new security group for each web server. Given that all web servers attached to this load balancer would be serving the same role or function, it makes sense to apply the same security group to them.</div>
<p style="padding-left: 60px">This is where the power of security groups really comes in. If an EC2 instance is serving multiple roles<span><span>—</span></span>let's say you have an outbound HTTP proxy server in your VPC which you also want to act as an SMTP relay<span><span>—</span></span>then you can simply apply multiple security groups to it.</p>
<ol start="4">
<li>Next, we need to add our load balancer. This is probably the most basic load balancer configuration you'll come across. The following code will give you a load balancer, a listener and a target group containing our EC2 instance.</li>
</ol>
<pre>
      ExampleLoadBalancer: <br/>        Type: AWS::ElasticLoadBalancingV2::LoadBalancer <br/>        Properties: <br/>          Subnets:  <br/>            - Fn::Select: [ 0, Ref: SubnetIDs ] <br/>            - Fn::Select: [ 1, Ref: SubnetIDs ] <br/>          SecurityGroups: <br/>            - Fn::GetAtt: ExampleELBSecurityGroup.GroupId <br/>      ExampleListener: <br/>        Type: AWS::ElasticLoadBalancingV2::Listener <br/>        Properties: <br/>          LoadBalancerArn: <br/>            Ref: ExampleLoadBalancer <br/>          DefaultActions: <br/>            - Type: forward <br/>              TargetGroupArn: <br/>                Ref: ExampleTargetGroup <br/>          Port: 80 <br/>          Protocol: HTTP <br/>      ExampleTargetGroup: <br/>        Type: AWS::ElasticLoadBalancingV2::TargetGroup <br/>        Properties:  <br/>          Port: 80 <br/>          Protocol: HTTP <br/>          VpcId: <br/>             Ref: VPCID <br/>          Targets: <br/>            - Id: <br/>                Ref: ExampleEC2Instance
</pre>
<ol start="5">
<li>The last resource we'll add to our template is an EC2 server. This server will install and start <kbd>nginx</kbd> when it boots.</li>
</ol>
<pre>
      ExampleEC2Instance: <br/>        Type: AWS::EC2::Instance <br/>        Properties: <br/>          InstanceType: t2.nano <br/>          UserData: <br/>            Fn::Base64: <br/>              Fn::Sub: | <br/>                #!/bin/bash -ex <br/>                yum install -y nginx <br/>                service nginx start <br/>                exit 0 <br/>        ImageId: <br/>          Ref: AmiId <br/>        SecurityGroupIds: <br/>          - Fn::GetAtt: ExampleEC2InstanceSecurityGroup.GroupId <br/>        SubnetId:  <br/>          Fn::Select: [ 0, Ref: SubnetIDs ]
</pre>
<ol start="6">
<li>Lastly, we're going to add some <kbd>Outputs</kbd> to the template to make it a little more convenient to use our ELB and EC2 instance after the stack is created.</li>
</ol>
<pre>
      Outputs: <br/>        ExampleEC2InstanceHostname: <br/>          Value: <br/>            Fn::GetAtt: [ ExampleEC2Instance, PublicDnsName ] <br/>        ExampleELBURL: <br/>          Value: <br/>            Fn::Join: <br/>              - '' <br/>              - [ 'http://', { 'Fn::GetAtt': [ ExampleLoadBalancer,<br/>                  DNSName ] }, '/' ]
</pre>
<ol start="7">
<li>Go ahead and launch this template using the CloudFormation web console or the AWS CLI.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">There's more...</h1>
            </header>

            <article>
                
<p>You'll eventually run into circular dependency issues when configuring security groups using CloudFormation. Let's say you want all servers in our <kbd>ExampleEC2InstanceSecurityGroup</kbd> to be able to access each other on port <kbd>22</kbd> (SSH). In order to achieve this, you would need to add this rule as the separate resource type <kbd>AWS::EC2::SecurityGroupIngress</kbd>. This is because a security group can't refer to itself in CloudFormation when it is yet to be created. This is what the extra resource type looks like:</p>
<pre>
      ExampleEC2InstanceIngress: <br/>        Type: AWS::EC2::SecurityGroupIngress <br/>        Properties: <br/>          IpProtocol: tcp <br/>          SourceSecurityGroupName: <br/>            Ref: ExampleEC2InstanceSecurityGroup <br/>          GroupName: <br/>            Ref: ExampleEC2InstanceSecurityGroup <br/>          FromPort: 22 <br/>          ToPort: 22
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Differences from traditional firewalls</h1>
            </header>

            <article>
                
<ul>
<li>Security groups can't be used to explicitly block traffic. Only rules of a permissive kind can be added; deny style rules are not supported. Essentially, all inbound traffic is denied unless you explicitly allow it.</li>
<li>Your rules also may not refer to source ports; only destination ports are supported.</li>
<li>When security groups are created, they will contain a rule which allows all outbound connections. If you remove this rule, new outbound connections will be dropped. It's a common pattern to leave this rule in place and filter all your traffic using inbound rules only.</li>
<li>If you do replace the default outbound rule, it's important to note that only new outbound connections will be filtered. Any outbound traffic being sent in response to an inbound connection will still be allowed. This is because security groups are <em>stateful</em>.</li>
<li>Unlike security groups, network ACLs are not stateful and do support <kbd>DENY</kbd> rules. You can use them as a complementary layer of security inside your VPC, especially if you need to control traffic flow between subnets.</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating a load balancer</h1>
            </header>

            <article>
                
<p>AWS offers two kinds of load balancers:</p>
<ul>
<li>Classic load balancer</li>
<li>Application load balancer</li>
</ul>
<p>We're going to focus on the application load balancer. It's effectively an upgraded, second generation of the ELB service, and it offers a lot more functionality than the classic load balancer. HTTP/2 and WebSockets are supported natively, for example. The hourly rate also happens to be cheaper.</p>
<div class="packt_infobox">Application load balancers do not support layer-4 load balancing. For this kind of functionality, you'll need to use a classic load balancer.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Open up your text editor and create a new CloudFormation template. We're going to require a VPC ID and some subnet IDs as <kbd>Parameters</kbd>. Add them to your template like this:</li>
</ol>
<pre>
      AWSTemplateFormatVersion: '2010-09-09' <br/>      Parameters: <br/>        VPCID: <br/>          Type: AWS::EC2::VPC::Id <br/>          Description: VPC where load balancer and instance will launch <br/>        SubnetIDs: <br/>          Type: List&lt;AWS::EC2::Subnet::Id&gt; <br/>          Description: Subnets where load balancer and instance will launch<br/>           (pick at least 2)
</pre>
<ol start="2">
<li>Next we need to add some <kbd>Mappings</kbd> of ELB account IDs. These will make it easier for us to give the load balancer permission to write logs to an S3 bucket. Your mappings should look like this:</li>
</ol>
<div class="packt_infobox">You can find the complete list of ELB account IDs here <a href="http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/enable-access-logs.html#attach-bucket-policy">http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/enable-access-logs.html#attach-bucket-policy</a>.</div>
<pre>
      Mappings: <br/>        ELBAccountMap: <br/>          us-east-1: <br/>        ELBAccountID: 127311923021 <br/>          ap-southeast-2: <br/>        ELBAccountID: 783225319266
</pre>
<ol start="3">
<li>We can now start adding <kbd>Resources</kbd> to our template. First we're going to create an S3 bucket and bucket policy for storing our load balancer logs. In order to make this template portable, we'll omit a bucket name, but for convenience we'll include the bucket name in our outputs so that CloudFormation will echo the name back to us.</li>
</ol>
<pre>
      Resources: <br/>        ExampleLogBucket: <br/>          Type: AWS::S3::Bucket <br/>        ExampleBucketPolicy: <br/>          Type: AWS::S3::BucketPolicy <br/>          Properties: <br/>            Bucket: <br/>              Ref: ExampleLogBucket <br/>            PolicyDocument: <br/>              Statement: <br/>                - <br/>                  Action: <br/>                    - "s3:PutObject" <br/>                  Effect: "Allow" <br/>                  Resource: <br/>                    Fn::Join: <br/>                      - "" <br/>                      - <br/>                        - "arn:aws:s3:::" <br/>                        - Ref: ExampleLogBucket <br/>                        - "/*" <br/>                  Principal: <br/>                    AWS: <br/>                      Fn::FindInMap: [ ELBAccountMap, Ref: "AWS::Region",<br/>                        ELBAccountID ]                       
</pre>
<ol start="4">
<li>Next, we need to create a security group for our load balancer to reside in. This security group will allow inbound connections to port <kbd>80</kbd> (HTTP). To simplify this recipe, we'll leave out port <kbd>443</kbd> (HTTPS), but we'll briefly cover how to add this functionality later in this section. Since we're adding a public load balancer, we want to allow connections to it from everywhere (<kbd>0.0.0.0/0</kbd>). This is what our security group looks like:</li>
</ol>
<pre>
      ExampleELBSecurityGroup: <br/>        Type: AWS::EC2::SecurityGroup <br/>        Properties: <br/>          GroupDescription: Security Group for example ELB <br/>          SecurityGroupIngress: <br/>            - <br/>              IpProtocol: tcp <br/>              CidrIp: 0.0.0.0/0 <br/>              FromPort: 80 <br/>              ToPort: 80
</pre>
<ol start="5">
<li>We now need to define a target group. Upon completion of this recipe, you can go ahead and register your instances in this group so that HTTP requests will be forwarded to it. Alternatively, you can attach the target group to an auto scaling group and AWS will take care of the instance registration and de-registration for you.</li>
</ol>
<ol start="6">
<li>The target group is where we specify the health checks our load balancer should perform against the target instances. This health check is necessary to determine if a registered instance should receive traffic. The example provided with this recipe includes these health-check parameters with the values all set to their defaults. Go ahead and tweak these to suit your needs, or, optionally, remove them if the defaults work for you.</li>
</ol>
<pre>
      ExampleTargetGroup: <br/>        Type: AWS::ElasticLoadBalancingV2::TargetGroup <br/>        Properties: <br/>          Port: 80 <br/>          Protocol: HTTP <br/>          HealthCheckIntervalSeconds: 30 <br/>          HealthCheckProtocol: HTTP <br/>          HealthCheckPort: 80 <br/>          HealthCheckPath: / <br/>          HealthCheckTimeoutSeconds: 5 <br/>          HealthyThresholdCount: 5 <br/>          UnhealthyThresholdCount: 2 <br/>          Matcher: <br/>            HttpCode: '200' <br/>          VpcId: <br/>            Ref: VPCID
</pre>
<ol start="7">
<li>We need to define at least one listener to be added to our load balancer. A listener will <em>listen</em> for incoming requests to the load balancer on the port and protocol we configure for it. Requests matching the port and protocol will be forwarded through to our target group.</li>
</ol>
<p style="padding-left: 60px">The configuration of our listener is going to be reasonably simple. We're listening for HTTP requests on port <kbd>80</kbd>. We're also setting up a default action for this listener, which will forward our requests to the target group we've defined before. There is a limit of 10 listeners per load balancer.</p>
<div class="packt_infobox">Currently, AWS only supports one action: forward.</div>
<pre>
      ExampleListener:<br/>        Type: AWS::ElasticLoadBalancingV2::Listener <br/>        Properties: <br/>          LoadBalancerArn: <br/>            Ref: ExampleLoadBalancer <br/>          DefaultActions: <br/>            - Type: forward <br/>              TargetGroupArn: <br/>        <strong>        </strong>Ref: ExampleTargetGroup <br/>          Port: 80 <br/>          Protocol: HTTP
</pre>
<ol start="8">
<li>Finally, now that we have all <kbd>Resources</kbd> we need, we can go ahead and set up our load balancer. We'll need to define at least two subnets for it to live in—these are included as <kbd>Parameters</kbd> in our example template:</li>
</ol>
<pre>
      ExampleLoadBalancer: <br/>        Type: AWS::ElasticLoadBalancingV2::LoadBalancer <br/>        Properties: <br/>          LoadBalancerAttributes: <br/>            - Key: access_logs.s3.enabled <br/>             Value: true <br/>            - Key: access_logs.s3.bucket <br/>             Value: <br/>               Ref: ExampleLogBucket <br/>            - Key: idle_timeout.timeout_seconds <br/>              Value: 60 <br/>          Scheme: internet-facing <br/>          Subnets: <br/>            - Fn::Select: [ 0, Ref: SubnetIDs ]               <br/>            - Fn::Select: [ 1, Ref: SubnetIDs ]               <br/>          SecurityGroups: <br/>            - Fn::GetAtt: ExampleELBSecurityGroup.GroupId
</pre>
<ol start="9">
<li>Lastly, we're going to add some <kbd>Outputs</kbd> to our template for convenience. We're particularly interested in the name of the S3 bucket we created and the URL of the load balancer.</li>
</ol>
<pre>
      Outputs: <br/>        ExampleELBURL: <br/>          Value: <br/>            Fn::Join: <br/>              - '' <br/>              - [ 'http://', { 'Fn::GetAtt': [ ExampleLoadBalancer,<br/>                  DNSName ] }, '/' ] <br/>        ExampleLogBucket: <br/>          Value: <br/>            Ref: ExampleLogBucket
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>As you can see, we're applying a logging configuration which points to the S3 bucket we've created. We're configuring this load balancer to be Internet-facing, with an idle timeout of 60 seconds (the default).</p>
<p>All load balancers are Internet-facing by default, so it's not strictly necessary to define a <kbd>Scheme</kbd> in our example; however, it can be handy to include this anyway. This is especially the case if your CloudFormation template contains a mix of public and private load balancers.</p>
<div class="packt_infobox">If you specify a logging configuration but the load balancer can't access the S3 bucket, your CloudFormation stack will fail to complete.</div>
<p>Private ELBs are not Internet-facing and are available only to resources which live inside your VPC.</p>
<p>That's it! You now have a working application load balancer configured to ship logs to an S3 bucket.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">There's more...</h1>
            </header>

            <article>
                
<p>Load balancers on AWS are highly configurable and there are many options available to you. Here are some of the more frequent ELB options you'll encounter:</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">HTTPS/SSL</h1>
            </header>

            <article>
                
<p>If you wish to accept HTTPS requests, you'll need to configure an additional listener. It will look something like the following:</p>
<pre>
      ExampleHTTPSListener: <br/>        Type: AWS::ElasticLoadBalancingV2::Listener <br/>        Properties: <br/>          Certificates: <br/>            - CertificateArn:<br/>               arn:aws:acm:ap-southeast-2:123456789012:<br/>               certificate/12345678-1234-1234-1234-123456789012 <br/>          LoadBalancerArn: <br/>            Ref: ExampleLoadBalancer <br/>          DefaultActions: <br/>            - Type: forward <br/>              TargetGroupArn: <br/>                Ref: ExampleTargetGroup <br/>          Port: 443 <br/>          Protocol: HTTPS
</pre>
<p>The listener will need to reference a valid <strong>Amazon Resource Name</strong> (<strong>ARN</strong>) for the certificate you wish to use. It's really easy to have AWS Certificate Manager create a certificate for you, but it does require validation of the domain name you're generating the certificate for. You can, of course, bring your own certificate if you wish. You'll need to import it in to AWS Certificate Manager before you can use it with your ELB (or CloudFront distribution).</p>
<p>Unless you have specific requirements around ciphers, a good starting approach is to not define an SSL Policy and let AWS choose what is currently <em>best of breed</em>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Path-based routing</h1>
            </header>

            <article>
                
<p>Once you are comfortable with ELB configuration, you can start to experiment with path-based routing. In a nutshell, it provides a way to inspect a request and proxy it to different targets based on the path requested.</p>
<p>One common scenario you might encounter is needing to route requests for <kbd>/blog</kbd> to a different set of servers running WordPress, instead of to your main server pool, which is running your Ruby on Rails application.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>