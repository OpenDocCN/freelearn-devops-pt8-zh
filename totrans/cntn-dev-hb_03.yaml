- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Sharing Docker Images
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分享 Docker 镜像
- en: Sharing container images is key to being able to run your applications anywhere.
    You’ve built your application components on your workstation or laptop, and now
    you are ready to move them to different platform stages. This chapter will cover
    how images will be stored and shared with other users or orchestration platforms.
    We will also review various methods for signing container images to improve security
    in our development workflow. We will also learn how to use content scanners to
    find any possible security issues in our container images. By the end of this
    chapter, you will be ready to deliver secure and trusted images to production.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 分享容器镜像是能够在任何地方运行应用程序的关键。你已经在工作站或笔记本电脑上构建了应用程序组件，现在你准备将它们移动到不同的平台阶段。本章将介绍镜像如何存储并与其他用户或编排平台共享。我们还将回顾各种容器镜像签名的方法，以提高开发工作流中的安全性。我们还将学习如何使用内容扫描工具来发现容器镜像中可能存在的安全问题。到本章结束时，你将能够交付安全可信的镜像到生产环境。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: Container image registries and repositories
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器镜像注册表和仓库
- en: Improving security by signing container images
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过签名容器镜像来提高安全性
- en: Analyzing container image content by using image scanners
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用镜像扫描工具分析容器镜像内容
- en: This chapter will teach you about the different tools and techniques used to
    deliver secure images, which will really improve the use of software containers
    in your projects.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教授你不同的工具和技术，这些工具和技术可用于交付安全的镜像，这将极大地提高你在项目中使用软件容器的效果。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the labs for this chapter at [https://github.com/PacktPublishing/Containers-for-Developers-Handbook/tree/main/Chapter3](https://github.com/PacktPublishing/Containers-for-Developers-Handbook/tree/main/Chapter3),
    where you will find some extended explanations, omitted in the chapter’s content
    to make it easier to follow. The *Code In Action* video for this chapter can be
    found at [https://packt.link/JdOIY](https://packt.link/JdOIY).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/PacktPublishing/Containers-for-Developers-Handbook/tree/main/Chapter3](https://github.com/PacktPublishing/Containers-for-Developers-Handbook/tree/main/Chapter3)
    找到本章的实验内容，里面有一些章节中省略的详细解释，以便更容易跟进。本章的*实战视频*可以在 [https://packt.link/JdOIY](https://packt.link/JdOIY)
    找到。
- en: Container image registries and repositories
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器镜像注册表和仓库
- en: In [*Chapter 1*](B19845_01.xhtml#_idTextAnchor015), *Modern Infrastructure and
    Applications with Docker*, we discussed why software containers have become so
    popular. In [*Chapter 2*](B19845_02.xhtml#_idTextAnchor036), *Building Docker
    Images*, we learned how we can create containers by using them as templates and
    building container images. Before deep-diving into container execution, we will
    learn, in this chapter, how to store and manage container images by using registries.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 1 章*](B19845_01.xhtml#_idTextAnchor015)《使用 Docker 的现代基础设施和应用》中，我们讨论了为什么软件容器变得如此流行。在[*第
    2 章*](B19845_02.xhtml#_idTextAnchor036)《构建 Docker 镜像》中，我们学习了如何通过使用容器模板来创建容器镜像。在深入容器执行之前，本章将教你如何通过使用注册表来存储和管理容器镜像。
- en: What is a registry?
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是注册表？
- en: A **registry** is a service where container images can be stored. This storage
    can be delivered as a service by cloud providers or on-premises by deploying your
    own registry. Cloud registries require zero maintenance from you; you just need
    to manage the usual housekeeping of unused images. Docker Hub ([docker.io](http://docker.io))
    is probably the most common service of this kind, but we also have Google’s Container
    Registry ([gcr.io](http://gcr.io)) and similar services from Red Hat, GitHub,
    and GitLab, among others. Container images have become the new artifacts to run
    applications, and nowadays, many cloud code repositories include their own image
    registry services.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**注册表**是一个容器镜像存储服务。这种存储可以由云服务提供商以服务形式提供，或者通过部署自己的注册表在本地提供。云注册表不需要你进行任何维护；你只需要管理通常的未使用镜像的清理工作。Docker
    Hub ([docker.io](http://docker.io)) 可能是最常见的这类服务，但我们也有 Google 的 Container Registry
    ([gcr.io](http://gcr.io)) 和 Red Hat、GitHub、GitLab 等的类似服务。容器镜像已经成为运行应用程序的新制品，现如今，许多云代码仓库也包含了它们自己的镜像注册表服务。'
- en: Nowadays, most registries can ingest and manage Docker’s Image Manifest V2 and
    Open Container Initiative specifications, and therefore, we can use any of these
    formats for our images. These image schemas specify how image layers and metadata
    will be associated for use in our container runtime.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，大多数镜像仓库都可以接受并管理 Docker 的镜像清单 V2 以及开放容器倡议（OCI）规范，因此，我们可以使用这些格式来管理我们的镜像。这些镜像架构指定了如何将镜像层和元数据关联，以供容器运行时使用。
- en: At the end of this chapter, we will run our own local registry and verify how
    images are stored.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们将运行自己的本地镜像仓库，并验证镜像是如何存储的。
- en: Container runtimes completely manage all the actions we do with software containers
    or their images; hence, your client will just tell your runtime to download images
    before executing a container or upload them once built.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 容器运行时完全管理我们与软件容器或其镜像的所有操作；因此，你的客户端只是告诉容器运行时在执行容器之前下载镜像，或者在构建完成后上传镜像。
- en: Understanding how image registries work
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解镜像仓库如何工作
- en: 'Before continuing to understand how image registries work, we should introduce
    here the complete container image naming convention. Images will always be referenced
    by using the following `name`:`tag` format:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续了解镜像仓库如何工作之前，我们应该在这里介绍完整的容器镜像命名约定。镜像总是通过以下格式进行引用：`name`:`tag`。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This means that all image references must contain the registry where they are
    stored. You can omit this while your container runtime works with local images,
    but any time you use any remote image, you should always use the registry’s `443`,
    using **TLS/SSL**. This port will be used by default by container runtimes to
    connect to registries, but we can use any other port by specifying it when we
    refer to its images. **Image repository** is the term we commonly use to refer
    to the software repository where images are stored, but it is important to understand
    that images follow the same nomenclature used for code repositories, and hence,
    different tags are used to identify images within repositories.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着所有镜像引用必须包含存储它们的镜像仓库。当容器运行时与本地镜像交互时，你可以省略镜像仓库，但每次使用任何远程镜像时，你应始终使用仓库的 `443`
    端口，并且采用 **TLS/SSL**。容器运行时将默认使用该端口连接到镜像仓库，但我们可以通过指定端口来使用其他端口。**镜像仓库**是我们通常用来指代存储镜像的软件仓库的术语，但需要理解的是，镜像遵循与代码仓库相同的命名规则，因此，不同的标签用来在仓库内标识镜像。
- en: Container images may be associated with the users or teams that own the images
    in the registries. This is common for these kinds of services, as the user is
    the one who pushed the image, which may be public or private. If you are part
    of a group, your image may be accessible to the members of the group. This role-based
    access may differ from one registry to another; you should ask your administrators
    or read the appropriate documentation for your registry. Docker images published
    in Docker Hub are shown as `docker.io/library`, and all their public repositories
    are published under this root group, similar to the schema presented at the beginning
    of this subsection.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像可能与在仓库中拥有这些镜像的用户或团队相关联。这在这类服务中是常见的，因为用户是推送镜像的人，而镜像可以是公开的或私有的。如果你是某个组的一部分，你的镜像可能对该组的成员可访问。这种基于角色的访问可能在不同的镜像仓库之间有所不同；你应该向管理员询问或阅读相应镜像仓库的文档。发布在
    Docker Hub 上的 Docker 镜像显示为 `docker.io/library`，并且所有公开的镜像仓库都发布在这个根组下，类似于本小节开头呈现的架构。
- en: Conversely, although tags help identify images, we learned in [*Chapter 2*](B19845_02.xhtml#_idTextAnchor036),
    *Building Docker Images*, that one image can have multiple tags; hence, a tag
    does not uniquely identify a specific image. **Image digests**, however, uniquely
    identify a set of layers for each image, and these really differ between images.
    To ensure that we use the correct image, we should use its **digest**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，虽然标签有助于识别镜像，我们在[*第二章*](B19845_02.xhtml#_idTextAnchor036)《构建 Docker 镜像》中了解到，一张镜像可以有多个标签；因此，标签并不能唯一地标识一个特定的镜像。然而，**镜像摘要**能够唯一标识每个镜像的一组层，这些在不同镜像间确实是不同的。为了确保我们使用正确的镜像，我们应当使用它的**摘要**。
- en: Tagging images is not always easy; you must ensure, as a developer, that anyone
    can follow your work by using appropriate tags that reference the release on which
    users are running. Remember that you can add as many labels as you need to include
    additional information that is relevant for users. I always try to follow the
    code release schema, using `X.Y.Z` to represent major versions, minor versions,
    and fixes. It is a good idea to include a label regarding the commit in your code
    that generated the image artifact. This will help you track problems and also
    improve the application’s life cycle. Automation will really help you to implement
    a workflow and follow your own tagging and labeling logic schema.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 给镜像打标签并不总是容易的；作为开发者，你必须确保其他人能够通过使用适当的标签来跟踪你的工作，这些标签引用了用户正在运行的版本。记住，你可以根据需要添加尽可能多的标签，以包含对用户相关的额外信息。我总是尝试遵循代码发布方案，使用`X.Y.Z`表示主版本、次版本和修复版本。包含关于生成镜像工件的代码提交标签是个好主意。这将帮助你跟踪问题，同时也能改善应用的生命周期。自动化将真正帮助你实现工作流，并遵循你自己的标签和标记逻辑方案。
- en: 'Whenever we pull an image from a registry, we get its digest within its metadata,
    as we can see in the following example, by executing `docker image` `pull alpine:3.17.2`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们从注册表拉取镜像时，我们都会在其元数据中获取镜像摘要，如下例所示，通过执行`docker image pull alpine:3.17.2`：
- en: '![Figure 3.1 – An image digest can be easily recovered after pulling an image
    from remote registries](img/B19845_03_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 拉取镜像后，镜像摘要可以轻松恢复](img/B19845_03_01.jpg)'
- en: Figure 3.1 – An image digest can be easily recovered after pulling an image
    from remote registries
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 拉取镜像后，镜像摘要可以轻松恢复
- en: Depending on which container runtime you use, a default container registry can
    be set. The Docker container runtime will use [docker.io](http://docker.io) by
    default, which is why we can execute `docker image pull alpine:3.17.2` to download
    an `alpine:3.17.2` image, as shown in *Figure 3**.1*. The digest in both cases
    is the same; hence, they are the same image. However, we can create a new image
    with this same name in our system. If we first delete the previously downloaded
    image (names are unique within a container runtime) and create a new one, it will
    have a completely different digest. This will happen even if we used the same
    Dockerfile because digests will also integrate the dates for each execution done
    during the build process.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你使用的容器运行时，可以设置默认的容器注册表。Docker容器运行时默认使用[docker.io](http://docker.io)，这就是为什么我们可以执行`docker
    image pull alpine:3.17.2`来下载`alpine:3.17.2`镜像，如*图 3.1*所示。两种情况下的摘要是相同的，因此它们是相同的镜像。然而，我们可以在系统中创建一个具有相同名称的新镜像。如果我们先删除之前下载的镜像（名称在容器运行时中是唯一的）并创建一个新的，它将具有完全不同的摘要。即使我们使用相同的Dockerfile，这也会发生，因为摘要还会整合每次构建过程中的执行日期。
- en: Important note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: 'We can download all images from a repository by using the `--all-tags` argument,
    as in the following example: `docker image pull --all-tags alpine`. This will
    download all images inside the `alpine` repository.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`--all-tags`参数来下载仓库中的所有镜像，如下例所示：`docker image pull --all-tags alpine`。这将下载`alpine`仓库中的所有镜像。
- en: 'We can review which registries are included by default in Docker Desktop by
    using `docker info`. The following screenshot shows an example output using **Windows
    PowerShell**:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`docker info`查看Docker Desktop中默认包含的注册表。以下截图展示了使用**Windows PowerShell**的示例输出：
- en: '![Figure 3.2 – Local container image registries used by our container runtime](img/B19845_03_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 我们的容器运行时使用的本地容器镜像注册表](img/B19845_03_02.jpg)'
- en: Figure 3.2 – Local container image registries used by our container runtime
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 我们的容器运行时使用的本地容器镜像注册表
- en: 'In this example, the `localhost` registry and `hubproxy.docker.internal:5000`
    are shown. The local registry is used to store images locally. Desktop clients
    such as **Docker Desktop** and **Rancher Desktop** will show local images graphically:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，展示了`localhost`注册表和`hubproxy.docker.internal:5000`。本地注册表用于将镜像存储在本地。桌面客户端，如**Docker
    Desktop**和**Rancher Desktop**，将以图形方式展示本地镜像：
- en: '![Figure 3.3 – An overview of Docker Desktop local images](img/B19845_03_03.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – Docker Desktop本地镜像概览](img/B19845_03_03.jpg)'
- en: Figure 3.3 – An overview of Docker Desktop local images
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – Docker Desktop本地镜像概览
- en: 'In fact, Docker offers integration with your Docker Hub account. You can also
    view your remote images:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Docker提供了与Docker Hub账户的集成。你还可以查看你的远程镜像：
- en: '![Figure 3.4 – An overview of Docker Desktop Docker Hub remote images](img/B19845_03_04.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – Docker Desktop Docker Hub 远程镜像概览](img/B19845_03_04.jpg)'
- en: Figure 3.4 – An overview of Docker Desktop Docker Hub remote images
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – Docker Desktop Docker Hub 远程镜像概览
- en: This interface also allows you to download and review the vulnerabilities found
    in the image’s content if you pay for a Docker subscription. We will learn more
    about security content scanning in the *Scanning image content for vulnerabilities*
    section in this chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 该界面还允许你下载并查看镜像内容中发现的漏洞，如果你订阅了 Docker 服务。我们将在本章的 *扫描镜像内容中的漏洞* 部分深入了解安全内容扫描。
- en: Important note
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Your container runtime may require some specific configurations to allow new
    container registries. All container image registries are expected to use `insecure-registries`
    list.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你的容器运行时可能需要一些特定的配置，以允许新的容器镜像仓库。所有容器镜像仓库都应该使用 `insecure-registries` 列表。
- en: Registries will usually require a login, and we will use their FQDN to access
    them. If you need to access private repositories, an account will be required.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像仓库通常需要登录，我们将使用其 FQDN 来访问它们。如果需要访问私有仓库，则需要一个账户。
- en: 'We will use `docker search` to find repositories based on a string:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `docker search` 来基于字符串查找仓库：
- en: '![Figure 3.5 – Searching for images using the docker search command](img/B19845_03_05.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 使用 docker search 命令搜索镜像](img/B19845_03_05.jpg)'
- en: Figure 3.5 – Searching for images using the docker search command
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 使用 docker search 命令搜索镜像
- en: Note that some images are marked as `OFFICIAL` and others as `AUTOMATED`. Docker
    Hub provides this feature as, depending on your registry, some CI/CD integrations
    may build images automatically for you. These values help mark automatically built
    images. You can use their automation if it fits your requirements.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，某些镜像标记为 `OFFICIAL`，而其他则标记为 `AUTOMATED`。Docker Hub 提供此功能，因为根据你的镜像仓库，一些 CI/CD
    集成可能会自动为你构建镜像。这些标记有助于标识自动构建的镜像。如果符合你的需求，你可以使用它们的自动化功能。
- en: 'Docker official images are container images built and maintained by Docker
    following best practices. They also ensure security by providing continuous updates.
    All official image code is publicly available on GitHub, and you can use it directly
    or customize it to your needs. You can provide feedback and contact Docker if
    you have any issues with using them. A great example of these repositories is
    the one for Alpine images ([https://github.com/alpinelinux/docker-alpine/](https://github.com/alpinelinux/docker-alpine/)),
    where you will find code to build all Alpine images. The following screenshot
    shows how can you find official images for any technology you may need:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 官方镜像是由 Docker 根据最佳实践构建和维护的容器镜像。它们还通过持续更新来确保安全性。所有官方镜像的代码都可以在 GitHub 上公开查看，你可以直接使用它或根据自己的需求进行自定义。如果在使用过程中遇到任何问题，你可以提供反馈并联系
    Docker。一个很好的示例是 Alpine 镜像仓库（[https://github.com/alpinelinux/docker-alpine/](https://github.com/alpinelinux/docker-alpine/)），你可以在这里找到构建所有
    Alpine 镜像的代码。以下截图展示了如何找到你需要的任何技术的官方镜像：
- en: '![Figure 3.6 – An overview of official images available in Docker Hub](img/B19845_03_06.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – Docker Hub 中可用的官方镜像概览](img/B19845_03_06.jpg)'
- en: Figure 3.6 – An overview of official images available in Docker Hub
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – Docker Hub 中可用的官方镜像概览
- en: Software vendors and open source community projects also offer container images,
    prepared and maintained by them. The best method to integrate third-party projects
    or components in your applications will always be using images already prepared
    for you by Docker, a verified publisher, or sponsored open source software providers.
    These images are quite well documented, and you will be able to customize container
    behavior by using arguments and environment variables. You will avoid a lot of
    problems by using these images, instead of having to create your own from scratch.
    In the *Labs* section, we will review a very commonly used PostgreSQL database
    example to understand this better.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 软件供应商和开源社区项目也提供由他们准备和维护的容器镜像。将第三方项目或组件集成到你的应用程序中的最佳方法永远是使用 Docker、经过验证的发布者或赞助的开源软件提供商已为你准备好的镜像。这些镜像有很好的文档支持，你可以通过使用参数和环境变量来定制容器行为。使用这些镜像可以避免许多问题，而不必从头开始创建你自己的镜像。在
    *实验室* 部分，我们将通过一个非常常用的 PostgreSQL 数据库示例来更好地理解这一点。
- en: Searching in repositories
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在仓库中搜索
- en: The Docker client provides certain repository search features, but they are
    not sufficient when you try to find specific images. You will probably use the
    Docker Hub web interface to perform fine-grained searches. Image registries publish
    their API, and we can use `curl` or any other web interface with arguments to
    find these images. Alternatively, we can use `skopeo` instead. This tool allows
    us to filter specific tags when we search inside a repository.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Docker客户端提供了一些仓库搜索功能，但在尝试查找特定镜像时，它们并不充分。你可能会使用Docker Hub的Web界面来进行更细致的搜索。镜像注册表会发布它们的API，我们可以使用`curl`或其他Web接口，带上参数来查找这些镜像。或者，我们可以使用`skopeo`。这个工具可以让我们在搜索仓库时，过滤出特定的标签。
- en: 'As mentioned previously in this section, registries provide an HTTP API that
    we can use to query specific repositories, tags, and so on, but it is not easy
    to use. We can use, for example, `curl` [https://myregistry.com:5000/v2/_catalog](https://myregistry.com:5000/v2/_catalog)
    to list all the images in the catalog. It is recommended to use `skopeo` instead
    because it will give you a clear and easy command line, especially when working
    with authenticated registries (certificates and login are required). It is available
    for different Linux flavors in their package repositories. You can follow the
    instructions for your distribution, or WSL, here: [https://github.com/containers/skopeo/blob/main/install.md](https://github.com/containers/skopeo/blob/main/install.md).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节前面提到的，注册表提供了一个HTTP API，我们可以用来查询特定的仓库、标签等，但它并不容易使用。例如，我们可以使用`curl` [https://myregistry.com:5000/v2/_catalog](https://myregistry.com:5000/v2/_catalog)
    来列出目录中的所有镜像。推荐使用`skopeo`，因为它提供了一个清晰简便的命令行，特别是当处理需要身份验证的注册表时（需要证书和登录）。它在不同Linux发行版的包管理库中都有提供。你可以按照你所在发行版或WSL的安装说明，查看这里的指引：[https://github.com/containers/skopeo/blob/main/install.md](https://github.com/containers/skopeo/blob/main/install.md)。
- en: 'Unfortunately, `skopeo` isn’t available in the Ubuntu 20.04 LTS package repository.
    We can install a newer WSL distribution by executing `wsl --install -d Ubuntu-22.04`
    in a Windows PowerShell terminal. Once the new Ubuntu 22.04 WSL distribution is
    ready, we can install the package by using `sudo apt-get update -qq && sudo apt-get
    install skopeo -qq`. Then, we can integrate the container runtime from either
    Docker Desktop or Rancher Desktop by navigating to **Settings** | **Resources**
    | **WSL Integration** or **File** | **Preferences** | **WSL**. The following screenshot
    shows the interface in Docker Desktop:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`skopeo`在Ubuntu 20.04 LTS的包管理库中不可用。我们可以通过在Windows PowerShell终端执行`wsl --install
    -d Ubuntu-22.04`来安装更新的WSL发行版。一旦新的Ubuntu 22.04 WSL发行版准备好后，我们可以通过使用`sudo apt-get
    update -qq && sudo apt-get install skopeo -qq`来安装该软件包。然后，我们可以通过进入**设置** | **资源**
    | **WSL集成**，或者**文件** | **首选项** | **WSL**来将容器运行时集成到Docker Desktop或Rancher Desktop中。以下截图展示了Docker
    Desktop中的界面：
- en: '![Figure 3.7 – Enabling Docker Desktop integration in Ubuntu 22.04 LTS WSL](img/B19845_03_07.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7 – 在Ubuntu 22.04 LTS WSL中启用Docker Desktop集成](img/B19845_03_07.jpg)'
- en: Figure 3.7 – Enabling Docker Desktop integration in Ubuntu 22.04 LTS WSL
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – 在Ubuntu 22.04 LTS WSL中启用Docker Desktop集成
- en: 'With `skopeo`, we can easily list all tags included in a repository, as shown
    in the following example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`skopeo`，我们可以轻松列出一个仓库中包含的所有标签，如下例所示：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can even inspect remote image information by using `skopeo inspect`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以通过使用`skopeo inspect`来检查远程镜像的信息：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Instead of installing `skopeo` locally, we can use Red Hat’s official image
    by using `docker` `container run`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`docker` `container run`命令，直接使用Red Hat的官方镜像，而不需要在本地安装`skopeo`：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Hopefully, this has given you a new perspective on using software containers.
    We can package tools in container images and use them instead of having to install
    software on our computers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这能为你使用软件容器提供新的视角。我们可以将工具打包成容器镜像，使用它们，而不必在计算机上安装软件。
- en: Now that we know how to store and reference images from registries, it is time
    to learn how we can improve the ownership and security of our images by signing
    them.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道如何存储和引用注册表中的镜像，接下来是学习如何通过对镜像进行签名来提高镜像的所有权和安全性。
- en: Improving security by signing container images
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过对容器镜像进行签名来提高安全性
- en: As we mentioned in the previous section, a digest is the only way we can validate
    which image we are really using. In this section, we will review how we can improve
    this by signing images. This will really ensure we use the right images, as we
    can check the signature and verify the ownership of every image.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一部分提到的，摘要是我们验证自己使用的镜像的唯一方式。在这一部分，我们将回顾如何通过签署镜像来改进这一过程。这将确保我们使用的是正确的镜像，因为我们可以检查签名并验证每个镜像的所有权。
- en: We are going to analyze and learn about the Docker methodology used to sign
    images, but there are other methods available. We will use **Cosign** in the *Labs*
    section, which seems easier and integrates very well with the Kubernetes container
    orchestrator.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分析并了解 Docker 用于签署镜像的方法，但也有其他方法可用。我们将在 *实验室* 部分使用 **Cosign**，它看起来更简单，并且与 Kubernetes
    容器编排器集成得非常好。
- en: Docker created **Docker Content Trust** some years ago to integrate digital
    signatures in the container images management workflow and associate signatures
    with image tags. We will be able to have repositories with signed and unsigned
    images, for example, for local tests before moving on to a new stage. You, as
    a developer, create your images and decide which ones should be signed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 几年前创建了**Docker 内容信任**，将数字签名集成到容器镜像管理工作流中，并将签名与镜像标签关联起来。我们将能够拥有签名和未签名的镜像仓库，例如，在进入新阶段之前进行本地测试。作为开发者，您可以创建镜像并决定哪些镜像应签名。
- en: 'The signing process is based on a list of different keys that will be used
    to include meta-information in your registered image. Some of these keys are interactively
    managed, while others are calculated during the execution. These include the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 签名过程基于一组不同的密钥，这些密钥将用于将元信息添加到您注册的镜像中。其中一些密钥由用户交互式管理，而其他一些则在执行过程中计算。这些密钥包括以下内容：
- en: A `root` key is always used to start the signing process. You will be asked
    for this key, but you can also include it in your environment as a variable. It
    is very important to mention that if you lose this key, you will need to re-sign
    all your images, as there isn’t a known process to recover them. Always have a
    backup of this key; losing it can be a real problem in a production environment
    because your old signatures will not be valid.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`root` 密钥始终用于启动签名过程。系统会要求您提供此密钥，但您也可以将其作为变量包含在您的环境中。非常重要的一点是，如果您丢失了此密钥，您将需要重新签署所有镜像，因为没有已知的恢复过程。始终备份此密钥；丢失它可能会在生产环境中造成真正的问题，因为您的旧签名将不再有效。'
- en: Each repository will also have its `own` key. This key will be used to sign
    images in a specific repository, so losing it will only affect the images there.
    Nonetheless, you should keep it safe and have a backup.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个仓库也将拥有其`自己的`密钥。此密钥将用于签署特定仓库中的镜像，因此丢失它只会影响该仓库中的镜像。尽管如此，您应该妥善保管并备份它。
- en: The `timestamp` key is added automatically to the final signature. This ensures
    security because each signature will always be completely different.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timestamp` 密钥会自动添加到最终的签名中。这确保了安全性，因为每个签名将始终完全不同。'
- en: You will be asked to create a passphrase for the root key, and each repository
    key will be created randomly. Docker provides its own password manager under your
    user’s `~/.``docker` directory.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被要求为根密钥创建一个密码短语，每个仓库的密钥将随机生成。Docker 在您用户的 `~/.docker` 目录下提供了它自己的密码管理器。
- en: Important note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'To back up your keys, prepare a `tar.gz` file with the contents of `~/.docker/trust/private`.
    We can execute the following command line:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了备份您的密钥，请准备一个包含 `~/.docker/trust/private` 目录内容的 `tar.gz` 文件。我们可以执行以下命令：
- en: '`$ umask 077; tar -zcvf private_keys_backup.tar.gz ~/.docker/trust/private;`
    `umask 022`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ umask 077; tar -zcvf private_keys_backup.tar.gz ~/.docker/trust/private;`
    `umask 022`'
- en: We can enable Docker Content Trust in our client by setting the `DOCKER_CONTENT_TRUST=1`
    environment variable. This will enable Content Trust for any new command executed,
    which means that only signed images will be enabled in your environment. If we
    just need to enable Content Trust for a specific command, we can use the `--``disable-content-trust=false`
    argument.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过设置 `DOCKER_CONTENT_TRUST=1` 环境变量，在客户端启用 Docker 内容信任。这将为执行的任何新命令启用内容信任，这意味着您的环境中将只启用签名镜像。如果我们只需要为特定命令启用内容信任，可以使用
    `--disable-content-trust=false` 参数。
- en: 'Let’s try enabling Content Trust for an image by setting the `DOCKER_CONTENT_TRUST`
    variable. In this example, we perform the following steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试通过设置 `DOCKER_CONTENT_TRUST` 变量来启用镜像的内容信任。在这个示例中，我们执行以下步骤：
- en: 'We first pull the `docker.io/busybox:latest` image:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先拉取 `docker.io/busybox:latest` 镜像：
- en: '[PRE4]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: $ export DOCKER_CONTENT_TRUST=1
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ export DOCKER_CONTENT_TRUST=1
- en: $ docker image pull busybox
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker image pull busybox
- en: 'Using default tag: latest'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用默认标签：latest
- en: 'Pull (1 of 1): busybox:latest@sha256:7b3ccabffc97de872a30dfd234fd972a66d247c8cfc69b0550f276481852627c'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 拉取（1/1）：busybox:latest@sha256:7b3ccabffc97de872a30dfd234fd972a66d247c8cfc69b0550f276481852627c
- en: 'docker.io/library/busybox@sha256:7b3ccabffc97de872a30dfd234fd972a66d247c8cfc69b0550f276481852627c:
    Pulling from library/busybox'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'docker.io/library/busybox@sha256:7b3ccabffc97de872a30dfd234fd972a66d247c8cfc69b0550f276481852627c:
    从 library/busybox 拉取'
- en: 'Digest: sha256:7b3ccabffc97de872a30dfd234fd972a66d247c8cfc69b0550f276481852627c'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 摘要：sha256:7b3ccabffc97de872a30dfd234fd972a66d247c8cfc69b0550f276481852627c
- en: 'Status: Image is up to date for busybox@sha256:7b3ccabffc97de872a30dfd234fd972a66d247c8cfc69b0550f276481852627c'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 状态：镜像已更新，适用于 busybox@sha256:7b3ccabffc97de872a30dfd234fd972a66d247c8cfc69b0550f276481852627c
- en: Tagging busybox@sha256:7b3ccabffc97de872a30dfd234fd972a66d247c8cfc69b0550f276481852627c
    as busybox:latest
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将 busybox@sha256:7b3ccabffc97de872a30dfd234fd972a66d247c8cfc69b0550f276481852627c
    标记为 busybox:latest
- en: 'busybox image, docker.io/frjaraur/busybox-untrusted:0.1. Let’s see what happens
    if we try to pull an untrusted image when Docker Content Trust is enabled:'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: busybox 镜像，docker.io/frjaraur/busybox-untrusted:0.1。让我们看看当 Docker 内容信任启用时，如果尝试拉取一个不受信任的镜像会发生什么：
- en: '[PRE5]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This means that no valid signature is found, but if we disable Content Trust,
    we can pull the image without a problem:'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着未找到有效的签名，但如果我们禁用内容信任，我们就可以毫无问题地拉取镜像：
- en: '[PRE6]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In fact, we can’t run any container using this untrusted image, which we can
    easily verify:'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 事实上，我们不能使用这个不受信任的镜像来运行任何容器，这点我们可以轻松验证：
- en: '[PRE7]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Conversely, if we run a trusted image, everything works as expected:'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相反，如果我们运行一个受信任的镜像，一切按预期工作：
- en: '[PRE8]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: $ docker trust inspect \
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker trust inspect \
- en: --pretty docker.io/busybox:latest
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --pretty docker.io/busybox:latest
- en: Signatures for docker.io/busybox:latest
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: docker.io/busybox:latest 的签名
- en: SIGNED TAG   DIGEST
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 签名标签   摘要
- en: SIGNERS
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 签名者
- en: latest       7b3ccabffc97de872a30dfd234fd972a66d247c8cfc69b0550f276481852627c   (Repo
    Admin)
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: latest       7b3ccabffc97de872a30dfd234fd972a66d247c8cfc69b0550f276481852627c   （仓库管理员）
- en: Administrative keys for docker.io/busybox:latest
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: docker.io/busybox:latest 的管理密钥
- en: Repository Key:       02d15c99120886f6e02b4b0186522bc72d21a339ec35fad8af0a1b4a47c871d2
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 仓库密钥：       02d15c99120886f6e02b4b0186522bc72d21a339ec35fad8af0a1b4a47c871d2
- en: Root Key:     074cad59e43e13b440b11d1b5521e20aa8633fc8f3928720590268895711d0c6
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根密钥：     074cad59e43e13b440b11d1b5521e20aa8633fc8f3928720590268895711d0c6
- en: $ docker trust inspect --pretty docker.io/frjaraur/busybox-untrusted:0.1
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker trust inspect --pretty docker.io/frjaraur/busybox-untrusted:0.1
- en: frjaraur/busybox-untrusted:0.1; hence, this image cannot be used in a container
    runtime in which Docker Content Trust is enabled.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: frjaraur/busybox-untrusted:0.1；因此，这个镜像不能在启用 Docker 内容信任的容器运行时中使用。
- en: '[PRE9]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s start the signing process by creating a key for our user by using `docker
    trust` `key generate`:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过使用 `docker trust` `key generate` 创建一个用户密钥，开始签名过程：
- en: '[PRE11]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: $ ls -lart ~/.docker/trust/private/
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ ls -lart ~/.docker/trust/private/
- en: total 12
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 总计 12
- en: drwx------ 4 frjaraur frjaraur 4096 Mar  5 17:43 ..
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: drwx------ 4 frjaraur frjaraur 4096 Mar  5 17:43 ..
- en: -rw------- 1 frjaraur frjaraur  420 Mar  5 17:50 ceb39cd48cf78d478ffef211cc9da3e97ff9912ae60585254d6dc661076d0d2a.key
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: -rw------- 1 frjaraur frjaraur  420 Mar  5 17:50 ceb39cd48cf78d478ffef211cc9da3e97ff9912ae60585254d6dc661076d0d2a.key
- en: 'busybox image with docker.io/frjaraur/busybox-trusted:0.1; hence, both images
    are the same, but the signature is related to the tag:'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 带有 docker.io/frjaraur/busybox-trusted:0.1 的 busybox 镜像；因此，两个镜像是相同的，但签名与标签相关：
- en: '[PRE12]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we can easily review our image signature:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以轻松查看我们的镜像签名：
- en: '[PRE14]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It is important to say here that you will need a registry server with **Notary**.
    This project is responsible for managing your signatures. It is a client-server
    application that runs alongside your registry to integrate the signing part. Docker
    Hub already integrates a Notary server with their registry, which is why we are
    able to integrate our signatures in our image metadata.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要强调的是，你需要一个带有**Notary**的注册表服务器。这个项目负责管理你的签名。它是一个客户端-服务器应用程序，和你的注册表一起运行，集成签名部分。Docker
    Hub 已经将 Notary 服务器集成到他们的注册表中，这就是为什么我们能够将签名集成到我们的镜像元数据中的原因。
- en: If you are planning to use a local registry with Content Trust, you will need
    to also run and integrate a Notary server. You can learn more about Notary at
    [https://github.com/notaryproject/notary](https://github.com/notaryproject/notary).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划使用带有内容信任的本地注册表，你还需要运行并集成一个 Notary 服务器。你可以在 [https://github.com/notaryproject/notary](https://github.com/notaryproject/notary)
    上了解更多关于 Notary 的信息。
- en: We can revoke our signatures for a specific container image tag by using `docker
    trust revoke`. Signatures can be delegated to other users by sharing our public
    key. The integration of image signatures in your platform really depends on the
    registries you use. We have learned about the process for Docker Hub, but other
    solutions may implement different commands and options. We will show you how to
    use Cosign, which manages a different type of signature, but it also works to
    implement a good, secure supply chain, ensuring an image’s provenance and ownership.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `docker trust revoke` 来撤销特定容器镜像标签的签名。通过共享我们的公钥，可以将签名委托给其他用户。镜像签名的集成在你的平台中实际上取决于你使用的注册表。我们已经了解了
    Docker Hub 的流程，但其他解决方案可能会实现不同的命令和选项。我们将展示如何使用 Cosign，它管理一种不同类型的签名，但它同样有助于实施良好的安全供应链，确保镜像的来源和所有权。
- en: Now that we know how to ensure the uniqueness of container images by using their
    digests and signatures, we will continue to secure our images by implementing
    image content vulnerability scanning.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道如何通过使用摘要和签名来确保容器镜像的唯一性，接下来我们将通过实施镜像内容漏洞扫描来进一步保障镜像的安全性。
- en: Scanning image content for vulnerabilities
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扫描镜像内容中的漏洞
- en: Container images can be securely stored in registries, and we can track their
    provenance and ownership by reviewing their digests and signatures. It would be
    great if we could trust all the files included in the image layers. There are
    many solutions that can check whether any of the files included inside the image
    layers are somehow vulnerable to any reported issues or exploits that can affect
    your application’s integrity. However, this requires new tools and effort.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像可以安全地存储在注册表中，我们可以通过查看它们的摘要和签名来追踪它们的来源和所有权。如果我们能信任镜像层中包含的所有文件，那将是非常棒的。现在有许多解决方案可以检查镜像层中的文件是否存在任何已报告的问题或漏洞，这些漏洞可能会影响到应用程序的完整性。然而，这需要新的工具和努力。
- en: '**Image scanning** can be implemented in either your local development environment
    or the remote registries where images are eventually stored and shared. Most content
    scanners use well-known public and community-supported databases of known vulnerabilities
    and exploits. These will give us a list of **Common Vulnerabilities and Exposures**
    (**CVEs**) to compare against our content. Each binary or library in this list
    is identified by its digest, and it is easy to find out whether a file in our
    image layers is considered vulnerable in this list.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**镜像扫描**可以在本地开发环境或镜像最终存储和共享的远程注册表中实施。大多数内容扫描器使用著名的公共和社区支持的已知漏洞和利用数据库。这些数据库会为我们提供一份**常见漏洞和暴露**（**CVE**）列表，用于与我们的内容进行对比。该列表中的每个二进制文件或库都会通过其摘要进行标识，我们可以轻松找出镜像层中的文件是否被认为在该列表中是脆弱的。'
- en: The Docker container runtime scanning facility is integrated into the client
    command line and can be executed with either images or Dockerfiles, which is very
    interesting because we can get an overview of possible problems in our images
    even before they are built.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 容器运行时扫描功能集成在客户端命令行中，可以通过镜像或 Dockerfile 来执行，这一点非常有趣，因为我们可以在镜像构建之前就概览可能出现的问题。
- en: 'All of Docker Hub’s official images provide a pretty descriptive report of
    the security scanner results. This is also available for **verified publisher**
    (software vendors) and **sponsored OSS** (open source community-supported projects)
    images. We can access these reports from the **Tags** section on any of these
    images. The following screenshot shows the summary report for each tag in Postgres:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Docker Hub 的官方镜像都会提供非常详细的安全扫描报告。**已验证的发布者**（软件供应商）和**赞助的开源软件**（开源社区支持的项目）镜像也提供此类报告。我们可以通过这些镜像的**标签**部分访问这些报告。以下截图显示了
    Postgres 每个标签的摘要报告：
- en: '![Figure 3.8 – A review of the vulnerabilities for the official Postgres image
    in Docker Hub](img/B19845_03_08.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – Docker Hub 中官方 Postgres 镜像漏洞的回顾](img/B19845_03_08.jpg)'
- en: Figure 3.8 – A review of the vulnerabilities for the official Postgres image
    in Docker Hub
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – Docker Hub 中官方 Postgres 镜像漏洞的回顾
- en: 'We can deep-dive by clicking on any tag. This will show us the CVE number associated
    with the vulnerability detected. The following screenshot shows some CVEs found
    for **stdlib 1.18.2**, included in the **postgres:latest** image layers:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过点击任何标签进行深入探讨。这将显示与检测到的漏洞相关的 CVE 编号。以下截图显示了在**postgres:latest**镜像层中发现的一些
    **stdlib 1.18.2** 的 CVE：
- en: '![Figure 3.9 – Deep-diving inside the current vulnerabilities in the postgres:latest
    image](img/B19845_03_09.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9 – 深入分析当前在 postgres:latest 镜像中的漏洞](img/B19845_03_09.jpg)'
- en: Figure 3.9 – Deep-diving inside the current vulnerabilities in the postgres:latest
    image
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 深入分析当前在 postgres:latest 镜像中的漏洞
- en: This report gives us a good idea of the health of Docker Hub’s images. It is
    recommended to always review the scanner report of the official images we will
    use in our developments.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 该报告让我们对 Docker Hub 镜像的健康状况有了很好的了解。建议始终查看我们在开发中使用的官方镜像的扫描报告。
- en: 'The Docker command-line scanning implementation uses the `docker scan`. Here
    is an example of the execution against **postgres:latest**:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 命令行扫描实现使用 `docker scan`。下面是对 **postgres:latest** 执行的一个示例：
- en: '![Figure 3.10 – Using the docker scan facility in our local environment](img/B19845_03_10.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10 – 在我们的本地环境中使用 docker scan 功能](img/B19845_03_10.jpg)'
- en: Figure 3.10 – Using the docker scan facility in our local environment
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – 在我们的本地环境中使用 docker scan 功能
- en: In the preceding screenshot, we used the `–-accept-license` argument to use
    a non-interactive execution; otherwise, we would be asked to accept the agreement
    with the Snyk service. We also included `--severity` for filtering and only showed
    critical vulnerabilities. In this example, Snyk does not show any critical vulnerabilities,
    which differs from Docker Hub’s website. This may depend on base image scanning.
    The Snyk scanner only provides 10 scans a month, which probably won’t be enough.
    You can sign up to increase this limit or even subscribe to their service to increase
    the features available, avoiding any limitations. In this chapter’s *Labs* section,
    we will learn how to use another scanning tool, **Trivy**, which will be executed
    as a container to avoid any installation in our working environment.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们使用了 `--accept-license` 参数进行非交互式执行；否则，我们会被要求接受与 Snyk 服务的协议。我们还加入了 `--severity`
    参数进行过滤，只显示严重漏洞。在这个示例中，Snyk 没有显示任何严重漏洞，这与 Docker Hub 网站上的情况不同。这可能与基础镜像扫描有关。Snyk
    扫描器每月仅提供 10 次扫描，这可能不够用。你可以注册以增加这个限制，或者订阅他们的服务以增加可用功能，避免任何限制。在本章的 *实验* 部分，我们将学习如何使用另一种扫描工具
    **Trivy**，该工具将作为容器执行，从而避免在我们的工作环境中安装。
- en: We have learned how to work with image registries and ensure security by scanning
    and signing images. In the next section, we will review some easy labs to put
    into practice the concepts we’ve discussed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用镜像注册表并通过扫描和签名镜像确保安全。在接下来的部分，我们将回顾一些简单的实验，帮助实践我们讨论过的概念。
- en: Labs
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验
- en: The following labs will provide examples to put into practice the concepts and
    procedures learned in this chapter. We will use Docker Desktop as the container
    runtime and WSL 2 (or your Linux/macOS Terminal) to execute the commands described.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的实验将提供示例，帮助实践本章中学到的概念和程序。我们将使用 Docker Desktop 作为容器运行时，使用 WSL 2（或你的 Linux/macOS
    终端）来执行所描述的命令。
- en: The first step for all labs is always to download the most updated version of
    this book’s GitHub repository at [https://github.com/PacktPublishing/Containers-for-Developers-Handbook.git](https://github.com/PacktPublishing/Containers-for-Developers-Handbook.git).
    To do this, simply execute `git clone` [https://github.com/PacktPublishing/Containers-for-Developers-Handbook.git](https://github.com/PacktPublishing/Containers-for-Developers-Handbook.git)
    to download all its content. If you have already downloaded it before, ensure
    you have the newest version by executing `git pull` inside the directory.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 所有实验的第一步都是始终下载本书 GitHub 仓库的最新版本，地址为 [https://github.com/PacktPublishing/Containers-for-Developers-Handbook.git](https://github.com/PacktPublishing/Containers-for-Developers-Handbook.git)。为此，只需执行
    `git clone` [https://github.com/PacktPublishing/Containers-for-Developers-Handbook.git](https://github.com/PacktPublishing/Containers-for-Developers-Handbook.git)
    即可下载所有内容。如果你之前已经下载过，确保通过在该目录下执行 `git pull` 来获取最新版本。
- en: All commands presented in these labs will be executed within the `Containers-for-Developers-Handbook/Chapter3`
    directory.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有实验中的命令将会在 `Containers-for-Developers-Handbook/Chapter3` 目录下执行。
- en: Deploying and using your own local registry
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署和使用你自己的本地注册表
- en: 'In this first lab, we will deploy a simple unauthenticated and untrusted (HTTP,
    not HTTPS) registry. We will use the currently available Docker official registry
    image, which is `registry:2.8.1` at the time of writing. We can review its vulnerabilities
    by navigating to [https://hub.docker.com/layers/library/registry/2.8.1/images/sha256-a001a2f72038b13c1cbee7cdd2033ac565636b325dfee98d8b9cc4ba749ef337?context=explore](https://hub.docker.com/layers/library/registry/2.8.1/images/sha256-a001a2f72038b13c1cbee7cdd2033ac565636b325dfee98d8b9cc4ba749ef337?context=explore):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个实验中，我们将部署一个简单的无认证和不受信任（HTTP，而非 HTTPS）的注册中心。我们将使用当前可用的 Docker 官方注册镜像，它是`registry:2.8.1`，写作时该版本为最新。我们可以通过访问[https://hub.docker.com/layers/library/registry/2.8.1/images/sha256-a001a2f72038b13c1cbee7cdd2033ac565636b325dfee98d8b9cc4ba749ef337?context=explore](https://hub.docker.com/layers/library/registry/2.8.1/images/sha256-a001a2f72038b13c1cbee7cdd2033ac565636b325dfee98d8b9cc4ba749ef337?context=explore)来查看它的漏洞：
- en: '![Figure 3.11 – An overview of the official Docker registry:2.8.1 vulnerabilities](img/B19845_03_11.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.11 – 官方 Docker registry:2.8.1 漏洞概览](img/B19845_03_11.jpg)'
- en: Figure 3.11 – An overview of the official Docker registry:2.8.1 vulnerabilities
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – 官方 Docker registry:2.8.1 漏洞概览
- en: 'We then perform the following steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们执行以下步骤：
- en: 'Pull the `docker.io/registry:2.8.1` image:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拉取`docker.io/registry:2.8.1`镜像：
- en: '[PRE15]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, review its **CMD**, **ENTRYPOINT**, **VOLUME**, and **EXPOSE** keys. These
    will show us which command will be executed, the port that will be used, and which
    directory will be used for persistent data:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，回顾其**CMD**、**ENTRYPOINT**、**VOLUME**和**EXPOSE**键。这些将显示我们将执行的命令、将使用的端口以及将用于持久化数据的目录：
- en: '[PRE16]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a directory for registry data, and execute a container using the registry
    image pulled previously:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于注册数据的目录，并使用之前拉取的注册镜像执行一个容器：
- en: '[PRE17]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: $ docker container ls
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker container ls
- en: CONTAINER ID   IMAGE            COMMAND                  CREATED         STATUS         PORTS                     NAMES
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 容器 ID   镜像              命令                      创建时间          状态              端口                       名称
- en: '5000. We used –P to allow the container runtime to choose any port available
    to publish the application’s port; therefore, this port may be different in your
    environment:'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 5000。我们使用了–P选项，以便容器运行时可以选择任何可用端口来发布应用程序的端口；因此，这个端口在您的环境中可能不同：
- en: '[PRE18]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s download an `alpine` container image and upload it to our registry. First,
    we need to pull this image:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们下载一个`alpine`容器镜像并上传到我们的注册中心。首先，我们需要拉取这个镜像：
- en: '[PRE20]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Chapter3$ docker image tag alpine localhost:32768/alpine:0.1
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Chapter3$ docker image tag alpine localhost:32768/alpine:0.1
- en: '[PRE21]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can list the local images before pushing them to the local registry:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以列出本地镜像，然后再推送到本地注册中心：
- en: '[PRE22]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Chapter3$ docker image push localhost:32768/alpine:0.1
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Chapter3$ docker image push localhost:32768/alpine:0.1
- en: The push refers to repository [localhost:32768/alpine]
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 推送涉及的仓库是[localhost:32768/alpine]
- en: '7cd52847ad77: Pushed'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '7cd52847ad77: 推送完成'
- en: '0.1: digest: sha256:e2e16842c9b54d985bf1ef9242a313f36b856181f188de21313820e177002501
    size: 528'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '0.1: 摘要：sha256:e2e16842c9b54d985bf1ef9242a313f36b856181f188de21313820e177002501
    大小：528'
- en: '[PRE23]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let’s now review how images are distributed in our filesystem:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们回顾一下图像在文件系统中的分布情况：
- en: '[PRE24]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Chapter3$ ls -lart registry-data/docker/registry/v2/blobs/sha256/
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Chapter3$ ls -lart registry-data/docker/registry/v2/blobs/sha256/
- en: total 20
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 总计 20
- en: drwxr-xr-x 3 root root 4096 Mar  6 19:55 63
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: drwxr-xr-x 3 root root 4096 3月 6 19:55 63
- en: drwxr-xr-x 3 root root 4096 Mar  6 19:55 ..
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: drwxr-xr-x 3 root root 4096 3月 6 19:55 ..
- en: drwxr-xr-x 3 root root 4096 Mar  6 19:55 e2
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: drwxr-xr-x 3 root root 4096 3月 6 19:55 e2
- en: drwxr-xr-x 3 root root 4096 Mar  6 19:55 b2
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: drwxr-xr-x 3 root root 4096 3月 6 19:55 b2
- en: 'alpine:latest image as localhost:32768/alpine:0.2:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: alpine:latest 镜像作为 localhost:32768/alpine:0.2：
- en: '[PRE25]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This means that we have a new tag for the original Alpine image; hence, we expect
    that only metadata should be modified.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着我们为原始 Alpine 镜像创建了一个新的标签；因此，我们预计只有元数据会被修改。
- en: '[PRE26]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let’s push the image and review the filesystem changes:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们推送镜像并回顾文件系统的变化：
- en: '[PRE27]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can list the content of the registry again:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以再次列出注册表的内容：
- en: '[PRE28]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Chapter3$ ls -lart registry-data/docker/registry/v2/repositories/alpine/_manifests/tags/
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Chapter3$ ls -lart registry-data/docker/registry/v2/repositories/alpine/_manifests/tags/
- en: total 16
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 总计 16
- en: drwxr-xr-x 4 root root 4096 Mar  6 19:55 0.1
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: drwxr-xr-x 4 root root 4096 3月 6 19:55 0.1
- en: drwxr-xr-x 4 root root 4096 Mar  6 19:55 ..
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: drwxr-xr-x 4 root root 4096 3月 6 19:55 ..
- en: drwxr-xr-x 4 root root 4096 Mar  6 19:59 0.2
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: drwxr-xr-x 4 root root 4096 3月 6 19:59 0.2
- en: blobs directory for both tags 0.1 and 0.2. Let’s now push a new image with some
    changes.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: blobs 目录适用于标签 0.1 和 0.2。现在，让我们推送一个有些变化的新镜像。
- en: '[PRE29]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We will now create a modified version of the original `alpine.latest` image
    by using it as the base image in a new build process. We will use an on-the-fly
    build by piping a Dockerfile:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将通过将 `alpine.latest` 镜像作为基础镜像，在新的构建过程中创建它的修改版。我们将通过管道传递 Dockerfile 来进行实时构建：
- en: '[PRE30]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This is a different way of building images using a Dockerfile. In this case,
    we can’t use the image content, and therefore, copying files wouldn’t work, but
    it is fine for this example. We create a new image using Unix pipes to avoid the
    creation of a file. This way, we create an image on the fly:'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是另一种使用 Dockerfile 构建镜像的方式。在这种情况下，我们不能使用镜像内容，因此复制文件将不起作用，但对于这个例子来说是可以的。我们使用
    Unix 管道创建一个新的镜像，以避免创建文件。这样，我们就可以实时创建镜像：
- en: '[PRE31]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We now push this new image and review the directories:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们推送这个新镜像并查看目录：
- en: '[PRE32]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, one new layer is pushed.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，一个新的层已被推送。
- en: 'Now, we’ll review the local folders, where the image registry stores data in
    our host:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们来查看本地文件夹，了解镜像注册表在我们的主机中存储数据的位置：
- en: '[PRE33]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We have seen how images are stored and managed inside our registry. Let’s now
    move on to a new lab, in which we will review how to sign images with a different
    tool, **Cosign**.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了镜像是如何在我们的注册表中存储和管理的。现在让我们进入一个新实验，回顾一下如何使用一个不同的工具**Cosign**来签名镜像。
- en: Signing images with Cosign
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Cosign 签署镜像
- en: 'For this new lab, we will use a new tool, Cosign, which can be easily downloaded
    in different formats:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新实验中，我们将使用一个新的工具Cosign，它可以以不同的格式轻松下载：
- en: 'We will install Cosign by downloading its binary:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过下载其二进制文件来安装Cosign：
- en: '[PRE34]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Chapter3$ cosign generate-key-pair \
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Chapter3$ cosign generate-key-pair \
- en: --output-key-prefix frjaraur
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --output-key-prefix frjaraur
- en: 'Enter password for private key:'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输入私钥密码：
- en: 'Enter password for private key again:'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次输入私钥密码：
- en: Private key written to frjaraur.key
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 私钥写入到 frjaraur.key
- en: Public key written to frjaraur.pub
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 公钥写入到 frjaraur.pub
- en: '[PRE35]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Chapter3$ ls -l
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Chapter3$ ls -l
- en: total 12
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: total 12
- en: -rw------- 1 frjaraur frjaraur  649 Mar  7 19:51 frjaraur.key
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: -rw------- 1 frjaraur frjaraur 649 Mar 7 19:51 frjaraur.key
- en: -rw-r--r-- 1 frjaraur frjaraur  178 Mar  7 19:51 frjaraur.pub
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: -rw-r--r-- 1 frjaraur frjaraur 178 Mar 7 19:51 frjaraur.pub
- en: '[PRE36]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We will add a new name and tag to the image, and after that, we will push it:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为镜像添加一个新的名称和标签，然后推送它：
- en: '[PRE37]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, we can proceed to sign the image:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以继续签署镜像：
- en: '[PRE38]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note the warning message. As we learned in [*Chapter 2*](B19845_02.xhtml#_idTextAnchor036),
    *Building Docker Images*, only the image digest really ensures image uniqueness,
    and in this example, we use the tags to reference the image we are signing. We
    should use the digest to improve the signing process and ensure that we sign the
    right image for production, but for this example, we can continue.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意警告信息。正如我们在[*第2章*](B19845_02.xhtml#_idTextAnchor036)《构建 Docker 镜像》中学到的，*只有镜像摘要真正确保镜像的唯一性*，在这个例子中，我们使用标签来引用我们正在签名的镜像。我们应该使用摘要来改进签名过程，确保我们为生产签署正确的镜像，但在这个例子中，我们可以继续使用标签。
- en: 'We can now verify the signature associated with the image:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以验证与该镜像相关联的签名：
- en: '[PRE39]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Chapter3$ cosign triangulate localhost:32768/\
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Chapter3$ cosign triangulate localhost:32768/\
- en: alpine:0.4-signed
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: alpine:0.4-signed
- en: localhost:32768/alpine:sha256-f7ffc0ab458dfa9e474f656afebb4289953bd1196022911f0b4c739705e49956.sig
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: localhost:32768/alpine:sha256-f7ffc0ab458dfa9e474f656afebb4289953bd1196022911f0b4c739705e49956.sig
- en: '[PRE40]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Chapter3$ docker image ls --digests |grep "0.4-signed"
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Chapter3$ docker image ls --digests |grep "0.4-signed"
- en: 'localhost:32768/alpine:0.3 image:'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: localhost:32768/alpine:0.3 镜像：
- en: '[PRE41]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we push it again:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们再次推送它：
- en: '[PRE43]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can now verify the newly pushed image again:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以再次验证新推送的镜像：
- en: '[PRE44]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now that we know how to improve security by signing and verifying their signatures,
    we can go a step further by using security scanners to review any possible vulnerability
    in their content.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何通过签名和验证签名来提高安全性，我们可以更进一步，使用安全扫描器来审查它们内容中的任何潜在漏洞。
- en: Improving security by using image content vulnerability scanners
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过使用镜像内容漏洞扫描器来提高安全性
- en: For this lab, we will use **Trivy**, from Aquasec. It is a very powerful security
    scanner for file content, misconfigurations, and even Kubernetes resources. It
    will really help you in your daily DevOps tasks as well as as a developer. We
    will create a custom Trivy image for offline usage by including the online database.
    With this example, we will also learn how to manage cached content inside our
    images.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，我们将使用来自 Aquasec 的**Trivy**。它是一个非常强大的安全扫描器，可以扫描文件内容、配置错误，甚至是 Kubernetes
    资源。它将大大帮助你在日常的 DevOps 工作中，也会对开发人员有帮助。我们将创建一个用于离线使用的自定义 Trivy 镜像，并包含在线数据库。在这个例子中，我们还将学习如何管理镜像中的缓存内容。
- en: 'Inside the `Chapter3` folder, you will find the `trivy` directory, with a Dockerfile
    ready for you to build the aforementioned custom image for this lab:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Chapter3`文件夹中，您将找到`trivy`目录，其中包含一个准备好的Dockerfile，供您为本实验构建上述自定义镜像：
- en: 'First, we will verify the digest for the latest stable version of the `docker.io/trivy`
    image by using `skopeo`:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将使用`skopeo`验证最新稳定版本的`docker.io/trivy`镜像的摘要：
- en: '[PRE45]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: FROM aquasec/trivy:0.38.2-amd64@sha256:8038205ca56f2d88b93d804d0407831056ee0e40616cb0b8d74b0770c93aaa9f
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: FROM aquasec/trivy:0.38.2-amd64@sha256:8038205ca56f2d88b93d804d0407831056ee0e40616cb0b8d74b0770c93aaa9f
- en: LABEL MAINTAINER "frjaraur at github.com"
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: LABEL MAINTAINER "frjaraur at github.com"
- en: LABEL TRIVY "0.38.2-amd64"
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: LABEL TRIVY "0.38.2-amd64"
- en: ENV TRIVY_CACHE_DIR="/cache"  \
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ENV TRIVY_CACHE_DIR="/cache"  \
- en: TRIVY_NO_PROGRESS=true
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: TRIVY_NO_PROGRESS=true
- en: RUN TRIVY_TEMP_DIR=$(mktemp -d) \
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: RUN TRIVY_TEMP_DIR=$(mktemp -d) \
- en: '&& trivy --cache-dir $TRIVY_CACHE_DIR image --download-db-only \'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '&& trivy --cache-dir $TRIVY_CACHE_DIR image --download-db-only \'
- en: '&& tar -cf ./db.tar.gz -C $TRIVY_CACHE_DIR/db metadata.json trivy.db'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '&& tar -cf ./db.tar.gz -C $TRIVY_CACHE_DIR/db metadata.json trivy.db'
- en: ENV TRIVY_SKIP_DB_UPDATE=true
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ENV TRIVY_SKIP_DB_UPDATE=true
- en: RUN chmod 777 -R /cache
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: RUN chmod 777 -R /cache
- en: USER nobody
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: USER nobody
- en: '[PRE46]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We will now build our image:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将构建我们的镜像：
- en: '[PRE47]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Chapter3/trivy$ docker run -ti \
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Chapter3/trivy$ docker run -ti \
- en: localhost:32768/trivy:custom-0.38.2 \
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: localhost:32768/trivy:custom-0.38.2 \
- en: image python:alpine --scanners vuln \
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: image python:alpine --scanners vuln \
- en: --severity HIGH,CRITICAL
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --severity 高危,严重
- en: 2023-03-08T20:49:21.927Z        INFO    Vulnerability scanning is enabled
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2023-03-08T20:49:21.927Z        INFO    已启用漏洞扫描
- en: '2023-03-08T20:49:26.865Z        INFO    Detected OS: alpine'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '2023-03-08T20:49:26.865Z        INFO    检测到操作系统: alpine'
- en: 2023-03-08T20:49:26.865Z        INFO    Detecting Alpine vulnerabilities...
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2023-03-08T20:49:26.865Z        INFO    正在检测Alpine漏洞...
- en: '2023-03-08T20:49:26.869Z        INFO    Number of language-specific files:
    1'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2023-03-08T20:49:26.869Z        INFO    语言特定文件的数量：1
- en: 2023-03-08T20:49:26.869Z        INFO    Detecting python-pkg vulnerabilities...
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2023-03-08T20:49:26.869Z        INFO    正在检测python-pkg漏洞...
- en: python:alpine (alpine 3.17.2)
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: python:alpine (alpine 3.17.2)
- en: 'Total: 1 (HIGH: 1, CRITICAL: 0)'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 总计：1（高危：1，严重：0）
- en: │  Library   │ Vulnerability │ Severity │ Installed Version │ Fixed Version
    │                           Title                            │
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: │  库       │ 漏洞         │ 严重程度 │ 已安装版本 │ 修复版本 │                           标题                            │
- en: '│ libcom_err │ CVE-2022-1304 │ HIGH     │ 1.46.5-r4         │ 1.46.6-r0     │
    e2fsprogs: out-of-bounds read/write via crafted filesystem │'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '│ libcom_err │ CVE-2022-1304 │ 高危     │ 1.46.5-r4         │ 1.46.6-r0     │
    e2fsprogs: 通过精心构造的文件系统进行越界读写 │'
- en: HIGH and CRITICAL severities only to avoid any non-critical output. We used
    the default table format for the output, but it is possible to use the JSON format,
    for example, to include the vulnerability scanner in automated tasks.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 仅报告高危和严重漏洞，以避免任何非关键输出。我们使用了默认的表格格式输出，但也可以使用JSON格式，例如，将漏洞扫描器集成到自动化任务中。
- en: '[PRE48]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Image scanning will really help us decide which releases to use, or even fix
    issues in our images by understanding the vulnerabilities included in our base
    images. Scanning processes will usually be included in your building pipelines
    to ensure that your workflow does not produce images with vulnerabilities that
    can be easily managed.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像扫描将真正帮助我们决定使用哪些版本，甚至通过了解基础镜像中包含的漏洞，修复镜像中的问题。扫描过程通常会被包含在构建管道中，以确保您的工作流不会产生易于管理的漏洞镜像。
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to store container images in registries, using
    appropriate repositories and tags for our application components. You, as a developer,
    must provide the logic names, tags, and required information to your images to
    allow users to run your applications correctly. Labels will also allow you to
    include any relevant information that can help you track code changes and how
    they apply to your application’s processes.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何将容器镜像存储在镜像仓库中，使用适当的仓库和标签来管理我们的应用组件。作为开发者，您必须为您的镜像提供逻辑名称、标签和所需信息，以便用户能够正确运行您的应用程序。标签还允许您包括任何相关信息，这些信息有助于您跟踪代码更改以及这些更改如何影响您的应用程序流程。
- en: In addition, it is critical to ensure a secure supply chain for our image artifacts.
    We learned that digests provide uniqueness, but that is not enough. We can include
    signatures to inform users about the provenance and ownership of the images we
    create, but signing does not guarantee the health of the files included inside
    our image layers. We will include content vulnerability scanning in our build
    process. This will allow us to review and verify whether the images we use to
    create our projects contain any security problems. Knowing the vulnerabilities
    in our images will help us to improve our application life cycle. Although fixing
    all vulnerabilities can be hard or even impossible, it is key to understand the
    possible issues we have to manage in our projects.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，确保我们图像制品的安全供应链至关重要。我们了解到摘要提供了唯一性，但这还不够。我们可以包含签名来告知用户我们创建的图像的来源和所有权，但签名并不能保证我们图像层内包含的文件的健康。我们将在构建过程中包含内容漏洞扫描。这将使我们能够审查和验证我们用来创建项目的图像是否包含任何安全问题。了解我们图像中的漏洞将帮助我们改进应用程序生命周期。尽管修复所有漏洞可能很困难甚至不可能，但理解我们在项目中必须处理的可能问题是关键的。
- en: Now that we have a good base to create and share our application images, using
    the best techniques and improved security, it’s time to move on to the next chapter,
    in which we will learn how to run software containers and the command line for
    different features and container runtimes.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个良好的基础来创建和共享我们的应用程序图像，使用最佳技术和改进的安全性，是时候进入下一章了，我们将学习如何运行软件容器以及不同功能和容器运行时的命令行。
