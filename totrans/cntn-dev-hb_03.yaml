- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sharing Docker Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sharing container images is key to being able to run your applications anywhere.
    You’ve built your application components on your workstation or laptop, and now
    you are ready to move them to different platform stages. This chapter will cover
    how images will be stored and shared with other users or orchestration platforms.
    We will also review various methods for signing container images to improve security
    in our development workflow. We will also learn how to use content scanners to
    find any possible security issues in our container images. By the end of this
    chapter, you will be ready to deliver secure and trusted images to production.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Container image registries and repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving security by signing container images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing container image content by using image scanners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will teach you about the different tools and techniques used to
    deliver secure images, which will really improve the use of software containers
    in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the labs for this chapter at [https://github.com/PacktPublishing/Containers-for-Developers-Handbook/tree/main/Chapter3](https://github.com/PacktPublishing/Containers-for-Developers-Handbook/tree/main/Chapter3),
    where you will find some extended explanations, omitted in the chapter’s content
    to make it easier to follow. The *Code In Action* video for this chapter can be
    found at [https://packt.link/JdOIY](https://packt.link/JdOIY).
  prefs: []
  type: TYPE_NORMAL
- en: Container image registries and repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B19845_01.xhtml#_idTextAnchor015), *Modern Infrastructure and
    Applications with Docker*, we discussed why software containers have become so
    popular. In [*Chapter 2*](B19845_02.xhtml#_idTextAnchor036), *Building Docker
    Images*, we learned how we can create containers by using them as templates and
    building container images. Before deep-diving into container execution, we will
    learn, in this chapter, how to store and manage container images by using registries.
  prefs: []
  type: TYPE_NORMAL
- en: What is a registry?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **registry** is a service where container images can be stored. This storage
    can be delivered as a service by cloud providers or on-premises by deploying your
    own registry. Cloud registries require zero maintenance from you; you just need
    to manage the usual housekeeping of unused images. Docker Hub ([docker.io](http://docker.io))
    is probably the most common service of this kind, but we also have Google’s Container
    Registry ([gcr.io](http://gcr.io)) and similar services from Red Hat, GitHub,
    and GitLab, among others. Container images have become the new artifacts to run
    applications, and nowadays, many cloud code repositories include their own image
    registry services.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, most registries can ingest and manage Docker’s Image Manifest V2 and
    Open Container Initiative specifications, and therefore, we can use any of these
    formats for our images. These image schemas specify how image layers and metadata
    will be associated for use in our container runtime.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, we will run our own local registry and verify how
    images are stored.
  prefs: []
  type: TYPE_NORMAL
- en: Container runtimes completely manage all the actions we do with software containers
    or their images; hence, your client will just tell your runtime to download images
    before executing a container or upload them once built.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how image registries work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before continuing to understand how image registries work, we should introduce
    here the complete container image naming convention. Images will always be referenced
    by using the following `name`:`tag` format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This means that all image references must contain the registry where they are
    stored. You can omit this while your container runtime works with local images,
    but any time you use any remote image, you should always use the registry’s `443`,
    using **TLS/SSL**. This port will be used by default by container runtimes to
    connect to registries, but we can use any other port by specifying it when we
    refer to its images. **Image repository** is the term we commonly use to refer
    to the software repository where images are stored, but it is important to understand
    that images follow the same nomenclature used for code repositories, and hence,
    different tags are used to identify images within repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Container images may be associated with the users or teams that own the images
    in the registries. This is common for these kinds of services, as the user is
    the one who pushed the image, which may be public or private. If you are part
    of a group, your image may be accessible to the members of the group. This role-based
    access may differ from one registry to another; you should ask your administrators
    or read the appropriate documentation for your registry. Docker images published
    in Docker Hub are shown as `docker.io/library`, and all their public repositories
    are published under this root group, similar to the schema presented at the beginning
    of this subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, although tags help identify images, we learned in [*Chapter 2*](B19845_02.xhtml#_idTextAnchor036),
    *Building Docker Images*, that one image can have multiple tags; hence, a tag
    does not uniquely identify a specific image. **Image digests**, however, uniquely
    identify a set of layers for each image, and these really differ between images.
    To ensure that we use the correct image, we should use its **digest**.
  prefs: []
  type: TYPE_NORMAL
- en: Tagging images is not always easy; you must ensure, as a developer, that anyone
    can follow your work by using appropriate tags that reference the release on which
    users are running. Remember that you can add as many labels as you need to include
    additional information that is relevant for users. I always try to follow the
    code release schema, using `X.Y.Z` to represent major versions, minor versions,
    and fixes. It is a good idea to include a label regarding the commit in your code
    that generated the image artifact. This will help you track problems and also
    improve the application’s life cycle. Automation will really help you to implement
    a workflow and follow your own tagging and labeling logic schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever we pull an image from a registry, we get its digest within its metadata,
    as we can see in the following example, by executing `docker image` `pull alpine:3.17.2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – An image digest can be easily recovered after pulling an image
    from remote registries](img/B19845_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – An image digest can be easily recovered after pulling an image
    from remote registries
  prefs: []
  type: TYPE_NORMAL
- en: Depending on which container runtime you use, a default container registry can
    be set. The Docker container runtime will use [docker.io](http://docker.io) by
    default, which is why we can execute `docker image pull alpine:3.17.2` to download
    an `alpine:3.17.2` image, as shown in *Figure 3**.1*. The digest in both cases
    is the same; hence, they are the same image. However, we can create a new image
    with this same name in our system. If we first delete the previously downloaded
    image (names are unique within a container runtime) and create a new one, it will
    have a completely different digest. This will happen even if we used the same
    Dockerfile because digests will also integrate the dates for each execution done
    during the build process.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'We can download all images from a repository by using the `--all-tags` argument,
    as in the following example: `docker image pull --all-tags alpine`. This will
    download all images inside the `alpine` repository.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can review which registries are included by default in Docker Desktop by
    using `docker info`. The following screenshot shows an example output using **Windows
    PowerShell**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Local container image registries used by our container runtime](img/B19845_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Local container image registries used by our container runtime
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the `localhost` registry and `hubproxy.docker.internal:5000`
    are shown. The local registry is used to store images locally. Desktop clients
    such as **Docker Desktop** and **Rancher Desktop** will show local images graphically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – An overview of Docker Desktop local images](img/B19845_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – An overview of Docker Desktop local images
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, Docker offers integration with your Docker Hub account. You can also
    view your remote images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – An overview of Docker Desktop Docker Hub remote images](img/B19845_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – An overview of Docker Desktop Docker Hub remote images
  prefs: []
  type: TYPE_NORMAL
- en: This interface also allows you to download and review the vulnerabilities found
    in the image’s content if you pay for a Docker subscription. We will learn more
    about security content scanning in the *Scanning image content for vulnerabilities*
    section in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your container runtime may require some specific configurations to allow new
    container registries. All container image registries are expected to use `insecure-registries`
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Registries will usually require a login, and we will use their FQDN to access
    them. If you need to access private repositories, an account will be required.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use `docker search` to find repositories based on a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Searching for images using the docker search command](img/B19845_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Searching for images using the docker search command
  prefs: []
  type: TYPE_NORMAL
- en: Note that some images are marked as `OFFICIAL` and others as `AUTOMATED`. Docker
    Hub provides this feature as, depending on your registry, some CI/CD integrations
    may build images automatically for you. These values help mark automatically built
    images. You can use their automation if it fits your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker official images are container images built and maintained by Docker
    following best practices. They also ensure security by providing continuous updates.
    All official image code is publicly available on GitHub, and you can use it directly
    or customize it to your needs. You can provide feedback and contact Docker if
    you have any issues with using them. A great example of these repositories is
    the one for Alpine images ([https://github.com/alpinelinux/docker-alpine/](https://github.com/alpinelinux/docker-alpine/)),
    where you will find code to build all Alpine images. The following screenshot
    shows how can you find official images for any technology you may need:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – An overview of official images available in Docker Hub](img/B19845_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – An overview of official images available in Docker Hub
  prefs: []
  type: TYPE_NORMAL
- en: Software vendors and open source community projects also offer container images,
    prepared and maintained by them. The best method to integrate third-party projects
    or components in your applications will always be using images already prepared
    for you by Docker, a verified publisher, or sponsored open source software providers.
    These images are quite well documented, and you will be able to customize container
    behavior by using arguments and environment variables. You will avoid a lot of
    problems by using these images, instead of having to create your own from scratch.
    In the *Labs* section, we will review a very commonly used PostgreSQL database
    example to understand this better.
  prefs: []
  type: TYPE_NORMAL
- en: Searching in repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Docker client provides certain repository search features, but they are
    not sufficient when you try to find specific images. You will probably use the
    Docker Hub web interface to perform fine-grained searches. Image registries publish
    their API, and we can use `curl` or any other web interface with arguments to
    find these images. Alternatively, we can use `skopeo` instead. This tool allows
    us to filter specific tags when we search inside a repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously in this section, registries provide an HTTP API that
    we can use to query specific repositories, tags, and so on, but it is not easy
    to use. We can use, for example, `curl` [https://myregistry.com:5000/v2/_catalog](https://myregistry.com:5000/v2/_catalog)
    to list all the images in the catalog. It is recommended to use `skopeo` instead
    because it will give you a clear and easy command line, especially when working
    with authenticated registries (certificates and login are required). It is available
    for different Linux flavors in their package repositories. You can follow the
    instructions for your distribution, or WSL, here: [https://github.com/containers/skopeo/blob/main/install.md](https://github.com/containers/skopeo/blob/main/install.md).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, `skopeo` isn’t available in the Ubuntu 20.04 LTS package repository.
    We can install a newer WSL distribution by executing `wsl --install -d Ubuntu-22.04`
    in a Windows PowerShell terminal. Once the new Ubuntu 22.04 WSL distribution is
    ready, we can install the package by using `sudo apt-get update -qq && sudo apt-get
    install skopeo -qq`. Then, we can integrate the container runtime from either
    Docker Desktop or Rancher Desktop by navigating to **Settings** | **Resources**
    | **WSL Integration** or **File** | **Preferences** | **WSL**. The following screenshot
    shows the interface in Docker Desktop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Enabling Docker Desktop integration in Ubuntu 22.04 LTS WSL](img/B19845_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Enabling Docker Desktop integration in Ubuntu 22.04 LTS WSL
  prefs: []
  type: TYPE_NORMAL
- en: 'With `skopeo`, we can easily list all tags included in a repository, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even inspect remote image information by using `skopeo inspect`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of installing `skopeo` locally, we can use Red Hat’s official image
    by using `docker` `container run`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, this has given you a new perspective on using software containers.
    We can package tools in container images and use them instead of having to install
    software on our computers.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to store and reference images from registries, it is time
    to learn how we can improve the ownership and security of our images by signing
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Improving security by signing container images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned in the previous section, a digest is the only way we can validate
    which image we are really using. In this section, we will review how we can improve
    this by signing images. This will really ensure we use the right images, as we
    can check the signature and verify the ownership of every image.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to analyze and learn about the Docker methodology used to sign
    images, but there are other methods available. We will use **Cosign** in the *Labs*
    section, which seems easier and integrates very well with the Kubernetes container
    orchestrator.
  prefs: []
  type: TYPE_NORMAL
- en: Docker created **Docker Content Trust** some years ago to integrate digital
    signatures in the container images management workflow and associate signatures
    with image tags. We will be able to have repositories with signed and unsigned
    images, for example, for local tests before moving on to a new stage. You, as
    a developer, create your images and decide which ones should be signed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The signing process is based on a list of different keys that will be used
    to include meta-information in your registered image. Some of these keys are interactively
    managed, while others are calculated during the execution. These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A `root` key is always used to start the signing process. You will be asked
    for this key, but you can also include it in your environment as a variable. It
    is very important to mention that if you lose this key, you will need to re-sign
    all your images, as there isn’t a known process to recover them. Always have a
    backup of this key; losing it can be a real problem in a production environment
    because your old signatures will not be valid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each repository will also have its `own` key. This key will be used to sign
    images in a specific repository, so losing it will only affect the images there.
    Nonetheless, you should keep it safe and have a backup.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `timestamp` key is added automatically to the final signature. This ensures
    security because each signature will always be completely different.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will be asked to create a passphrase for the root key, and each repository
    key will be created randomly. Docker provides its own password manager under your
    user’s `~/.``docker` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'To back up your keys, prepare a `tar.gz` file with the contents of `~/.docker/trust/private`.
    We can execute the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ umask 077; tar -zcvf private_keys_backup.tar.gz ~/.docker/trust/private;`
    `umask 022`'
  prefs: []
  type: TYPE_NORMAL
- en: We can enable Docker Content Trust in our client by setting the `DOCKER_CONTENT_TRUST=1`
    environment variable. This will enable Content Trust for any new command executed,
    which means that only signed images will be enabled in your environment. If we
    just need to enable Content Trust for a specific command, we can use the `--``disable-content-trust=false`
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try enabling Content Trust for an image by setting the `DOCKER_CONTENT_TRUST`
    variable. In this example, we perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first pull the `docker.io/busybox:latest` image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ export DOCKER_CONTENT_TRUST=1
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: $ docker image pull busybox
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using default tag: latest'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Pull (1 of 1): busybox:latest@sha256:7b3ccabffc97de872a30dfd234fd972a66d247c8cfc69b0550f276481852627c'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'docker.io/library/busybox@sha256:7b3ccabffc97de872a30dfd234fd972a66d247c8cfc69b0550f276481852627c:
    Pulling from library/busybox'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Digest: sha256:7b3ccabffc97de872a30dfd234fd972a66d247c8cfc69b0550f276481852627c'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Status: Image is up to date for busybox@sha256:7b3ccabffc97de872a30dfd234fd972a66d247c8cfc69b0550f276481852627c'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tagging busybox@sha256:7b3ccabffc97de872a30dfd234fd972a66d247c8cfc69b0550f276481852627c
    as busybox:latest
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'busybox image, docker.io/frjaraur/busybox-untrusted:0.1. Let’s see what happens
    if we try to pull an untrusted image when Docker Content Trust is enabled:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This means that no valid signature is found, but if we disable Content Trust,
    we can pull the image without a problem:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In fact, we can’t run any container using this untrusted image, which we can
    easily verify:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Conversely, if we run a trusted image, everything works as expected:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ docker trust inspect \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --pretty docker.io/busybox:latest
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Signatures for docker.io/busybox:latest
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: SIGNED TAG   DIGEST
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: SIGNERS
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: latest       7b3ccabffc97de872a30dfd234fd972a66d247c8cfc69b0550f276481852627c   (Repo
    Admin)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Administrative keys for docker.io/busybox:latest
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Repository Key:       02d15c99120886f6e02b4b0186522bc72d21a339ec35fad8af0a1b4a47c871d2
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Root Key:     074cad59e43e13b440b11d1b5521e20aa8633fc8f3928720590268895711d0c6
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: $ docker trust inspect --pretty docker.io/frjaraur/busybox-untrusted:0.1
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: frjaraur/busybox-untrusted:0.1; hence, this image cannot be used in a container
    runtime in which Docker Content Trust is enabled.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s start the signing process by creating a key for our user by using `docker
    trust` `key generate`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ ls -lart ~/.docker/trust/private/
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: total 12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: drwx------ 4 frjaraur frjaraur 4096 Mar  5 17:43 ..
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: -rw------- 1 frjaraur frjaraur  420 Mar  5 17:50 ceb39cd48cf78d478ffef211cc9da3e97ff9912ae60585254d6dc661076d0d2a.key
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'busybox image with docker.io/frjaraur/busybox-trusted:0.1; hence, both images
    are the same, but the signature is related to the tag:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can easily review our image signature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is important to say here that you will need a registry server with **Notary**.
    This project is responsible for managing your signatures. It is a client-server
    application that runs alongside your registry to integrate the signing part. Docker
    Hub already integrates a Notary server with their registry, which is why we are
    able to integrate our signatures in our image metadata.
  prefs: []
  type: TYPE_NORMAL
- en: If you are planning to use a local registry with Content Trust, you will need
    to also run and integrate a Notary server. You can learn more about Notary at
    [https://github.com/notaryproject/notary](https://github.com/notaryproject/notary).
  prefs: []
  type: TYPE_NORMAL
- en: We can revoke our signatures for a specific container image tag by using `docker
    trust revoke`. Signatures can be delegated to other users by sharing our public
    key. The integration of image signatures in your platform really depends on the
    registries you use. We have learned about the process for Docker Hub, but other
    solutions may implement different commands and options. We will show you how to
    use Cosign, which manages a different type of signature, but it also works to
    implement a good, secure supply chain, ensuring an image’s provenance and ownership.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to ensure the uniqueness of container images by using their
    digests and signatures, we will continue to secure our images by implementing
    image content vulnerability scanning.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning image content for vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Container images can be securely stored in registries, and we can track their
    provenance and ownership by reviewing their digests and signatures. It would be
    great if we could trust all the files included in the image layers. There are
    many solutions that can check whether any of the files included inside the image
    layers are somehow vulnerable to any reported issues or exploits that can affect
    your application’s integrity. However, this requires new tools and effort.
  prefs: []
  type: TYPE_NORMAL
- en: '**Image scanning** can be implemented in either your local development environment
    or the remote registries where images are eventually stored and shared. Most content
    scanners use well-known public and community-supported databases of known vulnerabilities
    and exploits. These will give us a list of **Common Vulnerabilities and Exposures**
    (**CVEs**) to compare against our content. Each binary or library in this list
    is identified by its digest, and it is easy to find out whether a file in our
    image layers is considered vulnerable in this list.'
  prefs: []
  type: TYPE_NORMAL
- en: The Docker container runtime scanning facility is integrated into the client
    command line and can be executed with either images or Dockerfiles, which is very
    interesting because we can get an overview of possible problems in our images
    even before they are built.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of Docker Hub’s official images provide a pretty descriptive report of
    the security scanner results. This is also available for **verified publisher**
    (software vendors) and **sponsored OSS** (open source community-supported projects)
    images. We can access these reports from the **Tags** section on any of these
    images. The following screenshot shows the summary report for each tag in Postgres:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – A review of the vulnerabilities for the official Postgres image
    in Docker Hub](img/B19845_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – A review of the vulnerabilities for the official Postgres image
    in Docker Hub
  prefs: []
  type: TYPE_NORMAL
- en: 'We can deep-dive by clicking on any tag. This will show us the CVE number associated
    with the vulnerability detected. The following screenshot shows some CVEs found
    for **stdlib 1.18.2**, included in the **postgres:latest** image layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Deep-diving inside the current vulnerabilities in the postgres:latest
    image](img/B19845_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Deep-diving inside the current vulnerabilities in the postgres:latest
    image
  prefs: []
  type: TYPE_NORMAL
- en: This report gives us a good idea of the health of Docker Hub’s images. It is
    recommended to always review the scanner report of the official images we will
    use in our developments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker command-line scanning implementation uses the `docker scan`. Here
    is an example of the execution against **postgres:latest**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Using the docker scan facility in our local environment](img/B19845_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Using the docker scan facility in our local environment
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we used the `–-accept-license` argument to use
    a non-interactive execution; otherwise, we would be asked to accept the agreement
    with the Snyk service. We also included `--severity` for filtering and only showed
    critical vulnerabilities. In this example, Snyk does not show any critical vulnerabilities,
    which differs from Docker Hub’s website. This may depend on base image scanning.
    The Snyk scanner only provides 10 scans a month, which probably won’t be enough.
    You can sign up to increase this limit or even subscribe to their service to increase
    the features available, avoiding any limitations. In this chapter’s *Labs* section,
    we will learn how to use another scanning tool, **Trivy**, which will be executed
    as a container to avoid any installation in our working environment.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how to work with image registries and ensure security by scanning
    and signing images. In the next section, we will review some easy labs to put
    into practice the concepts we’ve discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Labs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following labs will provide examples to put into practice the concepts and
    procedures learned in this chapter. We will use Docker Desktop as the container
    runtime and WSL 2 (or your Linux/macOS Terminal) to execute the commands described.
  prefs: []
  type: TYPE_NORMAL
- en: The first step for all labs is always to download the most updated version of
    this book’s GitHub repository at [https://github.com/PacktPublishing/Containers-for-Developers-Handbook.git](https://github.com/PacktPublishing/Containers-for-Developers-Handbook.git).
    To do this, simply execute `git clone` [https://github.com/PacktPublishing/Containers-for-Developers-Handbook.git](https://github.com/PacktPublishing/Containers-for-Developers-Handbook.git)
    to download all its content. If you have already downloaded it before, ensure
    you have the newest version by executing `git pull` inside the directory.
  prefs: []
  type: TYPE_NORMAL
- en: All commands presented in these labs will be executed within the `Containers-for-Developers-Handbook/Chapter3`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying and using your own local registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this first lab, we will deploy a simple unauthenticated and untrusted (HTTP,
    not HTTPS) registry. We will use the currently available Docker official registry
    image, which is `registry:2.8.1` at the time of writing. We can review its vulnerabilities
    by navigating to [https://hub.docker.com/layers/library/registry/2.8.1/images/sha256-a001a2f72038b13c1cbee7cdd2033ac565636b325dfee98d8b9cc4ba749ef337?context=explore](https://hub.docker.com/layers/library/registry/2.8.1/images/sha256-a001a2f72038b13c1cbee7cdd2033ac565636b325dfee98d8b9cc4ba749ef337?context=explore):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – An overview of the official Docker registry:2.8.1 vulnerabilities](img/B19845_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – An overview of the official Docker registry:2.8.1 vulnerabilities
  prefs: []
  type: TYPE_NORMAL
- en: 'We then perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pull the `docker.io/registry:2.8.1` image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, review its **CMD**, **ENTRYPOINT**, **VOLUME**, and **EXPOSE** keys. These
    will show us which command will be executed, the port that will be used, and which
    directory will be used for persistent data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a directory for registry data, and execute a container using the registry
    image pulled previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ docker container ls
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: CONTAINER ID   IMAGE            COMMAND                  CREATED         STATUS         PORTS                     NAMES
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5000. We used –P to allow the container runtime to choose any port available
    to publish the application’s port; therefore, this port may be different in your
    environment:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s download an `alpine` container image and upload it to our registry. First,
    we need to pull this image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Chapter3$ docker image tag alpine localhost:32768/alpine:0.1
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can list the local images before pushing them to the local registry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Chapter3$ docker image push localhost:32768/alpine:0.1
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The push refers to repository [localhost:32768/alpine]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '7cd52847ad77: Pushed'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '0.1: digest: sha256:e2e16842c9b54d985bf1ef9242a313f36b856181f188de21313820e177002501
    size: 528'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s now review how images are distributed in our filesystem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Chapter3$ ls -lart registry-data/docker/registry/v2/blobs/sha256/
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: total 20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: drwxr-xr-x 3 root root 4096 Mar  6 19:55 63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: drwxr-xr-x 3 root root 4096 Mar  6 19:55 ..
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: drwxr-xr-x 3 root root 4096 Mar  6 19:55 e2
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: drwxr-xr-x 3 root root 4096 Mar  6 19:55 b2
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'alpine:latest image as localhost:32768/alpine:0.2:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This means that we have a new tag for the original Alpine image; hence, we expect
    that only metadata should be modified.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s push the image and review the filesystem changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can list the content of the registry again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Chapter3$ ls -lart registry-data/docker/registry/v2/repositories/alpine/_manifests/tags/
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: total 16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: drwxr-xr-x 4 root root 4096 Mar  6 19:55 0.1
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: drwxr-xr-x 4 root root 4096 Mar  6 19:55 ..
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: drwxr-xr-x 4 root root 4096 Mar  6 19:59 0.2
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: blobs directory for both tags 0.1 and 0.2. Let’s now push a new image with some
    changes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now create a modified version of the original `alpine.latest` image
    by using it as the base image in a new build process. We will use an on-the-fly
    build by piping a Dockerfile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is a different way of building images using a Dockerfile. In this case,
    we can’t use the image content, and therefore, copying files wouldn’t work, but
    it is fine for this example. We create a new image using Unix pipes to avoid the
    creation of a file. This way, we create an image on the fly:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now push this new image and review the directories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, one new layer is pushed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we’ll review the local folders, where the image registry stores data in
    our host:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have seen how images are stored and managed inside our registry. Let’s now
    move on to a new lab, in which we will review how to sign images with a different
    tool, **Cosign**.
  prefs: []
  type: TYPE_NORMAL
- en: Signing images with Cosign
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this new lab, we will use a new tool, Cosign, which can be easily downloaded
    in different formats:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will install Cosign by downloading its binary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Chapter3$ cosign generate-key-pair \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --output-key-prefix frjaraur
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Enter password for private key:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Enter password for private key again:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Private key written to frjaraur.key
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Public key written to frjaraur.pub
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Chapter3$ ls -l
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: total 12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: -rw------- 1 frjaraur frjaraur  649 Mar  7 19:51 frjaraur.key
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: -rw-r--r-- 1 frjaraur frjaraur  178 Mar  7 19:51 frjaraur.pub
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will add a new name and tag to the image, and after that, we will push it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can proceed to sign the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the warning message. As we learned in [*Chapter 2*](B19845_02.xhtml#_idTextAnchor036),
    *Building Docker Images*, only the image digest really ensures image uniqueness,
    and in this example, we use the tags to reference the image we are signing. We
    should use the digest to improve the signing process and ensure that we sign the
    right image for production, but for this example, we can continue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now verify the signature associated with the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Chapter3$ cosign triangulate localhost:32768/\
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: alpine:0.4-signed
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: localhost:32768/alpine:sha256-f7ffc0ab458dfa9e474f656afebb4289953bd1196022911f0b4c739705e49956.sig
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Chapter3$ docker image ls --digests |grep "0.4-signed"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'localhost:32768/alpine:0.3 image:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we push it again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now verify the newly pushed image again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we know how to improve security by signing and verifying their signatures,
    we can go a step further by using security scanners to review any possible vulnerability
    in their content.
  prefs: []
  type: TYPE_NORMAL
- en: Improving security by using image content vulnerability scanners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this lab, we will use **Trivy**, from Aquasec. It is a very powerful security
    scanner for file content, misconfigurations, and even Kubernetes resources. It
    will really help you in your daily DevOps tasks as well as as a developer. We
    will create a custom Trivy image for offline usage by including the online database.
    With this example, we will also learn how to manage cached content inside our
    images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `Chapter3` folder, you will find the `trivy` directory, with a Dockerfile
    ready for you to build the aforementioned custom image for this lab:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will verify the digest for the latest stable version of the `docker.io/trivy`
    image by using `skopeo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: FROM aquasec/trivy:0.38.2-amd64@sha256:8038205ca56f2d88b93d804d0407831056ee0e40616cb0b8d74b0770c93aaa9f
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: LABEL MAINTAINER "frjaraur at github.com"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: LABEL TRIVY "0.38.2-amd64"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ENV TRIVY_CACHE_DIR="/cache"  \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: TRIVY_NO_PROGRESS=true
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: RUN TRIVY_TEMP_DIR=$(mktemp -d) \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '&& trivy --cache-dir $TRIVY_CACHE_DIR image --download-db-only \'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '&& tar -cf ./db.tar.gz -C $TRIVY_CACHE_DIR/db metadata.json trivy.db'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ENV TRIVY_SKIP_DB_UPDATE=true
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: RUN chmod 777 -R /cache
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: USER nobody
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now build our image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Chapter3/trivy$ docker run -ti \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: localhost:32768/trivy:custom-0.38.2 \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: image python:alpine --scanners vuln \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --severity HIGH,CRITICAL
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 2023-03-08T20:49:21.927Z        INFO    Vulnerability scanning is enabled
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2023-03-08T20:49:26.865Z        INFO    Detected OS: alpine'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 2023-03-08T20:49:26.865Z        INFO    Detecting Alpine vulnerabilities...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2023-03-08T20:49:26.869Z        INFO    Number of language-specific files:
    1'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 2023-03-08T20:49:26.869Z        INFO    Detecting python-pkg vulnerabilities...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: python:alpine (alpine 3.17.2)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Total: 1 (HIGH: 1, CRITICAL: 0)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: │  Library   │ Vulnerability │ Severity │ Installed Version │ Fixed Version
    │                           Title                            │
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '│ libcom_err │ CVE-2022-1304 │ HIGH     │ 1.46.5-r4         │ 1.46.6-r0     │
    e2fsprogs: out-of-bounds read/write via crafted filesystem │'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: HIGH and CRITICAL severities only to avoid any non-critical output. We used
    the default table format for the output, but it is possible to use the JSON format,
    for example, to include the vulnerability scanner in automated tasks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Image scanning will really help us decide which releases to use, or even fix
    issues in our images by understanding the vulnerabilities included in our base
    images. Scanning processes will usually be included in your building pipelines
    to ensure that your workflow does not produce images with vulnerabilities that
    can be easily managed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to store container images in registries, using
    appropriate repositories and tags for our application components. You, as a developer,
    must provide the logic names, tags, and required information to your images to
    allow users to run your applications correctly. Labels will also allow you to
    include any relevant information that can help you track code changes and how
    they apply to your application’s processes.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, it is critical to ensure a secure supply chain for our image artifacts.
    We learned that digests provide uniqueness, but that is not enough. We can include
    signatures to inform users about the provenance and ownership of the images we
    create, but signing does not guarantee the health of the files included inside
    our image layers. We will include content vulnerability scanning in our build
    process. This will allow us to review and verify whether the images we use to
    create our projects contain any security problems. Knowing the vulnerabilities
    in our images will help us to improve our application life cycle. Although fixing
    all vulnerabilities can be hard or even impossible, it is key to understand the
    possible issues we have to manage in our projects.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a good base to create and share our application images, using
    the best techniques and improved security, it’s time to move on to the next chapter,
    in which we will learn how to run software containers and the command line for
    different features and container runtimes.
  prefs: []
  type: TYPE_NORMAL
