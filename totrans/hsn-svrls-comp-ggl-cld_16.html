<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Consuming Third-Party Data via a REST API</h1>
                </header>
            
            <article>
                
<p><span>Previously, in <a href="20f050bc-5118-4170-b2a4-e6c280db6802.xhtml" target="_blank">Chapter 11</a>,<em> </em><em>Building a</em> <em>PDF Conversion</em> <em>Servic</em><em>e</em>, we learned how to create a PDF service using Cloud Run. </span>In this final chapter, we will turn the complexity up a gear in order to build a more complex example based on the Pet Theory case study. The requirement is to implement a serverless solution on Google Cloud using multiple services.</p>
<p>Through this chapter, your knowledge of serverless workloads and the experience required for real-world enterprise products will be challenged. By the end of it, a real-world application will be created that demonstrates the key aspects of serverless workloads on the Google Cloud.</p>
<p class="mce-root">Over the course of this chapter, we will discuss the following topics:</p>
<ul>
<li>An overview of the Pet Theory case study</li>
<li>Designing a lab report solution</li>
<li>Developing the lab solution</li>
<li>Email SMS communication</li>
<li>The continuous integration workflow</li>
<li>Testing a lab service</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To complete the exercises i<span>n this chapter</span>, you will require a Google Cloud project or a Qwiklabs account.</p>
<p>You can find all the code files for this chapter in the GitHub repository for this book, under the <kbd>ch12</kbd> <span>subdirectory, </span>at <a href="https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch12">https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch12</a>.</p>
<div class="packt_infobox">While you are going through the code snippets in this book, you will notice that, in a few instances, a few lines from the code/output have been removed and replaced with dots (<kbd>...</kbd>). The use of ellipses is only to show relevant code/output. The complete code is available on GitHub at the previously mentioned link.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An overview of the Pet Theory case study</h1>
                </header>
            
            <article>
                
<p class="mce-root">As per the previous chapter, our case study is based on the Pet Theory veterinary practice. The full Pet Theory case study incorporates a number of different scenarios that demonstrate how you can resolve typical real-world issues with serverless technology. To view the complete scenario, visit the Qwiklabs website and reference the Pet Theory Quest in order to see the associated labs.</p>
<p class="mce-root">In this exercise, the Pet Theory management team has expressed their concern regarding the level of manual effort that is required to process lab reports. Currently, clinical reports sent from third-party labs are received electronically and are then manually processed by the internal admin team. The process of managing the report is effectively to download the information and add it to a report that is then communicated to the pet owner via email or SMS. Since the veterinary practice has become more and more successful, the number of reports associated with this process has become unmanageable.</p>
<p class="mce-root">To resolve the issue relating to processing lab reports, it has been proposed that a proof of concept should be built. The initial revision should demonstrate how to automate processing the lab reports that are received and also the distribution of report information.</p>
<p class="mce-root">To begin our review, we will outline, at a high level, what the proposed architecture should achieve and the associated component roles and requirements.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing a lab report solution</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this scenario, the Pet Theory team is keen to explore how they can use serverless technologies to automate the receiving and processing of lab results. Lab reports are currently received electronically and then have to be manually sent to clients. As per previous examples, the emphasis of the activities to be performed is to demonstrate how to replace existing tasks with minimum development effort. In addition to this, the components used should be loosely coupled so that further enhancements are straightforward to implement and do not require significant rework.</p>
<p class="mce-root">In terms of the requirements stated, the Pet Theory team has decided they need a system capable of the following:</p>
<table border="1" style="border-collapse: collapse;width: 60%">
<tbody>
<tr>
<td style="width: 24%">
<p><strong>Requirement</strong></p>
</td>
<td style="width: 21.059%">
<p><strong>Service</strong></p>
</td>
</tr>
<tr>
<td style="width: 24%">
<p>Report collation</p>
</td>
<td style="width: 21.059%">
<p>Reporting</p>
</td>
</tr>
<tr>
<td style="width: 24%">
<p>Message handling</p>
</td>
<td style="width: 21.059%">
<p>Message</p>
</td>
</tr>
<tr>
<td style="width: 24%">
<p>Email communication</p>
</td>
<td style="width: 21.059%">
<p>Email</p>
</td>
</tr>
<tr>
<td style="width: 24%">
<p>SMS communication</p>
</td>
<td style="width: 21.059%">
<p>SMS</p>
</td>
</tr>
<tr>
<td style="width: 24%">
<p>Test data capture</p>
</td>
<td style="width: 21.059%">
<p class="mce-root">Test</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><span>Let's add to our understanding by describing each requirement.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Report collation</h1>
                </header>
            
            <article>
                
<p class="mce-root">Lab reports are sent directly to the Pet Theory web endpoint using an HTTP(S) POST command. The information received utilizes the JSON format and the external application has already agreed on the content for the message communicated.</p>
<p class="mce-root">Both Cloud Run and Cloud Functions provide the ability to consume web endpoints. Apart from consuming messages, a reporting service also needs to be capable of propagating the message to downstream services.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Message handling</h1>
                </header>
            
            <article>
                
<p class="mce-root">Pet Theory has experienced a similar requirement for the lab, which was discussed in <a href="20f050bc-5118-4170-b2a4-e6c280db6802.xhtml" target="_blank">Chapter 11</a>,<em> Building a PDF Conversion Service</em>. In that example, the sender and receiver used asynchronous messaging via Cloud Pub/Sub to achieve their aim.</p>
<p class="mce-root">In this situation, lab reports are to be delivered to email and SMS services for further processing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Email communication</h1>
                </header>
            
            <article>
                
<p class="mce-root">The email service represents a new requirement and delivers the ability to communicate with clients using an existing email solution. Information is to be passed to this component via a Cloud Pub/Sub subscription.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SMS communication</h1>
                </header>
            
            <article>
                
<p class="mce-root">Similar to email communication, the SMS component offers an alternative way to communicate with clients when receiving test results.</p>
<p class="mce-root">Now that we have a shared understanding of the key components of the architecture, the elements necessary for building the solution should be clearer. From an overview perspective, our solution architecture can be described with the following steps:</p>
<ol>
<li class="mce-root">A JSON formatted lab report is submitted to the Pet Theory HTTP(S) endpoint.</li>
<li class="mce-root">A report service consumes the JSON message.</li>
<li class="mce-root">The lab information in the JSON message is published to a Cloud Pub/Sub topic.</li>
<li class="mce-root">A subscription notification is received by the email service.</li>
<li class="mce-root">A subscription notification is received by the SMS service.</li>
</ol>
<p class="mce-root">In addition, we can see that the following components are required:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-854 image-border" src="assets/85e5fe08-d707-422a-b10e-e0d7899f5545.png" style=""/></div>
<div class="mce-root packt_infobox"><br/>
It is important to note that there are many other ways to resolve the requirements outlined here.</div>
<p class="mce-root">In the preceding diagram, we have defined a number of components to meet our initial requirements. Remember that Pet Theory is a small organization, so it will not want to incur development costs unnecessarily.</p>
<p class="mce-root">In this example, we are going to implement multiple services, each of which will perform a specific task. As such, later in this exercise, we will look at how to test the individual components by enhancing them to write a status update within a document.</p>
<p class="mce-root">Based on what we've just covered, we now have a general understanding of the lab report solution for processing reports submitted to our service. In the next section, we will start to look at the practical elements of developing the solution in order to fulfill the requirements.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing the lab solution</h1>
                </header>
            
            <article>
                
<p class="mce-root">Several advanced topics will be covered in this chapter; so, having worked through the examples presented in prior chapters is highly recommended. Over the course of the previous chapters, knowledge of Google Cloud and its serverless product portfolio has been presented in order to guide you on this journey.</p>
<div class="mce-root packt_infobox"><br/>
Using your Google Cloud account, open the Cloud Shell and make sure that a clone of the lab repository for <kbd>Chap12</kbd> is accessible.</div>
<p><span>Unlike the earlier chapters, some activities will not be covered in detail. Instead, this chapter is devoted to bringing together a skeleton solution that illustrates how to construct an application to meet requirements. If you get stuck or need help, don't forget that you can consult the solution directory. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Linking to Google Docs</h1>
                </header>
            
            <article>
                
<p>In addition to using a centralized service such as Stackdriver, we can also introduce alternative tooling. In this section, we will be demonstrating how to integrate Google Docs (specifically, Google Sheets).</p>
<div class="mce-root packt_infobox">When you create a spreadsheet on Google Sheets, by default, only the creator has permission to read and write to the sheet. To allow the Cloud Run application access to the sheet, we need to provide it with access permissions. As you might have guessed, for this task, we will use a service account.</div>
<p class="mce-root">From Cloud Shell, we need to retrieve the name of the service account for our project:</p>
<pre class="mce-root"><strong>gcloud iam service-accounts list --filter="Compute Engine default service account" --format='value(EMAIL)'</strong></pre>
<p>Now, we can use that information to link to Google Docs:</p>
<ol>
<li class="mce-root">Create a new spreadsheet in Google Sheets (that is, <a href="https://docs.google.com/spreadsheets">https://docs.google.com/spreadsheets</a>).</li>
<li class="mce-root">Click on the default spreadsheet name of <kbd>Untitled spreadsheet</kbd>.</li>
<li class="mce-root">Rename the spreadsheet to <kbd>Lab Results Status</kbd>.</li>
<li class="mce-root">Click on the <span class="packt_screen">Share</span> button and enter the service account email address we retrieved previously.</li>
</ol>
<p>Great! We now have a spreadsheet available that is linked to our service account <span>project</span>. To link our new spreadsheet with our services, we need to use the <kbd>SHEET-ID</kbd> variable. The <kbd>SHEET-ID</kbd> variable is a unique identifier for your document and is accessible by accessing the URL of the Google Sheet, as per the following example URL:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-855 image-border" src="assets/721cb22d-dee5-4c65-affa-bb120f0b3aad.png" style=""/></div>
<p>From the preceding graphic, we can see the <kbd>SHEET-ID</kbd> has been clearly marked. Now, we need to incorporate that identifier into our application code.</p>
<p>Perform the following steps to access the spreadsheet using Cloud Run:</p>
<ol>
<li>Access the URL for the spreadsheet we created.</li>
<li>Copy the string that starts after <kbd>spreadsheets/d/</kbd> and ends before <kbd>/edit</kbd>, as shown in the preceding screenshot.</li>
</ol>
<ol start="3">
<li>Now, go back to Cloud Shell and edit the file named <kbd>pet theory/lab05/common/sheet.js</kbd>.</li>
<li>Replace the <kbd>SHEET-ID</kbd> <span>variable </span>with the value copied from the URL.</li>
</ol>
<p>Excellent! Now, the spreadsheet can be accessed using our Cloud Run application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Report collation</h1>
                </header>
            
            <article>
                
<p class="mce-root">From our prior discussion on the Lab Service architecture, we know that the initial service to be created relates to report collation. If we focus on the requirements for this stage of processing, we can see that we need to consume a JSON file that's received from external sources:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-856 image-border" src="assets/fd57de1d-2e7d-43be-a64f-8daecb27330b.png" style=""/></div>
<p>At this point in this exercise, let's take the opportunity to create a Cloud Pub/Sub topic, as follows:</p>
<ol>
<li>Run the following command:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"><strong> gcloud pubsub topics create new-lab-report</strong></pre>
<p class="mce-root" style="padding-left: 60px">The Cloud Pub/Sub topic will be used to communicate lab reports between the report collation service and backend email/SMS services.</p>
<ol start="2">
<li class="mce-root">Install the <kbd>npm</kbd> packages dependencies for the lab report:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"><strong> npm install express</strong><br/><strong> npm install body-parser</strong><br/><strong> npm install @google-cloud/pubsub</strong><br/><strong> npm install googleapis</strong></pre>
<ol start="3">
<li class="mce-root">Amend the <kbd>package.json</kbd> file to incorporate a <kbd>start</kbd> command:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"> "scripts": {<br/>  "start": "node index.js",<br/>   "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/> },</pre>
<ol start="4">
<li class="mce-root">Create an <kbd>index.js</kbd> file with the following content:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">const sheet = require('./common/sheet.js');<br/>const {PubSub} = require('@google-cloud/pubsub');<br/>const pubsub = new PubSub();<br/>const express = require('express');<br/>const app = express();<br/>const bodyParser = require('body-parser');<br/>app.use(bodyParser.json());<br/>const port = process.env.PORT || 8080;<br/><br/>app.listen(port, () =&gt; {<br/>  console.log('Listening on port', port);<br/>});</pre>
<ol start="5">
<li class="mce-root">Append the following content to <kbd>index.js</kbd>:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">app.post('/', async (req, res) =&gt; {<br/>  try {<br/>    await sheet.reset();<br/>    const labReport = req.body;<br/>    await publishPubSubMessage(labReport);<br/>    res.status(204).send();<br/>  }<br/>  catch (ex) {<br/>    console.log(ex);<br/>    res.status(500).send(ex);<br/>  }<br/>})</pre>
<ol start="6">
<li class="mce-root">Finally, in <kbd>index.js</kbd>, add the following function, and then close the file for editing:</li>
</ol>
<pre style="padding-left: 60px">async function publishPubSubMessage(labReport) {<br/>  const buffer = Buffer.from(JSON.stringify(labReport));<br/>  await pubsub.topic('new-lab-report').publish(buffer);<br/>}</pre>
<ol start="7">
<li class="mce-root">Copy across the <kbd>common</kbd> directory that includes the Google API's code:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"> cp -R ../pet-theory/lab05/common/ .</pre>
<p class="mce-root" style="padding-left: 60px">Take a moment to look at the<span> <kbd>index.js</kbd> source code, taking note of the following elements:</span></p>
<ul>
<li style="list-style-type: none">
<ul>
<li class="mce-root">The <kbd>request.body</kbd> property represents the lab report to be processed.</li>
<li class="mce-root">The schema associated with the lab report is not required at this point.</li>
<li class="mce-root">The data from the lab report is added to a Cloud Pub/Sub topic named <kbd>new-lab-report</kbd>.</li>
<li class="mce-root">Once the topic has been published, the service returns an HTTP status code of 204 (that is, successful but no data to return).</li>
<li class="mce-root">If an error occurs, an HTTP status code of 500 (a server error) is returned.</li>
</ul>
</li>
</ul>
<p class="mce-root" style="padding-left: 60px">Besides the Node.js source code for the report service, we also require a Dockerfile to be created in the same directory.</p>
<ol start="8">
<li>Create a Dockerfile, as follows:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"> FROM node:12<br/> WORKDIR /usr/src/app<br/> COPY package.json package*.json ./<br/> RUN npm install --only=production<br/> COPY . .<br/> CMD [ "npm", "start" ]</pre>
<p class="mce-root">The content of this manifest should, at this stage, be familiar and require no further explanation. We will deploy the manifest later in this exercise when we discuss component deployment.</p>
<p class="mce-root">Congratulations! The code definition for a report service capable of consuming external lab reports is available and ready to be deployed. A Cloud Pub/Sub has been provisioned and made ready to accept information that's received from external third parties.</p>
<p class="mce-root">Next, we will take a closer look at the email and SMS services and review the instructions associated with their implementation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Email/SMS communication</h1>
                </header>
            
            <article>
                
<p class="mce-root">For the sake of brevity in our proof of concept, the email and SMS services will utilize a similar code base to demonstrate how background services can be designed within Google Cloud. While these components are meant to provide isolated services, in our example, we will use common code to demonstrate their functionality. In a real-world situation, the communication component presents an opportunity for a common code base to be replicated/extended for different solutions (for example, email, bots, SMSes, pagers, and more).</p>
<p class="mce-root">The Cloud Pub/Sub topic we previously created pushes the data to be consumed by the communication components. In this instance, the lab report data object represents a JSON file that is used to communicate lab results:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-863 image-border" src="assets/c858700d-3281-42ef-8f3c-a04ac7d66f68.png" style=""/></div>
<div class="packt_infobox"><span><br/>
It is worth pointing out that we have not actually referenced the data passed in the lab report, nor do we know the content schema being used. Instead, we treat it as a black box and, therefore, don't have any data validation to be performed on the content. Taking this step reduces the level of testing to be performed later on in the development cycle.</span></div>
<p class="mce-root CDPAlignLeft CDPAlign">In the context of Cloud Run message processing, this means the following processes are observed when using Cloud Pub/Sub:</p>
<ul>
<li class="mce-root">Cloud Pub/Sub maintains its responsibility for pushing messages.</li>
<li class="mce-root">The subscriber is responsible for consuming the messages.</li>
<li class="mce-root">A service is aligned with the subscriber to accept the message payload.</li>
</ul>
<p class="mce-root">Once again, we are using techniques that should now be familiar, as these same design patterns are common when using Cloud Pub/Sub to interact between resources.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Email</h1>
                </header>
            
            <article>
                
<p class="mce-root">From the <kbd>email-service</kbd> directory, we need to perform a couple of activities. If you are unsure of the exact command, refer to the <em>Designing a lab report solution</em> section earlier in this chapter:</p>
<ol>
<li class="mce-root">Amend the <kbd>package.json</kbd> file to include a node start <kbd>index.js</kbd> statement.</li>
<li class="mce-root">Add package dependencies for <kbd>express</kbd>, <kbd>body-parser</kbd>, and <kbd>googleapis</kbd>.</li>
<li class="mce-root">Create an <kbd>index.js</kbd> file and populate it with the following code:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">const sheet = require('./common/sheet.js');<br/>const util = require('./common/util.js');<br/>const express = require('express');<br/>const app = express();<br/>const bodyParser = require('body-parser');<br/>app.use(bodyParser.json());<br/><br/>const port = process.env.PORT || 8080;<br/>  app.listen(port, () =&gt; {<br/>  console.log('Listening on port', port);<br/>});</pre>
<ol start="4">
<li class="mce-root">Add the <kbd>index.js</kbd> file and populate it with this additional code:</li>
</ol>
<pre style="padding-left: 60px">app.post('/', async (req, res) =&gt; {<br/>  const labReport = util.decodeBase64Json(req.body.message.data);<br/>  try {<br/>    await sheet.update('email', labReport.id, 'Trying');<br/>    const status = await util.attemptFlakeyOperation();<br/>    await sheet.update('email', labReport.id, status);<br/>    res.status(204).send();<br/>  }<br/>  catch (ex) {<br/>    await sheet.update('email', labReport.id, ex);<br/>    res.status(500).send();<br/>  }<br/>})</pre>
<ol start="5">
<li class="mce-root">Copy across the <kbd>common</kbd> directory that includes the Google API's code:</li>
</ol>
<pre style="padding-left: 60px">cp -R ../pet-theory/lab05/common/ .</pre>
<p class="mce-root" style="padding-left: 60px">Once more, take a moment to observe the <kbd>index.js</kbd> source code, taking note of the following key elements:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li class="mce-root">The <kbd>request.body</kbd> property translates the Cloud Pub/Sub message using <kbd>decodeBase64</kbd>.</li>
<li class="mce-root">Data processing uses a <kbd>console.log</kbd> statement.</li>
<li class="mce-root">The service returns an HTTP status code of <kbd>204</kbd> (that is, successful but no data to return).</li>
<li class="mce-root">If an error occurs, an HTTP status code of <kbd>500</kbd> (that is, an unsuccessful server error occurred) is returned.</li>
</ul>
</li>
</ul>
<p class="mce-root" style="padding-left: 60px">We also need a Dockerfile manifest that will be used later to build the image for the Node.js application.</p>
<ol start="6">
<li class="mce-root">Create a Dockerfile for a <kbd>Node.js</kbd> application.</li>
</ol>
<p>Great! Let's move on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SMS</h1>
                </header>
            
            <article>
                
<p class="mce-root">From the SMS service directory, we need to perform the same steps. If you are unsure of the exact command, reference to the Developing the <em>Lab solution</em> section earlier in this chapter:</p>
<ol>
<li class="mce-root">Amend the <kbd>package.json</kbd> file to include a node start <kbd>index.js</kbd> statement.</li>
<li class="mce-root">Add package dependencies for <kbd>express</kbd>, <kbd>body-parser</kbd>, and <kbd>googleapis</kbd>.</li>
<li class="mce-root">Create an <kbd>index.js</kbd> file and populate it with the following code:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">const sheet = require('./common/sheet.js');<br/>const util = require('./common/util.js');<br/>const express = require('express');<br/>const app = express();<br/>const bodyParser = require('body-parser');<br/>app.use(bodyParser.json());<br/><br/>const port = process.env.PORT || 8080;<br/>  app.listen(port, () =&gt; {<br/>  console.log('Listening on port', port);<br/>});</pre>
<ol start="4">
<li class="mce-root">Add the <kbd>index.js</kbd> file and populate it with this additional code:</li>
</ol>
<pre style="padding-left: 60px">app.post('/', async (req, res) =&gt; {<br/>  const labReport = util.decodeBase64Json(req.body.message.data);<br/>  try {<br/>    await sheet.update('sms', labReport.id, 'Trying');<br/>    const status = await util.attemptFlakeyOperation();<br/>    await sheet.update('sms', labReport.id, status);<br/>    res.status(204).send();<br/>  }<br/>  catch (ex) {<br/>    await sheet.update('sms', labReport.id, ex);<br/>    res.status(500).send();<br/>  }<br/>})</pre>
<ol start="5">
<li class="mce-root">Copy across the <kbd>common</kbd> directory that includes the Google API's code:</li>
</ol>
<pre style="padding-left: 60px">cp -R ../pet-theory/lab05/common/ .</pre>
<p class="mce-root" style="padding-left: 60px">Add a Dockerfile manifest that will be used later to build the image for the Node.js application.</p>
<ol start="6">
<li class="mce-root">Create a Dockerfile for a <kbd>Node.js</kbd> application.</li>
</ol>
<p class="mce-root">Congratulations! The email and SMS services are now available and ready to be deployed. Now that we have looked at the general code base, we can move on to thinking about how to efficiently build the multiple components needed for this solution.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The continuous integration workflow</h1>
                </header>
            
            <article>
                
<p class="mce-root">While building components, using a manual approach may seem like a good technique due to its implementation simplicity. In this chapter, we will automate this process. The reason for this is that there are multiple code bases that need to be built and deployed, which, if done manually, can result in unnecessary errors in the process.</p>
<p class="mce-root">Instead of a manual build, we turn our focus to a development tool to take care of this repetitive build and deploy process. In our project, we intend to use Cloud Build to manage the build workflow on Google Cloud. To use Cloud Build, it is worth understanding the actual process to be automated, since the configuration required will often be an approximation of the manual steps to be followed.</p>
<p class="mce-root">When working in this project, our developer workflow can be defined using the following steps:</p>
<ol>
<li class="mce-root">A developer commits their code using <kbd>git</kbd>.</li>
<li class="mce-root">Code commits are notified to Source Repositories.</li>
<li class="mce-root">Cloud Build triggers when a matching pattern is found.</li>
<li class="mce-root">If the build process fails, the developer is required to rectify the code (go to <em>step 1</em>).</li>
<li class="mce-root">If the build process succeeds, the image is added to the Container Registry.</li>
<li class="mce-root">A <strong>Quality Assurance</strong> (<strong>QA</strong>) team member can then access the new image.</li>
</ol>
<p class="mce-root">As you can see, there are multiple steps involved in this process, and an error could potentially occur during any one of these stages. Introducing automation in this process can help to remediate any errors through consistency and also make the overall maintenance of the project more straightforward.</p>
<p class="mce-root">The defined steps provide a common approach to ensure building software can be achieved in an iterative manner. Using a development tool such as Cloud Build ensures that the build process remains both consistent and flexible and that the process is managed through an external build file. The build file can easily be shared between team members and means updates and build profiles can be managed under version control.</p>
<p class="mce-root">Developers are part of a continual feedback workflow based on their code commits, meaning they control code submissions and can also react directly to any issues. The initiation of the build process, based on a code commit, will feedback on the success or failure of the relevant component submitted.</p>
<p class="mce-root">Take a look at the following diagram to see how this process could work in practice:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-864 image-border" src="assets/ee3ee395-38ea-496b-acb9-2c4c3219aa38.png" style=""/></div>
<p class="mce-root">Once the code component has been successfully built, it will be stored in the Container Registry. From here, the QA team members have access to the latest verified image and are able to test each of the images independently, without needing to refer to the development team. In this way, alternative versions such as dev, staging, and prod could be deployed and tested as different stage gates.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring Lab Service CI</h1>
                </header>
            
            <article>
                
<p class="mce-root">To understand how this process will be used in our example, we can create a configuration for Pet Theory based on a basic Cloud Build script.</p>
<div class="packt_infobox"><br/>
You can refer to the <em>Further reading</em> section at the end of this chapter for more information regarding account permissions.</div>
<p class="mce-root">To get started, go back to the <kbd>lab-service</kbd> directory. This is where we will create a basic Cloud Build configuration:</p>
<ol>
<li class="mce-root"><span>Create and edit a new</span> <kbd>cloudbuild.yaml</kbd> file <span>for <kbd>lab-service</kbd>:</span></li>
</ol>
<pre style="color: black;padding-left: 60px">steps:<br/># Build the container image<br/>- name: 'gcr.io/cloud-builders/docker'<br/>args: ['build', '-t', 'gcr.io/$PROJECT_ID/lab-service', 'lab-service/.']<br/># Push the container image to Container Registry<br/>- name: 'gcr.io/cloud-builders/docker'<br/>args: ['push', 'gcr.io/$PROJECT_ID/lab-service']<br/># Deploy the image to Cloud Run<br/>- name: 'gcr.io/cloud-builders/gcloud'<br/>args: ['beta', 'run', 'deploy', 'lab-service', '--image', 'gcr.io/$PROJECT_ID/lab-service', '--region', 'us-central1', '--platform', 'managed', '--no-allow<br/>-unauthenticated']<br/>images:<br/>- 'gcr.io/$PROJECT_ID/lab-service'<br/>timeout: "600s"</pre>
<p class="mce-root" style="padding-left: 60px">Next, we are going to set up Google Source Repositories for our project. We need to create a temporary repository in order to host our code and demonstrate some additional features of Google Cloud.</p>
<ol start="2">
<li class="mce-root">Create a Cloud Source Repositories configuration:</li>
</ol>
<pre style="color: black;padding-left: 60px"><strong> gcloud source repos create pet-theory-test</strong></pre>
<ol start="3">
<li>Clone the newly created repository, noting you will need to supply your project identity as a parameter:</li>
</ol>
<pre style="padding-left: 60px"><strong> gcloud source repos clone pet-theory-test --project=[PROJECT_ID]</strong></pre>
<ol start="4">
<li>Copy across the subdirectories (that is, <kbd>email-service</kbd>, <kbd>sms-service</kbd>, <kbd>lab-service</kbd>, and <kbd>common</kbd>) to the new Google Source repository directory. Your new <kbd>pet-theory-test</kbd> <span>directory </span>should look like this:</li>
</ol>
<pre style="padding-left: 60px">.<br/>├── common<br/>│ ├── sheet.js<br/>│ └── util.js<br/>├── email-service<br/>│ ├── index.js<br/>│ ├── node_modules<br/>│ ├── package.json<br/>│ └── package-lock.json<br/>├── lab-service<br/>│ ├── cloudbuild.yaml<br/>│ ├── Dockerfile<br/>│ ├── index.js<br/>│ └── package.json<br/>│ └── package-lock.json<br/>└── sms-service<br/>├── index.js<br/>├── node_modules<br/>├── package.json<br/>└── package-lock.json</pre>
<ol start="5">
<li>Check the status of the <kbd>git</kbd> directory to ensure you have the common <kbd>email-service</kbd>, <kbd>lab-service</kbd>, and <kbd>sms-service</kbd> subdirectories as untracked files:</li>
</ol>
<pre style="padding-left: 60px"><strong> git status</strong></pre>
<ol start="6">
<li>Add the amended files to <kbd>git</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong> git add .</strong></pre>
<ol start="7">
<li>Set up the email credentials using your email address:</li>
</ol>
<pre style="padding-left: 60px"><strong> git config --global user.email "EMAIL"</strong></pre>
<ol start="8">
<li>Set up the name credentials using your username:</li>
</ol>
<pre style="padding-left: 60px"><strong> git config --global user name "MY NAME"</strong></pre>
<ol start="9">
<li>Add a commit message to the repository:</li>
</ol>
<pre style="padding-left: 60px"><strong> git commit -m "Initial commit - Pet Theory CH12"</strong></pre>
<ol start="10">
<li>Commit the code for the repository directly to the master branch:</li>
</ol>
<pre style="padding-left: 60px"><strong> git push origin master</strong></pre>
<ol start="11">
<li class="mce-root">Check the Cloud Source Repositories in the console to ensure the code is now available.</li>
</ol>
<p class="mce-root">Congratulations! Knowing how to use Cloud Source Repositories can save time when hosting code in Google Cloud. In general, being able to use a Git-based solution provides some assurance over the safety of code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Triggering Cloud Build</h1>
                </header>
            
            <article>
                
<p class="mce-root">So, now that we have our code in Cloud Source Repositories, how do we get it to automatically build using the Google Cloud developer tools? To automatically build code on commit, we can use our old friend Cloud Build. For this example, we will use our <kbd>lab-service</kbd> directory to demonstrate the build process:</p>
<div class="mce-root packt_infobox"><br/>
For this example, make sure that you are in the <kbd>pet-theory-test</kbd>/<kbd>lab-service</kbd> directory. The initial steps in Cloud Build requires the selection of a repository.</div>
<ol>
<li class="mce-root">From the Cloud Console, access Cloud Build (located under the <span class="packt_screen">Developer Tools</span> options).</li>
<li class="mce-root">Select the <span class="packt_screen">Triggers</span> menu option and the <span class="packt_screen">Create Trigger</span> option.</li>
<li class="mce-root">Set up the trigger using the following information:</li>
</ol>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td style="width: 28%">
<p><strong>Field</strong></p>
</td>
<td style="width: 35.5617%">
<p><strong>Value</strong></p>
</td>
</tr>
<tr>
<td style="width: 28%">
<p><span class="packt_screen">Name</span></p>
</td>
<td style="width: 35.5617%">
<p><kbd>trigger-lab-service</kbd></p>
</td>
</tr>
<tr>
<td style="width: 28%">
<p><span class="packt_screen">Description</span></p>
</td>
<td style="width: 35.5617%">
<p><kbd>Push to the lab branch</kbd></p>
</td>
</tr>
<tr>
<td style="width: 28%">
<p><span class="packt_screen">Trigger type</span></p>
</td>
<td style="width: 35.5617%">
<p><kbd>Branch</kbd></p>
</td>
</tr>
<tr>
<td style="width: 28%">
<p><span class="packt_screen">Branch (regex)</span></p>
</td>
<td style="width: 35.5617%">
<p><kbd>^([lL]ab)/\w+</kbd></p>
</td>
</tr>
<tr>
<td style="width: 28%">
<p><span class="packt_screen">Cloudbuild configuration</span></p>
</td>
<td style="width: 35.5617%">
<p><kbd>lab-service/cloudbuild.yaml</kbd></p>
</td>
</tr>
<tr>
<td style="width: 28%">
<p><span class="packt_screen">Substitution variables</span></p>
</td>
<td style="width: 35.5617%">
<p><kbd>N/A</kbd></p>
</td>
</tr>
</tbody>
</table>
<ol start="4">
<li class="mce-root">Select the <span class="packt_screen">Create Trigger</span> button at the bottom of the screen to enable the trigger.</li>
</ol>
<div class="mce-root packt_tip"><br/>
The <span>regex </span>branch in the Cloud Build trigger table is a common way of filtering which content should be built. In many instances, developers will want to only build a specific branch, and using regex helps to isolate particular branches.</div>
<p class="mce-root">To test the trigger has been successfully set up, commit a code change to the <kbd>lab-service</kbd> trigger. Follow these steps:</p>
<ol>
<li>Add a comment to the <kbd>cloudbuild.yaml</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">steps:<br/># comment<br/># Build the container image<br/>- name: 'gcr.io/cloud-builders/docker'<br/>args: ['build', '-t', 'gcr.io/$PROJECT_ID/lab-service', 'lab-service/.']<br/># Push the container image to Container Registry<br/>- name: 'gcr.io/cloud-builders/docker'<br/>args: ['push', 'gcr.io/$PROJECT_ID/lab-service']<br/># Deploy the image to Cloud Run<br/>- name: 'gcr.io/cloud-builders/gcloud'<br/>args: ['beta', 'run', 'deploy', 'lab-service', '--image', 'gcr.io/$PROJECT_ID/lab-service', '--region', 'us-central1', '--platform', 'managed', '--no-allow<br/>-unauthenticated']<br/>images:<br/>- 'gcr.io/$PROJECT_ID/lab-service'<br/>timeout: "600s"</pre>
<ol start="2">
<li>Add the updated file to <kbd>git</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong> git add cloudbuild.yaml</strong></pre>
<ol start="3">
<li>Add a commit message:</li>
</ol>
<pre style="padding-left: 60px"><strong> git commit -m "Add updated cloudbuild.yaml"</strong></pre>
<ol start="4">
<li>Push the change to Cloud Source Repositories:</li>
</ol>
<pre style="padding-left: 60px"><strong> git push origin lab/fix-1</strong></pre>
<p class="mce-root">In the final command, we use a special regex command to indicate that the change refers to the <kbd>lab-service</kbd> trigger. When we set up the trigger, we used a regular expression to only look at branches that were labelled with <kbd>lab</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-862 image-border" src="assets/d6b20ae0-b5f8-4f50-b66e-bf7c031f3df0.png" style=""/></div>
<p class="mce-root">Once the code has been committed, checking the <span class="packt_screen">Cloud Build History</span> will indicate a new build job has commenced. After each Git commit to a branch, our components will automatically trigger a build process. Now that we know that the build configuration works correctly, let's roll out the same changes to the email and SMS directories. We will ensure each build is maintained on a separate branch to minimize the potential for code merging.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Triggering email and SMS</h1>
                </header>
            
            <article>
                
<p class="mce-root">As per the work we did with the <kbd>lab-service</kbd> trigger, we need to set up a Cloud Build trigger. However, this time, we can just duplicate the existing <kbd>lab-service</kbd> trigger:</p>
<div class="packt_tip">In this example, we used a single repository for services. However, in the real world, this approach would not be optimal. Instead, I would suggest that a repository for each service is used for better code isolation.</div>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-910 image-border" src="assets/454ea543-1966-489f-9515-32fba1319e4d.png" style=""/></div>
<p>To set up the trigger perform the following steps:</p>
<ol>
<li class="mce-root">From the <span class="packt_screen">Cloud Console</span>, access <span class="packt_screen">Cloud Build</span> (located under the <span class="packt_screen">Developer Tools</span> options).</li>
<li class="mce-root">Select the three-dot menu item to open the pop-up menu and select <span class="packt_screen">Duplicate.</span></li>
<li class="mce-root">Select the three-dot menu (of the newly created trigger) item to open the pop-up menu and select <span class="packt_screen">Edit</span>.</li>
<li class="mce-root">Set up the trigger with the following information:</li>
</ol>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td style="width: 38%">
<p><strong>Field</strong></p>
</td>
<td style="width: 43.7002%">
<p><strong>Value</strong></p>
</td>
</tr>
<tr>
<td style="width: 38%">
<p><span class="packt_screen">Name</span></p>
</td>
<td style="width: 43.7002%">
<p><kbd>trigger-email-service</kbd></p>
</td>
</tr>
<tr>
<td style="width: 38%">
<p><span class="packt_screen">Description</span></p>
</td>
<td style="width: 43.7002%">
<p><kbd>Push to the email branch</kbd></p>
</td>
</tr>
<tr>
<td style="width: 38%">
<p><span class="packt_screen">Trigger type</span></p>
</td>
<td style="width: 43.7002%">
<p><kbd>Branch</kbd></p>
</td>
</tr>
<tr>
<td style="width: 38%">
<p><span class="packt_screen">Branch (regex)</span></p>
</td>
<td style="width: 43.7002%">
<p><kbd>^([eE]mail)/\w+</kbd></p>
</td>
</tr>
<tr>
<td style="width: 38%">
<p><span class="packt_screen">Cloudbuild configuration</span></p>
</td>
<td style="width: 43.7002%">
<p><kbd>email-service</kbd>/<kbd>cloudbuild.yaml</kbd></p>
</td>
</tr>
<tr>
<td style="width: 38%">
<p><span class="packt_screen">Substitution variables</span></p>
</td>
<td style="width: 43.7002%">
<p>N/A</p>
</td>
</tr>
</tbody>
</table>
<ol start="5">
<li class="mce-root">Select the <span class="packt_screen">Save</span> button at the bottom of the screen to enable the trigger.</li>
<li>Now, do exactly the same again; however, this time, create an SMS trigger using the following details:</li>
</ol>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td style="width: 28%">
<p><strong>Field</strong></p>
</td>
<td style="width: 35.5617%">
<p><strong>Value</strong></p>
</td>
</tr>
<tr>
<td style="width: 28%">
<p><span class="packt_screen">Name</span></p>
</td>
<td style="width: 35.5617%">
<p><kbd>trigger-sms-service</kbd></p>
</td>
</tr>
<tr>
<td style="width: 28%">
<p><span class="packt_screen">Description</span></p>
</td>
<td style="width: 35.5617%">
<p><kbd>Push to the sms branch</kbd></p>
</td>
</tr>
<tr>
<td style="width: 28%">
<p><span class="packt_screen">Trigger type</span></p>
</td>
<td style="width: 35.5617%">
<p><kbd>Branch</kbd></p>
</td>
</tr>
<tr>
<td style="width: 28%">
<p><span class="packt_screen">Branch (regex)</span></p>
</td>
<td style="width: 35.5617%">
<p><kbd>^([sS]ms)/\w+</kbd></p>
</td>
</tr>
<tr>
<td style="width: 28%">
<p><span class="packt_screen">Cloudbuild configuration</span></p>
</td>
<td style="width: 35.5617%">
<p><kbd>sms-service</kbd>/<kbd>cloudbuild.yaml</kbd></p>
</td>
</tr>
<tr>
<td style="width: 28%">
<p><span class="packt_screen">Substitution variables</span></p>
</td>
<td style="width: 35.5617%">
<p>N/A</p>
</td>
</tr>
</tbody>
</table>
<ol start="7">
<li class="mce-root">Select the <span class="packt_screen">Save</span> button at the bottom of the screen to enable the trigger.</li>
</ol>
<p class="mce-root">Having created three triggers, the Cloud Build screen should look similar to the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-861 image-border" src="assets/5ffe261c-3c94-4a30-beb9-4fdcada44282.png" style=""/></div>
<p class="mce-root">Each of these triggers operates in isolation using a different branch to signify work that's been performed on a specific service. Thanks to our regex filter, each branch will be checked and a new build job will be created when code is committed to the repository. To make this work, we need to add the <kbd>cloudbuild.yaml</kbd> file to the email and SMS directories to initiate the build process.</p>
<p class="mce-root">Let's create some configurations using <kbd>cloudbuild.yaml</kbd>:</p>
<ol>
<li>In the <kbd>email-service</kbd> directory, create a new <kbd>cloudbuild.yaml</kbd> file containing the following:</li>
</ol>
<pre style="padding-left: 60px">steps:<br/># Build the container image<br/>- name: 'gcr.io/cloud-builders/docker'<br/>args: ['build', '-t', 'gcr.io/$PROJECT_ID/email-service', 'email-service/.']<br/># Push the container image to Container Registry<br/>- name: 'gcr.io/cloud-builders/docker'<br/>args: ['push', 'gcr.io/$PROJECT_ID/email-service']<br/># Deploy the image to Cloud Run<br/>- name: 'gcr.io/cloud-builders/gcloud'<br/>args: ['beta', 'run', 'deploy', 'email-service', '--image', 'gcr.io/$PROJECT_ID/email-service', '--region', 'us-central1', '--platform', 'managed', '--no-allow-unauthenticated']<br/>images:<br/>- 'gcr.io/$PROJECT_ID/email-service'<br/>timeout: "600s"</pre>
<div class="mce-root packt_tip"><br/>
If you do not remember how to perform any of these actions in Git, you can review the earlier examples on how to use Google Source Repositories. The commands are similar; we are just working on a different branch.</div>
<ol start="2">
<li class="mce-root">Create a new branch in <kbd>git</kbd> called <kbd>email/fix-1</kbd>.</li>
<li class="mce-root">Use <kbd>git</kbd> to add the updated <kbd>cloudbuild.yaml</kbd> file to the <kbd>email/fix-1</kbd> <span>branch. </span></li>
<li class="mce-root">Add a commit message: <kbd>Initial revision - email/fix-1</kbd>.</li>
<li class="mce-root">Push the <kbd>email/fix-1</kbd> branch code to the repository.</li>
<li class="mce-root">In the <kbd>sms-service</kbd> directory, create a new <kbd>cloudbuild.yaml</kbd> file containing the following:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"> steps:<br/> # Build the container image<br/> - name: 'gcr.io/cloud-builders/docker'<br/> args: ['build', '-t', 'gcr.io/$PROJECT_ID/sms-service', 'sms-service/.']<br/> # Push the container image to Container Registry<br/> - name: 'gcr.io/cloud-builders/docker'<br/> args: ['push', 'gcr.io/$PROJECT_ID/sms-service']<br/> # Deploy the image to Cloud Run<br/> - name: 'gcr.io/cloud-builders/gcloud'<br/> args: ['beta', 'run', 'deploy', 'sms-service', '--image', 'gcr.io/$PROJECT_ID/sms-service', '--region', 'us-central1', '--platform', 'managed', '--no-allow-unauthenticated']<br/> images:<br/> - 'gcr.io/$PROJECT_ID/sms-service'<br/> timeout: "600s"</pre>
<ol start="7">
<li>Create a new branch in <kbd>git</kbd> called <kbd>sms/fix-1</kbd>.</li>
<li class="mce-root">Use <kbd>git</kbd> to add the updated <kbd>cloudbuild.yaml</kbd> file to the <kbd>sms/fix-1</kbd> <span>branch. </span></li>
<li class="mce-root">Add a commit message: <kbd>Initial revision - sms/fix-1</kbd>.</li>
<li class="mce-root">Push the <kbd>sms/fix-1</kbd> branch code to the repository.</li>
<li class="mce-root">Pushing the final piece of code automatically initiates Cloud Build and the associated three-stage script.</li>
</ol>
<p class="mce-root">Congratulations! Using Cloud Build for build process automation increases developer productivity. Now that we have integrated a component-based build capability, we can move on and look at how to test the multiple components for this solution.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing a lab service</h1>
                </header>
            
            <article>
                
<p class="mce-root">Technically, if you need to log information, the correct answer is typically Stackdriver as it is already integrated into Google Cloud. However, there are instances where you may need an alternative solution – such as in this scenario, in which a quick and easy method of checking the services is required.</p>
<p class="mce-root">In this test section, rather than utilizing <em>Logging</em> to a centralized system such as Stackdriver, we will be posting our data to a Google Sheet. An approach such as this can be a very handy technique to know, so it is worth incorporating it into our solution to demonstrate how this is achieved.</p>
<p class="mce-root">From a high level, the following process is applicable to the test service:</p>
<ol>
<li class="mce-root">Write information to sheets</li>
<li class="mce-root">Application Audit</li>
<li class="mce-root">Vulnerability Fix</li>
</ol>
<p class="mce-root">Take a look at the following diagram in order to understand the components involved in this solution:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-909 image-border" src="assets/1f612b6a-d9f0-4058-b840-f5606adc2196.png" style=""/></div>
<p class="mce-root">In the preceding diagram, we add a new service component to the existing code to log information into a Google spreadsheet. Being able to demonstrate the resilience of the solution is a handy feature in order to build into our proof of concept. The spreadsheet will be completed by the service; so, if it is working <span>successfully</span>, the output will be indicated in the spreadsheet. If the service is unavailable for some reason, then an alternative status message is written for the service that is unable to complete the task:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-860 image-border" src="assets/d0edb504-84bb-436b-adde-80864376f08e.png" style=""/></div>
<p class="mce-root">The spreadsheet is dynamically linked to each of the services and writes a message to a spreadsheet cell when invoked by a service. The new component will provide a straightforward method to test each service in isolation and show whether a service component is operating to specification. As we now have a description of the service and properties, we can begin developing the code base to deliver against requirements.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing the credentials</h1>
                </header>
            
            <article>
                
<p>In this section, we'll begin by accessing the Compute Engine service account:</p>
<ol>
<li>List the service accounts associated with the <span>project</span>:</li>
</ol>
<pre style="padding-left: 60px"><strong> gcloud iam service-accounts list</strong></pre>
<ol start="2">
<li class="mce-root">Copy the Compute Engine service account email address listed.</li>
<li>Open a new Google Sheets document.</li>
<li class="mce-root">Rename the sheet to <kbd>Lab Results Status</kbd>.</li>
<li class="mce-root">Click on the <span class="packt_screen">Share</span> button and add the Compute Engine service account email with full edit rights.</li>
</ol>
<p>Next, we need to set up the email Cloud Pub/Sub subscription.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up the email Cloud Pub/Sub subscription</h1>
                </header>
            
            <article>
                
<p>To set up the email Cloud Pub/Sub subscription, follow these simple steps:</p>
<ol>
<li>Create a service account with invoking privileges:</li>
</ol>
<pre style="padding-left: 60px"><strong>gcloud iam service-accounts create pubsub-cloud-run-invoker --display-name "PubSub Cloud Run Invoker"</strong></pre>
<ol start="2">
<li>Give the service account permissions to invoke the email service:</li>
</ol>
<pre style="padding-left: 60px"><strong>gcloud beta run services add-iam-policy-binding email-service --member=serviceAccount:pubsub-cloud-run-invoker@$GOOGLE_CLOUD_PROJECT.iam.gserviceaccount.com --role=roles/run.invoker --region us-central1 --platform managed</strong></pre>
<ol start="3">
<li>Get the Google Cloud project number:</li>
</ol>
<pre style="padding-left: 60px"><strong>PROJECT_NUMBER=$(gcloud projects list --format="value(projectNumber)" --filter="projectId=$GOOGLE_CLOUD_PROJECT")</strong></pre>
<ol start="4">
<li>Create a role binding of <kbd>serviceAccountTokenCreator</kbd> using the <kbd>PROJECT_NUMBER</kbd> environment variable:</li>
</ol>
<pre style="padding-left: 60px"><strong>gcloud projects add-iam-policy-binding $GOOGLE_CLOUD_PROJECT --member=serviceAccount:service-$PROJECT_NUMBER@gcp-sa-pubsub.iam.gserviceaccount.com --role=roles/iam.serviceAccountTokenCreator</strong></pre>
<ol start="5">
<li>Get the <kbd>EMAIL_URL</kbd> endpoint for the email service:</li>
</ol>
<pre style="padding-left: 60px"><strong> EMAIL_URL=$(gcloud beta run services describe email-service --platform managed --region us-central1 --format "value(status.address.url)")</strong></pre>
<ol start="6">
<li>Create the Cloud Pub/Sub subscription:</li>
</ol>
<pre style="padding-left: 60px"><strong> gcloud pubsub subscriptions create email-service-sub --topic new-lab-report --push-endpoint=$EMAIL_URL --push-auth-service-account=pubsub-cloud-run-invoker@$GOOGLE_CLOUD_PROJECT.iam.gserviceaccount.com</strong></pre>
<p>Great work! We have now set up email subscriptions for Cloud Pub/Sub. Next, we need to repeat the process for SMS subscriptions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up the SMS Cloud Pub/Sub subscription</h1>
                </header>
            
            <article>
                
<p>To set up the SMS Cloud Pub/Sub subscription, complete the following steps:</p>
<ol>
<li>Create a role binding of <kbd>run.invoker</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>gcloud beta run services add-iam-policy-binding sms-service --member=serviceAccount:pubsub-cloud-run-invoker@$GOOGLE_CLOUD_PROJECT.iam.gserviceaccount.com --role=roles/run.invoker --region us-central1 --platform managed</strong></pre>
<ol start="2">
<li>Get the <kbd>SMS_URL</kbd> endpoint for the <kbd>sms-service</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>SMS_URL=$(gcloud beta run services describe sms-service --platform managed --region us-central1 --format "value(status.address.url)")</strong></pre>
<ol start="3">
<li>Create the Cloud Pub/Sub subscription:</li>
</ol>
<pre style="padding-left: 60px"><strong>gcloud pubsub subscriptions create sms-service-sub --topic new-lab-report --push-endpoint=$SMS_URL --push-auth-service-account=pubsub-cloud-run-invoker@$GOOGLE_CLOUD_PROJECT.iam.gserviceaccount.com</strong></pre>
<p><span>Fantastic! We have now set up both subscriptions for Cloud Pub/Sub. Next, we need to test our services.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing the service</h1>
                </header>
            
            <article>
                
<p>Now, it's time to test the service. To do this, follow these steps: </p>
<ol>
<li>Get the <kbd>LAB_URL</kbd> endpoint for the <kbd>lab-service</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong> LAB_URL=$(gcloud beta run services describe lab-service --platform managed --region us-central1 --format "value(status.address.url)")</strong></pre>
<ol start="2">
<li>Post some data to the lab report service:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"><strong>curl -X POST \</strong><br/><strong>-H "Content-Type: application/json" \</strong><br/><strong>-d "{\"id\": 12}" \</strong><br/><strong>$LAB_URL &amp;</strong><br/><strong>curl -X POST \</strong><br/><strong>-H "Content-Type: application/json" \</strong><br/><strong>-d "{\"id\": 34}" \</strong><br/><strong>$LAB_URL &amp;</strong><br/><strong>curl -X POST \</strong><br/><strong>-H "Content-Type: application/json" \</strong><br/><strong>-d "{\"id\": 56}" \</strong><br/><strong>$LAB_URL &amp;</strong></pre>
<p class="mce-root" style="padding-left: 60px">In the following screenshot, you can see the result of posting information to the lab service:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-859 image-border" src="assets/0c01b7d4-4f0b-4859-99cf-81e0109f30ef.png" style=""/></div>
<p class="mce-root CDPAlignLeft CDPAlign" style="padding-left: 60px">Congratulations! The application is now responding to external stimuli.</p>
<p class="mce-root" style="padding-left: 60px">To test our service for resilience, we need to add an error that will mean the service will not be able to process information. For this example, we will use the email service to introduce an error.</p>
<ol start="3">
<li>Change to the <kbd>ch12/email-service</kbd> subdirectory and edit the <kbd>index.js</kbd> source code – add the <span>erroneous </span><kbd>oops</kbd> <span>line entry:</span></li>
</ol>
<pre style="padding-left: 60px">Add an error in the app.post function<br/>...<br/>app.post('/', async (req, res) =&gt; {<br/><strong>oops</strong><br/>const labReport = util.decodeBase64Json(req.body.message.data);<br/>...</pre>
<ol start="4">
<li>Entering the invalid code will ensure the service will not be able to complete successfully when invoked.</li>
<li class="mce-root">Commit the updated <kbd>email-service</kbd> code.</li>
<li class="mce-root">The code will be automatically built, pushed to the registry, and deployed.</li>
</ol>
<p>Now, when the application is run, the email service will be unable to complete as the erroneous line entry, <kbd>oops</kbd>, stops the service from working correctly. Consequentially, no entries will be written in the spreadsheet. To validate this, check the Stackdriver logs to see that an error is shown relating to the defect entered.</p>
<p>Finally, correct the source file to remove the code defect to resume normal service and have the information successfully logged to the spreadsheet.</p>
<p>Congratulations! We have now successfully concluded testing the various components. We will now provide an overview of this chapter's contents.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">Over the course of this final chapter, we built an application to consume external information based on JSON. To our credit, we used a scalable and resilient mechanism to handle messaging so that retries occur seamlessly. We also learned how to incorporate Google Sheets to output information. A new technique like this has many applications and will prove useful time and time again. To complete our application, we also looked at developer productivity so that we can use tools such as Cloud Build when building multiple components.</p>
<p>Throughout this chapter, you have learned how to integrate with Google APIs, initiate Cloud Pub/Sub, and consume JSON information from external services. Learning how to aggregate services is part and parcel of working with serverless on Google Cloud. For example, achieving scalable application messaging is simple when using Cloud Pub/Sub. Each of the patterns that's been used over the previous chapters can easily be enhanced for your own projects. Hopefully, you will be able to create the next big thing or encourage your colleagues to build even more awesome products on <span>Google Cloud</span>. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">What products can be used for asynchronous messaging on <span>Google Cloud</span>?</li>
<li class="mce-root">Can you name some notifications supported by Google Cloud Storage?</li>
<li class="mce-root">Why are there beta commands for the GCloud SDK?</li>
<li class="mce-root">What is regex and why is it useful for creating triggers for branch names?</li>
<li class="mce-root">Cloud Source Repositories are project-based. <span>(True or False)</span></li>
<li class="mce-root">If I wanted to invoke rate limiting on messages, I would use Cloud Tasks over Cloud Pub/Sub. (True or False)</li>
<li class="mce-root">Where would I be able to see HTTP latency associated with a Cloud Run application?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li class="mce-root"><strong>Deploying builds</strong>: <a href="https://cloud.google.com/cloud-build/docs/deploying-builds/deploy-cloud-run">https://cloud.google.com/cloud-build/docs/deploying-builds/deploy-cloud-run</a></li>
<li><strong>Google Docs</strong>: <a href="https://www.google.co.uk/docs/about/">https://www.google.co.uk/docs/about/</a></li>
<li><strong>Stackdriver</strong>: <a href="https://cloud.google.com/stackdriver/">https://cloud.google.com/stackdriver/</a></li>
<li><strong>Cloud Run API</strong>: <a href="https://cloud.google.com/run/docs/reference/rest/">https://cloud.google.com/run/docs/reference/rest/</a></li>
<li><strong>Troubleshooting Cloud Run – fully managed</strong>: <a href="https://cloud.google.com/run/docs/troubleshooting">https://cloud.google.com/run/docs/troubleshooting</a></li>
<li><strong>Stackoverflow [google-cloud-run]</strong>: <a href="https://stackoverflow.com/questions/tagged/google-cloud-run">https://stackoverflow.com/questions/tagged/google-cloud-run</a></li>
</ul>


            </article>

            
        </section>
    </body></html>