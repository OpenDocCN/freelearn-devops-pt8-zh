- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying Containers in AWS with Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In recent years, containerization has become an increasingly popular method
    for deploying and managing applications in the cloud. **Amazon Web Services**
    (**AWS**) offers a range of containerization services, including Amazon **Elastic
    Container Registry** (**ECR**), Amazon **Elastic Container Service** (**ECS**),
    and Amazon **Elastic Kubernetes Service** (**EKS**). In this chapter, you will
    learn how to use Terraform to deploy containers in AWS, from selecting and designing
    the appropriate infrastructure to developing and deploying your container infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Get ready to dive into the world of containerization and learn how to deploy
    containers in AWS using Terraform with the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are containers?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to utilize Terraform for containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Terraform for AWS container resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are containers?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containers are a type of virtualization technology that allows developers to
    package up an application and its dependencies into a single container, which
    can be easily moved between different environments. Containers provide a consistent
    environment for the application to run in, regardless of the underlying infrastructure.
    They are lightweight and efficient, as they share the host operating system kernel
    and do not require a full **virtual machine** (**VM**). Popular containerization
    platforms include Docker and Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Containers offer a more lightweight and efficient alternative to VMs. In essence,
    a container is a self-contained, portable, and executable package that contains
    all the necessary components to run specific software, such as the code, runtime,
    libraries, environment variables, and configuration files. Because containers
    provide a consistent environment for the application to run in, they are well
    suited for use in various environments, including development, testing, and production.
  prefs: []
  type: TYPE_NORMAL
- en: Containers are built on top of a container engine, such as Docker or **Linux
    Containers** (**LXC**). These engines provide an abstraction layer on top of the
    host operating system and manage the container’s resources, such as CPU, memory,
    and storage. Containers can be run on a single host or can be orchestrated across
    multiple hosts using container orchestration platforms such as Kubernetes, Amazon
    EKS, Amazon ECS, or Docker Swarm.
  prefs: []
  type: TYPE_NORMAL
- en: Containers are also highly portable, so they can be easily moved between different
    environments, such as from a developer’s laptop to a test environment and then
    to production. This makes it easier to manage the entire application life cycle
    and ensures consistency across different stages of development.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, containers are a way to package software in a format that can run
    consistently across different environments. They are lightweight, efficient, and
    easy to manage, making them a popular choice for modern application development
    and deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Containers in AWS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In AWS, containers refer to a way of packaging and deploying applications as
    container images. These container images can be run on AWS services such as Amazon
    ECS and Amazon EKS.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon ECS is a fully managed container orchestration service that makes it
    easy to run, scale, and secure containerized applications. With ECS, you can run
    containers on a cluster of Amazon **Elastic Compute Cloud** (**EC2**) instances,
    and it automatically handles tasks such as scaling, load balancing, and health
    monitoring. ECS also integrates with other AWS services such as **Elastic Load
    Balancing** (**ELB**), Amazon **Relational Database Service** (**RDS**), and Amazon
    **Simple Storage** **Service** (**S3**).
  prefs: []
  type: TYPE_NORMAL
- en: Amazon EKS is a managed service that makes it easy to deploy, scale, and operate
    containerized applications using Kubernetes. EKS automates the provisioning and
    management of the Kubernetes control plane and worker nodes, so you can focus
    on building and running your applications. EKS also integrates with other AWS
    services, such as ELB and Amazon RDS, to provide a fully managed Kubernetes experience
    on AWS.
  prefs: []
  type: TYPE_NORMAL
- en: AWS also offers other services that can be used in conjunction with containers,
    such as Amazon ECR for storing and managing container images, and AWS Fargate
    for running containers without the need to manage the underlying infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, in AWS, containers refer to containerized applications that can
    be run and managed on AWS services such as ECS and EKS, and other related services
    such as ECR and Fargate that provide a fully managed container orchestration service,
    allowing developers to focus on building and running their applications without
    worrying about the underlying infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: The reasons for using containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several reasons why developers and organizations use containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Portability**: Containers provide a consistent environment for an application
    to run in, regardless of the underlying infrastructure. This makes them highly
    portable, so they can be easily moved between different environments such as development,
    testing, and production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Isolation**: Containers provide isolation between different applications
    running on the same host, which helps to prevent conflicts and ensures that each
    application has the resources it needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: Containers can be easily scaled up or down to meet changing
    demands, allowing for more efficient use of resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cost-effective**: Containers are lightweight and share the host operating
    system kernel, so they are more efficient than full VMs. This means that you can
    run more containers on a single host, which can help to reduce costs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automation**: Containers can be easily automated and orchestrated using tools
    such as Kubernetes and Docker, making it easier to manage the entire application
    life cycle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficiency**: Containers can be built and deployed faster, leading to faster
    development cycles and faster **time-to-market** (**TTM**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: Containers provide an additional layer of security by isolating
    the application from the host operating system and other applications running
    on the same host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservices**: Containers can be used to deploy microservices-based architectures,
    which can make it easier to build and maintain complex applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility**: Containers can be used with a variety of platforms and technologies,
    such as Linux, Windows, and cloud providers, making them a flexible choice for
    different types of applications and environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Versioning**: Containers can be versioned, making it easy to roll back to
    a previous version of an application if necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testability**: Containers make it easy to test applications in different
    environments, as the entire application and its dependencies are packaged together
    in a container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous integration and deployment**: Containers can be integrated with
    **Continuous Integration and Continuous Deployment** (**CI/CD**) pipelines, allowing
    for automated building, testing, and deployment of applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hybrid and multi-cloud**: Containers can be used to deploy and run applications
    across multiple cloud providers, allowing for greater flexibility and choice when
    it comes to cloud infrastructure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serverless**: Containers can be used in conjunction with serverless platforms
    such as AWS Lambda, Azure Functions, and Google Cloud Functions, to create highly
    scalable, event-driven applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, containers provide a consistent and isolated environment, helping
    to ensure that an application will run the same way across different environments
    and making it easy to move the application between different environments. They
    are lightweight, easy to automate and scale, cost-effective, efficient, and provide
    additional security. They are also a good fit for microservices-based architectures.
  prefs: []
  type: TYPE_NORMAL
- en: How to containerize applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several steps involved in containerizing an application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Package the application and its dependencies**: The first step is to package
    the application and its dependencies into a single container. This typically involves
    creating a container image, which includes the application code, runtime, libraries,
    environment variables, and config files.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Define the container’s environment**: The next step is to define the container’s
    environment, including the operating system and runtime that the application will
    run on. This is done by creating a Dockerfile, which specifies the base image
    to use, any additional software to install, and any configuration settings.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Build the container image**: Once the Dockerfile is defined, the container
    image can be built using a tool such as Docker. This creates a lightweight, standalone,
    executable package that includes everything needed to run the application.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Push the container image to a registry**: After the container image is built,
    it can be pushed to a container registry, such as Docker Hub or Amazon ECR, where
    it can be easily shared and distributed to different environments.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Deploy the container**: The final step is to deploy the container to a container
    orchestration platform, such as Kubernetes or Amazon ECS, where it can be easily
    scaled and managed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Test the containerized application**: Before deploying the containerized
    application to production, it’s important to test it in a non-production environment
    to make sure it works as expected. This can be done by running the container image
    on a test cluster or on a developer’s local machine. This step can help identify
    and fix any issues before the application is deployed to production.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Optimize the container image**: It’s important to optimize the container
    image to minimize the size and reduce the number of layers. This can be done by
    using multi-stage builds, removing unnecessary files and packages, and using smaller
    base images.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Monitor and update the containerized application**: Once the containerized
    application is deployed, it’s important to monitor it to ensure it’s running smoothly
    and to identify any potential issues. Regular updates and security patches should
    be applied to the containerized application and its dependencies.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Consider security best practices**: Security should always be considered
    when containerizing an application. Best practices include running containers
    with the least privilege, using a container registry with built-in security features,
    and regularly updating the container images and the host system.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In summary, containerizing an application is a multi-step process that involves
    packaging the application and its dependencies into a container image, defining
    the container’s environment, building the image, pushing it to a registry, deploying
    it to a container orchestration platform, testing it, optimizing the image, monitoring
    and updating the application, and considering security best practices.
  prefs: []
  type: TYPE_NORMAL
- en: AWS containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In AWS, containers refer to a way of packaging and deploying applications as
    container images. These container images can be run on AWS services such as Amazon
    ECS and Amazon EKS.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon ECS and Amazon EKS are explained in the *Containers in AWS* section,
    so we won’t repeat them here.
  prefs: []
  type: TYPE_NORMAL
- en: AWS Fargate is a serverless compute engine for containers that allows you to
    run containers without having to provision and manage the underlying infrastructure.
    With Fargate, you only pay for the resources that your containers use, and there
    is no need to manage the underlying EC2 instances.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon ECR is a fully managed container registry service that makes it easy
    to store, manage, and deploy container images. ECR is integrated with other AWS
    services such as ECS and EKS, making it easy to store and retrieve container images
    for use in those services.
  prefs: []
  type: TYPE_NORMAL
- en: AWS App Runner is a fully managed service that makes it easy to build, test,
    and deploy containerized applications quickly. It automates the building, testing,
    and deployment of containerized applications, allowing developers to focus on
    writing code.
  prefs: []
  type: TYPE_NORMAL
- en: AWS Elastic Beanstalk is a fully managed service that makes it easy to deploy,
    run, and scale web applications and services. Elastic Beanstalk supports multiple
    platforms, including Java, .NET, PHP, Node.js, Python, Ruby, and Go, and it also
    supports deploying applications as Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: AWS Lambda is a serverless compute service that allows you to run code without
    provisioning or managing servers. It automatically scales your applications in
    response to incoming requests, and you only pay for the compute time that you
    consume. AWS Lambda with container support allows developers to package their
    application code and dependencies together in a container and deploy it as a function.
    This enables developers to take advantage of the benefits of containers such as
    consistent runtime environments and the ability to run their applications in different
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, AWS offers a range of services that can be used to deploy and manage
    containerized applications, including Amazon ECS, Amazon EKS, AWS Fargate, Amazon
    ECR, and AWS App Runner. These services provide an easy way to deploy, run, and
    manage containerized applications, integrate with other AWS services, and automate
    various aspects of the application life cycle management.
  prefs: []
  type: TYPE_NORMAL
- en: How to choose the best containerization platform in AWS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Choosing the best containerization platform in AWS will depend on the specific
    requirements of your application and use case. Here are some factors to consider
    when making your decision:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Microservices versus monolithic**: If your application is built using a microservices-based
    architecture, then ECS or EKS would be a good choice, as they are designed to
    handle the scaling and orchestration of multiple services. If your application
    is a monolithic application, then Fargate or App Runner may be a better fit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scale**: Consider the scale of your application and the resources it requires.
    ECS and EKS are both highly scalable and can handle large numbers of containers
    and services. Fargate is also scalable, but it is more suited for running small
    to medium-sized applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Existing infrastructure**: If you already have an existing infrastructure
    in place, it may be more cost-effective to use ECS or EKS, as they can integrate
    with your existing resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cost**: Consider the cost of running your application on each platform. ECS
    and EKS may be more expensive than Fargate, as they require the provisioning and
    management of underlying infrastructure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functionality**: Consider the functionality that you need for your application.
    ECS and EKS provide more advanced features for deploying, scaling, and managing
    containerized applications, while Fargate is more suited for running individual
    containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Team experience**: Consider the experience of your team with the different
    platforms. If your team has experience with Kubernetes, EKS might be a better
    fit; if it has experience with AWS native services, ECS or Fargate might be more
    appropriate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each platform has its own set of features and capabilities, and the choice of
    which platform to use will depend on the specific requirements of your application
    and use case. ECS and EKS are more suited for microservices-based architectures,
    while Fargate and App Runner are more suited for running individual containers.
    AWS Lambda is more suited for running function-based workloads, and Elastic Beanstalk
    is more suited for deploying web applications and services.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, the best containerization platform for your application will depend
    on the specific requirements of your use case. It is important to evaluate each
    platform based on the factors that are most important to your application, such
    as scalability, cost, and functionality. It may also be beneficial to test different
    platforms in a non-production environment to determine which one works best for
    your application before making a final decision.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, it’s worth considering the level of flexibility and control you
    want over the infrastructure and the level of automation you want to achieve.
    ECS and EKS provide more control and flexibility over the infrastructure, while
    Fargate and App Runner provide more automation.
  prefs: []
  type: TYPE_NORMAL
- en: In general, it’s recommended to start with the simplest option that meets your
    needs and gradually add complexity as needed. AWS Lambda, for instance, is a good
    starting point for function-based workloads, Elastic Beanstalk for web-based applications,
    Fargate for small to medium-sized applications, and ECS or EKS for complex microservices-based
    architectures.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also important to note that AWS provides a variety of services that can
    be used in conjunction with the containerization platform, such as ECR for storing
    and managing container images, and AWS App Mesh for service mesh management.
  prefs: []
  type: TYPE_NORMAL
- en: How to utilize Terraform for containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Terraform provides a powerful platform for managing and deploying container
    infrastructure on AWS. With Terraform, you can easily create and manage resources
    such as ECR, ECS, and EKS. This section will cover the basics of how to utilize
    Terraform for containers, including selecting and designing container infrastructure
    with Terraform, and how to develop and deploy container infrastructure using Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying containers with Terraform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Terraform is a tool that allows you to define, provision, and manage infrastructure
    as code. To design a container using Terraform, you can use the `docker_container`
    resource to create, configure, and manage a container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how to use Terraform to create a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This example creates a container named `"example-container"` using the latest
    version of the `nginx` image, maps port `80` inside the container to port `8080`
    on the host, and sets an environment variable named `EXAMPLE_VAR` with a value
    of `"example value"`. The container also creates a volume that maps the `/var/www/html`
    path inside the container to the `./data` path on the host, with read-only access.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the `docker_image` resource to create, manage, and configure
    a container image, and the `docker_network` resource to create, manage, and configure
    container networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how to use Terraform to create a container image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This example creates a container image named `"example-image"` using the Dockerfile
    in the `"./``example-image"` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how to use Terraform to create a container network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This example creates a container network named `"example-network"` with a `bridge`
    driver.
  prefs: []
  type: TYPE_NORMAL
- en: By using the `docker_container`, `docker_image`, and `docker_network` resources,
    you can use Terraform to create, manage, and configure containers, container images,
    and container networks in a repeatable and automated way.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform also supports other providers besides Docker, such as AWS ECS, ECR,
    and EKS, **Azure Container Instance** (**ACI**), and Google Container Engine,
    which provides more specific resources and data sources that are tailored to those
    specific providers.
  prefs: []
  type: TYPE_NORMAL
- en: How to use Terraform for AWS container resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several ways to deploy containers in AWS, depending on your specific
    requirements and use case. Here are the general steps to deploy a container in
    AWS:'
  prefs: []
  type: TYPE_NORMAL
- en: Build and push your container image to a container registry such as Amazon ECR
    or any other public or private registry
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose a container orchestration platform such as Amazon ECS, Amazon EKS, AWS
    Fargate, AWS Lambda, AWS Elastic Beanstalk, or AWS App Runner
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a task definition or Pod definition that describes the container image
    and its configurations, such as environment variables, ports, and volumes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a service or deployment that uses the task definition or Pod definition
    to launch one or more instances of the container
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, configure scaling, load balancing, and monitoring for your containerized
    application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, you can use services such as Terraform or AWS CloudFormation to
    automate the deployment and management of your container infrastructure
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test your application and monitor its performance to make sure it’s working
    as expected
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s worth noting that each of the container orchestration platforms that AWS
    provides has its own set of management consoles, APIs, and CLIs that you can use
    to deploy, manage, and scale your containerized applications.
  prefs: []
  type: TYPE_NORMAL
- en: After building container images to push container images to ECR, we can utilize
    Terraform to create ECR repositories.
  prefs: []
  type: TYPE_NORMAL
- en: How to deploy AWS ECR with Terraform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Amazon ECR is a fully managed container registry service that makes it easy
    to store, manage, and deploy container images. To use Terraform to manage ECR
    resources and to deploy an Amazon ECR repository, you can use the AWS provider
    for Terraform, which provides a set of resources and data sources specific to
    ECR. Here are the general steps to deploy an ECR repository using Terraform:'
  prefs: []
  type: TYPE_NORMAL
- en: Install and configure the AWS provider for Terraform in your local environment
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Terraform configuration file and specify the AWS provider and the
    `aws_ecr_repository` resource
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the properties of the ECR repository, such as the repository name, in
    the resource configuration
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `terraform init` to initialize the Terraform environment and download the
    necessary provider plugins
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `terraform plan` to preview the changes that will be made to your infrastructure
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `terraform apply` to create an ECR repository in your AWS account
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is an example of how to use Terraform to create an ECR repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This example creates an ECR repository named `"example-repository"` in the `"``us-west-2"`
    region.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the `aws_ecr_lifecycle_policy` resource to manage the life
    cycle policies for an ECR repository and the `aws_ecr_image` resource to manage
    the images stored in an ECR repository using Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how to use Terraform to create a life cycle policy for
    an ECR repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This example creates a life cycle policy for the ECR repository specified by
    the `aws_ecr_repository.example.name` reference. This policy expires images that
    are older than 30 days and have no tag associated with them.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that this is a simple example of a life cycle policy.
    You can use the full set of options that an AWS ECR life cycle policy provides
    to create more complex policies, such as image tagging rules, image scanning rules,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the `terraform plan` and `terraform apply` commands to preview
    and apply the changes made to the repository policy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how to use Terraform to create an image in an ECR repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This example creates an image in an ECR repository specified by the `aws_ecr_repository.example.name`
    reference. The image is tagged with `"latest"` and the digest of the image is
    obtained from the `aws_ecr_image` data source.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `aws_ecr_image` resource to push and pull images to and from
    an ECR repository, as well as to manage images stored in an ECR repository.
  prefs: []
  type: TYPE_NORMAL
- en: The `aws_ecr_image` resource also allows you to specify image details such as
    the image tag, image digest, image manifest, and image scanned status.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that the preceding example is a simple example of creating
    an image in an ECR repository. You can use the full set of options that the `aws_ecr_image`
    resource provides to create and manage images in your ECR repository.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying container images to AWS container platforms with Terraform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will explore how to deploy container images to AWS container
    platforms using Terraform. By utilizing Terraform, we can simplify the process
    of managing container infrastructure and automate the deployment of containerized
    applications on AWS. We will discuss the use of AWS container services such as
    ECR, ECS, and EKS and how to deploy container images to these services using Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to AWS ECS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To deploy container images to Amazon ECS using Terraform, you can use the AWS
    provider for Terraform, which provides a set of resources and data sources specific
    to ECS. Here are the general steps to deploy an ECS container using Terraform:'
  prefs: []
  type: TYPE_NORMAL
- en: Install and configure the AWS provider for Terraform in your local environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Terraform configuration file and specify the AWS provider and the
    necessary ECS resources such as `aws_ecs_task_definition`, `aws_ecs_service`,
    and `aws_ecs_cluster`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the properties of the container, such as the container image, container
    name, port mappings, and environment variables, in the task definition resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a service resource that references the task definition, and configure
    the desired number of task replicas and the load balancer settings if applicable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a cluster resource if it doesn’t exist, and reference it in the task
    definition and service resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `terraform init` to initialize the Terraform environment and download the
    necessary provider plugins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `terraform plan` to preview the changes that will be made to your infrastructure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `terraform apply` to create the ECS service and deploy the container to
    your cluster in your AWS account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is an example of how to use Terraform to deploy a container to ECS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This example creates an ECS task definition, service, and cluster using Terraform.
    The task definition defines the container image, container name, port mappings,
    and memory and CPU requirements. The service references the task definition and
    creates two replicas of the container in the specified ECS cluster.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the `aws_elbv2_listener` and `aws_elbv2_target_group` resources
    to configure a load balancer and register the ECS service as a target group.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that this is a simple example of deploying an ECS container
    using Terraform. You can use the full set of options that the ECS resources provide
    to create and manage more complex ECS environments, such as auto scaling, rolling
    updates, and integration with other AWS services such as CloudWatch, CloudTrail,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the `terraform plan` and `terraform apply` commands to preview
    and apply the changes made to the ECS environment.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to AWS EKS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two steps for deploying applications to AWS EKS, as detailed next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an AWS EKS cluster with Terraform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create an Amazon EKS cluster using Terraform, you can use the AWS provider
    for Terraform, which provides a set of resources and data sources specific to
    EKS. Here are the general steps to create an EKS cluster using Terraform:'
  prefs: []
  type: TYPE_NORMAL
- en: Install and configure the AWS provider for Terraform in your local environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Terraform configuration file and specify the AWS provider and the
    `aws_eks_cluster` resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the properties of the EKS cluster, such as the cluster name, Kubernetes
    version, and VPC settings, in the resource configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, create an `aws_eks_cluster` resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, create a configuration file for `kubeconfig` to use the cluster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `terraform init` to initialize the Terraform environment and download the
    necessary provider plugins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `terraform plan` to preview the changes that will be made to your infrastructure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `terraform apply` to create the EKS cluster in your AWS account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is an example of how to use Terraform to create an EKS cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This example creates an EKS cluster with the specified name and Kubernetes version
    and associates it with the specified IAM role and security group.
  prefs: []
  type: TYPE_NORMAL
- en: It also creates two subnets in the specified Availability Zone for worker nodes
    to launch into.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that this is a simple example of creating an EKS cluster using
    Terraform. You can use the full set of options that the EKS resources provide
    to create and manage more complex EKS environments, such as scaling, monitoring,
    and integration with other AWS services such as CloudWatch, CloudTrail, and more.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the `terraform plan` and `terraform apply` commands to preview
    and apply the changes made to the EKS environment.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an application to an AWS EKS cluster with Terraform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To deploy container images to Amazon EKS using Terraform, you can use the Kubernetes
    provider for Terraform, which provides a set of resources and data sources specific
    to EKS. Here are the general steps to deploy a Kubernetes Pod using Terraform:'
  prefs: []
  type: TYPE_NORMAL
- en: Install and configure the Kubernetes provider for Terraform in your local environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Terraform configuration file and specify the Kubernetes provider
    and the necessary resources such as `kubernetes_namespace`, `kubernetes_deployment`,
    and `kubernetes_service`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the properties of the Pod, such as the container image, container name,
    container ports, and environment variables, in the deployment resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a service resource that references the deployment, and configure the
    load balancer settings if applicable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a namespace resource if it doesn’t exist, and reference it in the deployment
    and service resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `terraform init` to initialize the Terraform environment and download the
    necessary provider plugins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `terraform plan` to preview the changes that will be made to your infrastructure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `terraform apply` to create the Kubernetes deployment and service, and deploy
    the Pod to your EKS cluster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is an example of how to use Terraform to deploy a Pod to EKS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This example creates a Kubernetes namespace, deployment, and service using Terraform.
    The deployment defines the container image, container name, container ports, and
    the number of replicas for the Pod. The service references the deployment and
    creates a load balancer that directs traffic to the Pods.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the `kubernetes_config_map` and `kubernetes_secret` resources
    to manage configuration data and secrets for the Pod.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that this is a simple example of deploying a Pod to EKS using
    Terraform. You can use the full set of options that the Kubernetes resources provide
    to create and manage more complex EKS environments, such as auto scaling, rolling
    updates, and integration with other AWS services such as CloudWatch, CloudTrail,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the `terraform plan` and `terraform apply` commands to preview
    and apply the changes made to the EKS environment.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In conclusion, containers are a powerful tool for packaging and deploying applications
    in a consistent and portable way. AWS offers a variety of container services and
    platforms, each with its own set of features and capabilities. Terraform is an
    **infrastructure-as-code** (**IaC**) tool that can be used to manage and provision
    resources in AWS, including containers. By using Terraform to deploy containers
    to AWS, you can automate the process of creating and managing containerized applications,
    and ensure that your infrastructure is consistent, repeatable, and versionable.
    This can greatly simplify the process of deploying and scaling applications, and
    allows you to focus on the business logic of your application rather than managing
    the underlying infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll take a closer look at how Terraform can be leveraged
    for enterprise-level AWS projects. You’ll learn about the unique challenges and
    considerations that come with managing large-scale infrastructure, and how to
    navigate the decision-making process when it comes to implementing AWS and Terraform
    at the enterprise level. We’ll cover topics such as project planning, design considerations,
    and best practices for successful enterprise deployments. Stay tuned for a deep
    dive into the world of enterprise AWS and Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Part 3:How to Structure and Advance Terraform in Enterprises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we explore how to use Terraform in enterprise-level projects,
    focusing on structuring and advancing Terraform implementations to meet the demands
    of large-scale organizations. We discuss how to integrate Terraform into enterprises,
    including building Git workflows for IaC and Terraform projects to enable version
    control, collaboration, and automated deployment. You’ll learn how to automate
    the deployment of Terraform projects, streamlining the provisioning and management
    of cloud resources. We also delve into governance and security, exploring how
    to use Terraform to govern AWS resources and build a secure infrastructure on
    AWS. Finally, we discuss how to achieve a perfect AWS infrastructure with Terraform,
    optimizing performance, reliability, and cost-effectiveness. By the end of this
    part, you’ll be equipped to structure and advance Terraform implementations in
    enterprises, ensuring scalable, secure, and efficient cloud infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B18198_10.xhtml#_idTextAnchor186)*, Leveraging Terraform for
    the Enterprise*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B18198_11.xhtml#_idTextAnchor196)*, Building Git Workflows for
    IaC and Terraform Projects*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B18198_12.xhtml#_idTextAnchor204)*, Automating the Deployment
    of Terraform Projects*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B18198_13.xhtml#_idTextAnchor213)*, Governing AWS with Terraform*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B18198_14.xhtml#_idTextAnchor227)*, Building a Secure Infrastructure
    with AWS Terraform*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 15*](B18198_15.xhtml#_idTextAnchor258)*, Perfecting AWS Infrastructure
    with Terraform*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
