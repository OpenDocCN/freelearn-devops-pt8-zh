- en: Cloud Run Labs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore some use cases to see how Cloud Run can be
    deployed on **Google Kubernetes Engine** (**GKE**). The most common use cases
    revolve around building web applications, performing deployments, and the need
    for **continuous integration** (**CI**).
  prefs: []
  type: TYPE_NORMAL
- en: The focus of this chapter is to illustrate the wide spectrum of use cases that
    are possible using Cloud Run. This chapter will also show how to perform many
    of the activities required to deploy your container when using this platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over the course of this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying Cloud Run on GKE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CI on GKE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete the exercises in this chapter, you will require a Google Cloud Project
    or a Qwiklabs account.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code files of this chapter in the GitHub repository for this
    book in the `ch10` subdirectory at [https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch10](https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch10).
  prefs: []
  type: TYPE_NORMAL
- en: While you are going through the code snippets in this book, you will notice
    that, in a few instances, a few lines from the code/output have been removed and
    replaced with dots (`...`). Ellipses are used to only show relevant code/output.
    The complete code is available on GitHub at the link mentioned previously.
  prefs: []
  type: TYPE_NORMAL
- en: Building a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a container for an application should be a familiar activity at this
    point in this book. For the most part, when building an image, we can normally
    rely on existing knowledge to determine how to incorporate a runtime language
    or package. From a personal perspective, I like to containerize applications as
    it provides a consistent and well-understood interface. The isolation from system
    updates and other changes impacting an application is a very common and annoying
    aspect of maintaining a computer.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the assumption is that building images is second nature and the
    next challenge relates to deploying the containers. What your container is actually
    meant to do will probably influence the complexity of the running container. For
    example, running a container with a graphical user interface (potentially) presents
    more issues than one using a command-line interface. Over the course of this chapter,
    we will walk through a couple of examples dedicated to indicating how this process
    can be performed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using Cloud Shell or a local development environment (Cloud SDK)
    to create the next example, which is a fun example to demonstrate how to build
    an application running in a container. In this example, we will develop a simple
    application called **announce** (based on the command-line utility **Boxes**)
    that will display a message on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not familiar with Boxes, it draws ASCII art around text. To begin,
    we want to create an application that can call the Boxes application to output
    some arbitrary text.
  prefs: []
  type: TYPE_NORMAL
- en: To commence the example, let's initialize the environment ready to build our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize the `npm` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `package.json` to add a `start` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the `npm` packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Create and edit a file named `index.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the main functionality to the `index.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check your application at this stage by just running `npm start` from
    the command line. It won''t do anything spectacular, but it will give you the
    chance to correct any issues in terms of code not working as expected. Assuming
    you don''t have `boxes` installed locally, the output would be similar to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Message: undefined`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Error: Command failed: echo undefined | boxes -d boy`'
  prefs: []
  type: TYPE_NORMAL
- en: Don't worryâ€”this is expected and will be corrected with the creation of our
    application image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Dockerfile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the build process is invoked, an output similar to the following will
    be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9c03ce9-6fbb-4a4e-aa23-98e0f5eca765.png)'
  prefs: []
  type: TYPE_IMG
- en: Pushing the image to the Container Registry means we have more control over
    how and where our image can be accessed. Now that the image has been built, we
    can perform an initial test of the container by deploying it locally.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the announce service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having a container deployed to Container Registry is only part of the work
    to be performed. Next, we need to run the container from the image stored. Cloud
    Run containers run on port `8080`, so we should enable port mapping for images
    pulled from the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the container from the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Test the output from the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Test sending a message to the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Stop the Docker container running on the local machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations, you have now deployed and tested the application to generate
    box ASCII art from a container. In the next section, we will deploy the application
    to **Google Kubernetes Engine** (**GKE**) and access the service from a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Cloud Run on GKE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to create an image of an application, how does that translate
    to running an image on GKE? Fortunately, we already know how to deploy a container
    on Cloud Run, which means we know most of what is required for deployment on GKE.
  prefs: []
  type: TYPE_NORMAL
- en: From an external perspective, we interact with the Cloud Run service URL. Internally,
    when running on GKE, there is actually a lot more going on in the background.
    However, we will focus on how to replicate our application when running as a service.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning a GKE cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can deploy our application onto Cloud Run on GKE, we need to create
    a GKE cluster. So, let''s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example we use the standard cluster definition. So, create a GKE cluster
    called `hos-cluster-1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/09b71612-679f-4686-a489-55bd738c6138.png)'
  prefs: []
  type: TYPE_IMG
- en: It's important to select the Enable Cloud Run for Anthos option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot indicates that Cloud Run for Anthos has been enabled
    for the cluster. By default, monitoring is enabled on the cluster to be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bbe92de3-13c2-4f66-92c1-1bf1cea147c1.png)'
  prefs: []
  type: TYPE_IMG
- en: We can also use the command line to create a cluster and perform tasks on Google
    Cloud. In this instance, creating a cluster requires quite a long command, so
    I normally stick to doing this activity through the Cloud Console.
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes cluster to be created is standard apart from the checkbox located
    right at the bottom of the cluster configuration screen. For Cloud Run to be enabled
    within the cluster, this box needs to be checked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the cluster has been successfully provisioned, configure `kubectl` to
    connect to the cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Deploy the service to the `hos-cluster-1` Kubernetes cluster. Note that we
    now specify GKE as the platform as well as the cluster and cluster location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Make an environment variable called `ANNOUNCE_URL` to store the URL of the
    deployed service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: External access to the Cloud Run service is provided via Istio, which is deployed
    to another namespace. The deployed namespaces are displayed in the Cloud Console.
    However, if you were to do `kubectl get service` from the command line in the
    default namespace, there would be no reference to Istio. To access the Istio gateway
    service from the command line, we need to indicate that we would like to use the
    `gke-system` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the GKE service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have a service deployed, but we need to know how to access it. Cloud Run
    on GKE utilizes an Istio Ingress to enable external access to the GKE cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To show the details on the Istio Ingress (which is a `loadBalancer` created
    in the `gke-system` namespace), use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Assign the `loadBalancer.ingress` address to the `ISTIO_INGRESS` environment
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, we can see the result of the cluster. The information
    we need is labeled `istio-ingress`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/77ea1f2f-c5ea-48a9-9dec-d8d1d4e48674.png)'
  prefs: []
  type: TYPE_IMG
- en: Information returned from the `kubectl` command can be filtered to only display
    the field required. For example, in this instance, we only require the IP address.
    If we would like to filter the output to return specific information, we can use
    JQ to filter on the information desired.
  prefs: []
  type: TYPE_NORMAL
- en: JQ is a lightweight command-line tool built to process JSON objects. Using this
    tool, you can manipulate JSON objects in a similar fashion to using `sed` or `awk`.
    You can find more information on this amazing tool at [https://stedolan.github.io/jq/](https://stedolan.github.io/jq/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The application running in the cluster can be tested by visiting the Cloud
    Run service page or by using `curl` on the external IP associated with istio-ingress
    displayed in the Cloud Run console. For example, in my case, it is `announce-service.default.35.223.78.170.xip.io`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The namespace default can be seen in the service details screen for Cloud Run,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb109e96-5e62-419d-bc2a-d27d4969362f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For the deployed service, you may have noticed that the domain associated with
    our service is registered as `xip.io`. The default used by Cloud Run on GKE is
    actually `example.com`. So, how did this address become assigned to the deployed
    service? When testing, it is possible to change from the default domain to an
    alternative. Google currently provides three wildcard DNS test sites that can
    be set up to be used with Cloud Run services:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nip.io`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xip.io`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sslip.io`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sites declared above represent a simple and effective way to register a
    temporary domain for the purposes of testing.
  prefs: []
  type: TYPE_NORMAL
- en: Applying a custom domain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Alternatively, if you own a domain, this can also be set up instead of the
    default domain. Changing to use one of the free DNS sites requires doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the cluster to use a custom domain by patching the `configmap` for the
    cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: To determine the external IP of a Cloud Run service on GKE, remember that this
    is referring to the external IP of the Istio Ingress. Once the DNS has been updated,
    you will see that the address of the deployed service will use the new DNS reference.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to an alternative domain, there might also be a need to incorporate
    HTTPS for the cluster in use. For most situations, it is advisable to utilize
    a service such as Let's Encrypt on your cluster. Note that when using a Google
    service, HTTPS may be required, so it is important to know how to apply this to
    your environment so that the authentication methods work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: The console output includes a reference to service and ingress. The deployed
    service URL will be available in the Cloud Run console. The externally available
    IP is only available to the Istio Ingress of the load balancer type. Note that
    the internal address range, that is, `10.0.x.x`, is not accessible to the `curl`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Access the service URL and store it in an environment variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'List the information for the `istio-ingress` associated with the `gke-system`
    namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the external IP associated with the `istio-ingress` endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the external IP of the Istio Ingress to patch the endpoint for testing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to generate a digital SSL certificate. We can do this by using
    the `Certbot` utility. Certbot automates certificate generation using Let''s Encrypt
    as its backend. Download the Certbot ([https://certbot.eff.org/](https://certbot.eff.org/))
    application and use it to generate a digital SSL certificate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the SSL certificate to the domain to provide SSL access for the domain:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! We have successfully built and deployed a simple service on
    Cloud Run on GKE. However, to use it, we need to add some additional components.
    In the next section, we will expand on this example to illustrate how application
    components are integrated.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to build and deploy a container on Cloud Run on GKE, the
    next step is to explore how to link this together with other services to create
    an application. With our application deployed on GKE, we now need to configure
    Cloud Storage and Cloud Pub/Sub.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example, we are going to build a form to call our announce service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new directory called `simple-form`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `package.json` file and add the `start` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the `npm` packages (`pug` and `express`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the following code, we will call our `announce-service:1.0`. Replace the
    service URL endpoint with the address that was generated on Google Cloud for your
    Cloud Run deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a list of services that have been deployed, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gcloud run services list --platform managed`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following table, the commands that were used to deploy has been listed
    for reference. Take note of the platform command as this determines the target
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Platform** | **Command** |'
  prefs: []
  type: TYPE_TB
- en: '| Cloud Run | `gcloud run deploy SERVICE --platform managed --region REGION`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Cloud Run for Anthos (Google Cloud) | `gcloud run deploy SERVICE --platform
    gke --cluster CLUSTER-NAME``--cluster-location CLUSTER-LOCATION` |'
  prefs: []
  type: TYPE_TB
- en: '| Cloud Run for Anthos (VMware) | `gcloud run deploy SERVICE --platform kubernetes
    --kubeconfig KUBECONFIG-FILE` |'
  prefs: []
  type: TYPE_TB
- en: 'Create an `index.js` file and add the following content to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new directory for a `pug` view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `index.pug` file in the `views` directory and add the following style
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the form controls to the `index.pug` file (replace `ANNOUNCE_URL` with
    the URL for the `announce-service` URL identified earlier in the project):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application to test and see that the form calls the service and displays
    the message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9973f34f-1864-468d-9fe5-0b5f12e7c5aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On entering a message and pressing the Submit button, the form will call the
    `announce-service` and display the message that was entered, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca1d7d2a-90c3-422a-abc0-c91370f46b14.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! At this point, when a message is entered, it will invoke the
    service associated with the `ANNOUNCE_URL`. As the service URL is exposed, we
    can easily integrate other applications or services using web forms or other straightforward
    applications built around the service.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked at the general interface associated with deploying a
    web application, let's turn our focus to CI. In the next section, we will look
    at how to automate the build process.
  prefs: []
  type: TYPE_NORMAL
- en: CI on GKE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already seen, getting Cloud Run on GKE up and running takes a lot
    of work in comparison to Cloud Run. Besides that, we also need to iterate against
    the development cycle to ensure the build, testing, and deployment processes are
    performed consistently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, there is a mechanism available to help out with the development
    life cycle. Cloud Build is used to automate development tasks and can easily be
    extended to automate many of the tasks associated with developing code. Making
    the transition to working with containers provides many benefits, but does add
    the additional layer of effort necessary to ensure the images reflect the latest
    changes. A typical life cycle may look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Amend the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the code to version control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additionally, there may be different environments, tools, and processes to contend
    with outside of the typical stage gates associated with a developer pipeline.
    However, by using Cloud Build, we can easily create a CI pipeline that can initiate
    a build function based on committing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining a pipeline uses three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Service account permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build triggers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud Build file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To get started with Cloud Build, there are some additional permissions that
    need to be granted to the Cloud Run service account (Cloud Run Admin), and Service
    Accounts (Service Account User) need to be set to enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The permission state can be viewed in the Cloud Build interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e4077cf1-5f32-4f23-a452-8859ad833290.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Triggers a signal when a build should be initiated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/20c40ab4-32f8-4720-b716-fc358d785beb.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a push trigger can be set up for specific branches or for all pushes
    to the repository. Note the type of trigger will attempt to auto-detect the configuration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The build process steps are defined in a `cloudbuild.yaml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, working with Cloud Build can save a lot of effort in exchange for very
    little configuration. The dividend from using these types of development tools
    also has a high payoff for Google Cloud because the tool can be adapted to run
    a wide spectrum of packages. Indeed, the community for Cloud Build projects is
    quite significant and includes many different runtime languages beyond the scope
    of this book. Suffice to say it is well worth investing the time to understand
    how it works. A fully working example of how to incorporate Cloud Build for this
    type of CI pipeline is provided in [Chapter 12](d6dfba80-8556-4c35-ae9b-d6e33199fb8b.xhtml),
    *Consuming Third-Party Data via a REST API*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the course of this chapter, we have highlighted the initial elements of
    migrating to Cloud Run on GKE. Containers are fundamental to working with Kubernetes
    and provide a solid foundation on which to build both experience and expertise.
    To gain experience with the platform, we deployed a simple web application that
    illustrated many of the common elements that will need to be mastered as part
    of developing with Cloud Run on GKE.
  prefs: []
  type: TYPE_NORMAL
- en: The additional complexity of managing a Kubernetes environment should not dissuade
    you from using this platform. While serverless does provide many benefits already
    alluded to in this book, having a self-healing platform supporting critical infrastructure
    should provide additional comfort. Having the ability to seamlessly transition
    between Cloud Run and Cloud Run for Anthos ensures that, whenever it is needed,
    the choice exists and is accessible.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter concludes our brief introduction to Cloud Run and GKE. In the next
    couple of chapters, we'll change pace once again. We'll introduce two case studies
    to illustrate the power of serverless and expand on some of the techniques we've
    acquired over the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a key advantage of using Container Registry over another registry?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is it useful to use an environment variable such as `$GOOGLE_CLOUD_PROJECT`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What trigger types are supported by Cloud Build?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What domain is used for the Cloud Build service account?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What build configurations types are supported by Cloud Build?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Who provides the Certbot SSL certificates used in this chapter's example?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cloud SDK**: [https://cloud.google.com/sdk](https://cloud.google.com/sdk)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creating and Using SSL Certificates**: [https://cloud.google.com/load-balancing/docs/ssl-certificates](https://cloud.google.com/load-balancing/docs/ssl-certificates)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Certbot**: [https://certbot.eff.org/instructions](https://certbot.eff.org/instructions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Let''s Encrypt**: [https://letsencrypt.org/](https://letsencrypt.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
