<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Managing Authentication Protocols</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we will provide you with an overview about the important authentication protocols you need to know in order to handle your configurations and projects in that field.</p>
<p class="mce-root">We see a lot of confusion in the usage of authentication protocols in our projects. It's very important to understand the different protocols, that you can discuss with application providers about the correct implementation tasks and requirements. We see very often that a lot of time is used for discussing authentication methods and solutions. It's clearly impossible to put all the material about the different authentication methods in only one chapter, as that would fill a complete book in the real world. We decided to provide you with essential summaries with extensive and working external examples. We will deploy many of the different authentication methods in the labs of this book. You will find specific labs to adapt your knowledge of technical configurations in the following chapters:</p>
<ul>
<li><a href="468509fa-856c-411d-abdb-e9a39c266750.xhtml">Chapter 7</a>, <em>Deploying</em> <em>Solutions on Azure AD and ADFS</em></li>
<li><a href="efbe1917-c755-4449-b29e-fa4a21e819fd.xhtml" target="_blank">Chapter 8</a>, <em>Using the Azure AD App Proxy and the Web Application Proxy</em></li>
<li><a href="0cb2c20e-ca96-41ce-b555-24f63e63b9bf.xhtml">Chapter 9</a>, <em>Deploying additional applications on Azure AD</em></li>
<li><a href="6b29475f-7917-49bf-91d4-3024835d0278.xhtml">Chapter 10</a>, <em>Exploring Azure AD identity services</em></li>
</ul>
<p><span>The focus of this chapter will be to get you acquainted with some experiences and decision paths that can assist you with authentication protocols</span>. We will divide the chapter into the following sections:</p>
<ul>
<li>Microsoft identity platform</li>
<li>Common token standards in a federated world</li>
<li><strong>Security Assertion Markup Language</strong> (<strong>SAML</strong>) 2.0</li>
<li>WS-Federation</li>
<li>OAuth 2.0</li>
<li><strong>OpenID Connect</strong> (<strong>OIDC</strong>)</li>
<li>Pass-through authentication and seamless <strong>single sign-on</strong> (<strong>SSO</strong>)</li>
<li><strong>Multi-factor authentication</strong> (<strong>MFA</strong>)</li>
</ul>
<p>Let's start working through this authentication reference to kick off your journey.</p>
<div class="packt_tip">We highly recommend that you work through all the references in this chapter.</div>
<p>We will start with an overview of the Microsoft identity platform.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Microsoft identity platform</h1>
                </header>
            
            <article>
                
<p>Microsoft provides an identity platform with two endpoints called V1.0 and V2.0 with two sets of client libraries to work with these endpoints. The following libraries are used: Azure <strong>AD Authentication Library</strong> (<strong>ADAL</strong>) SDK and the <strong>Microsoft Authentication Library</strong> (<strong>MSAL</strong>). In the Azure AD portal, we will find how to include applications built with ADAL or MSAL over the app registrations (preview), as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/e4da5681-7ca3-42fe-979d-9349eacd13c0.png" width="918" height="388"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Microsoft identity platform overview</div>
<p>The following list describes the main use cases of the two endpoints:</p>
<ul>
<li>The V1.0 endpoint allows only work and school accounts to sign in</li>
<li>The V2.0 endpoint allows work and school accounts from Azure AD and <strong>Microsoft Accounts</strong> (<strong>MSA</strong>) to sign in</li>
<li>The v2.0 endpoint does not support SAML or WS-Federation—only <span>OIDC</span> and OAuth 2.0</li>
<li><span>The v2.0 endpoint doesn't support the</span> SAML assertion grant</li>
<li>Both endpoints accept sign-ins from guest users for single-tenant or multi-tenant applications</li>
</ul>
<p>Now that we have an overview on the available endpoints, we will jump into the token formats.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Common token standards in a federated world</h1>
                </header>
            
            <article>
                
<p><span class="fontstyle0">When a digital identity is transferred across a network, it's only a collection of bytes. It's common to refer to a set of bytes containing identity information as a security token or just a token. In a claims-based world, a token contains one or more claims, each of which carries some piece of information about the user it identifies.</span></p>
<p><span class="fontstyle0">Today, the tokens come in different flavors, including the following token formats:</span></p>
<ul>
<li><span class="fontstyle0"><strong>Security Assertion Markup Language</strong> (<strong><span class="fontstyle2">SAML</span></strong>):</span>
<ul>
<li><span class="fontstyle0">XML-based</span></li>
<li><span class="fontstyle0">Very descriptive metadata</span></li>
</ul>
</li>
<li><span class="fontstyle0"><strong>JSON Web Token</strong> (<strong><span class="fontstyle2">JWT</span></strong>):</span>
<ul>
<li><span class="fontstyle0">Easily readable by humans</span></li>
<li><span class="fontstyle0">Smaller token size</span></li>
</ul>
</li>
<li><span class="fontstyle0"><strong>Simple Web Token</strong> (<span class="fontstyle2"><strong>SWT</strong>):</span></span>
<ul>
<li><span class="fontstyle0">Form-encoded attribute/value pairs</span></li>
<li><span class="fontstyle0">Not very common</span></li>
</ul>
</li>
<li><strong><span class="fontstyle2">Kerberos</span></strong></li>
</ul>
<p><span class="fontstyle0">For the following protocol specifications, we recommend a good basic knowledge of claims-based authentication. You can download the Microsoft claims-based authentication handbook to prepare yourself. Use the following download link</span> <span class="fontstyle0">to get the book: <a href="https://www.microsoft.com/en-us/download/details.aspx?id=28362">https://www.microsoft.com/en-us/download/details.aspx?id=28362</a></span><span>.</span></p>
<p>We will discuss SAML 2.0 in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Security Assertion Markup Language (SAML) 2.0</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span class="fontstyle2">SAML is the foundation for much of the current identity federation activity. SAML 2.0 is preceded by SAML 1.0 and 1.1. SAML 1.1 was released in 2003 and had just two scenarios (also known as profiles), and both were IdP-initiated. Shibboleth 1.3 and Liberty Alliance—</span><span class="fontstyle2">WS-FF 1.2 extended SAML 1.1, and SAML 2.0 was released by OASIS in 2005.</span></p>
<p><span class="fontstyle0">The following table shows the SAML core principles:</span></p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 18%"><strong>Assertions</strong></td>
<td style="width: 22.8442%"><strong>Protocols</strong></td>
<td style="width: 30.1558%"><strong>Bindings</strong></td>
</tr>
<tr>
<td style="width: 18%"><strong>Package of identity</strong><br/>
<strong>information</strong></td>
<td style="width: 22.8442%">Request/response based</td>
<td style="width: 30.1558%">Associates a message (protocol)<br/>
with transport (communication<br/>
mechanism)</td>
</tr>
<tr>
<td style="width: 18%"><strong>Synonym token</strong></td>
<td style="width: 22.8442%">Defines the messaging<br/>
requirements</td>
<td style="width: 30.1558%">Examples:<br/>
<ul>
<li>HTTP Redirect</li>
<li>HTTP POST</li>
<li>HTTP Artifact</li>
<li>SOAP</li>
</ul>
</td>
</tr>
<tr>
<td style="width: 18%"><strong>XML-based</strong></td>
<td style="width: 22.8442%">Examples:<br/>
<ul>
<li>Authentication request</li>
<li>Single logout</li>
<li>Artifact resolution</li>
</ul>
</td>
<td style="width: 30.1558%"/>
</tr>
</tbody>
</table>
<p> </p>
<p>In the next section, we will talk about the key facts of the SAML 2.0 protocol.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Key facts about SAML</h1>
                </header>
            
            <article>
                
<p class="mce-root">The SAML standard provides accurate messages for the transfer of requests and assertions (claims). SAML offers several options for the transfer of information, such as the use of SOAP. The SAML standard defines identity information as assertions. A large part of the standard flows into the definition of assertions and attribute profiles. A session timeout is not considered. When logging off, an attempt is made to reach a large circle of recipients. SAML 2.0 uses profiles, which describe how assertions, protocols, and bindings combine to form a federation scenario.</p>
<p class="mce-root">For example, a web SSO profile will be used as follows:</p>
<ul>
<li>Authentication Request Protocol</li>
<li>HTTP Redirect binding at IdP</li>
<li>HTTP POST Binding at SP</li>
</ul>
<p>There are many different SSO profiles available that are defined in the specification:</p>
<ul>
<li>Web Browser SSO profile</li>
<li><strong>Enhanced Client or Proxy</strong> (<strong>ECP</strong>) profile</li>
<li>Identity provider discovery profile</li>
<li>Single logout profile</li>
<li>Name identifier management profile</li>
<li>Artifact resolution profile</li>
<li>Assertion query/request profile</li>
<li>Name identifier mapping profile</li>
</ul>
<div class="packt_tip"><span>For Shibboleth administrators, we highly recommend the following source: </span><a href="https://bit.ly/2DnG5pQ">https://bit.ly/2DnG5pQ</a><a href="https://bit.ly/2DnG5pQ">.</a></div>
<p>There are also SAML attribute profiles, such as the following, available for use:</p>
<ul>
<li>Basic attribute profile</li>
<li>X.500/LDAP attribute profile</li>
<li>UUID attribute profile</li>
<li>DCE PAC attribute profile</li>
<li>XACML attribute profile</li>
</ul>
<p>To give an example, we use the typical SAML web SSO profile in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/99f4c4a4-ba4c-489f-a5bc-45cb738629ac.png" style="width:25.58em;height:16.75em;" width="459" height="300"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>SAML web SSO profile</span></div>
<p>The following description explains the different steps in the authentication process:</p>
<ul>
<li><span class="fontstyle0">Trust is established between the <strong>Web Application</strong> and the <strong>SAML Issuer</strong></span></li>
<li><span class="fontstyle0"><span class="fontstyle0">The user browses to the <strong>Web Application</strong></span></span></li>
<li><span class="fontstyle0">The <strong>Web Application</strong> detects that the user is not authenticated and redirects him to the</span> <strong><strong>SAML Issuer</strong></strong></li>
<li><span class="fontstyle0">The user automatically browses to</span> the <strong>SAML Issuer</strong></li>
<li>The user authenticates to the <strong>SAML Issuer</strong></li>
<li>The <strong>SAML Issuer</strong> builds the toke<span class="fontstyle0">n and passes it back to the user</span></li>
<li><span class="fontstyle0">The user POSTs the token to the <strong>Web Application</strong></span></li>
</ul>
<div class="mce-root packt_tip">We highly recommend you work through the following Azure AD SAML 2.0 article:<a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/single-sign-on-saml-protocol"> https://docs.microsoft.com/en-us/azure/active-directory/develop/single-sign-on-saml-protocol</a><a href="https://bit.ly/2VYK2Z8">.</a></div>
<p>For debugging SAML-based SSO, work through the following articles:</p>
<ul>
<li><a href="https://bit.ly/2MpiDLK">https://social.technet.microsoft.com/wiki/contents/articles/31247.azure-active-directory-how-to-debug-saml-based-single-sign-on-to-applications.aspx</a> - How to debug SAML-based single sign-on to applications</li>
<li><a href="https://bit.ly/2U45UR8">https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-v1-debug-saml-sso-issues</a> - Debug SAML-based single sign-on to applications in Azure Active Directory</li>
</ul>
<p>In conclusion, we can say that SAML 2.0, which was released in 2005 by OASIS, is now commonly used in web sign-in scenarios, particularly for web applications with an XML token format.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">WS-Federation</h1>
                </header>
            
            <article>
                
<p><span class="fontstyle0">WS-Federation was developed by an industry consortium and was released in December 2006, with Microsoft being a key contributor. WS-Federation is also part of a larger framework, WS-Security, and builds on the work of WS-Trust from February 2005, defining the following two key principles:</span></p>
<ul>
<li><span class="fontstyle0">The protocol for requesting/receiving security tokens</span></li>
<li><span>How trust should be brokered between parties using an <strong>Security Token Service</strong> (<strong>STS</strong>)</span></li>
</ul>
<p><span>It also defines two profiles:</span></p>
<ul>
<li><span class="fontstyle0">Active Requestor Profile</span></li>
<li><span class="fontstyle0">Passive Requestor Profile</span></li>
</ul>
<p><span class="fontstyle0">WS-* Federation Suite consists of:</span></p>
<ul>
<li><span class="fontstyle0">WS-Trust</span></li>
<li><span class="fontstyle0">WS-Federation</span></li>
<li><span class="fontstyle0">WS-Policy</span></li>
</ul>
<p>In the next section, we will describe the key elements of the WS-Federation specification.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Key facts about WS-Federation</h1>
                </header>
            
            <article>
                
<p><span class="fontstyle2">In <strong>WS-Federation</strong>, in contrast to SAML, the token can be anything. Basically no defined messages are used. On the other hand, a suggestion is made for the use of a web service. The WS-Federation standard uses SOAP and makes the tunneling of SOAP available via the Web browser. The token for this standard is not subject to any concrete specification. WS-Federation can use a security token that is a SAML assertion. This means that WS-Federation can also use components from the SAML standard. As with SAML, there is no session timeout and an application must explicitly register to receive the information about a logoff.</span></p>
<p><span class="fontstyle2">There are also some relationships regarding SAML-P with the WS-Federation and the passive requestor profile, for example:</span></p>
<ul>
<li><span class="fontstyle2">Similar to <strong>SAML WebSSO</strong> profile</span></li>
<li><span class="fontstyle2">The following parts are incompatible:</span>
<ul>
<li><span class="fontstyle2">Different request and response messages</span></li>
<li><span class="fontstyle2">No IdP-initiated use case</span></li>
<li><span class="fontstyle2">No Assertion Query profile</span></li>
</ul>
</li>
</ul>
<p>Use the following source to gather more information about the topic:</p>
<p><a href="https://bit.ly/2AOnwcD">https://docs.microsoft.com/en-us/azure/active-directory/develop/azure-ad-federation-metadata</a></p>
<p>With the following sample, you can test and analyze WS-Federation with Azure AD:</p>
<p><a href="https://bit.ly/2TYiyRu">https://github.com/Azure-Samples/active-directory-dotnet-webapp-wsfederation</a></p>
<p><span class="fontstyle0">Conclusively, we can say that WS-Federation, which was established in 2006, is now commonly used for web sign-in scenarios, and .NET web applications. The token format is agnostic, like SAML, JWT, and so on.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">OAuth 2.0</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span class="fontstyle0">In simple words, authentication is the act of proving who you are, whereas authorization is the act of determining what you can do. OAuth 2.0 is about delegated authorization and not about authentication. It is not a protocol, it's an authorization framew</span>ork defined in the RFC 6749, <em>The OAuth 2.0 Authorization Framework</em>. T<span class="fontstyle0">his can be confusing because there are many cases in which you use OAuth 2.0 to log in to a client web application.</span></p>
<p class="mce-root"><span class="fontstyle0">The authentication process must end by figuring out and validating the identity of the end user, but OAuth doesn't do that. OAuth provides time-based tokens, which can be used to access a resource on behalf of the end user without providing any identity information about the end user.</span></p>
<p class="mce-root"><span class="fontstyle0">OAuth 2.0 is the existing standard for API security and is a major breakthrough in identity delegation.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Key facts about OAuth 2.0</h1>
                </header>
            
            <article>
                
<p><span class="fontstyle2">The following are the principal facts concerning OAuth 2.0:</span></p>
<ul>
<li><span class="fontstyle2">It is an internet protocol/specification for creating and managing application identity</span></li>
<li><span class="fontstyle2">It is a cross-platform mechanism</span></li>
<li><span class="fontstyle2">It has delegated authorization to APIs</span></li>
<li><span class="fontstyle2">Its main purpose is to get the client an access token</span></li>
<li><span class="fontstyle2">It is not an authentication protocol</span></li>
<li><span class="fontstyle2">It is preceded by OAuth 1.0 and OAuth</span> <span class="fontstyle3"><strong>Web Resource Authorization Profiles</strong> </span><span class="fontstyle2">(</span><strong><span class="fontstyle3">WRAP</span></strong><span class="fontstyle2">)</span></li>
<li><span class="fontstyle2">It is an internet standard used by Facebook, Google, and Twitter</span></li>
</ul>
<p><span class="fontstyle2">The OAuth framework differs between two client (application) types when accessing a service on behalf of a user. The two types of application can be described as follows: </span></p>
<ul>
<li><strong><span class="fontstyle3">Public</span></strong><span class="fontstyle2">: Runs locally on a device. Not trusted to hold a secret.</span></li>
<li><strong><span class="fontstyle3">Private</span></strong><span class="fontstyle2">: Runs behind firewalls. Can be trusted with secrets.</span></li>
</ul>
<p><span class="fontstyle0">The following diagram gives an example of the roles in the OAuth framework :</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/8a1f0bb5-0be6-42fd-9efe-0720c511d6ac.png" style="width:33.00em;height:21.83em;" width="621" height="409"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Roles in the OAuth framework</span></div>
<p><span class="fontstyle0">The provided list of roles are as follows:</span></p>
<ul>
<li><strong>Authorization Server</strong>: Issues the access token</li>
<li><strong>Resource Server</strong>: Verifies and accepts the access token</li>
<li><strong>Client</strong>: The application that requests the access token</li>
<li><strong>User (Resource Owner)</strong>: Is the end user, who grants the permission to access the resource server with an access token</li>
</ul>
<p>In the following screenshot, you will find an example consent, which is used with Cloud App Security that requires access to Salesforce:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/323e10ca-4f77-44a6-8ef5-7ee6d43e8455.png" style="width:23.58em;height:37.08em;" width="440" height="691"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Typical OAuth 2.0 consent</div>
<div class="mce-root packt_infobox">You will find more information about the Azure AD consent framework at: <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/consent-framework">https://docs.microsoft.com/en-us/azure/active-directory/develop/consent-framework</a>.</div>
<p><span class="fontstyle0">It is also important to understand the flows in OAuth 2.0 that define the process for obtaining an access token.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Main OAuth 2.0 flow facts</h1>
                </header>
            
            <article>
                
<p>There are four flows defined in the specification:</p>
<ul>
<li><strong>Authorization code</strong> <strong>flow</strong>:
<ul>
<li>One-time code issued to client</li>
<li>Client redeems code for access token</li>
<li>Access and ID token</li>
<li>Used for server-side apps</li>
<li><strong>Authorization code flow with proof key for code exchange</strong> (<strong>PKCE</strong>) <span>for </span><span>native/mobile applications</span></li>
</ul>
</li>
<li><strong>Client credentials</strong> <strong>flow</strong>:
<ul>
<li>Authenticates the client, not the user</li>
<li><span>Client receives an access token for itself</span></li>
<li><span>Does not support refresh tokens</span></li>
<li><span>Recommended for client applications with no end user (machine-to-machine communication)</span></li>
</ul>
</li>
<li><strong>Resource owner password</strong> <strong>flow</strong>:
<ul>
<li>Client collects username/password from user</li>
<li>Exchange username/password for access token</li>
<li>Used if you control the client application and the resource</li>
<li>Typically used in online services, where the online service client app talks with the own service</li>
</ul>
</li>
<li><strong>Implicit</strong> <strong>flow</strong>:
<ul>
<li>Client is untrusted (public)</li>
<li>No refresh token issued</li>
<li>Recommended to use for <strong>Single Page Applications</strong> (<strong>SPA</strong>)</li>
</ul>
</li>
</ul>
<p>You can use the following resources to deploy several OAuth 2.0 examples with your on-premise ADFS infrastructure:</p>
<p><a href="https://bit.ly/2S3gxqc">https://docs.microsoft.com/en-us/windows-server/identity/ad-fs/development/enabling-oauth-confidential-clients-with-ad-fs</a></p>
<p><a href="https://bit.ly/2HnAlAt">https://docs.microsoft.com/en-us/windows-server/identity/ad-fs/development/native-client-with-ad-fs</a></p>
<p>Work through the following examples with Azure AD to get deeper into the different flow types:</p>
<ul>
<li><strong>OAuth 2.0 implicit grant flow</strong>: <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/v1-oauth2-implicit-grant-flow">https://docs.microsoft.com/en-us/azure/active-directory/develop/v1-oauth2-implicit-grant-flow</a></li>
<li><strong>OAuth 2.0 auth code grant flow</strong><span>: <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/v1-protocols-oauth-code">https://docs.microsoft.com/en-us/azure/active-directory/develop/v1-protocols-oauth-code</a></span></li>
<li><strong>OAuth 2.0 On-Behalf-Of flow</strong><span>: <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/v1-oauth2-on-behalf-of-flow">https://docs.microsoft.com/en-us/azure/active-directory/develop/v1-oauth2-on-behalf-of-flow</a></span></li>
<li><strong>OAuth 2.0 client credentials flow</strong><span>: <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/v1-oauth2-client-creds-grant-flow">https://docs.microsoft.com/en-us/azure/active-directory/develop/v1-oauth2-client-creds-grant-flow</a></span></li>
</ul>
<p>The next section provides you with information about the authorization code flow.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Authorization code flow</h1>
                </header>
            
            <article>
                
<p><span class="fontstyle0">The main concept of this flow is that the client gets an authorization code first and uses the code to redeem the access token. It's recommended for private clients (web apps or native mobile applications) that have the capability to spawn a web browser. In that case, private clients establish a secret with the OAuth server. The secret will be used to authenticate the client during the access token redemption.</span></p>
<p><span class="fontstyle0">The access tokens expire and need to be refreshed with refresh tokens, and each of them has their own lifetime and can be stored for a longer term. A refresh token can also be used to redeem a new access token later.</span></p>
<p><span class="fontstyle0">The following figure shows an example of the</span> <span class="fontstyle2">authorization code grant type:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/4a14a60e-1151-4a1c-a298-f12bdcb68250.png" style="width:27.50em;height:26.33em;" width="550" height="526"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Authorization code grant type flow</div>
<p>The flow works in the following order:</p>
<ol>
<li>The <strong>User</strong> clicks the button to post this purchase</li>
<li>The <strong>Client</strong> redirects the user to OAuth server</li>
<li>The <strong>User</strong> authenticates and grants consent</li>
<li>The OAuth server redirects the <strong>User</strong> to the <strong>Client</strong> with the authorization code</li>
<li>The <strong>Client</strong> requests an access token from the <strong>Authorization Server</strong></li>
<li>The OAuth server returns the access token to the <strong>Client</strong></li>
<li>The <strong>Client</strong> uses the access token to authorize to the resource</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Client credential flow</h1>
                </header>
            
            <article>
                
<p>The main concept of this flow is application authentication and not user authorization, where the application establishes a secret. The application authenticates with the secret and receives an access token. Users are not involved in this flow and the client can perform this flow out of band. </p>
<p>The following diagram shows the client credential grant type:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/66508e4a-5bfb-4bb3-95c1-61e5c67e1ec3.png" style="width:21.58em;height:18.00em;" width="399" height="332"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Client credential grant flow</div>
<p>The flow runs in the following order:</p>
<ol>
<li>The <strong>User</strong> uses the client (through the address book app)</li>
<li>The client authenticates to the OAuth server (<strong>Azure AD</strong>)</li>
<li>The OAuth server provides an access token to the client</li>
<li>The client calls resource (web service) with the access token in the header</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implicit grant flow</h1>
                </header>
            
            <article>
                
<p>While acquiring an access token, this flow is mostly used by JavaScript clients running in the web browser. Also, important to note is that there is no authentication requirement for the JavaScript client. The difference between this and the authorization code flow is that the access token will be received in the grant request.</p>
<p>The following figure shows an example of the implicit grant type.</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/b1dfc699-ea9f-4422-b391-043cfeafd691.png" style="width:41.67em;height:22.58em;" width="808" height="437"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Implicit grant flow</div>
<p>The flow in the main points runs as follows:</p>
<ol>
<li>The <strong>Client</strong> <strong>Application</strong> opens a browser to send the user to the <strong>Authorization Server</strong></li>
<li>The authorization prompt appears to the user and approves the application request</li>
<li>A redirect for the user goes back to the application with an <strong>Access Token</strong></li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Resource owner password credentials flow</h1>
                </header>
            
            <article>
                
<p>The main concept in this flow is that the resource owner must trust the client application. This means that the resource owner has to give its credentials directly to the client application.</p>
<p>The following figure shows the resource owner password credentials grant type:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/6a6eb768-6001-463f-a4b2-3e1b24a13740.png" style="width:35.00em;height:10.42em;" width="716" height="212"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Resource owner password credential flow</div>
<p>In conclusion, we can say that the specification of OAuth 2.0, which was published in October 2012, is now commonly used in rich client and modern application scenarios and with <strong>RESTful Web API</strong> access. The token format is agnostic but <strong>JWT</strong> is primarily used.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">OpenID Connect (OIDC)</h1>
                </header>
            
            <article>
                
<p class="mce-root">OIDC <span>was established as a standard by its membership in February 2014. <span>OIDC</span> provides a lightweight framework for identity interactions in a RESTful manner. The specification was developed under the OpenID Foundation and has its roots in OpenID; it was greatly affected by OAuth 2.0, because that specification was not intended for authentication. Microsoft was also a co-author of the <span>OIDC</span> specification.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Key facts about OIDC</h1>
                </header>
            
            <article>
                
<p>It defines the following identity layers on top of OAuth 2.0:</p>
<ul>
<li>It uses two OAuth 2.0 flows:
<ul>
<li>Authorization code flow</li>
<li>Implicit flow</li>
</ul>
</li>
<li>Adds an ID token to OAuth 2.0 exchange</li>
<li>Adds the ability to request claims using an OAuth 2.0 access token</li>
</ul>
<p>The following roles are used:</p>
<ul>
<li><strong>OpenID Connect Provider</strong> (<strong>OP</strong>): Authorization server issues the ID token</li>
<li><strong>Relying Party</strong>: Client application that requests the ID token</li>
<li><strong>ID token</strong>: Issued by the <span>OP</span></li>
<li><strong>Claim</strong>: Information about the user</li>
</ul>
<p>The following figure shows the OpenID Connect flow:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/2d1fdfdf-c1ae-4063-86c0-c97ef28266b7.png" style="width:25.25em;height:18.42em;" width="455" height="332"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">OpenID Connect flow</div>
<p>The flow runs with the following steps:</p>
<ol>
<li>A client registers with the OP</li>
<li>The user browses to the web app and initiates login</li>
<li>The web app redirects the user to the OP</li>
<li>The user authenticates to the OP and gives consent for the web app to use his identity</li>
<li>OP builds the authorization code</li>
<li>OP redirects the user back to the web app with the authorization code</li>
<li>The web app sends the authorization code to OP</li>
<li>OP creates the ID token and access token and sends back to the web app</li>
<li>The web app verifies the ID token</li>
</ol>
<p>The specification also uses a UserInfo EndPoint with the following characteristics:</p>
<ul>
<li>Returns additional claims about a user</li>
<li>REST-based endpoint</li>
<li>Authenticates with access token received from OPx</li>
<li>Response returned in JSON</li>
</ul>
<div class="packt_infobox">More information about <span>OIDC</span> and Azure AD is available at: <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-protocols-oidc">https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-protocols-oidc</a>.</div>
<p>Build the following sample applications with an on-premise ADFS infrastucture:</p>
<ul>
<li><strong>Enabling </strong><span><strong>OIDC</strong>: <a href="https://docs.microsoft.com/en-us/windows-server/identity/ad-fs/development/enabling-openid-connect-with-ad-fs">https://docs.microsoft.com/en-us/windows-server/identity/ad-fs/development/enabling-openid-connect-with-ad-fs</a></span></li>
<li><strong>Single logout for</strong> <span><strong>OIDC</strong>:</span><a href="https://docs.microsoft.com/en-us/windows-server/identity/ad-fs/development/ad-fs-logout-openid-connect"> https://docs.microsoft.com/en-us/windows-server/identity/ad-fs/development/ad-fs-logout-openid-connect</a></li>
</ul>
<div class="packt_infobox">Use the examples with Azure AD to dive further into the OI<span>DC</span> implementation. These are covered here: <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/sample-v2-code">https://docs.microsoft.com/en-us/azure/active-directory/develop/sample-v2-code</a></div>
<p><span class="fontstyle0">In conclusion, we can say that the specification was released in February 2014, was co-authored by Microsoft, and is used for web sign-in when consent is needed. The token format is JWT.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Pass-through authentication and seamless SSO</h1>
                </header>
            
            <article>
                
<p>Azure AD pass-through authentication provides an alternative to the Azure AD password hash synchronization and a local ADFS infrastructure if all claims-based applications are connected to the Azure AD. Microsoft offers with this service the capabilities to reduce the on-premise complexity and operations of ADFS. Furthermore, in combination with the password hash synchronization, customers get a redundant and flexible authentication environment. You are also able to include password protection features for your local Active Directory.</p>
<p>Pass-through authentication supports the Azure AD conditional access policies, Azure MFA, and the blocking of legacy authentications to secure your organization's or customer environment. The communication of the on-premise agent and the Azure AD service is protected with certificate authentication. The feature can support multi forest infrastructures if forest trusts are enabled and the UPN-suffix routing is configured correctly. In combination with seamless SSO, users get a native SSO experience and are automatically signed into on-premise and cloud-based applications.</p>
<p>The following components are involved in the user sign-in process:</p>
<ul>
<li><strong>Azure AD STS</strong>: <strong>Stateless security token service</strong> (<strong>STS</strong>) for processing sign-in requests and security token issuance</li>
<li><strong>Azure Service Bus</strong>: Communication component between cloud and on-premise</li>
<li><strong>Azure AD Connect Authentication Agent</strong>: Listener and responder to password validation requests</li>
<li><strong>Azure SQL Database</strong>: Storage for tenant associated authentication agents</li>
<li><strong>Active Directory</strong>: Store for local user accounts and passwords</li>
</ul>
<p>Let's look at the following diagram to understand the functionality accessing the Outlook web app:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/b67aa456-062a-478f-b62f-516ab62a6463.png" width="859" height="342"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Path-through authentication flow</div>
<div class="mce-root packt_infobox">Deep dive information about the service can be found at the following source: <a href="https://docs.microsoft.com/en-us/azure/active-directory/hybrid/how-to-connect-pta-security-deep-dive">https://docs.microsoft.com/en-us/azure/active-directory/hybrid/how-to-connect-pta-security-deep-dive</a></div>
<p><span>The flow runs with the following steps:</span></p>
<ol>
<li>User tries to access Outlook web app</li>
<li>When the user is not signed in, he will be redirected to the Azure AD sign-in page</li>
<li>User enters his username, and selects <span class="packt_screen">Next</span></li>
<li>User enters his password, and selects <span class="packt_screen">Sign In</span></li>
<li>The Azure AD receives the sign in request and puts the username/password encrypted with the public key of the authentication agents in a queue</li>
<li>The on-premise authentication agent retrieves the encrypted credentials from the queue</li>
</ol>
<div class="mce-root packt_infobox">The agent retrieves requests over a pre-established and persistent connection.</div>
<ol start="7">
<li>The agent decrypts the password with his private key</li>
<li>The agent validates the username and credential against the local Active Directory, like ADFS</li>
<li>The Domain Controller evaluates the request and responds with the result the agent</li>
<li>The agent responds back to Azure AD</li>
<li>Azure AD validates the answer—the user will be signed in or Azure MFA will be executed</li>
<li>If all works fine, the user is signed in</li>
</ol>
<p>To choose the best option for your hybrid authentication solution, you can use the following source to help you with your decision <a href="https://docs.microsoft.com/en-us/azure/security/azure-ad-choose-authn">https://docs.microsoft.com/en-us/azure/security/azure-ad-choose-authn</a><span>.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Multi-factor authentication</h1>
                </header>
            
            <article>
                
<p><span class="fontstyle0">Protecting sensitive information or application access with additional authentication is an important task, not just in the on-premise world. In particular, it needs to be extended to every sensitive cloud service used. There are a lot of variations for providing this level of security and additional authentication, such as certificates, smart cards, or biometric options. For example, smart cards depend on special hardware used to read the smart card and cannot be used in every scenario without limiting the access to a special device or hardware. The following table gives you an overview of different attacks and how they can be mitigated with a well-designed and implemented security solution:</span></p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 26%" class="CDPAlignCenter CDPAlign"><strong>Attacker</strong></td>
<td style="width: 30.2036%" class="CDPAlignCenter CDPAlign"><strong>Possible security solution</strong></td>
</tr>
<tr>
<td style="width: 26%">Password brute force</td>
<td style="width: 30.2036%">Strong password policies</td>
</tr>
<tr>
<td style="width: 26%">Shoulder surfing<br/>
Key or screen logging</td>
<td style="width: 30.2036%">One-time password solution</td>
</tr>
<tr>
<td style="width: 26%">Phishing or pharming</td>
<td style="width: 30.2036%">Server authentication (HTTPS)</td>
</tr>
<tr>
<td style="width: 26%">Man-in-the-Middle<br/>
Whaling (Social engineering)</td>
<td style="width: 30.2036%">Two-factor authentication<br/>
Certificate or one-time password solution</td>
</tr>
<tr>
<td style="width: 26%">Certificate authority corruption<br/>
Cross Channel Attacks (CSRF)</td>
<td style="width: 30.2036%">Transaction signature and verification<br/>
Non repudiation</td>
</tr>
<tr>
<td style="width: 26%">Man-in-the-Browser<br/>
Key loggers</td>
<td style="width: 30.2036%">Secure PIN entry<br/>
Secure messaging<br/>
Browser (read only)<br/>
Push button (token)<br/>
Three-factor authentication</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Microsoft provides the Azure MFA functionality to address exactly the attacks described in the previous table. With a one-time password solution, you can build a very capable security solution to access information or applications from devices that cannot use smart cards as the additional authentication method. Otherwise, for small or medium business organizations, a smart card deployment, including the appropriate management solution, will be too costly, and the Azure MFA solution can be a good alternative for reaching the expected higher security level.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Azure MFA</h1>
                </header>
            
            <article>
                
<p>Azure MFA provides the security of a two-step verification. The user gets many options to verify his identity, like phone calls, text messages, the mobile app with notifications, and created codes. Also, the integration of OATH hardware tokens is in the actual preview. To roll out the feature, you can use the following sources:</p>
<p><a href="https://bit.ly/2Mjdbdj">https://docs.microsoft.com/en-us/azure/active-directory/authentication/tutorial-mfa-applications</a></p>
<p><a href="https://bit.ly/2McMo1B">https://docs.microsoft.com/en-us/azure/active-directory/authentication/howto-mfa-getstarted</a></p>
<p>Azure MFA includes the capabilities to integrate on-premise components with the following two agents:</p>
<ul>
<li><strong>Active Directory Federation Services</strong> (<strong>ADFS</strong>) 2016 and higher</li>
<li><strong>Network Policy Server</strong> (<strong>NPS</strong>)</li>
</ul>
<p>If you need to integrate older versions of ADFS or third-party RADIUS servers, the only option is to deploy the on-premise Azure MFA server. With this integration there are some limitations, such as:</p>
<ul>
<li>No synchronization of the registration information</li>
<li>Usage of two registration and user portals</li>
<li>Additional MFA infrastructure to manage</li>
</ul>
<p>In the next section, we will discuss the certificate authentication option.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Certificate authentication</h1>
                </header>
            
            <article>
                
<p>Azure AD supports the use of certificate-based authentication. Devices can use a client certificate to connect. This feature eliminates the need to enter a username/password combination to access your mail and Microsoft applications on your mobile device. You can use the following two sources to gather more information on the specific platform:</p>
<ul>
<li><strong>Android</strong>: <a href="https://docs.microsoft.com/en-us/azure/active-directory/authentication/active-directory-certificate-based-authentication-android">https://docs.microsoft.com/en-us/azure/active-directory/authentication/active-directory-certificate-based-authentication-android</a></li>
<li><strong>iOS</strong>: <a href="https://docs.microsoft.com/en-us/azure/active-directory/authentication/active-directory-certificate-based-authentication-ios">https://docs.microsoft.com/en-us/azure/active-directory/authentication/active-directory-certificate-based-authentication-ios</a></li>
</ul>
<p>Otherwise, you can use the device authentication as an alternative method. We describe the device authentication in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Device authentication</h1>
                </header>
            
            <article>
                
<p>The other method that Microsoft includes in the multi-factor solution framework is the device authentication. The device authentication can be used with the following registration or join method of the device:</p>
<ul>
<li>Azure AD registration</li>
<li>Workplace Join</li>
<li>Azure AD Join</li>
<li>Hybrid Azure AD Join</li>
</ul>
<p>You will find more information about all the different options at the following source: <a href="https://docs.microsoft.com/en-us/azure/active-directory/devices/overview">https://docs.microsoft.com/en-us/azure/active-directory/devices/overview</a>. You can use these states for conditional access in your on-premise ADFS or your Azure AD.</p>
<p>To deploy on-premise conditional access with your ADFS infrastructure, you can use the following source: <a href="https://docs.microsoft.com/en-us/windows-server/identity/ad-fs/operations/configure-device-based-conditional-access-on-premises">https://docs.microsoft.com/en-us/windows-server/identity/ad-fs/operations/configure-device-based-conditional-access-on-premises</a>. For cloud environments, we recommend the following source to start your journey into conditional access: <a href="https://docs.microsoft.com/en-us/azure/active-directory/conditional-access/overview">https://docs.microsoft.com/en-us/azure/active-directory/conditional-access/overview</a><a href="https://bit.ly/2W2nV4h">.</a></p>
<p><a href="https://bit.ly/2W2nV4h"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Biometric authentication</h1>
                </header>
            
            <article>
                
<p>Windows Hello is another authentication solution that uses biometric user information like the fingerprint, face, or iris recognition. The functionality is available for personal or enterprise-grade security to provide authentication. You also can use this feature against your on-premise ADFS and your Azure AD. Use the following source to plan and deploy <strong>Windows Hello</strong> in your organization: <a href="https://docs.microsoft.com/en-us/windows/security/identity-protection/hello-for-business/hello-planning-guide">https://docs.microsoft.com/en-us/windows/security/identity-protection/hello-for-business/hello-planning-guide</a><a href="https://bit.ly/2ELPBoL"><span>.</span></a></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Working through the chapter and the given references, you have worked through many aspects and practical examples of the most important authentication protocols. We have tried to provide you with a very crisp reference card with much valid additional information about this topic. You should be able to use WS-Federation, SAML, OAuth 2.0, and <span>OIDC</span> in your design or configuration work for customers or your own organization. As already mentioned at the beginning of the chapter, we will use the knowledge in the upcoming chapters.</p>
<p>In the next <a href="468509fa-856c-411d-abdb-e9a39c266750.xhtml" target="_blank">Chapter 7</a>, <span><em>Deploying Solutions on Azure AD and ADFS</em>, we start to work on it directly!</span></p>


            </article>

            
        </section>
    </div>



  </body></html>