<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer042">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 class="chapterTitle" id="_idParaDest-48"><span class="koboSpan" id="kobo.2.1">Principles of Solution Architecture Design</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">This chapter throws light on the most important and common design principles and attributes of solution architecture. </span><span class="koboSpan" id="kobo.3.2">While the focus in this chapter is on the most pivotal design elements, it’s worth noting that additional design aspects might arise, contingent on the complexity of the product and the specific industry domain. </span><span class="koboSpan" id="kobo.3.3">As you advance on your journey toward becoming a solutions architect through this book, you’ll see these foundational principles and attributes applied in more depth, including in the crafting of various design patterns tailored to diverse scenarios and challenges.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4.1">In this chapter, you will learn the principles of designing architectures that are scalable, resilient, and optimized for performance, while ensuring robust security measures are in place to safeguard your application. </span><span class="koboSpan" id="kobo.4.2">You will explore strategies to navigate architectural constraints and embrace change through testing and automation, emphasizing a data-driven approach. </span><span class="koboSpan" id="kobo.4.3">By understanding and applying these principles, you’ll be equipped to think critically and make informed decisions that enhance the effectiveness and reliability of your architectural designs.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5.1">You will learn about the following topics in this chapter:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.6.1">Building scalable architecture design</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.7.1">Building a highly available and resilient architecture</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.8.1">Design for performance</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.9.1">Creating immutable architecture</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.10.1">Think loose coupling</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.11.1">Think service, not server</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.12.1">Think data-driven design</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.13.1">Adding security everywhere</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.14.1">Making applications usable and accessible</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.15.1">Building future-proof extendable architecture</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.16.1">Ensuring architectural interoperability and portability</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.17.1">Applying automation everywhere</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.18.1">Design for operation</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.19.1">Overcoming architectural constraints</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.20.1">Let’s embark on exploring the foundational elements of architectural design. </span><span class="koboSpan" id="kobo.20.2">By the end of this chapter, you’ll have gained insights into various essential design aspects to consider when constructing an architecture. </span><span class="koboSpan" id="kobo.20.3">This knowledge will serve as a crucial stepping stone on your journey to understanding and implementing effective and robust architectural solutions.</span></p>
<h1 class="heading-1" id="_idParaDest-49"><span class="koboSpan" id="kobo.21.1">Building scalable architecture design</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.22.1">Scalability has </span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.23.1">always been a primary factor while designing a solution. </span><span class="koboSpan" id="kobo.23.2">If you ask any enterprise about their solutions, scalability will be one of the key </span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.24.1">considerations. </span><strong class="keyWord"><span class="koboSpan" id="kobo.25.1">Scalability</span></strong><span class="koboSpan" id="kobo.26.1"> refers to allowing your system to handle growing workloads, which can apply to multiple layers, such as the application server, web app, and database. </span><span class="koboSpan" id="kobo.26.2">Scalability helps you fulfill user demand without impacting application performance, resulting in higher business returns.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.27.1">As most applications nowadays are web-based, let’s also talk </span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.28.1">about </span><strong class="keyWord"><span class="koboSpan" id="kobo.29.1">elasticity</span></strong><span class="koboSpan" id="kobo.30.1">. </span><span class="koboSpan" id="kobo.30.2">This is about growing your system by adding more capabilities and shrinking it to save on unnecessary costs. </span><span class="koboSpan" id="kobo.30.3">With the adoption of the public cloud, it has become easy to quickly grow and shrink your workload, with elasticity now replacing scalability. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.31.1">Traditionally, there are two modes of scaling:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.32.1">Horizontal scaling</span></strong><span class="koboSpan" id="kobo.33.1">: Horizontal scaling</span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.34.1"> is becoming</span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.35.1"> increasingly popular as computing power has become an exponentially cheaper commodity in the last decade. </span><span class="koboSpan" id="kobo.35.2">In horizontal scaling, the team adds more servers to handle increasing workloads, as in </span><em class="italic"><span class="koboSpan" id="kobo.36.1">Figure 2.1</span></em><span class="koboSpan" id="kobo.37.1">: </span><figure class="mediaobject"><span class="koboSpan" id="kobo.38.1"><img alt="" role="presentation" src="../Images/B21336_02_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.39.1">Figure 2.1: Horizontal scaling</span></p>
<p class="normal"><span class="koboSpan" id="kobo.40.1">Let’s say</span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.41.1"> your application can handle </span><em class="italic"><span class="koboSpan" id="kobo.42.1">1,000 requests per second</span></em><span class="koboSpan" id="kobo.43.1"> with </span><em class="italic"><span class="koboSpan" id="kobo.44.1">two server instances</span></em><span class="koboSpan" id="kobo.45.1">, for example. </span><span class="koboSpan" id="kobo.45.2">As your user base grows, the </span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.46.1">application receives </span><em class="italic"><span class="koboSpan" id="kobo.47.1">2,000 requests per second</span></em><span class="koboSpan" id="kobo.48.1">, which means you may want to double your application instances to four to handle the increased load.</span></p>
</li>
</ul>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.49.1">Vertical scaling</span></strong><span class="koboSpan" id="kobo.50.1">: This has</span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.51.1"> been around for a long time. </span><span class="koboSpan" id="kobo.51.2">It </span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.52.1">is a practice in which the team adds additional computer storage capacity and memory power to the same server to handle increasing workloads. </span><span class="koboSpan" id="kobo.52.2">As shown in </span><em class="italic"><span class="koboSpan" id="kobo.53.1">Figure 2.2</span></em><span class="koboSpan" id="kobo.54.1">, during vertical scaling, you will get a larger server—rather than adding more servers—to handle the increased workload: </span><figure class="mediaobject"><span class="koboSpan" id="kobo.55.1"><img alt="" role="presentation" src="../Images/B21336_02_02.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.56.1">Figure 2.2: Vertical scaling</span></p>
<p class="normal"><span class="koboSpan" id="kobo.57.1">The vertical scaling model </span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.58.1">may be less cost-effective, however; when </span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.59.1">you purchase hardware with more computing power and memory capacity, the cost increases exponentially. </span><span class="koboSpan" id="kobo.59.2">You want to avoid vertical scaling after a certain threshold unless it is required to handle an increasing workload due to high costs and limitations on server capacity.</span></p>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.60.1">Vertical scaling is </span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.61.1">most commonly used to scale relational database servers. </span><span class="koboSpan" id="kobo.61.2">However, you need to think about database sharding here as if your server hits the limits of vertical scaling, it cannot grow beyond a specific memory and computing capacity.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.62.1">Sharding is a technique used to scale databases by dividing and distributing data across multiple servers. </span><span class="koboSpan" id="kobo.62.2">Data is partitioned based on a shard key, which determines how data is distributed across the shards. </span><span class="koboSpan" id="kobo.62.3">In vertical sharding, the shard key can be a specific column or a set of columns in a table.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.63.1">Scaling could be predictive if you are aware of your workload, which is often the case, or it could be reactive if you get a sudden spike or if you have never handled that kind of load before.</span></p>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.64.1">Predictive scaling</span></strong><span class="koboSpan" id="kobo.65.1"> is an advanced </span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.66.1">approach to managing application </span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.67.1">workloads, particularly useful for scenarios with predictable traffic patterns, like those seen on e-commerce websites. </span><span class="koboSpan" id="kobo.67.2">By analyzing historical data, organizations can forecast traffic trends and adjust their resources accordingly. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.68.1">For instance, an e-commerce site might experience varying traffic based on the day of the week, time of day, or specific shopping holidays, necessitating a scaling strategy that preemptively adjusts resources to handle expected load increases. </span><span class="koboSpan" id="kobo.68.2">This approach not only optimizes resource usage but also enhances user experience by reducing latency and preventing outages, which is especially important during traffic spikes when resource allocation might lag behind demand.</span></p>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.69.1">Reactive scaling</span></strong><span class="koboSpan" id="kobo.70.1">, on the </span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.71.1">other hand, is essential for dealing with </span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.72.1">unforeseen traffic surges, which might be significantly higher than the norm and could be triggered by events like flash sales. </span><span class="koboSpan" id="kobo.72.2">Understanding the unique traffic patterns for different pages of a website, as well as the user navigation path, is crucial for effectively managing these spikes. </span><span class="koboSpan" id="kobo.72.3">By identifying which pages can be cached or which queries are read-intensive, organizations can strategically offload traffic from the web layer, utilizing content distribution networks to manage static content. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.73.1">This combination of predictive </span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.74.1">and reactive scaling ensures that applications remain resilient and responsive, regardless of traffic fluctuations. </span><span class="koboSpan" id="kobo.74.2">For example, the</span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.75.1"> following </span><strong class="keyWord"><span class="koboSpan" id="kobo.76.1">Auto Scaling group</span></strong><span class="koboSpan" id="kobo.77.1"> has a maximum of six instances and a minimum size of three instances. </span><span class="koboSpan" id="kobo.77.2">During regular user traffic, three servers will be up and running to handle the workload, but the number of servers can reach six to handle a traffic spike. </span><span class="koboSpan" id="kobo.77.3">Your server fleet will increase based on the scaling policies you define to adjust the number of instances. </span><span class="koboSpan" id="kobo.77.4">For example, you can add one server when CPU utilization exceeds 60% in the existing servers’ fleet but doesn’t spin up more than six servers.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.78.1"><img alt="A picture containing text, screenshot, number, font  Description automatically generated" src="../Images/B21336_02_03.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.79.1">Figure 2.3: Server Auto Scaling</span></p>
<p class="normal"><span class="koboSpan" id="kobo.80.1">Regardless </span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.81.1">of scaling being reactive or predictive, you need to monitor the application and collect data to plan for your scaling needs.</span></p>
<h2 class="heading-2" id="_idParaDest-50"><span class="koboSpan" id="kobo.82.1">Scaling static content</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.83.1">Static content, such</span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.84.1"> as images and videos, plays a crucial role in engaging users on your website. </span><span class="koboSpan" id="kobo.84.2">However, if not managed properly, these elements can significantly slow down your application’s performance. </span><span class="koboSpan" id="kobo.84.3">To maintain optimal speed and user experience, it’s essential to scale and distribute static content efficiently.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.85.1">Let’s take the example of an e-commerce website. </span><span class="koboSpan" id="kobo.85.2">Each product will likely have multiple images—and perhaps even videos—to show a product’s texture and demos, which means the website will have a significant amount of static content with a read-heavy workload since, most of the time, users will be browsing products. </span><span class="koboSpan" id="kobo.85.3">In addition, users may upload multiple images and videos for product review.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.86.1">Storing static content in a web server means consuming lots of storage space, and as product listings grow, you have to worry about storage scalability. </span><span class="koboSpan" id="kobo.86.2">The other problem is that static content requires large file sizes, which may cause significant load latency on the user’s end. </span><span class="koboSpan" id="kobo.86.3">The web</span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.87.1"> architectural tier must utilize the </span><strong class="keyWord"><span class="koboSpan" id="kobo.88.1">Content Distribution Network</span></strong><span class="koboSpan" id="kobo.89.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.90.1">CDN</span></strong><span class="koboSpan" id="kobo.91.1">) to solve this issue. </span><span class="koboSpan" id="kobo.91.2">CDNs help cache this content closer to the users, reducing latency and speeding up loading times. </span><span class="koboSpan" id="kobo.91.3">Properly scaling static content ensures that your application remains fast and responsive, providing a seamless experience for your users even as traffic volumes increase.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.92.1">CDN providers (such as Akamai, Amazon CloudFront, Microsoft Azure CDN, and Google CDN) provide locations across the globe where static content can be cached from the web server near the user’s location, reducing latency. </span><em class="chapterRef"><span class="koboSpan" id="kobo.93.1">Chapter 4</span></em><span class="koboSpan" id="kobo.94.1">, </span><em class="italic"><span class="koboSpan" id="kobo.95.1">Solution Architecture Design Patterns</span></em><span class="koboSpan" id="kobo.96.1">, will teach you more about caching.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.97.1">To scale static </span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.98.1">content storage, it is recommended to use object storage, such as Amazon S3, or an on-premises custom origin, which can grow independently of memory and computer capabilities. </span><span class="koboSpan" id="kobo.98.2">Additionally, scaling storage independently with popular object storage services saves on cost. </span><span class="koboSpan" id="kobo.98.3">These storage solutions can hold static HTML pages to reduce the load of web servers and enhance the user experience by reducing latency through the CDN.</span></p>
<h3 class="heading-3" id="_idParaDest-51"><span class="koboSpan" id="kobo.99.1">Session management for application server scaling</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.100.1">The</span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.101.1"> application architectural tier collects user requests from the web tier and performs the </span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.102.1">heavy lifting of calculating business logic and talking to the database. </span><span class="koboSpan" id="kobo.102.2">When user requests increase, the application tier needs to scale to handle them and then shrink back as demands decrease. </span><span class="koboSpan" id="kobo.102.3">In such scenarios, users are tied to the session, where, for example, they may browse from their mobile and purchase from their desktop. </span><span class="koboSpan" id="kobo.102.4">Performing horizontal scaling without handling user sessions may cause a bad user experience, as it will reset the user’s shopping progress.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.103.1">Here, the first step is to take care of user sessions by decoupling them from the application server instance, which means you should consider maintaining the user session in an independent layer, such as a NoSQL database where you can store semi-structured data.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.104.1">NoSQL databases are best suited for semi-structured data where data entries vary in their schema. </span><span class="koboSpan" id="kobo.104.2">For example, one user can enter their name and address while setting up a user profile. </span><span class="koboSpan" id="kobo.104.3">In contrast, another user can enter more attributes, such as phone number, gender, marital status, name, and address. </span><span class="koboSpan" id="kobo.104.4">As users have different attributes, NoSQL data can accommodate them and provide fast searches.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.105.1">NoSQL databases such as Amazon DynamoDB or MongoDB offer exceptional partitioning capabilities, enabling effortless horizontal scaling at levels that surpass the scalability of other database types.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.106.1">Once you start storing your user session in NoSQL databases, your instance can scale horizontally without impacting the user experience. </span><span class="koboSpan" id="kobo.106.2">You can add a load balancer in front of a fleet of application servers, which can distribute the load among instances; with the help of autoscaling, you can automate adding or removing instances on demand.</span></p>
<h3 class="heading-3" id="_idParaDest-52"><span class="koboSpan" id="kobo.107.1">Database scaling</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.108.1">Most </span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.109.1">applications use relational databases to store their transactional data. </span><span class="koboSpan" id="kobo.109.2">These have been around for decades and provide the robust transactional consistency required for many applications. </span><span class="koboSpan" id="kobo.109.3">However, the main</span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.110.1"> problem with relational databases is that they cannot scale horizontally until you plan for other techniques, such as sharding, and modify your application accordingly. </span><span class="koboSpan" id="kobo.110.2">This will be a lot of work.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.111.1">For databases, taking preventive care and reducing their load is better. </span><span class="koboSpan" id="kobo.111.2">Using a combination of storage methods, such as storing user sessions in separate NoSQL databases, storing static content in an object store, and applying an external cache, helps to offload the master database. </span><span class="koboSpan" id="kobo.111.3">It’s better to keep the master database node for writing and updating data and use an additional read replica for all read requests. </span><span class="koboSpan" id="kobo.111.4">For example, Amazon RDS for MySQL provides up to 15 read replicas for relational databases. </span><span class="koboSpan" id="kobo.111.5">Read replicas may have milliseconds of delay while syncing with the leader node, and you need to plan for that while designing your application. </span><span class="koboSpan" id="kobo.111.6">Using a caching engine such as Memcached or Redis is recommended to cache frequent queries and thus reduce the load on the leader node.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.112.1">If your database starts growing beyond its current capacity, you need to redesign and divide it into shards by applying partitions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.113.1">Each shard can grow independently, and the application needs to determine a partition key to store user data in a respective shard. </span><span class="koboSpan" id="kobo.113.2">For example, if the partition key is </span><code class="inlineCode"><span class="koboSpan" id="kobo.114.1">user_name</span></code><span class="koboSpan" id="kobo.115.1">, then usernames from </span><code class="inlineCode"><span class="koboSpan" id="kobo.116.1">A</span></code><span class="koboSpan" id="kobo.117.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.118.1">E</span></code><span class="koboSpan" id="kobo.119.1"> can be stored in one shard, names from </span><code class="inlineCode"><span class="koboSpan" id="kobo.120.1">F</span></code><span class="koboSpan" id="kobo.121.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.122.1">I</span></code><span class="koboSpan" id="kobo.123.1"> can be stored in a second shard, and so on. </span><span class="koboSpan" id="kobo.123.2">The application needs to direct user records to the correct partition per their name’s first letter.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.124.1">So, as you can see, scalability is a significant factor while designing a solution architecture, and it can impact the overall project budget and user experience significantly if it’s not planned correctly. </span><span class="koboSpan" id="kobo.124.2">A solutions architect always needs to consider elasticity while designing applications and optimizing workloads for the best performance and least cost.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.125.1">A solutions architect needs to evaluate different options, such as CDNs for static content scaling and load balancing, autoscaling options for server scaling, and various data storage options for caching, object stores, NoSQL stores, read replicas, and sharding.</span></p>
<h3 class="heading-3" id="_idParaDest-53"><span class="koboSpan" id="kobo.126.1">Building elastic architecture</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.127.1">While focusing on</span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.128.1"> scalability to enhance application performance, it is crucial to construct a cost-aware architectural design. </span><span class="koboSpan" id="kobo.128.2">This implies that as you expand your server infrastructure to meet rising user demand, the system should also contract when the server load diminishes. </span><span class="koboSpan" id="kobo.128.3">Elasticity is required to right-size your architecture, which involves scaling your server infrastructure to match the current demand accurately. </span><span class="koboSpan" id="kobo.128.4">It’s a balancing act between ensuring there’s enough capacity to handle peak loads efficiently without over-provisioning resources that would lie idle during off-peak times.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.129.1">Let’s continue </span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.130.1">with the e-commerce website example by considering a modern three-tier architecture and see how we can achieve elasticity at a different Application Layer. </span><span class="koboSpan" id="kobo.130.2">Here, we only target the elasticity and scalability aspects of architecture design. </span><em class="italic"><span class="koboSpan" id="kobo.131.1">Figure 2.4</span></em><span class="koboSpan" id="kobo.132.1"> shows a three-tier architecture diagram of the AWS cloud tech stack:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.133.1"><img alt="" role="presentation" src="../Images/B21336_02_04.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.134.1">Figure 2.4: Scaling three-tier architecture</span></p>
<p class="normal"><span class="koboSpan" id="kobo.135.1">This diagram depicts a three-tier architecture designed for elasticity and high availability, focusing on building an elastic server fleet to manage variable loads efficiently.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.136.1">The following are the </span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.137.1">architectural components:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.138.1">Elastic Load Balancing </span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.139.1">automatically distributes incoming application traffic across multiple targets, such as Amazon </span><strong class="keyWord"><span class="koboSpan" id="kobo.140.1">Elastic Compute Cloud</span></strong><span class="koboSpan" id="kobo.141.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.142.1">EC2</span></strong><span class="koboSpan" id="kobo.143.1">) instances, containers, IP addresses, etc., in multiple Availability Zones. </span><span class="koboSpan" id="kobo.143.2">This increases the </span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.144.1">fault tolerance of the e-commerce application.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.145.1">The web layer consists of an Auto scaling group of EC2 instances designed to serve the application’s dynamic content. </span><span class="koboSpan" id="kobo.145.2">This fleet can automatically scale out (add instances) or scale in (remove instances) based on defined criteria like CPU utilization, ensuring that the fleet can adapt to the incoming traffic and maintain consistent performance.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.146.1">The Application Layer also has an autoscaling group of EC2 instances responsible for executing the business logic of the application. </span><span class="koboSpan" id="kobo.146.2">Like the web layer, this layer can dynamically adjust its size to meet the demands of the application workload.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.147.1">At the bottom, the</span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.148.1"> Database Layer includes Amazon </span><strong class="keyWord"><span class="koboSpan" id="kobo.149.1">Relational Database System</span></strong><span class="koboSpan" id="kobo.150.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.151.1">RDS</span></strong><span class="koboSpan" id="kobo.152.1">) instances, which provide managed relational databases. </span><span class="koboSpan" id="kobo.152.2">The setup includes a primary DB instance and a read replica to handle read-heavy operations, improving performance and reducing load on the primary instance. </span><span class="koboSpan" id="kobo.152.3">There is also a standby instance in a different Availability Zone for high availability and failover support.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.153.1">This architecture allows for a flexible, scalable application environment that can handle variable workloads with high availability across multiple zones. </span><span class="koboSpan" id="kobo.153.2">It’s designed to expand and contract automatically in response to the application’s needs, ensuring users experience consistent, responsive performance.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.154.1">When users access and interact to the application using website or mobile application. </span><span class="koboSpan" id="kobo.154.2">Their requests are routed through Amazon Route 53, which is a highly available and </span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.155.1">scalable </span><strong class="keyWord"><span class="koboSpan" id="kobo.156.1">Domain Name System</span></strong><span class="koboSpan" id="kobo.157.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.158.1">DNS</span></strong><span class="koboSpan" id="kobo.159.1">) web service. </span><span class="koboSpan" id="kobo.159.2">Amazon CloudFront, a CDN, is used to distribute static content like images, stylesheets, and JavaScript files efficiently. </span><span class="koboSpan" id="kobo.159.3">This reduces the load on the web servers and improves the user experience by decreasing latency.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.160.1">In this section, you have discovered the various scaling methods and how to inject elasticity into the different layers of your architecture. </span><span class="koboSpan" id="kobo.160.2">Scalability is an essential factor in ensuring that there is high application availability to make your application resilient. </span><span class="koboSpan" id="kobo.160.3">We will learn more about high availability and resiliency in the next section.</span></p>
<h1 class="heading-1" id="_idParaDest-54"><span class="koboSpan" id="kobo.161.1">Building a highly available and resilient architecture</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.162.1">Creating a highly available and resilient architecture involves designing systems that can tolerate failures of individual components without disrupting the overall system functionality.</span></p>
<h2 class="heading-2" id="_idParaDest-55"><span class="koboSpan" id="kobo.163.1">Highly available architecture</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.164.1">The one thing an </span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.165.1">organization wants to avoid is </span><em class="italic"><span class="koboSpan" id="kobo.166.1">downtime</span></em><span class="koboSpan" id="kobo.167.1">. </span><span class="koboSpan" id="kobo.167.2">Application downtime can cause a loss of business and user trust, making </span><strong class="keyWord"><span class="koboSpan" id="kobo.168.1">high availability</span></strong><span class="koboSpan" id="kobo.169.1"> a </span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.170.1">primary factor while designing the solution architecture. </span><span class="koboSpan" id="kobo.170.2">The principle of high availability is “design for failure, and nothing will fail.”</span></p>
<p class="normal"><span class="koboSpan" id="kobo.171.1">The requirement for application uptime varies from application to application. </span><span class="koboSpan" id="kobo.171.2">If you have an external-facing application with a large user base, such as an e-commerce website or social media platform, 100% uptime becomes critical. </span><span class="koboSpan" id="kobo.171.3">In the case of an internal application (accessed by an employee, such as an HR system or a company intranet), it can likely tolerate some downtime. </span><span class="koboSpan" id="kobo.171.4">Achieving high availability is directly associated with cost, so a solutions architect must always plan for high availability per the application requirements to avoid over-architecting.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.172.1">To achieve a high-availability architecture, it is better to plan workloads in an isolated physical location so that, should an outage occur in one place, your application replica can operate from another location. </span><span class="koboSpan" id="kobo.172.2">The high-availability architecture goes hand in hand with self-healing, where you can ensure your application is up and running, but you also need a quick recovery to maintain the desired user experience.</span></p>
<h2 class="heading-2" id="_idParaDest-56"><span class="koboSpan" id="kobo.173.1">Resilient architecture</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.174.1">A </span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.175.1">resilient architecture means your application should be available for customers while recovering from failure. </span><span class="koboSpan" id="kobo.175.2">Making your architecture resilient includes applying </span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.176.1">best practices to recover your application from increased loads due to more user requests, malicious attacks, and architectural component failure. </span><span class="koboSpan" id="kobo.176.2">Resiliency needs to be used in all architectural layers, including infrastructure, application, database, security, and networking. </span><span class="koboSpan" id="kobo.176.3">A resilient architecture should recover from failure within a desired amount of time.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.177.1">To make your architecture resilient, you need to define the time of recovery and address the following points:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.178.1">Identify and implement redundant architectural components wherever required.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.179.1">Understand when to fix versus when to replace architectural components. </span><span class="koboSpan" id="kobo.179.2">For example, fixing a server issue might take longer than replacing it with the same machine image.</span></li>
</ul>
<h2 class="heading-2" id="_idParaDest-57"><span class="koboSpan" id="kobo.180.1">Achieving redundancy</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.181.1">Redundancy </span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.182.1">is a crucial aspect of building resilient systems. </span><span class="koboSpan" id="kobo.182.2">Building a resilient architecture requires a multi-layered redundancy strategy. </span><span class="koboSpan" id="kobo.182.3">It involves deploying server clusters across different racks within a single data center, extending to multiple data centers within the same region, and further, across various geographic regions. </span><span class="koboSpan" id="kobo.182.4">This geographical distribution ensures protection against localized and regional disasters and reduces latency for a global user base.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.183.1">Incorporating</span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.184.1"> intelligent load balancing and global traffic management, such as DNS-based routing with health checks, ensures that users are always served from the optimal location. </span><span class="koboSpan" id="kobo.184.2">Database resiliency is achieved through strategic replication, with automated failover mechanisms to maintain database availability and integrity.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.185.1">If servers are spread across different physical locations, the first level of traffic routing can be handled using the DNS server before it reaches the load balancer. </span><span class="koboSpan" id="kobo.185.2">This way, in the case of an entire region failure, your application can still run.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.186.1"><img alt="" role="presentation" src="../Images/B21336_02_05.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.187.1">Figure 2.5: Application architecture resiliency using a DNS server</span></p>
<p class="normal"><span class="koboSpan" id="kobo.188.1">As you can </span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.189.1">see in the preceding architecture, resiliency must be applied in all the critical layers that affect the application’s availability in order to implement a design that can sustain failure. </span><span class="koboSpan" id="kobo.189.2">To achieve resiliency, in addition to using a DNS server to route traffic between different physical locations, the following best practices need to be applied to create a redundant environment:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.190.1">Use the CDN to distribute and cache static content such as videos, images, and static web pages near the user’s location so that your application will still be available.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.191.1">Once traffic reaches a region, use a load balancer to route traffic to a fleet of servers so that your application can still run even if one location fails within your region.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.192.1">Use autoscaling to add or remove servers based on user demand. </span><span class="koboSpan" id="kobo.192.2">As a result, your application should not be impacted by individual server failures.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.193.1">Create a standby database to ensure the high availability of the database, meaning that your application should be available in the event of a database failure.</span></li>
</ul>
<h2 class="heading-2" id="_idParaDest-58"><span class="koboSpan" id="kobo.194.1">Addressing component failure</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.195.1">If any </span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.196.1">components fail, you should have a backup to recover them and achieve architecture resiliency. </span><span class="koboSpan" id="kobo.196.2">The load balancer and routers at the DNS server perform a health check to ensure that the traffic is only routed to healthy application instances. </span><span class="koboSpan" id="kobo.196.3">You can configure this to perform a shallow health check, which monitors local host failures, or a deep health check, which can also take care of dependency failure. </span><span class="koboSpan" id="kobo.196.4">However, a deep health check takes more time and is more resource-intensive than a shallow health check. </span><span class="koboSpan" id="kobo.196.5">You will learn more about resilient architecture in </span><em class="chapterRef"><span class="koboSpan" id="kobo.197.1">Chapter 8</span></em><span class="koboSpan" id="kobo.198.1">, </span><em class="italic"><span class="koboSpan" id="kobo.199.1">Architectural Reliability Considerations</span></em><span class="koboSpan" id="kobo.200.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.201.1">At the application level, it is essential to </span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.202.1">avoid </span><strong class="keyWord"><span class="koboSpan" id="kobo.203.1">cascade failure</span></strong><span class="koboSpan" id="kobo.204.1">, where the failure of one component can bring down the entire system. </span><span class="koboSpan" id="kobo.204.2">To mitigate the risk of cascading failures in a system, various mechanisms can be employed:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.205.1">Timeouts</span></strong><span class="koboSpan" id="kobo.206.1">: Setting </span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.207.1">a maximum time limit for operations and requests can prevent waiting indefinitely for a response, which can lead to resource exhaustion.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.208.1">Traffic rejection</span></strong><span class="koboSpan" id="kobo.209.1">: When</span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.210.1"> the system is overwhelmed, it can proactively reject new requests to prevent overload and maintain stability for existing processes.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.211.1">Idempotent operations</span></strong><span class="koboSpan" id="kobo.212.1">: Ensuring </span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.213.1">that operations can be repeated without causing unintended effects can help recover from intermediate failures without duplicating actions or causing inconsistencies.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.214.1">Circuit breakers</span></strong><span class="koboSpan" id="kobo.215.1">: Implementing </span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.216.1">a circuit breaker pattern can detect failure patterns and open the “circuit” to stop further requests to a failing service, allowing it to recover and preventing the failure from spreading to other parts of the system.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.217.1">By incorporating these strategies, systems can become more resilient, maintaining functionality in the face of individual component failures and preventing those failures from escalating into widespread system outages.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.218.1">While high availability and resiliency ensure your system is up and available for users, it is also essential to maintain performance where fault tolerance comes into play. </span><span class="koboSpan" id="kobo.218.2">Let us now turn to the subject of fault tolerance.</span></p>
<h1 class="heading-1" id="_idParaDest-59"><span class="koboSpan" id="kobo.219.1">Making your architecture fault-tolerant </span></h1>
<p class="normal"><span class="koboSpan" id="kobo.220.1">High availability</span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.221.1"> means your application is available to the user but it can result in degraded performance. </span><span class="koboSpan" id="kobo.221.2">Suppose you need four servers to handle users’ traffic. </span><span class="koboSpan" id="kobo.221.3">For this, you put two servers in two different physically isolated data centers. </span><span class="koboSpan" id="kobo.221.4">If there is an outage in one data center, user traffic can be served from another. </span><span class="koboSpan" id="kobo.221.5">But now you have only two servers, which means only 50% of the original capacity is available, and users may experience performance issues. </span><span class="koboSpan" id="kobo.221.6">In this scenario, your application has 100% high availability but is only 50% fault tolerant.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.222.1">As shown in </span><em class="italic"><span class="koboSpan" id="kobo.223.1">Figure 2.6</span></em><span class="koboSpan" id="kobo.224.1">, to achieve 100% fault tolerance, you need full redundancy and have to maintain the double count of the servers so that the user doesn’t encounter any performance issues during the outage of one zone.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.225.1"><img alt="" role="presentation" src="../Images/B21336_02_06.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.226.1">Figure 2.6: Fault tolerance architecture</span></p>
<p class="normal"><span class="koboSpan" id="kobo.227.1">Fault tolerance is handling workload capacity if an outage occurs without compromising system performance. </span><span class="koboSpan" id="kobo.227.2">A fully fault-tolerant architecture involves high costs due to increased redundancy. </span><span class="koboSpan" id="kobo.227.3">Whether your user base can live with degraded performance for the period of application recovery depends on your application’s criticality.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.228.1">While designing </span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.229.1">the application architecture, a solutions architect needs to determine the nature of the application’s users and whether a fault tolerance of 100% is required, which will inevitably come with a cost implication. </span><span class="koboSpan" id="kobo.229.2">For example, an e-commerce website may need 100% fault tolerance, as degraded performance directly impacts business revenue. </span><span class="koboSpan" id="kobo.229.3">At the same time, an internal payroll system, which employees use at the end of the month to check their salary slips, can tolerate reducing performance for a short period. </span><span class="koboSpan" id="kobo.229.4">Let’s dive deep into building high-performance architecture next.</span></p>
<h1 class="heading-1" id="_idParaDest-60"><span class="koboSpan" id="kobo.230.1">Designing for performance</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.231.1">With</span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.232.1"> the availability of fast internet, customers are seeking high-performance applications with minimal load time. </span><span class="koboSpan" id="kobo.232.2">Organizations have noticed that a direct revenue impact is proportional to application performance, and slowness in application load time can significantly impact customer engagement. </span><span class="koboSpan" id="kobo.232.3">Modern companies are setting high expectations when it comes to performance, resulting in high-performance applications becoming necessary to stay relevant in the market.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.233.1">Like resiliency, the solutions architect needs to consider performance at every layer of architecture design. </span><span class="koboSpan" id="kobo.233.2">The DevOps team needs to put monitoring in place to check that the solution continues to perform effectively and work to improve it continuously. </span><span class="koboSpan" id="kobo.233.3">Better performance means increased user engagement and return on investment.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.234.1">High-performance applications are designed to handle application slowness due to external factors such as a slow internet connection. </span><span class="koboSpan" id="kobo.234.2">For example, you may have designed your blog web page to load within 500 milliseconds where there is good internet availability. </span><span class="koboSpan" id="kobo.234.3">However, where the internet is slow, you can have it load text first and engage the user with this content while images and videos are still loading.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.235.1">In an ideal environment, as your application workload increases, automated scaling mechanisms start handling additional requests without impacting application performance. </span><span class="koboSpan" id="kobo.235.2">But in the real world, your application latency goes down for a short duration when scaling takes effect. </span><span class="koboSpan" id="kobo.235.3">To understand how it will behave in a real-world situation, it’s better to test your application for performance by increasing the load and understanding whether you can achieve the desired concurrency and user experience.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.236.1">You need to</span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.237.1"> choose the right kind of server at the server level, depending on your workload. </span><span class="koboSpan" id="kobo.237.2">For example, choose the right amount of memory and compute to handle the workload, as memory congestion can slow down application performance and, eventually, the server may crash. </span><span class="koboSpan" id="kobo.237.3">You should choose the correct </span><strong class="keyWord"><span class="koboSpan" id="kobo.238.1">input/output operations per second</span></strong><span class="koboSpan" id="kobo.239.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.240.1">IOPS</span></strong><span class="koboSpan" id="kobo.241.1">) for storage. </span><span class="koboSpan" id="kobo.241.2">You need high IOPS for write-intensive applications to reduce latency and increase disk write speed.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.242.1">IOPS is a performance measurement used to benchmark the speed at which storage devices like hard drives, solid-state drives, and storage area networks can read and write data. </span><span class="koboSpan" id="kobo.242.2">Each input or output operation could be a data read or a data write.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.243.1">To achieve higher performance, apply caching at every layer of your architecture design. </span><span class="koboSpan" id="kobo.243.2">Caching makes your data locally available to users or keeps data in memory to serve an ultra-fast response.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.244.1">The following are considerations for adding caching to various layers of your application design:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.245.1">Use the browser cache on the user’s system to load frequently requested web pages.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.246.1">Use the DNS cache for quick website lookup.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.247.1">Use the CDN cache for high-resolution images and videos that are near the user’s location.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.248.1">At the server level, maximize the memory cache to serve user requests.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.249.1">Use cache engines such as Redis and Memcached to serve frequent queries from the caching engine.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.250.1">Use the database cache to serve frequent queries from memory.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.251.1">Take care of cache expiration, which is the process by which data stored in the cache becomes outdated and is marked for update or removal. </span><span class="koboSpan" id="kobo.251.2">Cache eviction, on the other hand, is the process by which data is removed from the cache, typically to make room for new data. </span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.252.1">As you can see, keeping your application performant is an essential design aspect and is directly related to organizational profitability. </span><span class="koboSpan" id="kobo.252.2">The solutions architect needs to think about performance when creating a solution design and should work relentlessly to keep improving the performance of the application. </span><span class="koboSpan" id="kobo.252.3">In </span><em class="chapterRef"><span class="koboSpan" id="kobo.253.1">Chapter 6</span></em><span class="koboSpan" id="kobo.254.1">, </span><em class="italic"><span class="koboSpan" id="kobo.255.1">Performance Considerations</span></em><span class="koboSpan" id="kobo.256.1">, you will dive deeper into this and learn techniques to optimize your application for better performance.</span></p>
<h1 class="heading-1" id="_idParaDest-61"><span class="koboSpan" id="kobo.257.1">Creating immutable architecture</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.258.1">Organizations</span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.259.1"> make a significant capital investment in hardware and develop the practice of regularly refreshing it with a new version of the application and configuration. </span><span class="koboSpan" id="kobo.259.2">Over time, this can lead to different servers running in varied configurations, and troubleshooting them becomes tedious. </span><span class="koboSpan" id="kobo.259.3">Sometimes organizations must keep running unnecessary resources when they are not needed, as they are unsure which server to shut down, which may cause application failure. </span><span class="koboSpan" id="kobo.259.4">The inability to replace servers makes rolling out and testing any new updates in your server fleet challenging. </span><span class="koboSpan" id="kobo.259.5">These problems can be solved by treating your server as a replaceable resource, which enables you to move more quickly to accommodate changes, such as upgrading applications and underlying software, resulting in less downtime and fixing application issues quickly. </span><span class="koboSpan" id="kobo.259.6">That is why, while designing your application, you should always think of immutable infrastructure. </span><span class="koboSpan" id="kobo.259.7">This means that, during application upgrades, you will not only replace software but hardware, too.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.260.1">Adopting a mindset where servers are treated like cattle, not pets, is fundamental in modern cloud architecture. </span><span class="koboSpan" id="kobo.260.2">This approach means that individual servers are not meticulously maintained or customized to the point where they become irreplaceable. </span><span class="koboSpan" id="kobo.260.3">Instead, servers are designed to be provisioned quickly, managed consistently, and disposed of or replaced without significant impact on the overall system. </span><span class="koboSpan" id="kobo.260.4">This methodology enhances scalability and resiliency, as it allows for rapid adaptation to changes in demand or recovery from failures.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.261.1">To create replaceable servers, making your application stateless to retain user experience and avoiding the hardcoding of any server IP or database DNS name is advisable to avoid failures during replacement. </span><span class="koboSpan" id="kobo.261.2">You need to apply the idea of treating your infrastructure as code instead of hardware, and not apply updates to the live system.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.262.1">Creating immutable infrastructure becomes more viable with a virtual machine. </span><span class="koboSpan" id="kobo.262.2">You can create a golden image of your virtual machine and deploy it with the new version of your infrastructure rather than trying to update an existing version. </span><span class="koboSpan" id="kobo.262.3">You should always spin up new server instances from the golden machine image, which acts as a template and has all the necessary security and software in place. </span><span class="koboSpan" id="kobo.262.4">This deployment strategy is also beneficial for server troubleshooting, where you can dispose of the server with an issue and spin up a new server from a golden image.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.263.1">You should</span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.264.1"> take a backup of logs for root cause analysis before disposing of the server with issues. </span><span class="koboSpan" id="kobo.264.2">This approach also ensures consistency across the environment, as you use the same baseline server image to create all your environments.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.265.1">Loose coupling is another critical design principle that complements the “cattle not pets” approach. </span><span class="koboSpan" id="kobo.265.2">It involves designing system components so they interact with each other through well-defined interfaces and are independent enough that changes in one component do not necessitate changes in others. </span><span class="koboSpan" id="kobo.265.3">This separation enhances flexibility and scalability, allowing individual components to evolve, scale, or recover from failures independently. </span><span class="koboSpan" id="kobo.265.4">Let’s learn more about loose coupling.</span></p>
<h1 class="heading-1" id="_idParaDest-62"><span class="koboSpan" id="kobo.266.1">Think loose coupling</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.267.1">A traditional </span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.268.1">application is deployed on a tightly integrated server fleet where each server has a specific responsibility. </span><span class="koboSpan" id="kobo.268.2">Often, applications depend on multiple servers for completeness of functionality.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.269.1">As shown in the following diagram, in a tightly coupled architecture, the web server fleet has a direct dependency on all application servers, and vice versa:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.270.1"><img alt="" role="presentation" src="../Images/B21336_02_07.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.271.1">Figure 2.7: Tightly coupled architecture</span></p>
<p class="normal"><span class="koboSpan" id="kobo.272.1">In the </span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.273.1">preceding architecture diagram, if one application server goes down, then all web servers will start receiving errors, as the request will route to an unhealthy application server, which may cause a complete system failure. </span><span class="koboSpan" id="kobo.273.2">With tightly coupled architecture, if you want to scale by adding and removing servers, it requires lots of work, as all connections need to be set up appropriately.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.274.1">With loose coupling, you can add an intermediate layer, such as a load balancer or a queue, which automatically handles failures or scaling for you.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.275.1">In the following architecture diagram, there is a load balancer between the web server and the application server fleet, which makes sure that user requests are always served from a healthy application server:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.276.1"><img alt="" role="presentation" src="../Images/B21336_02_08.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.277.1">Figure 2.8: Load balancer-based, loosely coupled architecture</span></p>
<p class="normal"><span class="koboSpan" id="kobo.278.1">If one of the </span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.279.1">application servers goes down, the load balancer will automatically start directing all the traffic to the other three healthy servers. </span><span class="koboSpan" id="kobo.279.2">Loosely coupled architecture also helps you to scale your servers independently and replace unhealthy instances gracefully. </span><span class="koboSpan" id="kobo.279.3">It makes your application more fault-tolerant as an error radius is limited to a single instance only.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.280.1">Loosely coupled architecture can also be queue-based; take the example of an image-processing website, where you need to store an image and then process it for encoding, thumbnails, and copyright. </span><span class="koboSpan" id="kobo.280.2">The following architecture diagram has queue-based decoupling. </span><span class="koboSpan" id="kobo.280.3">With this, loose coupling of systems is achieved by using queues between systems and exchanging messages that transfer jobs through these.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.281.1"><img alt="A picture containing screenshot, text, diagram, line  Description automatically generated" src="../Images/B21336_02_09.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.282.1">Figure 2.9: Queue-based, loosely coupled architecture</span></p>
<p class="normal"><span class="koboSpan" id="kobo.283.1">Queue-based decoupling enables the asynchronous linking of systems, where one server is not waiting for a response from another server and is working independently. </span><span class="koboSpan" id="kobo.283.2">This method </span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.284.1">lets you increase the number of virtual servers that receive and process the messages in parallel. </span><span class="koboSpan" id="kobo.284.2">You can configure autoscaling to terminate the excess servers if, for example, there is no image to process.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.285.1">In a complex system, a loosely coupled architecture is achieved by creating a microservice architecture where independent services contain a complete set of functionalities and communicate with each other over a standard protocol. </span><span class="koboSpan" id="kobo.285.2">In modern design, event-driven design like this is becoming highly popular, facilitating the decoupling of an application component. </span><span class="koboSpan" id="kobo.285.3">The loosely coupled design has many benefits, from scalability and high availability to ease of integration.</span></p>
<h1 class="heading-1" id="_idParaDest-63"><span class="koboSpan" id="kobo.286.1">Think service, not server</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.287.1">In the </span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.288.1">previous section, you learned about loose coupling and how important it is for our architecture to be loosely coupled for scalability and fault tolerance. </span><span class="koboSpan" id="kobo.288.2">Developing service-oriented thinking will help to achieve a loosely coupled architecture (as opposed to server-oriented thinking, which can lead to hardware dependency and a tightly coupled architecture). </span><span class="koboSpan" id="kobo.288.3">Microservice-based event-driven architecture helps us to achieve ease of deployment and maintenance for our solution design.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.289.1">In a RESTful architecture, you can format a message in XML, JSON, or plain text and send it over Internet using a simple HTTP protocol. </span><span class="koboSpan" id="kobo.289.2">RESTful architecture is popular as it is very lightweight. </span><span class="koboSpan" id="kobo.289.3">Microservices are based on RESTful architecture and are independently scalable, which makes it easier to expand or shrink one component of your application without impacting others.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.290.1">As you can see in the following diagram, in a monolithic architecture, all components are built into a single service, thus deployed in a single server and tied up with a single database, which creates a hard dependency. </span><span class="koboSpan" id="kobo.290.2">In contrast, in a microservice architecture, each component is independent, with its framework and database, which allows them to be scaled independently:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.291.1"><img alt="A picture containing text, screenshot, diagram, circle  Description automatically generated" src="../Images/B21336_02_10.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.292.1">Figure 2.10: Monolithic and microservice architectures</span></p>
<p class="normal"><span class="koboSpan" id="kobo.293.1">In the </span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.294.1">preceding diagram, you can see an example of an e-commerce website as both a monolithic architecture and a microservice architecture, where customers can log in and place an order, assuming the items they want are available, by adding items to the cart. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.295.1">To convert a monolithic architecture in to a microservice-based architecture, you can create applications made of small, independent components, which constitute smaller parts to iterate.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.296.1">The </span><em class="italic"><span class="koboSpan" id="kobo.297.1">modularization approach</span></em><span class="koboSpan" id="kobo.298.1"> reduces the </span><em class="italic"><span class="koboSpan" id="kobo.299.1">cost</span></em><span class="koboSpan" id="kobo.300.1">, </span><em class="italic"><span class="koboSpan" id="kobo.301.1">size</span></em><span class="koboSpan" id="kobo.302.1">, </span><em class="italic"><span class="koboSpan" id="kobo.303.1">and risk of change</span></em><span class="koboSpan" id="kobo.304.1">. </span><span class="koboSpan" id="kobo.304.2">In the preceding case, each component is created as a service. </span><span class="koboSpan" id="kobo.304.3">Here, the </span><strong class="screenText"><span class="koboSpan" id="kobo.305.1">Login </span></strong><span class="koboSpan" id="kobo.306.1">service can independently scale to handle more traffic, as the customer may log in frequently to explore the product catalog and order status. </span><span class="koboSpan" id="kobo.306.2">In comparison, the </span><strong class="screenText"><span class="koboSpan" id="kobo.307.1">Order</span></strong><span class="koboSpan" id="kobo.308.1"> and </span><strong class="screenText"><span class="koboSpan" id="kobo.309.1">Cart</span></strong><span class="koboSpan" id="kobo.310.1"> services may have less traffic, as a customer may not place an order very often.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.311.1">Solutions architects need to think of microservices while designing a solution. </span><span class="koboSpan" id="kobo.311.2">The clear advantage of services is that you have a smaller surface area of code to maintain, and services are self-contained. </span><span class="koboSpan" id="kobo.311.3">However, monitoring microservices involves a more granular approach compared to traditional monolithic applications due to the distributed nature of microservices. </span><span class="koboSpan" id="kobo.311.4">Each microservice functions independently, which means monitoring must be implemented at the individual service level as well as the system level to ensure a comprehensive view of the application’s health and performance.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.312.1">You can build </span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.313.1">microservices with no external dependencies. </span><span class="koboSpan" id="kobo.313.2">All prerequisites are included in the service, which enables loose coupling and scaling, and reduces the blast radius in case of failure.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.314.1">Any application design revolves around data, and working backward from data helps to build the best architecture. </span><span class="koboSpan" id="kobo.314.2">Let’s learn more about data-driven design.</span></p>
<h1 class="heading-1" id="_idParaDest-64"><span class="koboSpan" id="kobo.315.1">Think data-driven design</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.316.1">Any</span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.317.1"> software solution revolves around the collection and management of data. </span><span class="koboSpan" id="kobo.317.2">Take the example of an e-commerce website; the software application is built to showcase product data on the website and encourage the customers to buy the products. </span><span class="koboSpan" id="kobo.317.3">It starts by collecting customer data when they create a login, adding a payment method, storing order transactions, and maintaining inventory data as the product gets sold. </span><span class="koboSpan" id="kobo.317.4">Another example is a banking application, which stores customer financial information and handles all financial transaction data with integrity and consistency. </span><span class="koboSpan" id="kobo.317.5">The most important thing for any application is handling, storing, and securing data appropriately. </span><span class="koboSpan" id="kobo.317.6">Data heavily influences solution design, and by keeping data in mind, you can apply the right design-driven solution for your needs. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.318.1">It’s not just application design that revolves around data but operational maintenance and business decisions, too. </span><span class="koboSpan" id="kobo.318.2">You need to add monitoring capabilities to ensure that your application and your business are running without any issues. </span><span class="koboSpan" id="kobo.318.3">For example, for application monitoring, you collect log data from the server and create a dashboard to visualize the metrics. </span><span class="koboSpan" id="kobo.318.4">Continuous data monitoring and sending alerts in the case of issues help you to recover quickly from failure by triggering the auto-healing mechanism.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.319.1">As a solutions architect, you are thinking about application design and the overall business value proposition, including ways to collect data and utilize it around the application, which can help to increase customer satisfaction and maximize the return on your investment. </span><span class="koboSpan" id="kobo.319.2">Data is gold, and getting insights into data can significantly impact an organization’s profitability.</span></p>
<h1 class="heading-1" id="_idParaDest-65"><span class="koboSpan" id="kobo.320.1">Adding security everywhere</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.321.1">Security is </span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.322.1">one of the essential aspects of solution design; any gap in security can have a devastating effect on a business or organization’s future. </span><span class="koboSpan" id="kobo.322.2">Many organizations are compromised by security breaches, resulting in a loss of customer trust and damaging businesses’ reputations. </span><span class="koboSpan" id="kobo.322.3">Industry-standard regulations, such as </span><strong class="keyWord"><span class="koboSpan" id="kobo.323.1">PCI</span></strong><span class="koboSpan" id="kobo.324.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.325.1">Payment Card Industry</span></strong><span class="koboSpan" id="kobo.326.1">), </span><strong class="keyWord"><span class="koboSpan" id="kobo.327.1">HIPAA</span></strong><span class="koboSpan" id="kobo.328.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.329.1">Health Insurance Portability and Accountability Act</span></strong><span class="koboSpan" id="kobo.330.1">), </span><strong class="keyWord"><span class="koboSpan" id="kobo.331.1">GDPR</span></strong><span class="koboSpan" id="kobo.332.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.333.1">General Data Protection Regulation</span></strong><span class="koboSpan" id="kobo.334.1">), and </span><strong class="keyWord"><span class="koboSpan" id="kobo.335.1">SOC</span></strong><span class="koboSpan" id="kobo.336.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.337.1">System and Organization Controls</span></strong><span class="koboSpan" id="kobo.338.1">) compliance are pivotal frameworks securing data across distinct domains. </span><span class="koboSpan" id="kobo.338.2">PCI secures credit card information in finance, HIPAA safeguards patient data in healthcare, GDPR enhances data privacy in the EU, and SOC ensures data management security in service organizations, enforce security safeguards to protect consumer data while providing standard guidance to the organization. </span><span class="koboSpan" id="kobo.338.3">Depending on your industry and region, you must comply with local legislation by adhering to compliance needs such as these.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.339.1">Security can</span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.340.1"> significantly impact solution design, so you need to understand your security needs before starting your design. </span><span class="koboSpan" id="kobo.340.2">Security needs to be included in platform readiness at the hardware level and in application development at the software level.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.341.1">The following</span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.342.1"> are the security aspects that need to be considered during the design phase:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.343.1">Physical security of data center</span></strong><span class="koboSpan" id="kobo.344.1">: All IT resources in data centers should be secure from unauthorized access.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.345.1">Network security</span></strong><span class="koboSpan" id="kobo.346.1">: The network should be secure to prevent any unauthorized server access.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.347.1">Identity and Access Management</span></strong><span class="koboSpan" id="kobo.348.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.349.1">IAM</span></strong><span class="koboSpan" id="kobo.350.1">): Only authenticated users should have access to the application, and they can do the activity as per their authorization.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.351.1">Data security in transit</span></strong><span class="koboSpan" id="kobo.352.1">: Data should be secure while traveling over the network or the internet.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.353.1">Data security at rest</span></strong><span class="koboSpan" id="kobo.354.1">: Data should be secure while stored in the database or any other storage.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.355.1">Security monitoring</span></strong><span class="koboSpan" id="kobo.356.1">: Any security incident should be captured, and the team should be alerted to act.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.357.1">Application design needs to balance security requirements, such as encryption, and other factors, such as performance and latency. </span><span class="koboSpan" id="kobo.357.2">Data encryption always has a performance impact as it adds a layer of additional processing because data needs to be decrypted to be utilized. </span><span class="koboSpan" id="kobo.357.3">Your application needs to accommodate the overhead of additional encryption processing without impacting overall performance, so consider use cases where encryption is required while designing your application. </span><span class="koboSpan" id="kobo.357.4">For example, if the data is confidential, you need to encrypt it.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.358.1">The other </span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.359.1">aspect of application design to consider related to security is regulatory compliance for adherence to local law. </span><span class="koboSpan" id="kobo.359.2">Compliance is essential if your application belongs to a regulated industry such as healthcare, finance, or the federal government. </span><span class="koboSpan" id="kobo.359.3">Each type of compliance has its requirements, which commonly include data protection and recording each activity for audit purposes. </span><span class="koboSpan" id="kobo.359.4">Your application design should include comprehensive logging and monitoring, which will fulfill the audit requirement.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.360.1">Security is one</span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.361.1"> of the most important aspects of application resiliency. </span><span class="koboSpan" id="kobo.361.2">From a security perspective, a </span><strong class="keyWord"><span class="koboSpan" id="kobo.362.1">Distributed Denial of Service</span></strong><span class="koboSpan" id="kobo.363.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.364.1">DDoS</span></strong><span class="koboSpan" id="kobo.365.1">) attack can potentially impact the availability of services and applications. </span><span class="koboSpan" id="kobo.365.2">A DDoS attack usually puts fake traffic in your server and makes it busy, meaning legitimate users cannot access your application. </span><span class="koboSpan" id="kobo.365.3">This can happen at the network layer or the Application Layer. </span><span class="koboSpan" id="kobo.365.4">It’s essential to take a proactive approach to prevent DDoS attacks. </span><span class="koboSpan" id="kobo.365.5">Keep as much of the application workload as possible in the private network and avoid exposing your application endpoints to the internet wherever possible.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.366.1">Security automation is another factor you should consistently implement along with your design to reduce and mitigate any security incidents. </span><span class="koboSpan" id="kobo.366.2">Automation in security involves utilizing technology to perform security tasks without human intervention, streamlining the detection, analysis, and remediation of security incidents. </span><span class="koboSpan" id="kobo.366.3">By integrating automated security measures, you can achieve continuous monitoring and real-time threat detection, enabling quicker responses to vulnerabilities and breaches.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.367.1">In this section, you have learned how to apply security thinking while designing and considering any regulatory needs. </span><span class="koboSpan" id="kobo.367.2">However, you have a high-level overview here. </span><span class="koboSpan" id="kobo.367.3">You will learn more details in </span><em class="chapterRef"><span class="koboSpan" id="kobo.368.1">Chapter 7</span></em><span class="koboSpan" id="kobo.369.1">, </span><em class="italic"><span class="koboSpan" id="kobo.370.1">Security Considerations</span></em><span class="koboSpan" id="kobo.371.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.372.1">You might create a feature-rich product, but it may not appeal broadly to users until they find it easy to navigate and access. </span><span class="koboSpan" id="kobo.372.2">Your application’s usability and accessibility play a significant role in product success. </span><span class="koboSpan" id="kobo.372.3">Let’s learn more about this in the next section.</span></p>
<h1 class="heading-1" id="_idParaDest-66"><span class="koboSpan" id="kobo.373.1">Making applications usable and accessible</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.374.1">Ensuring applications are both usable and accessible is a critical aspect of design that impacts the user experience significantly. </span><span class="koboSpan" id="kobo.374.2">Usability refers to how easy and intuitive an application is for users to interact with, which involves a user-friendly interface, clear navigation, and efficient task-completion processes. </span><span class="koboSpan" id="kobo.374.3">Accessibility, on the other hand, ensures that applications are usable by people with various disabilities. </span><span class="koboSpan" id="kobo.374.4">Let’s learn more about these.</span></p>
<h2 class="heading-2" id="_idParaDest-67"><span class="koboSpan" id="kobo.375.1">Achieving usability</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.376.1">You want your</span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.377.1"> users to have a seamless experience browsing through the application. </span><span class="koboSpan" id="kobo.377.2">It should be so smooth that they don’t even notice how easily they can find things without any difficulties. </span><span class="koboSpan" id="kobo.377.3">You can do this by making your application highly usable. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.378.1">Usability is how quickly the user can learn navigation logic when using your application for the first time. </span><span class="koboSpan" id="kobo.378.2">It’s about how quickly they can bounce back if they make a mistake and whether they can perform the task efficiently. </span><span class="koboSpan" id="kobo.378.3">Complex and feature-rich applications have no meaning if they can’t be used effectively. </span><span class="koboSpan" id="kobo.378.4">The goal is to create an intuitive and user-friendly interface that enhances the user experience, ensuring that the application’s functionality is accessible and straightforward for all users.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.379.1">User research and testing are essential to defining usability that can satisfy user experience.</span></p>
<h2 class="heading-2" id="_idParaDest-68"><span class="koboSpan" id="kobo.380.1">Achieving accessibility</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.381.1">When</span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.382.1"> designing your application, you often want to target a global audience or significant geographic region. </span><span class="koboSpan" id="kobo.382.2">Your user base will be diverse regarding technical amenities and physical abilities. </span><span class="koboSpan" id="kobo.382.3">Accessibility is about inclusion; you want your application to be accessible to everyone, regardless of whether a user has a slow internet connection, uses an old device, or has physical limitations.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.383.1">While designing an application, a solutions architect must ensure that accessibility is considered. </span><span class="koboSpan" id="kobo.383.2">Sometimes, a different version of the application may need to be created altogether to achieve that.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.384.1">Accessibility design should include design components, such as voice recognition and voice-based navigation, screen magnifiers, and the ability to read content aloud to aid those who cannot easily access and use applications due, for example, to vision or hearing impairment.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.385.1">Localization helps the application become available in a language that’s specific to a region (for example, Spanish, Mandarin, German, Hindi, or Japanese), enabling global users across the world to navigate your application in their local languages.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.386.1">As shown in </span><em class="italic"><span class="koboSpan" id="kobo.387.1">Figure 2.11</span></em><span class="koboSpan" id="kobo.388.1">, customer</span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.389.1"> satisfaction is a key component of usability and accessibility.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.390.1"><img alt="" role="presentation" src="../Images/B21336_02_11.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.391.1">Figure 2.11: Customer satisfaction with usability and accessibility</span></p>
<p class="normal"><span class="koboSpan" id="kobo.392.1">You must know your users to achieve usability and accessibility—where accessibility is a component of usability—as they go hand in hand. </span><span class="koboSpan" id="kobo.392.2">Before starting the solution design process, a solutions architect should work alongside a product owner to research users by conducting interviews and surveys and gathering feedback on the mock frontend design. </span><span class="koboSpan" id="kobo.392.3">You need to understand the users’ limitations and empower them with supporting features during application development.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.393.1">When the product is launched, the team should plan for A/B testing by routing a small portion of user traffic to new features and understanding user reactions. </span><span class="koboSpan" id="kobo.393.2">A/B testing involves comparing two versions of an application to evaluate their performance and determine the superior option. </span><span class="koboSpan" id="kobo.393.3">After launch, the application must have a mechanism to collect continuous feedback (by providing a feedback form or by launching customer support) to make the design better.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.394.1">As your users keep evolving, your architecture should be able to keep up with increasing demands. </span><span class="koboSpan" id="kobo.394.2">For that, you need to design extendable and future-proof architecture. </span><span class="koboSpan" id="kobo.394.3">Let’s learn how to make your architecture future-proof.</span></p>
<h1 class="heading-1" id="_idParaDest-69"><span class="koboSpan" id="kobo.395.1">Building future-proof extendable and reusable architecture </span></h1>
<p class="normal"><span class="koboSpan" id="kobo.396.1">Businesses</span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.397.1"> evolve as they grow; applications scale to handle an increased user base and add more features to stay ahead and attain a competitive edge. </span><span class="koboSpan" id="kobo.397.2">A solution design needs to be extendable and flexible enough to modify an existing feature or add new functionality.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.398.1">To achieve solution extensibility, a solutions architect must use a loosely coupled architecture wherever possible. </span><span class="koboSpan" id="kobo.398.2">At a high level, creating a RESTful or queue-based architecture can help develop loosely coupled communication between different modules or across applications. </span><span class="koboSpan" id="kobo.398.3">You will learn more about the other kinds of architecture in </span><em class="chapterRef"><span class="koboSpan" id="kobo.399.1">Chapter 4</span></em><span class="koboSpan" id="kobo.400.1">, </span><em class="italic"><span class="koboSpan" id="kobo.401.1">Solution Architecture Design Patterns</span></em><span class="koboSpan" id="kobo.402.1">. </span><span class="koboSpan" id="kobo.402.2">In this section, we will take a simple example to explain the concept of architectural flexibility.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.403.1">To modularize their application, organizations often want to build a platform with a group of features and launch them as separate applications. </span><span class="koboSpan" id="kobo.403.2">This is only possible with a reusable design.</span></p>
<p class="normal"><em class="italic"><span class="koboSpan" id="kobo.404.1">Figure 2.12</span></em><span class="koboSpan" id="kobo.405.1"> shows an API-based architecture in an e-commerce application. </span><span class="koboSpan" id="kobo.405.2">Here, you have independent services, such as product catalog, order, payment, and shipping, utilized by an end user application in a pick-and-choose manner. </span><span class="koboSpan" id="kobo.405.3">The customer uses mobile and browser applications to place an online order. </span><span class="koboSpan" id="kobo.405.4">These applications need a product catalog service to allow the customer to browse the products on the web, an order service to allow them to place an order, and a payment service to process a payment.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.406.1">In turn, the product catalog and order service communicate with the shipping service to send ordered items to the customer’s doorstep. </span><span class="koboSpan" id="kobo.406.2">On the other hand, brick-and-mortar stores use point-of-sale systems, where a customer representative scans barcodes, places orders on behalf of the customer, and takes payment. </span><span class="koboSpan" id="kobo.406.3">No shipping service is required here, as the customer picks up the item in-store.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.407.1"><img alt="" role="presentation" src="../Images/B21336_02_12.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.408.1">Figure 2.12: Extensible API-based architecture</span></p>
<p class="normal"><span class="koboSpan" id="kobo.409.1">In </span><em class="italic"><span class="koboSpan" id="kobo.410.1">Figure 2.12</span></em><span class="koboSpan" id="kobo.411.1">, you can see the Reward API used for third-party API integration. </span><span class="koboSpan" id="kobo.411.2">This architecture allows you to extend the current design to integrate the Reward API for customer retention and to attract new customers by providing benefits when they purchase</span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.412.1"> an item. </span><span class="koboSpan" id="kobo.412.2">Here, you can see how payment services are reutilized by both online and store ordering. </span><span class="koboSpan" id="kobo.412.3">Another service can resue payment service if the organization wants to take payments for a gift card service, food services, and so on.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.413.1">Extensibility and reusability are not limited to the service design level—they go deep into the actual </span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.414.1">API framework level, where software architects should use </span><strong class="keyWord"><span class="koboSpan" id="kobo.415.1">object-oriented analysis and design</span></strong><span class="koboSpan" id="kobo.416.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.417.1">OOAD</span></strong><span class="koboSpan" id="kobo.418.1">) concepts, such as inheritance, to create an API framework. </span><span class="koboSpan" id="kobo.418.2">This can be extended and reutilized to add more features to the same service.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.419.1">OOAD is a foundational approach in software engineering that helps developers plan and model applications more effectively, ensuring that the software is modular, scalable, and maintainable.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.420.1">In order to extend your application feature, it needs to work seamlessly with other products where it can extend data and transactions. </span><span class="koboSpan" id="kobo.420.2">Making your application interoperable to the ecosystem helps to add new features by utilizing other adjacent applications. </span><span class="koboSpan" id="kobo.420.3">Let’s learn more about making compatible architecture. </span></p>
<h1 class="heading-1" id="_idParaDest-70"><span class="koboSpan" id="kobo.421.1">Ensuring architectural interoperability and portability</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.422.1">Architectural interoperability and portability are crucial aspects of modern software architecture, ensuring that applications can work across different environments and interact seamlessly with other systems. </span><span class="koboSpan" id="kobo.422.2">Let’s look at these concepts.</span></p>
<h3 class="heading-3" id="_idParaDest-71"><span class="koboSpan" id="kobo.423.1">Making applications interoperable</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.424.1">Interoperability </span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.425.1">is the ability of one application to work with others through a standard format or protocol. </span><span class="koboSpan" id="kobo.425.2">Often, an application must communicate with various upstream systems to consume data and downstream systems to supply data, so it is essential to establish that communication seamlessly.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.426.1">An</span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.427.1"> e-commerce application, for example, needs to work with other applications in the supply chain management ecosystem. </span><span class="koboSpan" id="kobo.427.2">This includes enterprise resource planning applications to record all transactions, transportation life cycle management, shipping companies, order management, warehouse management, and labor management.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.428.1">All applications should be able to exchange data seamlessly to achieve an end-to-end feature from customer order to delivery. </span><span class="koboSpan" id="kobo.428.2">You will encounter similar use cases everywhere, whether it is a healthcare application, manufacturing application, or telecom application.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.429.1">A solutions architect needs to consider application interoperability during design by identifying and working with various system dependencies. </span><span class="koboSpan" id="kobo.429.2">An interoperable application saves a lot in terms of cost, as it depends on systems that can communicate in the same format without any data messaging effort. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.430.1">Each industry has its standard data exchange size that needs to be understood and adhered to. </span><span class="koboSpan" id="kobo.430.2">In general, for software design, the architect may choose a popular format, such as JSON or XML, for different applications so that they can communicate with each other. </span><span class="koboSpan" id="kobo.430.3">Both formats are supported out of the box in modern RESTful API design and microservice architecture.</span></p>
<h3 class="heading-3" id="_idParaDest-72"><span class="koboSpan" id="kobo.431.1">Making applications portable</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.432.1">System </span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.433.1">portability allows your application to work across different environments without or with only minimal changes. </span><span class="koboSpan" id="kobo.433.2">Any software application must work across various operating systems and hardware to achieve higher usability.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.434.1">Since technology changes rapidly, you will often see that a new version of a software language, development platform, or operating system is released and you will need to ensure your application can adapt to these changes. </span><span class="koboSpan" id="kobo.434.2">Today, mobile applications are an integral part of any system design, and your mobile apps need to be compatible with major mobile operating system platforms, such as iOS and Android.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.435.1">During the design phase, the solutions architect needs to choose a technology that can achieve the desired portability of the application. </span><span class="koboSpan" id="kobo.435.2">For example, if you aim to deploy your application across different operating systems, programming languages such as Java may be a good choice, as all operating systems often support it, and your application will work on a different platform without needing to be ported across. </span><span class="koboSpan" id="kobo.435.3">For mobile applications, an architect may choose a JavaScript-based framework such as React Native, which can provide cross-platform mobile app development.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.436.1">Interoperability enriches system extensibility, and portability increases the usability of an application. </span><span class="koboSpan" id="kobo.436.2">Both are critical attributes of architecture design and may add exponential costs if not addressed during solution design. </span><span class="koboSpan" id="kobo.436.3">A solutions architect must carefully consider both aspects per industry requirements and system dependencies.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.437.1">Automation is key to reducing errors and improving efficiency. </span><span class="koboSpan" id="kobo.437.2">We will look at this next.</span></p>
<h1 class="heading-1" id="_idParaDest-73"><span class="koboSpan" id="kobo.438.1">Applying automation everywhere</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.439.1">Most accidents</span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.440.1"> happen due to human error, which can be avoided using </span><strong class="keyWord"><span class="koboSpan" id="kobo.441.1">automation</span></strong><span class="koboSpan" id="kobo.442.1">. </span><span class="koboSpan" id="kobo.442.2">Automation </span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.443.1">not only handles jobs efficiently but also increases productivity and saves costs. </span><span class="koboSpan" id="kobo.443.2">Anything identified as a repeatable task can be automated to free up valuable human resources so team members can spend their time on more exciting work and focus on solving a real problem. </span><span class="koboSpan" id="kobo.443.3">It also helps to increase team morale.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.444.1">When designing a solution, think about what can be automated. </span><span class="koboSpan" id="kobo.444.2">Think about automating any repeatable task. </span><span class="koboSpan" id="kobo.444.3">Consider the following </span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.445.1">components to be automated in your solution:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.446.1">Application testing</span></strong><span class="koboSpan" id="kobo.447.1">: You </span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.448.1">need to test your application every time you make any changes to ensure nothing breaks. </span><span class="koboSpan" id="kobo.448.2">Also, manual testing is very time-consuming and requires lots of resources. </span><span class="koboSpan" id="kobo.448.3">Automating repeatable test cases is better to speed up deployment and product launch. </span><span class="koboSpan" id="kobo.448.4">Automate your testing on a production scale and use rolling deployment techniques, such as canary and A/B testing, to release changes. </span><span class="koboSpan" id="kobo.448.5">Canary testing involves releasing changes to a small group of users to assess the impact and detect issues before a full rollout, acting as an early warning system for potential problems. </span><span class="koboSpan" id="kobo.448.6">A/B testing, or split testing, compares two versions of an application to determine which one performs better with users, guiding decisions based on data.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.449.1">IT infrastructure</span></strong><span class="koboSpan" id="kobo.450.1">: You</span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.451.1"> can automate your infrastructure by using </span><em class="italic"><span class="koboSpan" id="kobo.452.1">infrastructure as code</span></em><span class="koboSpan" id="kobo.453.1"> scripting, for example, Ansible, Terraform, and Amazon CloudFormation. </span><span class="koboSpan" id="kobo.453.2">The automation of infrastructure allows environments to be created in minutes compared to days. </span><span class="koboSpan" id="kobo.453.3">Automating infrastructure as code helps avoid configuration errors and creates a replica of the environment.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.454.1">Logging, monitoring, and alerting</span></strong><span class="koboSpan" id="kobo.455.1">: Monitoring is critical, and you want to monitor </span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.456.1">everything</span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.457.1"> every time to make sure all parts of your </span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.458.1">application are functioning properly and you can take proactive measures to fix any issues. </span><span class="koboSpan" id="kobo.458.2">You can only monitor the vast system by using automation. </span><span class="koboSpan" id="kobo.458.3">You need to automate all activity monitoring and logs to ensure that your application is running smoothly and functioning as desired. </span><span class="koboSpan" id="kobo.458.4">Also, based on monitoring, you should take automated action, such as scaling up your system or alerting your team to act.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.459.1">Deployment automation</span></strong><span class="koboSpan" id="kobo.460.1">: Deployment</span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.461.1"> is a repeatable task that is very time-consuming and delays the last-minute launch in many real-time scenarios. </span><span class="koboSpan" id="kobo.461.2">Automating your deploym</span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.462.1">ent pipeline by applying </span><strong class="keyWord"><span class="koboSpan" id="kobo.463.1">continuous integration and continuous deployment</span></strong><span class="koboSpan" id="kobo.464.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.465.1">CI/CD</span></strong><span class="koboSpan" id="kobo.466.1">) helps you to be agile and iterate quickly on product features with frequent launches. </span><span class="koboSpan" id="kobo.466.2">CI/CD helps you make small, incremental changes to your application.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.467.1">Security automation</span></strong><span class="koboSpan" id="kobo.468.1">: While automating everything, remember to add automation for</span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.469.1"> security. </span><span class="koboSpan" id="kobo.469.2">If someone tries to hack your application, you want to know immediately and act quickly.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.470.1">You want to take preventive action by automating any incoming or outgoing traffic in your system boundary and setting alerts for suspicious activity.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.471.1">Automation </span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.472.1">provides peace of mind by helping to ensure the product functions without a glitch. </span><span class="koboSpan" id="kobo.472.2">When designing an application, always think from an automation perspective and consider that as a critical component. </span><span class="koboSpan" id="kobo.472.3">You will learn more about automation in </span><em class="chapterRef"><span class="koboSpan" id="kobo.473.1">Chapter 9</span></em><span class="koboSpan" id="kobo.474.1">, </span><em class="italic"><span class="koboSpan" id="kobo.475.1">Operational Excellence Considerations</span></em><span class="koboSpan" id="kobo.476.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-74"><span class="koboSpan" id="kobo.477.1">Plan for business continuity</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.478.1">There may be a </span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.479.1">situation when the entire region where your data center is located goes down due to massive power grid outages, earthquakes, floods, or a security attack but your global business should continue running. </span><span class="koboSpan" id="kobo.479.2">In such situations, you must have a disaster recovery plan in which you will plan your business continuity by preparing sufficient IT resources in an entirely different region, perhaps even in different continents or countries, so that your business can get back up and running quickly or experience no downtime at all.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.480.1">When planning </span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.481.1">disaster recovery, a solutions architect must understand an organization’s </span><strong class="keyWord"><span class="koboSpan" id="kobo.482.1">Recovery Time Objective</span></strong><span class="koboSpan" id="kobo.483.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.484.1">RTO</span></strong><span class="koboSpan" id="kobo.485.1">) and </span><strong class="keyWord"><span class="koboSpan" id="kobo.486.1">Recovery Point Objective</span></strong><span class="koboSpan" id="kobo.487.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.488.1">RPO</span></strong><span class="koboSpan" id="kobo.489.1">). </span><span class="koboSpan" id="kobo.489.2">RTO </span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.490.1">measures how much downtime a business can sustain without significant impact; RPO indicates how much data loss a business can tolerate. </span><span class="koboSpan" id="kobo.490.2">Reducing RTO and RPO means incurring higher costs, so it is essential to understand whether the business is mission-critical and needs minimal RTO and RPO. </span><span class="koboSpan" id="kobo.490.3">For example, a stock trading application cannot afford to lose a single data point, and a railway signaling application cannot be down for a single second, as human life depends on it.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.491.1">The architecture diagram in </span><em class="italic"><span class="koboSpan" id="kobo.492.1">Figure 2.13</span></em><span class="koboSpan" id="kobo.493.1"> shows a multi-site disaster recovery architecture. </span><span class="koboSpan" id="kobo.493.2">The primary data center location is in Ireland, Europe, and the disaster recovery site is in Virginia, USA, hosted on the AWS public cloud. </span><span class="koboSpan" id="kobo.493.3">In this case, a business can continue operating even if something happens to the European region or the public cloud. </span><span class="koboSpan" id="kobo.493.4">The fact that the disaster recovery plan is based on a multi-site model to achieve minimal RTO and RPO means minimal to no outage and no data loss.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.494.1"><img alt="A diagram of a server  Description automatically generated with low confidence" src="../Images/B21336_02_13.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.495.1">Figure 2.13: Hybrid multi-site disaster recovery architecture</span></p>
<p class="normal"><span class="koboSpan" id="kobo.496.1">The following </span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.497.1">are the most common disaster recovery plans, all of </span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.498.1">which you will learn about in </span><em class="chapterRef"><span class="koboSpan" id="kobo.499.1">Chapter 11</span></em><span class="koboSpan" id="kobo.500.1">, </span><em class="italic"><span class="koboSpan" id="kobo.501.1">DevOps and Solution Architecture Framework</span></em><span class="koboSpan" id="kobo.502.1">:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.503.1">Backup and Store</span></strong><span class="koboSpan" id="kobo.504.1">: Thi</span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.505.1">s plan is the least costly but has the maximum RTO and RPO. </span><span class="koboSpan" id="kobo.505.2">In this plan, all the server’s machine images and database snapshots should be stored in the disaster recovery site. </span><span class="koboSpan" id="kobo.505.3">The team will try to restore the disaster site from a backup in a disaster.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.506.1">Pilot lite</span></strong><span class="koboSpan" id="kobo.507.1">: In this plan, all </span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.508.1">the server’s machine images are stored as a backup, and a small database server is maintained in the disaster recovery site with continual data synchronization from the leading site. </span><span class="koboSpan" id="kobo.508.2">Other critical services, such as Active Directory, may be running in small instances. </span><span class="koboSpan" id="kobo.508.3">In a disaster, the team will try to bring up the server from the machine image and scale up a database. </span><span class="koboSpan" id="kobo.508.4">Pilot lite is more costly but has lower RTO and RPO than Backup and Store.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.509.1">Warm standby</span></strong><span class="koboSpan" id="kobo.510.1">: In this </span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.511.1">plan, all the application and database server (running at low capacity) instances in the disaster recovery site continue to sync up with the leading site. </span><span class="koboSpan" id="kobo.511.2">In a disaster, the team will try to scale up all the servers and databases. </span><span class="koboSpan" id="kobo.511.3">Warm standby is costlier than the pilot lite option but has lower RTO and RPO.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.512.1">Multi-site</span></strong><span class="koboSpan" id="kobo.513.1">: This plan is the most expensive and has a </span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.514.1">near-zero RTO and RPO. </span><span class="koboSpan" id="kobo.514.2">This plan maintains a replica of the leading site in a disaster recovery site with equal capacity that actively serves user traffic. </span><span class="koboSpan" id="kobo.514.3">In a disaster, all traffic will be routed to an alternate location.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.515.1">Often, organizations </span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.516.1">choose a less costly option for disaster recovery, but it is essential to perform regular testing to ensure the failover works. </span><span class="koboSpan" id="kobo.516.2">The team should make operational excellence a routine checkpoint to ensure business continuity during disaster recovery. </span><span class="koboSpan" id="kobo.516.3">Running your application in production and maintaining it for years is very important. </span><span class="koboSpan" id="kobo.516.4">Let’s learn about the principles of making your application maintainable and operational.</span></p>
<h1 class="heading-1" id="_idParaDest-75"><span class="koboSpan" id="kobo.517.1">Design for operation</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.518.1">Operational excellence </span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.519.1">can be a great differentiator for your application by providing a high-quality service to customers with minimal outages. </span><span class="koboSpan" id="kobo.519.2">Applying operational excellence proactively also helps support and engineering teams increase productivity. </span><span class="koboSpan" id="kobo.519.3">Maintainability goes hand in hand with operational excellence. </span><span class="koboSpan" id="kobo.519.4">Easily maintainable applications help reduce costs, avoid errors, and let you gain a competitive edge.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.520.1">A solutions architect </span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.521.1">needs to design for operation, including how the workload will be deployed, updated, and operated in the long term. </span><span class="koboSpan" id="kobo.521.2">Planning for logging, monitoring, and alerting is essential to capture all incidents and take quick action for the best user experience. </span><span class="koboSpan" id="kobo.521.3">Apply automation wherever possible, whether deploying infrastructures or changing the application code, to avoid human error.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.522.1">Including deployment methods and automation strategy in your design is very important, as this can accelerate the time to market for any new changes without impacting existing operations. </span><span class="koboSpan" id="kobo.522.2">Operational excellence planning should consider security and compliance elements, as regulatory requirements may change over time, and your application must adhere to them to operate.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.523.1">Maintenance</span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.524.1"> can be proactive or reactive; for example, once a new version of an operating system becomes available, you can modernize your application to switch platforms immediately or monitor system health and wait until the end of the life of the software before making any changes. </span><span class="koboSpan" id="kobo.524.2">In any case, changes should be made in small increments with a rollback strategy. </span><span class="koboSpan" id="kobo.524.3">To apply these changes, you can automate the entire process by setting up a CI/CD pipeline. </span><span class="koboSpan" id="kobo.524.4">For the launch, you can plan for A/B testing or blue-green deployment.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.525.1">For </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.526.1">operational readiness, architecture design should include the appropriate documents and knowledge-sharing mechanisms—for example, creating and maintaining a runbook to document routine activity and creating a playbook to guide your system process through issues. </span><span class="koboSpan" id="kobo.526.2">This allows you to act quickly in the event of an incident. </span><span class="koboSpan" id="kobo.526.3">You should use </span><em class="italic"><span class="koboSpan" id="kobo.527.1">root cause analysis</span></em><span class="koboSpan" id="kobo.528.1"> for post-incident reporting to determine why the issue occurred and ensure it doesn’t happen again.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.529.1">Operational excellence and maintenance are ongoing; every operational event and failure is an opportunity to improve your operation by learning from previous mistakes. </span><span class="koboSpan" id="kobo.529.2">You must analyze the operation’s activities and failures, experiment, and improve. </span><span class="koboSpan" id="kobo.529.3">You will learn more about operational excellence in </span><em class="chapterRef"><span class="koboSpan" id="kobo.530.1">Chapter 9</span></em><span class="koboSpan" id="kobo.531.1">, </span><em class="italic"><span class="koboSpan" id="kobo.532.1">Operational Excellence Considerations</span></em><span class="koboSpan" id="kobo.533.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.534.1">In </span><em class="chapterRef"><span class="koboSpan" id="kobo.535.1">Chapter 1</span></em><span class="koboSpan" id="kobo.536.1">, </span><em class="italic"><span class="koboSpan" id="kobo.537.1">Solutions Architects in Organizations</span></em><span class="koboSpan" id="kobo.538.1">, you learned about the various constraints a solution architecture needs to handle and balance. </span><span class="koboSpan" id="kobo.538.2">It is a key architectural principle to take care of constraints, and we will look at this next.</span></p>
<h1 class="heading-1" id="_idParaDest-76"><span class="koboSpan" id="kobo.539.1">Overcoming architectural constraints</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.540.1">When</span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.541.1"> designing an application architecture, the significant limitations are cost, time, budget, scope, schedule, and resources. </span><span class="koboSpan" id="kobo.541.2">Overcoming these constraints is a significant factor that must be considered while designing a solution. </span><span class="koboSpan" id="kobo.541.3">You should look at the limitations as challenges that can be overcome rather than obstacles, as challenges always push you to the limit of innovation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.542.1">A solutions architect needs to make suitable trade-offs while considering the constraints. </span><span class="koboSpan" id="kobo.542.2">For example, a high-performance application results in more cost when you need to add additional caching in multiple layers of architecture. </span><span class="koboSpan" id="kobo.542.3">However, sometimes, cost is more important than performance, primarily if a system is used by internal employees, which may not directly impact revenue. </span><span class="koboSpan" id="kobo.542.4">Sometimes, the market is more important than launching a fully featured product, and you need to make the trade-off between scope versus speed. </span><span class="koboSpan" id="kobo.542.5">In such scenarios, you can take the </span><strong class="keyWord"><span class="koboSpan" id="kobo.543.1">minimum viable product</span></strong><span class="koboSpan" id="kobo.544.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.545.1">MVP</span></strong><span class="koboSpan" id="kobo.546.1">) approach; you will learn more about this in the next section.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.547.1">Technology </span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.548.1">constraints become evident in a large organization, as bringing changes across hundreds of systems will be challenging. </span><span class="koboSpan" id="kobo.548.2">When designing applications, you need to use the most common technique across the organization. </span><span class="koboSpan" id="kobo.548.3">You also need to make sure that the application is upgradable to adopt new technology and be able to plug in components built on a different platform.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.549.1">A RESTful service model is popular when teams are free to use any technology for their development. </span><span class="koboSpan" id="kobo.549.2">They only need to provide a URL with which their services can be accessed. </span><span class="koboSpan" id="kobo.549.3">Even legacy systems such as mainframes can be integrated into the new system using an API wrapper around it, and this can help overcome technology challenges.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.550.1">Throughout this book, you will learn more about handling various architectural constraints. </span><span class="koboSpan" id="kobo.550.2">An MVP approach helps you overcome constraints and build a customer-centric product.</span></p>
<h2 class="heading-2" id="_idParaDest-77"><span class="koboSpan" id="kobo.551.1">Taking the MVP approach</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.552.1">For a </span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.553.1">successful solution, always put the customer first, think backward from the customer’s needs, determine what is critical for them, and plan your solution delivery in an agile way.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.554.1">MVP is a development strategy used to build a new product or website with the minimum amount of features necessary to satisfy early adopters and validate a product idea early in the product development cycle. </span><span class="koboSpan" id="kobo.554.2">In this approach, the initial version of the product includes only the core features that allow the product to be deployed and no more. </span><span class="koboSpan" id="kobo.554.3">The goal is to provide immediate value, minimize development costs, and gather feedback from customers as quickly as possible to iterate and improve the product over time.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.555.1">One popular method of prioritizing customer</span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.556.1"> requirements is </span><strong class="keyWord"><span class="koboSpan" id="kobo.557.1">MoSCoW</span></strong><span class="koboSpan" id="kobo.558.1">, where you divide requirements into the following categories:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.559.1">Mo (must have)</span></strong><span class="koboSpan" id="kobo.560.1">: Requirements that are critical for your customers, without which the product cannot launch</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.561.1">S (should have)</span></strong><span class="koboSpan" id="kobo.562.1">: Requirements that are the most desirable to the customer once they start utilizing the application</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.563.1">Co (could have)</span></strong><span class="koboSpan" id="kobo.564.1">: Requirements that are nice to have, but their absence will not impact the desired functionality of the application</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.565.1">W (won’t have)</span></strong><span class="koboSpan" id="kobo.566.1">: Requirements</span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.567.1"> that customers may not notice if they are not there</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.568.1">You need</span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.569.1"> to plan an MVP for your customer with must-have requirements and go for the next delivery iteration with must-have requirements. </span><span class="koboSpan" id="kobo.569.2">With this phased delivery approach, you can thoroughly utilize your resources and overcome the challenges of time, budget, scope, and resources. </span><span class="koboSpan" id="kobo.569.3">The MVP approach helps you to determine customer needs. </span><span class="koboSpan" id="kobo.569.4">You are not trying to build everything without knowing if your features have added value for the customer. </span><span class="koboSpan" id="kobo.569.5">This customer-focused approach helps to utilize resources wisely and reduces the waste of resources.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.570.1">In the following diagram, you can see the MVP evaluation for a truck manufacturing delivery, where the customer wants a delivery truck that gets delivered initially, and you evolve the process based on the customer’s requirements and feedback:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.571.1"><img alt="" role="presentation" src="../Images/B21336_02_14.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.572.1">Figure 2.14: MVP approach to building the solution</span></p>
<p class="normal"><span class="koboSpan" id="kobo.573.1">Once a customer gets the first delivery truck, which is fully functioning, they can determine if they need a stronger or larger truck to handle a more significant load. </span><span class="koboSpan" id="kobo.573.2">Based on that, the manufacturer can build a 6-wheel, a 10-wheel, and an 18-wheel truck trailer. </span><span class="koboSpan" id="kobo.573.3">This stepwise approach provides working products with essential features that the customers can use, and the team can build upon them as per customer requirements.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.574.1">You can see how the MVP approach helps to utilize limited resources in an efficient way, which helps to buy more time for quality product development and clarify the scope, in comparison to an approach where we turn up the first time with an 18-wheel truck only to find out we only needed a 6-wheeler. </span><span class="koboSpan" id="kobo.574.2">Putting the working product in the customer’s hands early gives you an idea of where to invest. </span><span class="koboSpan" id="kobo.574.3">As your application has already started generating revenue, you can present use cases to ask for more resources as required.</span></p>
<h1 class="heading-1" id="_idParaDest-78"><span class="koboSpan" id="kobo.575.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.576.1">In this chapter, you explored an in-depth overview of design principles required to architect effective and efficient systems. </span><span class="koboSpan" id="kobo.576.2">Initially, we delved into scalable architecture design, detailing predictive and reactive scaling strategies, and discussing techniques for scaling architecture, including strategies for static content, session management for application server scaling, and database scaling. </span><span class="koboSpan" id="kobo.576.3">We also looked at the importance of elasticity.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.577.1">The chapter then explored constructing a highly available and resilient architecture, emphasizing the necessity of fault tolerance and using replaceable resources for robust system design. </span><span class="koboSpan" id="kobo.577.2">A separate section was dedicated to performance, underscoring how to build systems that perform optimally under various conditions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.578.1">The principle of loose coupling was discussed next, highlighting its importance in modern design, followed by the approach of “services, not servers,” which is central to the serverless computing paradigm. </span><span class="koboSpan" id="kobo.578.2">The chapter also underscored the importance of data-driven design, using data to make informed decisions about system architecture, and explored the need for robust security throughout the architecture. </span><span class="koboSpan" id="kobo.578.3">The importance of usability and accessibility in application design was also covered.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.579.1">Building future-proof, extendable architecture was next on the agenda, focusing on architectural interoperability and portability to guarantee that systems can evolve and adapt to changing needs. </span><span class="koboSpan" id="kobo.579.2">The application of automation in all aspects of system architecture was discussed as a means to improve efficiency and reduce error rates.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.580.1">Designing for operation was emphasized, emphasizing ease of system maintenance and updates. </span><span class="koboSpan" id="kobo.580.2">Lastly, the chapter addressed the challenge of overcoming architectural constraints, providing strategies to identify and mitigate the limitations of a given system design. </span><span class="koboSpan" id="kobo.580.3">The MVP approach was also explored as a tool for rapidly validating architectural choices.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.581.1">In the next chapter, you’ll delve into various strategies and methodologies essential for cloud migration, highlighting how businesses transition their infrastructure, applications, and data to the cloud. </span><span class="koboSpan" id="kobo.581.2">Additionally, the chapter will cover the intricacies of designing and implementing hybrid cloud architecture, which combines on-premises infrastructure with cloud services, offering a flexible and scalable solution.</span></p>
<h1 class="heading-1" id="_idParaDest-79"><span class="koboSpan" id="kobo.582.1">Leave a review!</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.583.1">Enjoying this book? </span><span class="koboSpan" id="kobo.583.2">Help readers like you by leaving an Amazon review. </span><span class="koboSpan" id="kobo.583.3">Scan the QR code below to get a free eBook of your choice.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.584.1"><img alt="" role="presentation" src="../Images/Image.png"/></span></p>
</div>
</body></html>