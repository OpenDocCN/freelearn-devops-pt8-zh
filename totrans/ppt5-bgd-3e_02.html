<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Creating your first manifests"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Creating your first manifests</h1></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><span class="emphasis"><em>Beginnings are such delicate times.</em></span></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<span class="attribution"><span class="emphasis"><em>Frank Herbert, 'Dune'</em></span></span></td></tr></table></div><p>In this chapter, you'll learn how to write your first manifest with Puppet, and how to put Puppet to work configuring a server. You'll also understand how Puppet compiles and applies a manifest. You'll see how to use Puppet to manage the contents of files, how to install packages, and how to control services.</p><div class="mediaobject"><img src="graphics/B08880_02_01.jpg" alt="Creating your first manifests"/></div><div class="section" title="Hello, Puppet – your first Puppet manifest"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Hello, Puppet – your first Puppet manifest</h1></div></div></div><p>The first example <a id="id32" class="indexterm"/>program in any programming language, by tradition, prints <code class="literal">hello, world</code>. Although we can do that easily in Puppet, let's do something a little more ambitious, and have Puppet create a file on the server containing that text.</p><p>On your Vagrant box, run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo puppet apply /examples/file_hello.pp</strong></span>
Notice: Compiled catalog for ubuntu-xenial in environment production in 0.07 seconds
Notice: /Stage[main]/Main/File[/tmp/hello.txt]/ensure: defined content as '{md5}22c3683b094136c3398391ae71b20f04'
Notice: Applied catalog in 0.01 seconds</pre></div><p>We can ignore the output from Puppet for the moment, but if all has gone well, we should be able to run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cat /tmp/hello.txt</strong></span>
hello, world</pre></div><div class="section" title="Understanding the code"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec01"/>Understanding the code</h2></div></div></div><p>Let's look at the <a id="id33" class="indexterm"/>example code to see what's going on (run <code class="literal">cat /example/file_hello.pp</code>, or open the file in a text editor):</p><div class="informalexample"><pre class="programlisting">file { '/tmp/hello.txt':
  ensure  =&gt; file,
  content =&gt; "hello, world\n",
}</pre></div><p>The code term <code class="literal">file</code> begins a <span class="strong"><strong>resource declaration</strong></span> for a <code class="literal">file</code> resource. A <span class="strong"><strong>resource</strong></span> is some bit of configuration that you want Puppet to manage: for example, a file, user account, or package. A resource declaration follows this pattern:</p><div class="informalexample"><pre class="programlisting">RESOURCE_TYPE { TITLE:
  ATTRIBUTE =&gt; VALUE,
  ...
}</pre></div><p>Resource declarations will make up almost all of your Puppet manifests, so it's important to understand exactly how they work:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">RESOURCE_TYPE</code> indicates the type of resource you're declaring; in this case, it's a <code class="literal">file</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">TITLE</code> is the name that Puppet uses to identify the resource internally. Every resource must have a unique title. With <code class="literal">file</code> resources, it's usual for this to be the full path to the file: in this case, <code class="literal">/tmp/hello</code>.</li></ul></div><p>The remainder of this block of code is a list of attributes that describe how the resource should be configured. The attributes available depend on the type of the resource. For a file, you can set attributes such as <code class="literal">content</code>, <code class="literal">owner</code>, <code class="literal">group</code>, and <code class="literal">mode</code>, but one attribute that every resource supports is <code class="literal">ensure</code>.</p><p>Again, the possible values for <code class="literal">ensure</code> are specific to the type of resource. In this case, we use <code class="literal">file</code> to indicate that we want a regular file, as opposed to a directory or symlink:</p><div class="informalexample"><pre class="programlisting">ensure  =&gt; file,</pre></div><p>Next, to put some text in the file, we <a id="id34" class="indexterm"/>specify the <code class="literal">content</code> attribute:</p><div class="informalexample"><pre class="programlisting">content =&gt; "hello, world\n",</pre></div><p>The <code class="literal">content</code> attribute sets the contents of a file to a string value you provide. Here, the contents of the file are declared to be <code class="literal">hello, world</code>, followed by a newline character (in Puppet strings, we write the newline character as <code class="literal">\n</code>).</p><p>Note that <code class="literal">content</code> specifies the entire content of the file; the string you provide will replace anything already in the file, rather than be appended to it.</p></div><div class="section" title="Modifying existing files"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec02"/>Modifying existing files</h2></div></div></div><p>What happens if the <a id="id35" class="indexterm"/>file already exists when Puppet runs and it contains something else? Will Puppet change it?</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo sh -c 'echo "goodbye, world" &gt;/tmp/hello.txt'</strong></span>
<span class="strong"><strong>cat /tmp/hello.txt</strong></span>
goodbye, world
<span class="strong"><strong>sudo puppet apply /examples/file_hello.pp</strong></span>
<span class="strong"><strong>cat /tmp/hello.txt</strong></span>
hello, world</pre></div><p>The answer is yes. If any attribute of the file, including its contents, doesn't match the manifest, Puppet will change it so that it does.</p><p>This can lead to some surprising results if you manually edit a file managed by Puppet. If you make changes to a file without also changing the Puppet manifest to match, Puppet will overwrite the file the next time it runs, and your changes will be lost.</p><p>So it's a good idea to add a comment to files that Puppet is managing: something like the following:</p><div class="informalexample"><pre class="programlisting"># This file is managed by Puppet - any manual edits will be lost</pre></div><p>Add this to Puppet's copy <a id="id36" class="indexterm"/>of the file when you first deploy it, and it will remind you and others not to make manual changes.</p></div><div class="section" title="Dry-running Puppet"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec03"/>Dry-running Puppet</h2></div></div></div><p>Because you can't <a id="id37" class="indexterm"/>necessarily tell in advance what applying a Puppet manifest will change on the system, it's a good idea to do a dry run first. Adding the <code class="literal">--noop</code> flag to <code class="literal">puppet apply</code> will show you what Puppet would have done, without actually changing anything:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo sh -c 'echo "goodbye, world" &gt;/tmp/hello.txt'</strong></span>
<span class="strong"><strong>sudo puppet apply --noop /examples/file_hello.pp</strong></span>
Notice: Compiled catalog for ubuntu-xenial in environment production in 0.04 seconds
Notice: /Stage[main]/Main/File[/tmp/hello.txt]/content: current_value {md5}7678..., should be {md5}22c3... (noop)</pre></div><p>Puppet decides whether or not a <code class="literal">file</code> resource needs updating, based on its MD5 hash sum. In the previous example, Puppet reports that the current value of the hash sum for <code class="literal">/tmp/hello.txt</code> is <code class="literal">7678...</code>, whereas according to the manifest, it should be <code class="literal">22c3...</code>. Accordingly, the file will be changed on the next Puppet run.</p><p>If you want to see what change Puppet would actually make to the file, you can use the <code class="literal">--show_diff</code> option:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo puppet apply --noop --show_diff /examples/file_hello.pp</strong></span>
Notice: Compiled catalog for ubuntu-xenial in environment production in 0.04 seconds
Notice: /Stage[main]/Main/File[/tmp/hello.txt]/content:
--- /tmp/hello.txt      2017-02-13 02:27:13.186261355 -0800
+++ /tmp/puppet-file20170213-3671-2yynjt        2017-02-13 02:30:26.561834755 -0800
@@ -1 +1 @@
-goodbye, world
+hello, world</pre></div><p>These options are very useful when you want to make sure that your Puppet manifest will affect only the things you're expecting it to—or, sometimes, when you want to check if something has been changed outside Puppet without actually undoing the change.</p></div><div class="section" title="How Puppet applies the manifest"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec04"/>How Puppet applies the manifest</h2></div></div></div><p>Here's how your <a id="id38" class="indexterm"/>manifest is processed. First, Puppet reads the manifest and the list of resources it contains (in this case, there's just one resource), and compiles these into a catalog (an internal representation of the desired state of the node).</p><p>Puppet then works through the catalog, applying each resource in turn:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, it checks if the resource exists on the server. If not, Puppet creates it. In the example, we've declared that the file <code class="literal">/tmp/hello.txt</code> should exist. The first time you run <code class="literal">sudo puppet apply</code>, this won't be the case, so Puppet will create the file for you.</li><li class="listitem">Then, for each resource, it checks the value of each attribute in the catalog against what actually exists on the server. In our example, there's just one attribute: <code class="literal">content</code>. We've specified that the content of the file should be <code class="literal">hello, world\n</code>. If the file is empty or contains something else, Puppet will overwrite the file with what the catalog says it should contain.</li></ol></div><p>In this case, the file will be empty the first time you apply the catalog, so Puppet will write the string <code class="literal">hello, world\n</code> into it.</p><p>We'll go on to examine the <code class="literal">file</code> resource in much more detail in later chapters.</p></div><div class="section" title="Creating a file of your own"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec05"/>Creating a file of your own</h2></div></div></div><p>Create your own <a id="id39" class="indexterm"/>manifest file (you can name it anything you like, so long as the file extension is <code class="literal">.pp</code>). Use a <code class="literal">file</code> resource to create a file on the server with any contents you like. Apply the manifest with Puppet and check that the file is created and contains the text you specified.</p><p>Edit the file directly and change the contents, then re-apply Puppet and check that it changes the file back to what the manifest says it should contain.</p></div></div></div>
<div class="section" title="Managing packages"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Managing packages</h1></div></div></div><p>Another key resource type <a id="id40" class="indexterm"/>in Puppet is the <span class="strong"><strong>package</strong></span>. A major part of configuring servers by hand involves installing packages, so we will also be using packages a lot in Puppet manifests. Although every operating system has its own package format, and different formats vary quite a lot in their capabilities, Puppet represents all these possibilities with a single <code class="literal">package</code> type. If you specify in your Puppet manifest that a given package should be installed, Puppet will use the appropriate package manager commands to install it on whatever platform it's running on.</p><p>As you've seen, all resource declarations in Puppet follow this form:</p><div class="informalexample"><pre class="programlisting">RESOURCE_TYPE { TITLE:
  ATTRIBUTE =&gt; VALUE,
  ...
}</pre></div><p>
<code class="literal">package</code> resources are no <a id="id41" class="indexterm"/>different. The <code class="literal">RESOURCE_TYPE</code> is <code class="literal">package</code>, and the only attribute you usually need to specify is <code class="literal">ensure</code>, and the only value it usually needs to take is <code class="literal">installed</code>:</p><div class="informalexample"><pre class="programlisting">package { 'cowsay':
  ensure =&gt; installed,
}</pre></div><p>Try this example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo puppet apply /examples/package.pp</strong></span>
Notice: Compiled catalog for ubuntu-xenial in environment production in 0.52 seconds
Notice: /Stage[main]/Main/Package[cowsay]/ensure: created
Notice: Applied catalog in 29.53 seconds</pre></div><p>Let's see whether <code class="literal">cowsay</code> is installed:</p><div class="informalexample"><pre class="programlisting">cowsay Puppet rules!
 _______________
&lt; Puppet rules! &gt;
 ---------------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||</pre></div><p>Now that's a useful package!</p><div class="section" title="How Puppet applies the manifest"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec06"/>How Puppet applies the manifest</h2></div></div></div><p>The title of the <a id="id42" class="indexterm"/>
<code class="literal">package</code> resource is <code class="literal">cowsay</code>, so Puppet knows that we're talking about a package named <code class="literal">cowsay</code>.</p><p>The <code class="literal">ensure</code> attribute governs the installation state of packages: unsurprisingly, <code class="literal">installed</code> tells Puppet that the package should be installed.</p><p>As we saw in the earlier example, Puppet processes this manifest by examining each resource in turn and checking its attributes on the server against those specified in the manifest. In this case, Puppet will look for the <code class="literal">cowsay</code> package to see whether it's installed. It is not, but the manifest says it should be, so Puppet carries out all the necessary actions to make <a id="id43" class="indexterm"/>reality match the manifest, which here means installing the package.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>It's still early on in the book, but you can already do a great deal with Puppet! If you can install packages and manage the contents of files, you can get a very long way towards setting up any kind of server configuration you might need. If you were to stop reading right here (which would be a shame, but we're all busy people), you would still be able to use Puppet to automate a large part of the configuration work you will encounter. But Puppet can do much more.</p></div></div></div><div class="section" title="Exercise"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec07"/>Exercise</h2></div></div></div><p>Create a manifest that uses the <code class="literal">package</code> resource to install any software you find useful for managing servers. Here are some suggestions: <code class="literal">tmux</code>, <code class="literal">sysdig</code>, <code class="literal">atop</code>, <code class="literal">htop</code>, and <code class="literal">dstat</code>.</p></div><div class="section" title="Querying resources with the puppet resource"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec08"/>Querying resources with the puppet resource</h2></div></div></div><p>If you <a id="id44" class="indexterm"/>want to see what version of a package Puppet thinks you have installed, you can use the <code class="literal">puppet resource</code> tool:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>puppet resource package openssl</strong></span>
package { 'openssl':
  ensure =&gt; '1.0.2g-1ubuntu4.8',
}</pre></div><p>
<code class="literal">puppet resource TYPE TITLE</code> will output a Puppet manifest representing the current state of the named resource on the system. If you leave out <code class="literal">TITLE</code>, you'll get a manifest for all the resources of the type <code class="literal">TYPE</code>. For example, if you run <code class="literal">puppet resource package</code>, you'll see the Puppet code for all the packages installed on the system.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip05"/>Tip</h3><p>
<code class="literal">puppet resource</code> even has an interactive configuration feature. To use it, run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>puppet resource -e package openssl</strong></span>
</pre></div><p>If you run this, Puppet will generate a manifest for the current state of the resource, and open it in an editor. If you now make changes and save it, Puppet will apply that manifest to make changes to the system. This is a fun little <a id="id45" class="indexterm"/>feature, but it would be rather time-consuming to do your entire configuration this way.</p></div></div></div></div>
<div class="section" title="Services"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Services</h1></div></div></div><p>The third most important <a id="id46" class="indexterm"/>Puppet resource type is the <span class="strong"><strong>service</strong></span>: a long-running process that either does some continuous kind of work, or waits for requests and then acts on them. For example, on most systems, the <code class="literal">sshd</code> process runs all the time and listens for SSH login attempts.</p><p>Puppet models services with the <code class="literal">service</code> resource type. The <code class="literal">service</code> resources look like the following example (you can find this in <code class="literal">service.pp</code> in the <code class="literal">/examples/</code> directory. From now on, I'll just give the filename of each example, as they are all in the same directory):</p><div class="informalexample"><pre class="programlisting">service { 'sshd':
  ensure =&gt; running,
  enable =&gt; true,
}</pre></div><p>The <code class="literal">ensure</code> parameter governs whether the service should be running or not. If its value is <code class="literal">running</code>, then as you might expect, Puppet will start the service if it is not running. If you set <code class="literal">ensure</code> to <code class="literal">stopped</code>, Puppet will stop the service if it is running.</p><p>Services may also be set to start when the system boots, using the <code class="literal">enable</code> parameter. If <code class="literal">enable</code> is set to <code class="literal">true</code>, the service will start at boot. If, on the other hand, <code class="literal">enable</code> is set to <code class="literal">false</code>, it will not. Generally speaking, unless there's a good reason not to, all services should be set to start at boot.</p><div class="section" title="Getting help on resources with puppet describe"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec09"/>Getting help on resources with puppet describe</h2></div></div></div><p>If you're struggling to <a id="id47" class="indexterm"/>remember all the different attributes of all the different resources, Puppet has a built-in help feature that will remind you. Run the following command, for example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>puppet describe service</strong></span>
</pre></div><p>This will give a description of the <code class="literal">service</code> resource, along with a complete list of attributes and allowed values. This works for all built-in resource types as well as many provided by third-party modules. To see a list of all the available resource types, run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>puppet describe --list</strong></span>
</pre></div></div><div class="section" title="The package-file-service pattern"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec10"/>The package-file-service pattern</h2></div></div></div><p>It's very <a id="id48" class="indexterm"/>common for a given piece of software to require these three Puppet resource types: the <code class="literal">package</code> resource installs the software, the <code class="literal">file</code> resource deploys one or more configuration files required for the software, and the <code class="literal">service</code> resource runs the software itself.</p><p>Here's an example using the MySQL database server (<code class="literal">package_file_service.pp</code>):</p><div class="informalexample"><pre class="programlisting">package { 'mysql-server':
  ensure =&gt; installed,
  notify =&gt; Service['mysql'],
}

file { '/etc/mysql/mysql.cnf':
  source =&gt; '/examples/files/mysql.cnf',
  notify =&gt; Service['mysql'],
}

service { 'mysql':
  ensure =&gt; running,
  enable =&gt; true,
}</pre></div><p>The <code class="literal">package</code> resource makes sure the <code class="literal">mysql-server</code> package is installed.</p><p>The config file for MySQL is <code class="literal">/etc/mysql/mysql.cnf</code>, and we use a <code class="literal">file</code> resource to copy this file from the Puppet repo so that we can control MySQL settings.</p><p>Finally, the <code class="literal">service</code> resource ensures that the <code class="literal">mysql</code> service is running.</p></div><div class="section" title="Notifying a linked resource"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec11"/>Notifying a linked resource</h2></div></div></div><p>You might have <a id="id49" class="indexterm"/>noticed a new attribute, called <code class="literal">notify</code>, in the <a id="id50" class="indexterm"/>
<code class="literal">file</code> resource in the previous example:</p><div class="informalexample"><pre class="programlisting">file { '/etc/mysql/mysql.cnf':
  source =&gt; '/examples/files/mysql.cnf',
  notify =&gt; Service['mysql'],
}</pre></div><p>What does this do? Imagine you've made a change to the <code class="literal">mysql.cnf</code> file and applied this change with Puppet. The updated file will be written to a disk, but because the <code class="literal">mysql</code> service is already running, it has no way of knowing that its config file has changed. Therefore, your changes will not actually take effect until the service is restarted. However, Puppet can do this for you if you specify the <code class="literal">notify</code> attribute on the <code class="literal">file</code> resource. The value of <code class="literal">notify</code> is the resource to notify about the change, and what that involves depends on the type of resource that's being notified. When it's a service, the default action is to restart the service. (We'll find out about the other options in <a class="link" href="ch04.html" title="Chapter 4. Understanding Puppet resources">Chapter 4</a>, <span class="emphasis"><em>Understanding Puppet resources</em></span>.)</p><p>Usually, with the package-file-service pattern, the file notifies the service, so whenever Puppet changes the contents of the file, it will restart the notified service to pick up the new configuration. If <a id="id51" class="indexterm"/>there are several files that affect the service, they <a id="id52" class="indexterm"/>should all notify the service, and Puppet is smart enough to only restart the service once, however many dependent resources are changed.</p><p>The name of the resource to notify is specified as the resource type, capitalized, followed by the resource title, which is quoted and within square brackets: <code class="literal">Service['mysql']</code>.</p></div><div class="section" title="Resource ordering with require"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Resource ordering with require</h2></div></div></div><p>In the <a id="id53" class="indexterm"/>package-file-service example, we declared three resources: the <code class="literal">mysql-server</code> package, the <code class="literal">/etc/mysql/mysql.cnf</code> file, and the <code class="literal">mysql</code> service. If you think about it, they need to be applied in that order. Without the <code class="literal">mysql-server</code> package installed, there will be no <code class="literal">/etc/mysql/</code> directory to put the <code class="literal">mysql.cnf</code> file in. Without the package or the config file, the <code class="literal">mysql</code> service won't be able to run.</p><p>A perfectly reasonable question to ask is, "Does Puppet apply resources in the same order in which they're declared in the manifest?" The answer is usually yes, unless you explicitly specify a different order, using the <code class="literal">require</code> attribute.</p><p>All resources support the <code class="literal">require</code> attribute, and its value is the name of another resource declared somewhere in the manifest, specified in the same way as when using <code class="literal">notify</code>. Here's the package-file-service example again, this time with the resource ordering specified explicitly using <code class="literal">require</code> (<code class="literal">package_file_service_require.pp</code>):</p><div class="informalexample"><pre class="programlisting">package { 'mysql-server':
  ensure =&gt; installed,
}

file { '/etc/mysql/mysql.cnf':
  source  =&gt; '/examples/files/mysql.cnf',
  notify  =&gt; Service['mysql'],
  require =&gt; Package['mysql-server'],
}

service { 'mysql':
  ensure  =&gt; running,
  enable  =&gt; true,
  require =&gt; [Package['mysql-server'], File['/etc/mysql/mysql.cnf']],
}</pre></div><p>You can see that the <code class="literal">mysql.cnf</code> resource requires the <code class="literal">mysql-server</code> package. The <code class="literal">mysql</code> service requires both the other resources, listed as an array within square brackets.</p><p>When resources are already in the right order, you don't need to use <code class="literal">require</code>, as Puppet will apply the resources in the order you declare them. However, it can be useful to specify an ordering explicitly, for the benefit of those reading the code, especially when there are lots of resources in a manifest file.</p><p>In older versions of <a id="id54" class="indexterm"/>Puppet, resources were applied in a more or less arbitrary order, so it was much more important to express dependencies using <code class="literal">require</code>. Nowadays, you won't need to use it very much, and you'll mostly come across it in legacy code.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Summary</h1></div></div></div><p>In this chapter, we've seen how a manifest is made up of Puppet resources. You've learned how to use Puppet's <code class="literal">file</code> resource to create and modify files, how to install packages using the <code class="literal">package</code> resource, and how to manage services with the <code class="literal">service</code> resource. We've looked at the common package-file-service pattern and seen how to use the <code class="literal">notify</code> attribute on a resource to send a message to another resource indicating that its configuration has been updated. We've covered the use of the <code class="literal">require</code> attribute to make dependencies between resources explicit, when necessary.</p><p>You've also learned to use <code class="literal">puppet resource</code> to inspect the current state of the system according to Puppet, and <code class="literal">puppet describe</code> to get command-line help on all Puppet resources. To check what Puppet would change on the system without actually changing it, we've introduced the <code class="literal">--noop</code> and <code class="literal">--show_diff</code> options to <code class="literal">puppet apply</code>.</p><p>In the next chapter, we'll see how to use the version control tool Git to keep track of your manifests, we'll get an introduction to fundamental Git concepts, such as the repo and the commit, and you'll learn how to distribute your code to each of the servers you're going to manage with Puppet.</p></div></body></html>