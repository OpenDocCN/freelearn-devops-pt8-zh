- en: Chapter 11. Orchestrating cloud resources
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章：编排云资源
- en: '|   | *Rest is not idleness, and to lie sometimes on the grass under trees
    on a summer''s day, listening to the murmur of the water, or watching the clouds
    float across the sky, is by no means a waste of time.* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *休息不是懒散，有时在夏日的树荫下躺在草地上，听着水流的低语，或看着云朵在天空中漂浮，这绝不是浪费时间。* |   |'
- en: '|   | --*John Lubbock* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*约翰·拉博克* |'
- en: In this chapter you'll learn how to use the `puppetlabs/aws` module to create
    and manage Amazon AWS cloud instances, and associated resources such as subnets,
    security groups, and VPCs. You'll also learn how to build your entire cloud infrastructure
    directly from Hiera data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用`puppetlabs/aws`模块来创建和管理Amazon AWS云实例，以及关联的资源，如子网、安全组和VPC。你还将学习如何直接从Hiera数据构建整个云基础设施。
- en: '![Orchestrating cloud resources](img/8880_11_01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![编排云资源](img/8880_11_01.jpg)'
- en: Introducing the cloud
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云的介绍
- en: 'Before exploring the advantages of cloud computing, perhaps we should define
    what it is. In the pre-cloud days, if you needed computing power, you bought an
    actual, physical computer. But from the customer''s point of view, we don''t necessarily
    want a computer: we just want to compute. We would like to be able to buy as much
    or as little compute resource as we happen to need at a given time, without paying
    a large fixed cost for a dedicated computer.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索云计算的优势之前，也许我们应该先定义一下它是什么。在云计算普及之前，如果你需要计算能力，你会购买一台实际的、物理存在的计算机。但从客户的角度来看，我们并不一定想要一台计算机：我们只想要计算能力。我们希望能够根据需要，随时购买所需的计算资源，而不是为一台专用计算机支付高昂的固定费用。
- en: Enter **virtualization**. A single physical server can provide a large number
    of virtual servers, each of which is (in theory) completely isolated from the
    others. The hosting provider builds a platform (consisting of many physical servers
    networked together) which provides, from the customer's point of view, a large
    intangible **cloud** of virtual compute resources (hence the term).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 进入**虚拟化**。一台物理服务器可以提供大量的虚拟服务器，每台虚拟服务器（理论上）彼此完全隔离。托管服务提供商建立了一个平台（由许多物理服务器通过网络连接而成），从客户的角度来看，这个平台提供了一个庞大的、无形的**云**虚拟计算资源（因此得名）。
- en: Automating cloud provisioning
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化云资源配置
- en: 'Creating new cloud instances is cheaper and easier than buying physical hardware,
    but you still have choices to make: how much CPU or memory the instance has, how
    much disk space, what kind of disks (physical, solid-state, network-attached storage),
    what operating system should be installed, whether the instance has a public IP
    address, what firewall rules it should have, and so on.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的云实例比购买物理硬件更便宜、更容易，但你仍然需要做出一些选择：实例的CPU或内存大小，硬盘空间的多少，硬盘的种类（物理硬盘、固态硬盘、网络附加存储），应安装的操作系统，实例是否需要公共IP地址，应该配置哪些防火墙规则等等。
- en: If you've read the book this far in the book, you should now recognize this
    as a **configuration management** problem. You will also probably have some idea
    what I'm going to recommend in order to solve it, but first let's look at a few
    of the available options.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经阅读到本书的这一部分，你应该已经认识到这是一个**配置管理**问题。你可能已经有了一些关于我将推荐什么方案来解决它的想法，但首先让我们来看一下几种可用的选项。
- en: Using CloudFormation
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CloudFormation
- en: 'CloudFormation is a template language specific to **Amazon Web Services** (**AWS**).
    It describes AWS resources in a declarative way, rather like Puppet resources.
    You upload your CloudFormation template to the AWS portal (or API), apply it,
    and AWS will create all the resources specified. The following example shows a
    snippet of CloudFormation code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormation是专门针对**Amazon Web Services**（**AWS**）的模板语言。它以声明的方式描述AWS资源，有点像Puppet资源。你将CloudFormation模板上传到AWS门户（或API），应用它，AWS会创建所有指定的资源。以下示例展示了一段CloudFormation代码：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Frankly, it's not much fun to program in. While it may technically be infrastructure
    as code, it's pretty basic. Nonetheless, it still represents an advance on manually
    setting up AWS infrastructure with a web browser.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 坦率地说，这个编程环境并不怎么有趣。尽管它从技术上来说是基础设施即代码，但它相当基础。尽管如此，它仍然比通过网页浏览器手动设置AWS基础设施有所进步。
- en: Using Terraform
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Terraform
- en: 'Terraform is a rather more sophisticated tool for provisioning cloud resources.
    It allows you to describe your resources in a declarative way, like CloudFormation,
    but at a slightly higher level of abstraction, which is not AWS-specific. The
    following example shows what Terraform code looks like:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 是一个相对复杂的云资源配置工具。它允许你以声明性方式描述资源，像 CloudFormation 一样，但在一个略高的抽象层次上，并且不是
    AWS 特定的。以下示例展示了 Terraform 代码的样子：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Terraform is a promising technology, but it's fair to say it's at an early stage
    of development.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 是一项有前景的技术，但可以说它仍处于开发的早期阶段。
- en: Using Puppet
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Puppet
- en: Stand-alone tools for managing cloud infrastructure are fine, but if we're doing
    everything else with Puppet, it seems a shame to introduce a whole new tool just
    for that. So could we use Puppet to manage cloud resources instead?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 用于管理云基础设施的独立工具是可以的，但如果我们用 Puppet 做其他所有事情，引入一个全新的工具仅仅为了这个似乎有些不值。所以我们能否用 Puppet
    来管理云资源呢？
- en: Fortunately, Puppet provides an excellent Forge module (`puppetlabs/aws`) which
    does exactly this. In the rest of this chapter, we'll work through some examples
    of how to use `puppetlabs/aws` to manage AWS cloud resources.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Puppet 提供了一个优秀的 Forge 模块（`puppetlabs/aws`），它正是为此而设计的。在本章的其余部分，我们将通过一些示例，展示如何使用
    `puppetlabs/aws` 来管理 AWS 云资源。
- en: Setting up an Amazon AWS account
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Amazon AWS 账户
- en: If you already have an AWS account, skip to the next section. Otherwise, you
    can follow these instructions to set up a new account and get the credentials
    you need to start building infrastructure with Puppet.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经拥有 AWS 账户，可以跳到下一部分。否则，你可以按照以下说明设置一个新账户，并获取你开始使用 Puppet 构建基础设施所需的凭证。
- en: Creating an AWS account
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 AWS 账户
- en: 'Follow these steps to create a new AWS account:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个新的 AWS 账户：
- en: 'Browse to the following URL:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到以下 URL：
- en: '[https://aws.amazon.com/](https://aws.amazon.com/)'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://aws.amazon.com/](https://aws.amazon.com/)'
- en: Click **Sign In to the Console**.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **登录到控制台**。
- en: Follow the instructions to create and verify your account.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照指示创建并验证你的账户。
- en: To manage AWS resources using Puppet, we will create an additional AWS user
    account specifically for Puppet, using Amazon's **Identiy and Access Management**
    (**IAM**) framework. We'll see how to do this in the following sections.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 Puppet 管理 AWS 资源，我们将创建一个额外的 AWS 用户账户专门用于 Puppet，使用 Amazon 的 **身份与访问管理**（**IAM**）框架。接下来的章节将演示如何操作。
- en: Creating an IAM policy
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个 IAM 策略
- en: Before we create the user account for Puppet, we need to grant specific permissions
    for the things it needs to do, such as read and create EC2 instances. This involves
    creating an **IAM policy**, which is a set of named permissions you can associate
    with a user account.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 Puppet 用户账户之前，我们需要为它需要执行的任务授予特定权限，例如读取和创建 EC2 实例。这涉及到创建一个 **IAM 策略**，它是一组你可以与用户账户关联的命名权限。
- en: IAM policies are expressed as a JSON-format document. There is a policy JSON
    file in the example repo, named `/examples/iam_policy.json`. Open this file and
    copy the contents, ready to paste into your web browser.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: IAM 策略以 JSON 格式文档的形式表达。在示例仓库中有一个策略 JSON 文件，名为 `/examples/iam_policy.json`。打开此文件并复制其内容，准备粘贴到你的网页浏览器中。
- en: 'Follow these steps to create the policy and associate it with the Puppet user:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建策略并将其与 Puppet 用户关联：
- en: In the AWS console, select **Services** | **IAM**.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 AWS 控制台中，选择 **服务** | **IAM**。
- en: Select **Policies**.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **策略**。
- en: Click **Create Policy**.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **创建策略**。
- en: On the **Create Policy** screen, select **Create Your Own Policy**.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **创建策略** 屏幕上，选择 **创建你自己的策略**。
- en: Enter **Policy Name** (for example, `puppet`).
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 **策略名称**（例如，`puppet`）。
- en: In the **Policy Document** textbox, paste the text you copied from the `iam_policy.json`
    file.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **策略文档** 文本框中，粘贴从 `iam_policy.json` 文件中复制的文本。
- en: Click **Create Policy** at the bottom to save this.![Creating an IAM policy](img/8880_11_02.jpg)
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击底部的 **创建策略** 以保存此设置。![创建 IAM 策略](img/8880_11_02.jpg)
- en: Creating an IAM user
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个 IAM 用户
- en: 'To create the Puppet IAM user and associate it with the policy, follow these
    steps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 Puppet IAM 用户并将其与策略关联，请按照以下步骤操作：
- en: Sign in to the AWS console.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录 AWS 控制台。
- en: Select **Services** | **IAM** | **Users**.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **服务** | **IAM** | **用户**。
- en: Click **Add user**.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **添加用户**。
- en: Enter the username you want to use for this account (for example, `puppet`).
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入你希望用于该账户的用户名（例如，`puppet`）。
- en: In the **Access type** section, select **Programmatic access**.![Creating an
    IAM user](img/8880_11_03.jpg)
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **访问类型** 部分，选择 **编程访问**。![创建 IAM 用户](img/8880_11_03.jpg)
- en: 'Click **Next: Permissions**.'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **下一步：权限**。
- en: Create **Attach existing policies** **directly**.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直接创建**附加现有策略**。
- en: Type `puppet` in the **Policy Type** search box and press *Enter*.![Creating
    an IAM user](img/8880_11_04.jpg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**策略类型**搜索框中输入`puppet`并按*回车*。![创建 IAM 用户](img/8880_11_04.jpg)
- en: 'You should see the policy we created in the previous section, so check the
    box next to it and click **Next: Review**.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该会看到我们在上一节中创建的策略，勾选旁边的框并点击**下一步：审查**。
- en: Check that the settings are correct and click on **Create user**.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查设置是否正确，然后点击**创建用户**。
- en: When you finish creating the IAM user and policy, you should see the **Success**
    screen, which lists your access credentials. Copy the access key ID and the secret
    access key (click **Show** to see the secret access key). You will need these
    credentials for the next steps (but keep them safe).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成创建 IAM 用户和策略后，应该会看到**成功**屏幕，其中列出了您的访问凭证。复制访问密钥 ID 和秘密访问密钥（点击**显示**查看秘密访问密钥）。您将在接下来的步骤中需要这些凭证（但请妥善保管）。
- en: Storing your AWS credentials
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储您的 AWS 凭证
- en: 'Follow these steps to configure your VM for access to AWS with your newly-generated
    credentials:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤配置您的虚拟机以使用新生成的凭证访问 AWS：
- en: 'On your Vagrant VM, run the following command to create the directory to hold
    your credentials file:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 Vagrant 虚拟机上，运行以下命令以创建一个目录来存放凭证文件：
- en: '[PRE2]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a file named `/home/ubuntu/.aws/credentials` with the following contents
    (substitute your Access Key ID and Secret Access Key values from the AWS console
    screen):'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`/home/ubuntu/.aws/credentials`的文件，内容如下（从 AWS 控制台屏幕中替换您的访问密钥 ID 和秘密访问密钥值）：
- en: '[PRE3]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Creating the file manually is fine for this example, but for production use,
    you should manage the credentials file with Puppet using encrypted Hiera data,
    as shown in the *Managing secret data* section in [Chapter 6](ch06.html "Chapter 6. Managing
    data with Hiera"), *Managing data with Hiera*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 手动创建文件在本例中是可以的，但对于生产环境，您应该使用 Puppet 来管理凭证文件，使用加密的 Hiera 数据，如[第6章](ch06.html
    "第6章：使用 Hiera 管理数据")，*使用 Hiera 管理数据*中所示。
- en: Getting ready to use puppetlabs/aws
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备使用 puppetlabs/aws
- en: In the following sections, we'll see how to generate an SSH key pair to connect
    to your EC2 instances, and also install the `puppetlabs/aws` module with its dependencies.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将演示如何生成一个 SSH 密钥对以连接到您的 EC2 实例，并安装`puppetlabs/aws`模块及其依赖项。
- en: Creating a key pair
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建密钥对
- en: You'll need an SSH key pair in order to connect to any EC2 instances you create.
    We will generate and download your key pair in this section.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个 SSH 密钥对才能连接到您创建的任何 EC2 实例。在本节中，我们将生成并下载您的密钥对。
- en: In the AWS console, go to the **EC2** section and select **Key pairs** under
    **Network & Security** in the left pane.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 AWS 控制台中，进入**EC2**部分，在左侧窗格中选择**密钥对**下的**网络与安全**。
- en: Click the **Create Key Pai**r button.![Creating a key pair](img/8880_11_05.jpg)
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建密钥对**按钮。![创建密钥对](img/8880_11_05.jpg)
- en: You will be prompted for the name of your key pair. Enter `pbg` for this example.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统会提示您输入密钥对的名称。对于本示例，请输入`pbg`。
- en: A file named `pbg.pem` will be automatically downloaded by your browser. Move
    this file to your `~/.ssh` directory on your own computer (or copy it to the `ubuntu`
    user's `~/.ssh` directory on the Vagrant VM, if you'd rather access your AWS instances
    from there).
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个名为`pbg.pem`的文件将由浏览器自动下载。将该文件移动到您计算机的`~/.ssh`目录（或者，如果您更愿意从那里访问 AWS 实例，也可以将其复制到
    Vagrant 虚拟机中`ubuntu`用户的`~/.ssh`目录）。
- en: 'Set the correct permissions on the key file with the following command:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令设置密钥文件的正确权限：
- en: '[PRE4]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Installing the puppetlabs/aws module
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 puppetlabs/aws 模块
- en: 'Follow these steps to install the `puppetlabs/aws` module:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤安装`puppetlabs/aws`模块：
- en: 'If you''ve already set up the `r10k` module management tool, as shown in [Chapter
    7](ch07.html "Chapter 7. Mastering modules"), *Mastering modules*, the required
    module will already be installed. If not, run the following commands to install
    it:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经设置了`r10k`模块管理工具，如[第7章](ch07.html "第7章：掌握模块")，*掌握模块*中所示，所需的模块应该已经安装。如果没有，请运行以下命令来安装：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Installing the AWS SDK gem
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 AWS SDK gem
- en: 'The `puppetlabs/aws` module requires a couple of gems, which we can install
    easily using Puppet, with the following manifest (`aws_sdk.pp`):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`puppetlabs/aws`模块需要一些 gems，我们可以使用 Puppet 轻松安装，使用以下清单（`aws_sdk.pp`）：'
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Notice the `provider => puppet_gem` in that example? You might remember from
    [Chapter 4](ch04.html "Chapter 4. Understanding Puppet resources"), *Understanding
    Puppet resources*, that `puppet_gem` installs a Ruby gem in Puppet's context (as
    opposed to the system Ruby context, which is completely separate). Gems which
    are required by Puppet modules need to be installed in this way or Puppet won't
    be able to load them.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到示例中的 `provider => puppet_gem` 吗？你可能还记得在[第4章](ch04.html "Chapter 4. Understanding
    Puppet resources")，*理解 Puppet 资源* 中提到过，`puppet_gem` 会在 Puppet 环境中安装 Ruby gem（与系统
    Ruby 环境完全独立）。Puppet 模块所需的 gem 需要这样安装，否则 Puppet 无法加载它们。
- en: 'Apply the manifest with the following command:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令应用清单：
- en: '[PRE7]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create the `/home/ubuntu/.aws/config` file with the following contents:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `/home/ubuntu/.aws/config` 文件，并添加以下内容：
- en: '[PRE8]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Creating EC2 instances with Puppet
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Puppet 创建 EC2 实例
- en: Although you can manage many different types of AWS resources with Puppet, the
    most important is the EC2 instance (the virtual server). In this section, we'll
    see how to create your first EC2 instance.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以使用 Puppet 管理许多不同类型的 AWS 资源，但最重要的资源是 EC2 实例（虚拟服务器）。在这一部分，我们将学习如何创建你的第一个
    EC2 实例。
- en: Choosing an Amazon Machine Image (AMI)
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择 Amazon Machine Image (AMI)
- en: In order to run an EC2 instance, which is to say an AWS virtual machine, you
    need to choose which virtual machine to run out of the many thousands available.
    Each virtual machine snapshot is called an **Amazon Machine Image** (**AMI**)
    and has a unique ID. It's this ID that you will add to your Puppet manifest to
    tell it what kind of instance to start.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行 EC2 实例，即 AWS 虚拟机，你需要从众多可用的虚拟机中选择一个。每个虚拟机快照称为 **Amazon Machine Image**（**AMI**），并且有一个唯一的
    ID。你将使用这个 ID 添加到 Puppet 清单中，以告知它要启动哪种类型的实例。
- en: 'It doesn''t matter much for the purposes of this example which AMI you choose,
    but we''ll be using an official Ubuntu image. To find one, follow these steps:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本示例，选择哪个 AMI 并不太重要，但我们将使用官方的 Ubuntu 镜像。按照以下步骤查找：
- en: 'Browse to the following URL:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到以下 URL：
- en: '[https://cloud-images.ubuntu.com/locator/ec2/](https://cloud-images.ubuntu.com/locator/ec2/)'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://cloud-images.ubuntu.com/locator/ec2/](https://cloud-images.ubuntu.com/locator/ec2/)'
- en: In the **Search** box, enter `us-east-1 xenial`
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Search** 框中，输入 `us-east-1 xenial`
- en: You should see a list of Ubuntu Xenial AMIs in the `us-east-1` region, of various
    instance types, looking something like the following screenshot:![Choosing an
    Amazon Machine Image (AMI)](img/8880_11_06.jpg)
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该能看到 `us-east-1` 区域中列出的 Ubuntu Xenial AMI，它们有不同的实例类型，类似以下截图：![选择 Amazon Machine
    Image (AMI)](img/8880_11_06.jpg)
- en: Find an AMI in the list whose **Instance Type** is `ebs-ssd`. In the preceding
    screenshot, the third AMI in the list (`ami-26d6d131`) is suitable.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表中找到 **Instance Type** 为 `ebs-ssd` 的 AMI。在之前的截图中，列表中的第三个 AMI（`ami-26d6d131`）是合适的。
- en: The hexadecimal code in the `AMI-ID` column, starting `ami-` is the AMI ID.
    Make a note of this for later. Click the link to see the AWS instance type selection
    page, and check that the AMI you've selected has a label saying **Free tier eligible**;
    these AMIs do not incur charges. If you start an instance of a non-free-tier AMI,
    you will be charged for it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`AMI-ID` 列中的十六进制代码，以 `ami-` 开头，就是 AMI ID。请记下这个 ID 以备后用。点击链接查看 AWS 实例类型选择页面，并确认你选择的
    AMI 上有标记 **Free tier eligible**；这些 AMI 不会产生费用。如果启动非免费层的 AMI 实例，你将会被收费。'
- en: Creating the EC2 instance
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 EC2 实例
- en: Now we have chosen a suitable AMI, we're ready to create an EC2 instance with
    Puppet.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经选择了合适的 AMI，准备使用 Puppet 创建 EC2 实例。
- en: 'Before we can do that, however, we need to make a couple of changes to the
    AWS settings, so follow these steps:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在此之前，我们需要对 AWS 设置做一些更改，请按照以下步骤操作：
- en: In the AWS console, select **VPC** from the **Services** menu.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 AWS 控制台中，从 **Services** 菜单中选择 **VPC**。
- en: Select **Your VPCs** in the left pane.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧窗格中选择 **Your VPCs**。
- en: There will be only one VPC listed. Click in the **Name** field and set its name
    to `default-vpc`
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将只列出一个 VPC。点击 **Name** 字段并将其名称设置为 `default-vpc`
- en: Select **Subnets** in the left pane.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧窗格中选择 **Subnets**。
- en: There will be several subnets listed, one for each availability zone. Find the
    one associated with the `us-east-1a` availability zone.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 会列出几个子网，每个子网对应一个可用区。找到与 `us-east-1a` 可用区相关联的子网。
- en: Click the subnet's **Name** field and set the name to `default-subnet`
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击子网的 **Name** 字段，并将名称设置为 `default-subnet`
- en: Tip
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Why do we have to set names for the VPC and subnet before running the example?
    The `puppetlabs/aws` module refers to resources by their 'name', which is an arbitrary
    string, rather than their ID, which is a long hexadecimal code like the AMI ID.
    Although AWS creates a default VPC and subnet for you automatically, it doesn't
    assign them a name, which means we can't refer to them in Puppet code until we've
    set names for them. It doesn't matter what the names actually are so long as the
    name in your Puppet code is the same as the name assigned in the AWS control panel.
    We'll find out more about what VPCs and subnets do, and how to use them, later
    in the chapter.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为什么在运行示例之前我们必须为 VPC 和子网设置名称？`puppetlabs/aws` 模块通过资源的“名称”来引用它们，而不是通过其 ID（像 AMI
    ID 这样的长十六进制代码）。尽管 AWS 会自动为你创建默认的 VPC 和子网，但它不会为它们分配名称，这意味着在我们为它们设置名称之前，我们无法在 Puppet
    代码中引用它们。只要你在 Puppet 代码中的名称与 AWS 控制面板中分配的名称相同，名称的具体内容并不重要。我们将在本章后面了解更多关于 VPC 和子网的功能以及如何使用它们。
- en: 'Edit the file `/examples/aws_instance.pp`, and change the value of `$ami` in
    the first line to the AMI ID you picked earlier (in our example, `ami-26d6d131`):'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑文件 `/examples/aws_instance.pp`，并将第一行中的 `$ami` 的值更改为你之前选择的 AMI ID（在我们的示例中是
    `ami-26d6d131`）：
- en: '[PRE9]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Save the file, and run the following command:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，并运行以下命令：
- en: '[PRE10]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You should see some output from Puppet like the following:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该会看到类似下面的 Puppet 输出：
- en: '[PRE11]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you check the **EC2** section of the AWS console, you should see that your
    new instance's status is **Initializing**, and it will soon be ready to use.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你检查 AWS 控制台中的 **EC2** 部分，你应该看到你的新实例的状态为 **初始化中**，很快就会准备好使用。
- en: Accessing your EC2 instance
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问你的 EC2 实例
- en: Once the status of the newly-launched instance has changed from **Initializing**
    to **Running** (you may need to click the refresh button on the AWS console),
    you can connect to it using SSH and the key file you downloaded earlier.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦新创建的实例的状态从 **初始化中** 变为 **运行中**（你可能需要点击 AWS 控制台中的刷新按钮），你就可以使用 SSH 和之前下载的密钥文件连接到它。
- en: In the AWS console, look for the **Public IP** address of the instance and copy
    it.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 AWS 控制台中，查找实例的**公共 IP** 地址并复制它。
- en: 'From your own machine (or from the Vagrant VM if you copied the `pbg.pem` file
    to it) run the following command (replace `YOUR_INSTANCE_IP` with the public IP
    of the instance):'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你自己的机器（或者如果你将 `pbg.pem` 文件复制到 Vagrant VM 上，从 Vagrant VM 中）运行以下命令（将 `YOUR_INSTANCE_IP`
    替换为实例的公共 IP 地址）：
- en: '[PRE12]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Now that you have SSH access to the instance, you can bootstrap it with Puppet
    in the same way as for physical nodes, or just install Puppet and Git manually
    and check out the manifest repo. (We'll develop a complete, automated bootstrap
    process in [Chapter 12](ch12.html "Chapter 12. Putting it all together"), *Putting
    it all together*.)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经获得了实例的 SSH 访问权限，你可以像对待物理节点一样使用 Puppet 对其进行引导，或者手动安装 Puppet 和 Git，并检查清单仓库。（我们将在[第12章](ch12.html
    "第12章：整合所有内容")中开发一个完整的自动化引导过程，*整合所有内容*。）
- en: Congratulations! You've just created your first EC2 instance with Puppet. In
    the next section, we'll look at the code and examine the resources in detail.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你！你刚刚用 Puppet 创建了你的第一个 EC2 实例。在下一节中，我们将查看代码并详细检查资源。
- en: VPCs, subnets, and security groups
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VPC、子网和安全组
- en: Let's go through the example manifest and see how it works. But first, we need
    to know something about AWS resources.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过示例清单来看一下它是如何工作的。但首先，我们需要了解一些关于 AWS 资源的信息。
- en: An EC2 **instance** lives inside a **subnet**, which is a self-contained virtual
    network. All instances within the subnet can communicate with each other. Subnets
    are partitions of a **Virtual Private Cloud** (**VPC**), which is a private internal
    network specific to your AWS account.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 EC2 **实例**位于一个**子网**中，子网是一个自包含的虚拟网络。所有位于子网内的实例可以相互通信。子网是**虚拟私有云**（**VPC**）的划分，VPC
    是特定于你 AWS 账户的私有内部网络。
- en: An instance also has a **security group**, which is a set of firewall rules
    governing network access to the instance.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 实例还拥有一个**安全组**，它是一组管理网络访问实例的防火墙规则。
- en: When you create an AWS account, you get a default VPC, divided into subnets
    for each AWS **availability zone** (**AZ**). We are using the default VPC and
    one of the default subnets for the example instance, but since we also need a
    security group, we create that first in Puppet code.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建 AWS 账户时，你会获得一个默认的 VPC，该 VPC 被划分为多个子网，每个 AWS **可用区**（**AZ**）一个。我们在示例实例中使用的是默认
    VPC 和其中一个默认子网，但由于我们还需要一个安全组，因此我们首先在 Puppet 代码中创建它。
- en: The ec2_securitygroup resource
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ec2_securitygroup 资源
- en: 'The first part of the example manifest creates the required `ec2_securitygroup`
    resource (`aws_instance.pp`):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 示例清单的第一部分创建了所需的`ec2_securitygroup`资源（`aws_instance.pp`）：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: First of all, an `ec2_securitygroup` has a title (`pbg-sg`) which we will use
    to refer to it from other resources (such as the `ec2_instance` resource). It
    also has a `description`, which is just to remind us what it's for.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`ec2_securitygroup`有一个标题（`pbg-sg`），我们将使用这个标题从其他资源（如`ec2_instance`资源）引用它。它还有一个`description`，仅仅是为了提醒我们它的用途。
- en: It is part of a `region` and a `vpc`, and has an array of `ingress` rules. These
    are your firewall rules. Each firewall port or protocol you want to allow needs
    a separate ingress rule.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 它属于一个`region`和一个`vpc`，并具有一组`ingress`规则。这些是你的防火墙规则。你希望允许的每个防火墙端口或协议都需要单独的入口规则。
- en: 'Each ingress rule is a hash like the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 每个入口规则都是类似以下内容的哈希：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `protocol` specifies the type of traffic (`tcp`, `udp`, and so on).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`protocol`指定了流量类型（`tcp`、`udp`等）。'
- en: The `port` is the port number to open (`22` is the SSH port, which we'll need
    in order to log in to the instance).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`port`是要打开的端口号（`22`是SSH端口，我们需要它来登录到实例）。'
- en: Finally, the `cidr` key specifies the range of network addresses to allow access
    to. (`0.0.0.0/0` means 'all addresses'.)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`cidr`键指定了允许访问的网络地址范围。 (`0.0.0.0/0`表示“所有地址”。)
- en: The ec2_instance resource
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ec2_instance`资源'
- en: 'The `ec2_instance` resource, as you''d expect, manages an individual EC2 instance.
    Here''s the relevant section of the example manifest (`aws_instance.pp`):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`ec2_instance`资源，顾名思义，用于管理单个EC2实例。以下是示例清单（`aws_instance.pp`）中的相关部分：'
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First, `ensure => present` tells AWS that the instance should be running. (You
    can also use `running` as a synonym for `present`.) Setting `ensure => absent`
    will terminate and delete the instance (and any ephemeral storage attached to
    it).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`ensure => present`告诉AWS该实例应该处于运行状态。（你也可以使用`running`作为`present`的同义词。）将`ensure
    => absent`设置为会终止并删除实例（以及任何附加的临时存储）。
- en: EC2 instances can also be in a third state, `stopped`. Stopped instances preserve
    their storage and can be restarted. Because AWS bills by the instance-hour, you
    don't pay for instances that are stopped, so it's a good idea to stop any instances
    that don't need to be running right now.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: EC2实例还可以处于第三种状态，即`stopped`。停止的实例会保留其存储，并可以重新启动。由于AWS按实例小时计费，因此停止的实例不需要付费，所以最好停止不需要立即运行的实例。
- en: The instance is part of a `region` and a `subnet`, and has one or more `security_groups`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 实例属于一个`region`和一个`subnet`，并且具有一个或多个`security_groups`。
- en: The `image_id` attribute tells AWS which AMI ID to use for the instance.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`image_id`属性告诉AWS为实例使用哪个AMI ID。'
- en: The `instance_type` attribute selects from AWS's large range of types, which
    more or less correspond to the computing power of the instance (different types
    vary in memory size and the number of virtual CPUs, and a few other factors).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`instance_type`属性从AWS提供的多种类型中进行选择，这些类型大致对应于实例的计算能力（不同类型在内存大小、虚拟CPU数量以及其他一些因素上有所不同）。'
- en: As we're inside a private network, instances will not be reachable from the
    Internet unless we assign them a public IP address. Setting `associate_public_ip_address`
    to `true` enables this feature. (You should set this to `false` unless the instance
    actually needs to expose a port to the Internet.)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们处于一个私有网络中，实例无法从互联网访问，除非我们为其分配公共IP地址。将`associate_public_ip_address`设置为`true`启用此功能。（除非实例确实需要暴露端口到互联网，否则应将其设置为`false`。）
- en: Finally, the instance has a `key_name` attribute which tells AWS which SSH key
    we are going to use to access it. In this case, we're using the key we created
    earlier in the chapter, named `pbg`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，实例有一个`key_name`属性，它告诉AWS我们将使用哪个SSH密钥来访问该实例。在这种情况下，我们使用的是在本章前面创建的名为`pbg`的密钥。
- en: Tip
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Before going on to the next example, terminate your instance to avoid using
    up your free hours. You can do this by selecting the instance in the AWS control
    panel and clicking **Actions** | **Instance State** | **Terminate**, or reapplying
    your Puppet manifest with the instance's `ensure` attribute set to `absent`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一个示例之前，请终止实例以避免浪费免费小时。你可以通过在AWS控制面板中选择实例，然后点击**操作** | **实例状态** | **终止**，或者重新应用Puppet清单，将实例的`ensure`属性设置为`absent`来实现。
- en: Managing custom VPCs and subnets
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理自定义VPC和子网
- en: In the previous example, we used the pre-existing default VPC and subnet to
    create our instance. That's fine for demonstration purposes, but in production
    you'll want to use a dedicated VPC for your Puppet-managed resources, to keep
    it separate from any other resources in your AWS account, and from other Puppet-managed
    VPCs. You could, for example, have a staging VPC and a production VPC.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了预先存在的默认VPC和子网来创建实例。对于演示目的来说这样是可以的，但在生产环境中，您会希望使用专用的VPC来管理您的Puppet资源，以便将其与AWS账户中的其他资源以及其他Puppet管理的VPC区分开来。例如，您可以有一个暂存VPC和一个生产VPC。
- en: By default, a new VPC has no access to the Internet; we'll also need an **Internet
    gateway** (which routes Internet traffic to and from the VPC) and a **route table**
    (which tells a given subnet to send non-local traffic to the gateway). The `puppetlabs/aws`
    module provides Puppet resources to create and manage each of these entities.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，新的VPC无法访问Internet；我们还需要一个**Internet网关**（它将Internet流量路由到VPC并从VPC返回）和一个**路由表**（它告诉某个子网将非本地流量发送到网关）。`puppetlabs/aws`模块提供了用于创建和管理这些实体的Puppet资源。
- en: Creating an instance in a custom VPC
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在自定义VPC中创建实例
- en: In this section, we'll use a more sophisticated example manifest to create a
    new VPC and subnet, with an associated Internet gateway and route table, then
    add a security group and EC2 instance.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用一个更复杂的示例清单来创建一个新的VPC和子网，并与之关联一个Internet网关和路由表，然后添加一个安全组和EC2实例。
- en: 'Follow these steps to apply the manifest:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤应用清单：
- en: 'Edit the file `/examples/aws_vpc.pp` and change the value of `$ami` in the
    first line to the AMI ID you picked earlier (in our example, `ami-26d6d131`):'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑文件`/examples/aws_vpc.pp`，并将第一行中的`$ami`值更改为您之前选择的AMI ID（在我们的示例中，`ami-26d6d131`）：
- en: '[PRE16]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Save the file and run the following command:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并运行以下命令：
- en: '[PRE17]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You should see some output from Puppet like the following:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该会看到如下Puppet输出：
- en: '[PRE18]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you check the **EC2** section of the AWS console, you should see that your
    new instance status is **Initializing**, and it will soon be ready to use.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您检查AWS控制台的**EC2**部分，您应该会看到新实例的状态是**初始化中**，很快就可以使用了。
- en: The ec2_vpc resource
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ec2_vpc资源
- en: 'Let''s look at the example manifest in detail. Here''s the `ec2_vpc` resource
    (`aws_vpc.pp`):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看一下示例清单。以下是`ec2_vpc`资源（`aws_vpc.pp`）：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The VPC requires a `region` attribute and `cidr_block`, which is the range of
    network addresses that the VPC will use. (Actually, this isn't required, as AWS
    will allocate you one at random if you don't specify it. We specify one here just
    for the demonstration.)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: VPC需要一个`region`属性和`cidr_block`，即VPC将使用的网络地址范围。（实际上，这不是必须的，因为如果不指定，AWS会随机为您分配一个。我们在这里指定一个仅用于演示。）
- en: Tip
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It doesn't matter what your network range actually is, as it's entirely internal.
    However, it's good practice to use one of the address ranges officially assigned
    to private networks, such as `10.x.y.z`. To make it less likely that your range
    will conflict with any other assigned in your organization, pick a random number
    for `x` (we've used `99` in the example).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您的网络范围并不重要，因为它完全是内部的。然而，采用官方分配给私有网络的地址范围（如`10.x.y.z`）是一种好习惯。为了减少与您组织中其他分配地址范围发生冲突的可能性，您可以为`x`选择一个随机数字（我们在示例中使用了`99`）。
- en: The ec2_vpc_internet_gateway resource
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ec2_vpc_internet_gateway资源
- en: 'We saw earlier that a VPC, by default, is not connected to the Internet. There
    are various ways to get Internet traffic into the VPC, including VPNs and Amazon
    **Elastic** **Load Balancers** (**ELB**), but for this example, we''ll use an
    `ec2_vpc_internet_gateway` resource, which looks like the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到，VPC默认情况下是无法连接到Internet的。将Internet流量引入VPC的方式有很多，包括VPN和Amazon **Elastic**
    **Load Balancers**（**ELB**），但在本示例中，我们将使用`ec2_vpc_internet_gateway`资源，其格式如下：
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The gateway has a title (`pbg-igw`), and it is associated with a particular
    `region` and `vpc`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 网关有一个标题（`pbg-igw`），并且与特定的`region`和`vpc`关联。
- en: The ec2_vpc_routetable resource
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ec2_vpc_routetable资源
- en: 'Having provisioned an `ec2_vpc_internet_gateway`, we now need to set up a route
    table to determine which traffic to send to it. Here is the `ec2_vpc_routetable`
    resource from the example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置了`ec2_vpc_internet_gateway`后，我们现在需要设置一个路由表，以确定哪些流量需要发送到它。以下是示例中的`ec2_vpc_routetable`资源：
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As usual, a route table has a title, `region`, and `vpc`. It also has an array
    of one or more routes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，路由表有一个标题，`region`和`vpc`。它还包含一个或多个路由的数组。
- en: A **route** is like a road sign for network packets. It says, "if you're heading
    for this destination, take this junction." Each route in the array is a hash containing
    a `destination_cidr_block` and `gateway` key.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由**就像是网络数据包的路标。它告诉你：“如果你要去这个目的地，请走这个路口。”每一条路由都是一个哈希表，包含`destination_cidr_block`和`gateway`键。'
- en: 'The first route in our example is for local traffic (destined for the `10.99.0.0/16`
    network, which is the network we assigned to our VPC):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们示例中的第一条路由是用于本地流量的（目的地为`10.99.0.0/16`网络，这是我们分配给VPC的网络）：
- en: '[PRE22]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This tells traffic for the `10.99.0.0/16` network that it is local; that is,
    there's no need to use a gateway, because it's already on the desired network.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉目的地为`10.99.0.0/16`的流量它是本地流量；也就是说，不需要使用网关，因为它已经在所需的网络上。
- en: 'The second route is for all other traffic:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条路由是针对所有其他流量的：
- en: '[PRE23]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The network address `0.0.0.0/0` matches all possible network addresses (traffic
    for `10.99.0.0/16` will already have been filtered out by the previous route,
    so we are left with all other traffic, which must be for the Internet). The designated
    gateway is `pbg-igw`, which is the `ec2_vpc_internet_gateway` we created earlier.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 网络地址`0.0.0.0/0`匹配所有可能的网络地址（`10.99.0.0/16`的流量已经通过之前的路由被过滤掉，所以剩下的所有流量必须是互联网流量）。指定的网关是`pbg-igw`，即我们之前创建的`ec2_vpc_internet_gateway`。
- en: 'So this route table equates to the following instructions for routing traffic:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这个路由表等同于以下的流量路由指令：
- en: Traffic for `10.99.0.0/16`, stay on this network
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目的地为`10.99.0.0/16`的流量，保持在此网络内
- en: All other traffic, please proceed to the `pbg-igw` gateway
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有其他流量，请通过`pbg-igw`网关
- en: These routes will suffice for a single VPC; if you have a more complicated network
    setup in AWS, you will need a more complicated route table, but the principles
    will be the same.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这些路由对于单个VPC来说已经足够；如果你在AWS中有更复杂的网络配置，你将需要更复杂的路由表，但基本原则是相同的。
- en: The ec2_vpc_subnet resource
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ec2_vpc_subnet`资源'
- en: A subnet, as we've seen, is a subdivision of the VPC network, which enables
    you to logically partition your VPC for different groups of resources. For example,
    you might have one subnet which is accessible from the Internet for public-facing
    nodes, and another for internal resources such as database or log servers.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，子网是VPC网络的一个子部分，它使你能够为不同的资源组逻辑地划分VPC。例如，你可能有一个子网，它可以通过互联网访问，供公共节点使用，另一个子网则供内部资源使用，如数据库或日志服务器。
- en: 'In the example we just have one subnet:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们只有一个子网：
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It has a title, `vpc`, and `region`. Because it is a subdivision of the VPC
    network, it also needs a `cidr_block` specifying exactly which part of the network
    address space it occupies. This must be a subdivision of the network address you
    assigned to the containing VPC, as indeed it is in this example.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个标题，`vpc`和`region`。因为它是VPC网络的一个子部分，它还需要一个`cidr_block`来指定它占用网络地址空间的具体部分。这必须是你分配给包含VPC的网络地址的子集，就像在这个示例中一样。
- en: A subnet exists within an AWS availability zone (equivalent to a data center).
    These are named after their region; for example, the `us-east-1` region has availability
    zones `us-east-1a`, `us-east-1b`, and so on. This allows you to provision redundant
    resources in different availability zones, so that if one should fail, the other
    can take over. For this example, however, we're using just one availability zone,
    `us-east-1a`, which we pass to the `availability_zone` attribute.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 子网存在于AWS的可用区内（相当于数据中心）。这些可用区以区域命名；例如，`us-east-1`区域有`us-east-1a`、`us-east-1b`等可用区。这使得你可以在不同的可用区中配置冗余资源，以便在一个可用区故障时，另一个可用区能够接管。然而，在这个示例中，我们只使用了一个可用区`us-east-1a`，并将其传递给`availability_zone`属性。
- en: By default, resources in a subnet can only communicate within the subnet. To
    allow traffic in and out of the subnet, we need to associate it with `route_table`.
    By using the `pbg-rt` route table we created earlier, we can send Internet traffic
    via the `pbg-igw` gateway.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，子网中的资源只能在子网内进行通信。为了允许子网内外的流量通信，我们需要将其与`route_table`关联。通过使用我们之前创建的`pbg-rt`路由表，我们可以通过`pbg-igw`网关发送互联网流量。
- en: And that's it. The `ec2_securitygroup` and `ec2_instance` resources are more
    or less the same as in our earlier example, except for using the new subnet.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。`ec2_securitygroup`和`ec2_instance`资源和我们之前的示例差不多，唯一不同的是使用了新的子网。
- en: Other AWS resource types
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他AWS资源类型
- en: 'Puppet is not limited to managing EC2 instances; the `puppetlabs/aws` module
    also supports ELB load balancers, Cloudwatch alarms, auto scaling groups, Elastic
    IPs, DHCP, VPNs, IAM users and policies, RDS databases, S3 storage buckets, SQS
    queues, Route 53 DNS management, and the **EC2 Container Service** (**ECS**).
    Due to constraints of space, time, and energy, I have not provided examples for
    all of these, but you can consult the module''s admirably comprehensive documentation
    at this URL:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet不仅仅限于管理EC2实例；`puppetlabs/aws`模块还支持ELB负载均衡器、Cloudwatch警报、自动扩展组、弹性IP、DHCP、VPN、IAM用户和策略、RDS数据库、S3存储桶、SQS队列、Route
    53 DNS管理和**EC2容器服务**（**ECS**）。由于空间、时间和精力的限制，我没有提供所有这些的示例，但你可以查阅该模块极为全面的文档，网址如下：
- en: '[https://forge.puppet.com/puppetlabs/aws](https://forge.puppet.com/puppetlabs/aws)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://forge.puppet.com/puppetlabs/aws](https://forge.puppet.com/puppetlabs/aws)'
- en: Provisioning AWS resources from Hiera data
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Hiera数据中配置AWS资源
- en: There's nothing wrong with managing AWS resources directly in the code, as we've
    done in the previous examples, but we can do just a little bit better.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 直接在代码中管理AWS资源没有任何问题，就像我们在前面的示例中做的那样，但我们可以做得稍微更好一点。
- en: 'In [Chapter 6](ch06.html "Chapter 6. Managing data with Hiera"), *Managing
    data with Hiera*, we saw how to create Puppet resources directly from Hiera data.
    In that example (*Building resources from Hiera hashes*), we stored all the users
    for our infrastructure in a Hiera hash called `users`, and then used the `each`
    keyword to iterate over that hash, creating a user resource for each user. Here''s
    the example code again (`hiera_users2.pp`):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章 管理Hiera中的数据")，*使用Hiera管理数据*中，我们展示了如何直接从Hiera数据创建Puppet资源。在那个例子中（*从Hiera哈希创建资源*），我们将所有基础设施的用户存储在一个名为`users`的Hiera哈希中，然后使用`each`关键字迭代该哈希，为每个用户创建一个用户资源。以下是再次展示的示例代码（`hiera_users2.pp`）：
- en: '[PRE25]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The magic `*` character (the **attribute splat operator**) tells Puppet to use
    the contents of the `$attrs` hash as the attributes of the resource.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 魔术字符`*`（**属性展开操作符**）告诉Puppet将`$attrs`哈希的内容作为资源的属性。
- en: The advantage of describing resources as Hiera data is that when we come to
    add a new user, or change the details for an existing user, we don't need to touch
    Puppet code at all. Everything is defined in Hiera.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 将资源描述为Hiera数据的优点在于，当我们需要添加一个新用户或更改现有用户的详细信息时，根本不需要触及Puppet代码。一切都在Hiera中定义。
- en: Iterating over Hiera data to create resources
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历Hiera数据以创建资源
- en: Alert readers may be wondering, "Couldn't we do the same thing with all these
    AWS resources? Can we just define everything in a Hiera hash and have Puppet iterate
    over it to create the resources?"
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 读者可能会问：“我们能不能用这些AWS资源做同样的事情？能不能直接在Hiera哈希中定义所有内容，然后让Puppet迭代它来创建资源？”
- en: 'Indeed we can. The manifest to create all these resources is surprisingly concise
    (`aws_hiera.pp`):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以这么做。用于创建所有这些资源的清单出奇地简洁（`aws_hiera.pp`）：
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To apply the manifest, follow these steps:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用清单，请按照以下步骤操作：
- en: 'Edit the Hiera data file `aws.yaml` and change the value of the `ami:` setting
    in the first line to the AMI ID you picked earlier (in our example, `ami-26d6d131`):'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑Hiera数据文件`aws.yaml`，并将第一行中`ami:`设置的值更改为你之前选择的AMI ID（在我们的示例中是`ami-26d6d131`）：
- en: '[PRE27]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Save the file and run the following command:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并运行以下命令：
- en: '[PRE28]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you've already run the previous example and the AWS resources are still present,
    you'll see no output from Puppet, because the resources are exactly the same.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经运行了前面的示例并且AWS资源仍然存在，你将不会看到Puppet的任何输出，因为这些资源完全相同。
- en: Note
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember, if the state of the system is already the same as the desired state
    expressed in the manifest, Puppet will do nothing.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果系统的状态已经与清单中表达的期望状态相同，Puppet将不会做任何事情。
- en: If you want to prove to yourself that the example manifest really works, delete
    the resources using the AWS control panel (or use Puppet to delete them by changing
    `present` to `absent` in the Hiera data) and reapply the manifest.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想证明示例清单确实有效，可以使用AWS控制面板删除资源（或通过将Hiera数据中的`present`更改为`absent`来使用Puppet删除它们），然后重新应用清单。
- en: 'If you compare the manifest to that from the Hiera users example, you can see
    that instead of a single loop, it consists of two nested loops. The outer loop
    iterates over the contents of the `$aws_resources` hash:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将该清单与Hiera用户示例中的清单进行比较，你会发现它由两个嵌套的循环组成，而不是一个单独的循环。外部循环遍历`$aws_resources`哈希的内容：
- en: '[PRE29]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Each key of the `$aws_resources` hash is the name of a Puppet resource type.
    Here''s the first one (from `hiera_aws.yaml`):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`$aws_resources`哈希的每个键都是一个Puppet资源类型的名称。以下是第一个（来自`hiera_aws.yaml`）：'
- en: '[PRE30]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'So the first time round this loop, the value of `$r_type` will be `ec2_vpc`,
    and the value of `$resources` will be this hash:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在第一次循环时，`$r_type`的值将是`ec2_vpc`，而`$resources`的值将是这个哈希：
- en: '[PRE31]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now we enter the inner loop, which creates all the resources of type `$r_type`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们进入内循环，创建所有类型为`$r_type`的资源：
- en: '[PRE32]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As it happens, there is only one `ec2_vpc` resource, so the first time round
    the inner loop, the value of `$r_title` will be `pbg-vpc`, and the value of `$attrs`
    will be this hash:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 实际情况是，只有一个`ec2_vpc`资源，因此在第一次循环时，`$r_title`的值将是`pbg-vpc`，而`$attrs`的值将是这个哈希：
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'So Puppet will create this resource:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 所以Puppet将创建这个资源：
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is identical to the `ec2_vpc` resource in the previous example, and as
    we go round the outer loop we will create the other resources in the same way.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这与前面示例中的`ec2_vpc`资源相同，在我们遍历外部循环时，我们将以相同的方式创建其他资源。
- en: 'What''s `Resource[$r_type]`? This is a bit of Puppet wizardry. The problem
    is that we need to declare a Puppet resource whose type we don''t know yet; it
    will be supplied by the `$r_type` variable. You might at first try using a syntax
    like the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`Resource[$r_type]`是什么？这是一种Puppet的技巧。问题在于我们需要声明一个其类型我们还不知道的Puppet资源；它将由`$r_type`变量提供。你可能最初会尝试使用类似以下的语法：'
- en: '[PRE35]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Unfortunately, Puppet doesn't allow this syntax, but there is a way to get round
    the problem. The abstract data type `Resource` matches any resource type (you
    can read more about Puppet data types in [Chapter 8](ch08.html "Chapter 8. Classes,
    roles, and profiles"), *Classes, roles, and profiles*).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Puppet不允许这种语法，但有一种方法可以绕过这个问题。抽象数据类型`Resource`匹配任何资源类型（你可以在[第8章](ch08.html
    "第8章 类、角色和配置文件")，*类、角色和配置文件*中了解更多关于Puppet数据类型的信息）。
- en: 'We can make `Resource` more specific by including the actual resource type
    in square brackets: `Resource[''ec2_vpc'']`. This is valid syntax for declaring
    a resource.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在方括号中包含实际的资源类型来使`Resource`更具体：`Resource['ec2_vpc']`。这是声明资源的有效语法。
- en: 'So this is how we declare a resource whose type comes from a variable:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是我们声明一个其类型来自变量的资源的方法：
- en: '[PRE36]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now that your AWS resources are described by Hiera data, it should be much easier
    to maintain and extend them as you use Puppet in production.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由Hiera数据描述的AWS资源应该更容易维护和扩展，当你在生产中使用Puppet时。
- en: Cleaning up unused resources
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理未使用的资源
- en: 'To close down your EC2 instance, and thus avoid using up your free hours or
    being billed for the instance, edit your Hiera data to set `ensure: absent` on
    the `ec2_instance` resource:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了关闭你的EC2实例，从而避免使用你的免费小时数或被收费，编辑你的Hiera数据，将`ec2_instance`资源的`ensure`设置为`absent`：
- en: '[PRE37]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When you reapply the manifest, Puppet will stop the instance. You can leave
    other resources in place, as they don't incur charges.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重新应用清单时，Puppet将停止该实例。你可以保持其他资源不变，因为它们不会产生费用。
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've introduced the basic idea of cloud computing, and looked
    at some options for managing cloud resources, including CloudFormation and Terraform,
    before meeting the `puppetlabs/aws` module.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了云计算的基本概念，并考察了管理云资源的一些选项，包括CloudFormation和Terraform，然后介绍了`puppetlabs/aws`模块。
- en: We've worked through the process of creating an AWS account, setting up an IAM
    user and policy, generating credentials and SSH keys, installing the AWS SDK gem,
    and choosing a suitable AMI (Amazon Machine Image).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了创建AWS账户、设置IAM用户和策略、生成凭证和SSH密钥、安装AWS SDK gem以及选择合适的AMI（Amazon机器映像）的过程。
- en: Using Puppet, we've created an EC2 instance and security group, and seen how
    to connect to the running instance with SSH. Going further, we've created a whole
    VPC from scratch, complete with subnets, Internet gateway, route table, security
    group, and EC2 instance.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Puppet，我们创建了一个EC2实例和安全组，并且看到了如何使用SSH连接到运行中的实例。更进一步，我们从头开始创建了整个VPC，包括子网、互联网网关、路由表、安全组和EC2实例。
- en: Lastly, we've seen how to build all these cloud resources directly from Hiera
    data, which is the most flexible and powerful way to describe Puppet resources.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经看到如何直接从Hiera数据构建所有这些云资源，这种方式是描述Puppet资源最灵活和强大的方法。
- en: In the next and final chapter, we'll draw together ideas and techniques from
    all the previous chapters in this book to create a complete, working example Puppet
    infrastructure which you can use as a basis for your own.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的最后一章，我们将汇集本书前面各章的思路和技巧，创建一个完整、可操作的Puppet基础设施示例，您可以将其作为自己项目的基础。
