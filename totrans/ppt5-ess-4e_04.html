<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Combining Resources in Classes and Defined Types</h1>
                </header>
            
            <article>
                
<p>At this point, you have already performed some production-grade tasks with Puppet. You learned how to write standalone manifests and then invoke <kbd>puppet apply</kbd> to put them to use. While setting up your first Puppet master and agent, you created a simple example for a node manifest on the master. In a <kbd>node '&lt;hostname&gt;'</kbd> block, you created the equivalent of a manifest file. This way, the Puppet master used just this manifest for the specified agent node.</p>
<p>While this is all useful and essentially important, it will obviously not suffice for daily business. By working with <kbd>node</kbd> blocks that contain sets of resources, you will end up performing lots of copy and paste operations for similar nodes, and the whole construct will become unwieldy very quickly. This is an unnatural approach to developing Puppet manifests. Despite the great differences to many other languages that you might be familiar with, the Puppet DSL is a programming language. Building manifests merely from <kbd>node</kbd> blocks and resources would be the same as writing C with no functions except <kbd>main</kbd>, or Ruby without any classes of your own.</p>
<p>The manifests that you can write with the means that are already at your disposal are not flat, you learned about common control structures such as <kbd>if</kbd> and <kbd>case</kbd>. Your manifests can use these to adapt to various circumstances on the agent by querying the values of Facter facts and branching in accordance with the results.</p>
<p>However, these constructs should be complemented by the language tools to create reusable units of manifest code, similar to functions or methods in procedural languages. This chapter introduces these concepts through the following topics:</p>
<ul>
<li>Introducing classes and defined types</li>
<li>Design patterns</li>
<li>The dynamic aspect of defined types</li>
<li>Ordering and events among classes</li>
<li>Making classes more flexible through parameters</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing classes and defined types</h1>
                </header>
            
            <article>
                
<p>Puppet's equivalents to methods or functions are twofold: there are <strong>classes</strong> on one hand and defined types (also just referred to as defines) on the other.</p>
<div class="packt_infobox">You will find that the function analogy is a bit weak for classes, but fits defined types quite well.</div>
<p>They are similar at first glance, in that they both hold a chunk of reusable Puppet DSL code. There are big differences in the way each is used though. Let's take a look at classes first.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining and declaring classes</h1>
                </header>
            
            <article>
                
<p>A Puppet class can be considered to be a container containing collections of Puppet resource declarations. It is created once (class definition) and used by all nodes that need to make use of the prepared functionality. Each class represents a well-known subset of a system's configuration, such as <kbd>ntp</kbd>, <kbd>nginx</kbd>, and <kbd>ssh</kbd>.</p>
<p>For example, a classic use <kbd>case</kbd> is a class that installs the Apache web server and applies some basic settings. This class will look the same as the following:</p>
<pre>class apache {<br/>  package { 'apache2':<br/>    ensure =&gt; present,<br/>  }<br/>  file { '/etc/apache2/apache2.conf':<br/>    ensure =&gt; 'file',<br/>    source =&gt;<br/>    'puppet:///modules/apache/etc/apache2/apache2.conf', <br/>  } <br/>  service { 'apache2': <br/>    ensure    =&gt; running,<br/>    enable    =&gt; true, <br/>    subscribe =&gt; File['/etc/apache2/apache2.conf', <br/>  } <br/>} </pre>
<p>All web server nodes will make use of this class. To this end, their manifests need to contain a simple statement:</p>
<pre>include apache </pre>
<p>This is referred to as including a class, or declaring it. If your <kbd>apache</kbd> class is powerful enough to do all that is needed, this line might fully comprise a <kbd>node</kbd> block's content:</p>
<pre>node 'webserver01' {<br/>  include apache<br/>}</pre>
<div class="packt_infobox">In your own setup, you will probably not write your own Apache class. You can use open source classes that are available through Puppet modules. <a href="3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Combining Classes, Configuration Files, and Extensions into Modules</em>, will give you all the details.</div>
<p>This concludes our tour of classes in a nutshell. There is yet more to discuss, of course, but let's take a look at defined types before that.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating and using defined types</h1>
                </header>
            
            <article>
                
<p>A defined type can be regarded as a new resource type which makes use of existing resource types. This is useful when you have repeating instances of existing resource types, as you can wrap them in a defined type. As a class, it consists mainly of a body containing the manifest code. However, a defined type takes arguments and makes their values available in its body as local variables.</p>
<p>Here is another typical example of a defined type, the Apache virtual host configuration:</p>
<pre>define virtual_host(<br/>  String $content,<br/>  String[3,3] $priority = '050'<br/>) {<br/>  file { "/etc/apache2/sites-available/${name}":<br/>    ensure  =&gt; 'file',<br/>    owner   =&gt; 'root',<br/>    group   =&gt; 'root',<br/>    mode    =&gt; '0644',<br/>    content =&gt; $content<br/>  }<br/>  file { "/etc/apache2/sites-enabled/${priority}-${name}": <br/>    ensure =&gt; 'link', <br/>    target =&gt; "../sites-available/${name}";<br/>  }<br/>} </pre>
<div class="packt_infobox">Data types such as <kbd>String</kbd> have been available since Puppet 4. In Puppet 3 and earlier, you would have just skipped these; all variables used to be untyped.</div>
<p>This code might still seem pretty cryptic. It will become clearer in the context of how it is actually used from other places in your manifest; the following code shows you how:</p>
<pre>virtual_host { 'example.net': <br/>  content =&gt; file('apache/vhosts/example.net') <br/>}<br/>virtual_host{ 'fallback': <br/>  priority =&gt; '999', <br/>  content  =&gt; file('apache/vhosts/fallback') <br/>}   </pre>
<p>This is why the construct is called a defined type; you can now place what appear to be resources in your manifest, but you really call your own manifest code construct.</p>
<p class="mce-root">When declaring multiple resources of the same type, as in the preceding code, you can do so in a single block and separate them with a semicolon:</p>
<pre>virtual_host {<br/>  'example.net':<br/>    content  =&gt; 'foo';<br/>  'fallback':<br/>    priority =&gt; '999',<br/>    content  =&gt; ...,<br/>} </pre>
<div class="packt_infobox">The official style guide forbids this syntax, but it can make manifests more readable and maintainable in some cases.</div>
<p>The <kbd>virtual_host</kbd> type takes two arguments: the <kbd>content</kbd> argument is mandatory as it has no default value and is used verbatim in the configuration file resource. Puppet will synchronize that file's content to what is specified in the manifest. The <kbd>priority</kbd> argument is optional and its value becomes the file name prefix. If omitted, the respective virtual host definition uses the default priority of <kbd>050</kbd>.</p>
<p>Both parameters of this example type are of the <kbd>String</kbd> type. For details about Puppet's variable type system, see <a href="3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Combining Classes, Configuration Files, and Extensions into Modules</em>. It suffices to say that you can restrict parameters to certain value types. This is optional, however. You can omit the type name, and Puppet will accept any value for the parameter in question.</p>
<p>Also, each defined type can implicitly refer to the name (or title) by which it was called. In other words, each instance that you define gets a name, and you can access it through the <kbd>$name</kbd> or <kbd>$title</kbd> variable.</p>
<div class="packt_infobox">There are a few other <em>magic</em> variables that are available in the body of a defined type. If a resource of the defined type is declared with a metaparameter such as <kbd>require =&gt; ...</kbd>, its value can be accessed through the <kbd>$require</kbd> variable in the body. The variable value remains empty if the metaparameter is not used. This works for metaparameters, such as <kbd>before</kbd>, <kbd>notify</kbd>, and all the others, but you will probably never need to make use of this. The metaparameters automatically do the right thing.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding and leveraging the differences</h1>
                </header>
            
            <article>
                
<p>The respective purposes of Puppet's class and defined type are very specific and they usually don't overlap.</p>
<p>The class declares resources and properties that are in some way centric to the system. A class is a finalized description of one, or sometimes more, aspect of your system as a whole. Whatever the class represents, it can only ever exist in one form; to Puppet, each class is implicitly a singleton, a fixed set of information that either applies to your system (the class is included), or not.</p>
<p>The typical resources you will encapsulate in a class for convenient inclusion in a manifest are as follows:</p>
<ul>
<li>One or more packages that should be installed (or removed)</li>
<li>A specific configuration file in <kbd>/etc</kbd></li>
<li>A common directory, needed to store scripts or configs for many subsystems</li>
<li>Cron jobs that should be mostly identical on all applicable systems</li>
</ul>
<p>The define is used for all things that exist in multiple instances. All aspects that appear in varying quantities in your system can possibly be modeled using this language construct. In this regard, the define is very similar to the full-fledged resource it mimics with its declaration syntax. Some of the typical contents of defined types are:</p>
<ul>
<li>Files in a <kbd>conf.d</kbd> style directory</li>
<li>Entries in an easily parseable file such as <kbd>/etc/hosts</kbd></li>
<li>Apache virtual hosts</li>
<li>Schemas in a database</li>
<li>Rules in a firewall</li>
</ul>
<p>The class's singleton nature is especially valuable because it prevents clashes in the form of multiple resource declarations. Remember that each resource must be unique to a catalog. For example, consider a second declaration of the Apache package:</p>
<pre>package { 'apache2': }<strong> </strong></pre>
<p>This declaration can be anywhere in the manifest of one of your web servers (for example, right in the <kbd>node</kbd> block, next to <kbd>include apache</kbd>); this additional declaration will prevent the successful compilation of a catalog.</p>
<div class="packt_tip">The reason for the prevention of a successful compilation is that Puppet currently cannot make sure that both declarations represent the same target state, or can be merged to form a composite state. It is likely that multiple declarations of the same resource may conflict about the desired value of property (for example, one declaration might want to ensure that a package is <kbd>absent</kbd>, while the other needs it to be <kbd>present</kbd>). You want to see Puppet as a declarative description of your system configuration state.</div>
<p>The virtue of the class is that there can be an arbitrary number of <kbd>include</kbd> statements for the same class strewn throughout the manifest. Puppet will commit the class's contents to the catalog just once.</p>
<p class="mce-root">The uniqueness constraint for resources applies to defined types. No two instances of your own define can share the same name. Using a name twice or more produces a compiler error:</p>
<pre>virtual_host { 'wordpress': <br/>  content  =&gt; file(...), <br/>  priority =&gt; '011', <br/>}<br/>virtual_host { 'wordpress': <br/>  content  =&gt; '# Dummy vhost', <br/>  priority =&gt; '600', <br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Design patterns</h1>
                </header>
            
            <article>
                
<p>Your knowledge of classes and defined types is still rather academic. You have learned about their defining aspects and the syntax to use them, but we have yet to give you a feeling of how these concepts come to bear in different real-life scenarios.</p>
<p>The following sections will present an overview of what you can do with these language tools.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing comprehensive classes</h1>
                </header>
            
            <article>
                
<p>Many classes are written to make Puppet perform momentous tasks on the agent platform. Of these, the Apache class is probably one of the more modest examples. You can conceive a class that can be included from any machine's manifest and make sure that the following conditions are met:</p>
<ul>
<li>The firewalling software is installed and configured with a default ruleset</li>
<li>The malware detection software is installed</li>
<li>Cron jobs run the scanners at set intervals</li>
<li>The mailing subsystem is configured to make sure the cron jobs can deliver their output</li>
</ul>
<p>There are two general ways you can go about the task of creating a class of this magnitude. It can either become what one might call a <strong>monolithic</strong> implementation, a class with a large body that comprises all resources that work together to form the desired security baseline. This approach has the benefit of precisely describing your infrastructure, but it lacks maintainability. On the other hand, you could aim for a <strong>composite</strong> design, with few resources (or none at all) in the class body, and a number of <kbd>include</kbd> statements for simpler classes instead. The functionality is compartmentalized, and the central class acts as a collector. This is the common best practice way in which Puppet module developers work.</p>
<p>We have not yet touched on the ability of classes to include other classes. That's because it's quite simple. The body of a class can comprise almost any manifest, and the <kbd>include</kbd> statement is no exception. Among the few things that cannot appear in a class are <kbd>node</kbd> blocks.</p>
<p>Adding some life to the descriptions, this is roughly what the respective classes will look like:</p>
<pre class="mce-root">class monolithic_security { <br/>  package { [ 'iptables', 'rkhunter', 'postfix' ]:<br/>    ensure =&gt; 'installed';<br/>  } <br/>  cron { 'run-rkhunter': <br/>    ... <br/>  } <br/>  file { '/etc/init.d/iptables-firewall': <br/>    source =&gt; ... <br/>    mode =&gt; 755 <br/>  }<br/>  file { '/etc/postfix/main.cf': <br/>    ensure =&gt; 'file', <br/>    content =&gt; ... <br/>  } <br/>  service { [ 'postfix', 'iptables-firewall' ]: <br/>    ensure =&gt; 'running', <br/>    enable =&gt; true <br/>  } <br/>}<br/>class divided_security {<br/>  include iptables_firewall<br/>  include rkhunter<br/>  include postfix<br/>}</pre>
<p>When developing your own functional classes, you should not try to pick either of these extremes. Most classes will end up anywhere on the spectrum in between. The choice can be largely based on your personal preference. The technical implications are subtle, but these are the respective drawbacks:</p>
<ul>
<li>Consequently aiming for monolithic classes opens you up to resource clashes, because you take almost no advantage of the singleton nature of classes</li>
<li>Splitting up classes too much can make it difficult to impose order and distribute refresh events, you can refer to the <span>Combining classes, configuration files and extensions into Modules</span> section later in this chapter</li>
</ul>
<p>Neither of these aspects is of critical importance at most times. The case-by-case design choices will be based on each author's experience and preference. When in doubt, lean towards composite designs at first.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing component classes</h1>
                </header>
            
            <article>
                
<p>There is another common use case for classes. Instead of filling a class with lots of aspects that work together to achieve a complex goal, you can also limit the class to a very specific purpose. Some classes will contain just one resource. The class wraps the resource, so to speak.</p>
<p>This is useful for resources that are needed in different contexts. By wrapping them away in a class, you can make sure that those contexts do not create multiple declarations of the same resource.</p>
<p>For example, the <kbd>netcat</kbd> package can be useful to firewall servers, but also to web application servers. There is probably a <kbd>firewall</kbd> class and an <kbd>appserver</kbd> class. Both declare the <kbd>netcat</kbd> package:</p>
<pre>package { 'netcat':  
  ensure =&gt; 'installed'  
}  </pre>
<p>If any server ever has both roles (this might happen for budget reasons or in other unforeseen circumstances), it is a problem; when both the <kbd>firewall</kbd> and <kbd>appserver</kbd> classes are included, and the resulting manifest declares the <kbd>netcat</kbd> package twice. This is forbidden. To resolve this situation, the package resource can be wrapped in a <kbd>netcat</kbd> class, which is included by both the <kbd>firewall</kbd> and <kbd>appserver</kbd> classes:</p>
<pre>class netcat { 
  package { 'netcat':  
    ensure =&gt; 'installed'  
  }  
}  </pre>
<p>Let's consider another typical example for component classes that ensures the presence of a common file path. Assume your IT policy requires all custom scripts and applications to be installed in <kbd>/opt/company/bin</kbd>. Many classes, such as <kbd>firewall</kbd> and <kbd>appserver</kbd> from the previous example, will need some relevant content there. Each class needs to make sure that the directories exist before a script can be deployed inside it. This will be implemented by including a component class that wraps the <kbd>file</kbd> resources of the <kbd>directory</kbd> tree:</p>
<pre>class scripts_directory {  
  file { [ '/opt/company/', '/opt/company/bin' ]:  
    ensure =&gt; 'directory',  
    owner  =&gt; 'root',  
    group  =&gt; 'root',  
    mode   =&gt; '0755',  
  }  
} </pre>
<p>The component class is a pretty precise concept. However, as you have seen in the previous section about the more powerful classes, the whole range of possible class designs forms a fine-grained scale between the presented examples. All manifests you write will likely comprise more than a few classes. The best way to get a feeling for the best practices is to just go ahead and use classes to build the manifests you need.</p>
<div class="packt_infobox">The terms <strong>comprehensive</strong> class and <strong>component</strong> class are not official Puppet language, and the community does not use them to communicate design practices. We chose them arbitrarily to describe the ideas we laid out in these sections. The same holds <kbd>true</kbd> for the descriptions of the use cases for defined types, which will be seen in the next sections.</div>
<p>Next, let's look at some uses for defined types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using defined types as resource wrappers</h1>
                </header>
            
            <article>
                
<p>For all their apparent similarity to classes, defined types are used in different ways. For example, the component class was described as <em>wrapping a resource</em>. This is accurate in a very specific context, the wrapped resource is a singleton, and it can only appear in one form throughout the manifest.</p>
<p>When wrapping a resource in a defined type instead, you end up with a variation on the respective resource type. The manifest can contain an arbitrary number of instances of the defined type, and each will wrap a distinct resource.</p>
<div class="packt_tip">For this to work, the name of the resource that is declared in the body of the defined type must be dynamically created. It is almost always the <kbd>$name</kbd> variable of the respective defined type instance, or a value derived from it.</div>
<p>Here is yet another typical example from the many manifests out there: most users who make use of Puppet's file serving capabilities will want to wrap the <kbd>file</kbd> type at some point so that the respective URL need not be typed for each file:</p>
<pre>define module_file(String $module) {  
  file { $title:  
    source =&gt; "puppet:///modules/${module}/${title}" 
  }  
} </pre>
<p>This makes it easy to get Puppet to sync files from the master to the agent. The master copy must be properly placed in the named modules on the master:</p>
<pre>module_file { '/etc/ntpd.conf':  
  module =&gt; 'ntp': 
}  </pre>
<p>This resource will make Puppet retrieve the <kbd>ntp.conf</kbd> file from the <kbd>ntp</kbd> module. The preceding declaration is more concise and less redundant than the fully written file resource with the Puppet URL (especially for the large number of files you might need to synchronize), which would resemble the following:</p>
<pre>file { '/etc/ntpd.conf':  
  source =&gt; 'puppet:///modules/ntp/etc/ntpd.conf': 
}  </pre>
<p>For a wrapper such as <kbd>module_file</kbd>, which will probably be used very widely, you will want to make sure that it supports all attributes of the wrapped resource type. In this case, the <kbd>module_file</kbd> wrapper should accept all <kbd>file</kbd> attributes. For example, this is how you add the <kbd>mode</kbd> attribute to the wrapper type:</p>
<pre>define module_file( 
  String $module, 
  Optional[String] <strong>$mode = undef 
) {  
  if $mode != undef {  
    File { mode =&gt; $mode }  
  } </strong> 
  file { $title:  
    source =&gt; "puppet:///modules/${module}/${title}"  
  }  
} </pre>
<p>The <kbd>File { ... }</kbd> block declares some default values for all <kbd>file</kbd> resource attributes in the same scope. The <kbd>undef</kbd> value is similar to Ruby's <kbd>nil</kbd>, and is a convenient parameter default value, because it is very unlikely that a user will need to pass it as an actual value for the wrapped resource.</p>
<p class="mce-root">You can employ the override syntax instead of the default syntax as well:</p>
<pre class="mce-root">File[$name] { mode =&gt; $mode }</pre>
<div class="packt_tip">This makes the intent of the code slightly more obvious, but is not necessary in the presence of just one <kbd>file</kbd> resource. <a href="60cec52e-6b29-4028-bc15-3b5685598e6b.xhtml"><span class="ChapterrefPACKT">Chapter 6</span></a>, <em>The Puppet Beginners Advanced Parts</em>, holds more information about overrides and defaults.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using defined types as resource multiplexers</h1>
                </header>
            
            <article>
                
<p>Wrapping single resources with a defined type is useful, but sometimes you will want to add functionality beyond the resource type you are wrapping. At other times, you might wish for your defined type to unify a lot of functionality, just as the comprehensive classes from the beginning of the section.</p>
<p>For both scenarios, what you want to have is multiple resources in the body of your defined type. There is a classic example for this as well:</p>
<pre>define user_with_key(<br/>  String $key, <br/>  Optional[String] $uid = undef, <br/>  String $group = 'users'<br/>) {<br/>  user { <strong>$title</strong>: <br/>    ensure     =&gt; present<br/>    gid        =&gt; $group, <br/>    uid        =&gt; $uid,<br/>    managehome =&gt; true, <br/>  }<br/>  ssh_authorized_key { <strong>"key for ${title}"</strong>: <br/>    ensure =&gt; present, <br/>    user   =&gt; <strong>$title</strong>, <br/>    type   =&gt; 'rsa', <br/>    key    =&gt; <strong>$key</strong>, <br/>  } <br/>}</pre>
<p>This code allows you to create user accounts with authorized SSH keys in one resource declaration. This code sample has some notable aspects:</p>
<ul>
<li>Since you are essentially wrapping multiple resource types, the titles of all inner resources are derived from the instance title (or name) of the current defined type instance; actually, this is a required practice for all defined types</li>
<li>You can hardcode parts of your business logic; in this example, we dispensed with the support for non-RSA SSH keys and defined <kbd>users</kbd> as the default group</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using defined types as macros</h1>
                </header>
            
            <article>
                
<p>Some source code requires many repetitive tasks. Assume that your site uses a subsystem that relies on symbolic links at a certain location to enable configuration files, just as <kbd>init</kbd> does with the symlinks in <kbd>rc2.d/</kbd> and its siblings, which point back to <kbd>../init.d/&lt;service&gt;</kbd>.</p>
<p>A manifest that enables a large number of configuration snippets might look the same as this:</p>
<pre>file { '/etc/example_app/conf.d.enabled/england': <br/>  ensure =&gt; 'link', <br/>  target =&gt; '../conf.d.available/england' <br/>}<br/>file { '/etc/example_app/conf.d.enabled/ireland': <br/>  ensure =&gt; 'link', <br/>  target =&gt; '../conf.d.available/ireland' <br/>}<br/>file { '/etc/example_app/conf.d.enabled/germany': <br/>  ensure =&gt; 'link', <br/>  target =&gt; '../conf.d.available/germany' <br/>  ... <br/>}</pre>
<p>This is tiring to read and somewhat painful to maintain. In a C program, one would use a preprocessor macro that just takes the base name of both link and target and expands to the three lines of each resource description. Puppet does not use a preprocessor, but you can use defined types to achieve a similar result:</p>
<pre>define example_app_config { <br/>  file { "/etc/example_app/conf.d.enabled/${title}": <br/>    ensure =&gt; 'link', <br/>    target =&gt; "../conf.d.available/${title}", <br/>  } <br/>} </pre>
<div class="packt_tip">The defined type actually acts more as a simple function call than an actual macro.</div>
<p>The define requires no arguments, it can rely solely on its resource name, so the preceding code can now be simplified to the following:</p>
<pre>example_app_config {'england': }<br/>example_app_config {'ireland': }<br/>example_app_config {'germany': }<br/>... </pre>
<p>Alternatively, the following code is even more terse:</p>
<pre>example_app_config { [ 'england', 'ireland', 'germany', ... ]: <br/>}</pre>
<p>This array notation leads us to another use of defined types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploiting array values using defined types</h1>
                </header>
            
            <article>
                
<p>One of the more common scenarios in programming is the requirement to accept an array value from some source and perform a task on each value. Puppet manifests are not exempt from this.</p>
<p>Let's assume that the symbolic links from the previous example actually led to directories, and that each such directory would contain a subdirectory to hold optional links to regions. Puppet should manage those links as well.</p>
<p>Of course, after learning about the macro aspect of defined types, you would not want to add each of those regions as distinct resources to your manifest. However, you will need to devise a way to map region names to countries. Seeing as there is already a defined resource type for countries, there is a very direct approach to this: make the list of regions an attribute (or rather, a parameter) of the defined type:</p>
<pre>define example_app_config (<br/>  <strong>Array $regions = []</strong><br/>) {<br/>  file { "/etc/example_app/conf.d.enabled/${name}":<br/>    ensure =&gt; link,<br/>    target =&gt; "../conf.d.available/${name}",<br/>  }<br/>  <strong># to do: add functionality for $regions</strong><br/>}</pre>
<p>Using the parameter is straightforward:</p>
<pre>example_app_config { 'england':<br/>  regions =&gt; [ 'South East', 'London' ],<br/>}<br/>example_app_config { 'ireland':<br/>  regions =&gt; [ 'Connacht', 'Ulster' ],<br/>}<br/>example_app_config { 'germany':<br/>  regions =&gt; [ 'Berlin', 'Bayern', 'Hamburg' ],<br/>}<br/>... </pre>
<p>The actual challenge is putting these values to use. A naïve approach is to add the following to the definition of <kbd>example_app_config</kbd>:</p>
<pre>file { $regions:<br/>  path   =&gt; "/etc/example_app/conf.d.enabled/${title}/ <br/>    regions/${name}",<br/>  ensure =&gt; 'link',<br/>  target =&gt; "../../regions.available/${name}";<br/>}</pre>
<p>However, this will not work. The <kbd>$name</kbd> variable does not refer to the title of the <kbd>file</kbd> resource that is being declared. It actually refers, just like <kbd>$title</kbd>, to the name of the enclosing class or defined type (in this case, the country name). Still, the actual construct will seem quite familiar to you. The only missing piece here is yet another defined type:</p>
<pre>define example_app_region(String $country) { <br/>  file { "/etc/example_app/conf.d.enabled/${country}/regions/${title}":<br/>    ensure =&gt; 'link', <br/>    target =&gt; "../../regions.available/${title}",<br/>  } <br/>}  </pre>
<p>The complete definition of the <kbd>example_app_config</kbd> defined type should look like this then:</p>
<pre>define example_app_config(Array $regions = []) {<br/>  file { "/etc/example_app/conf.d.enabled/${title}": <br/>    ensure =&gt; 'link', <br/>    target =&gt; "../conf.d.available/${title}", <br/>  } <br/>  example_app_region { $regions: <br/>   country =&gt; $title,<br/>  } <br/>}</pre>
<p>The <em>outer</em> defined type adapts the behavior of the <kbd>example_app_region</kbd> type to its respective needs by passing its own resource name as a parameter value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using iterator functions</h1>
                </header>
            
            <article>
                
<p>With Puppet 4 and later versions, you probably would not write code like the one in the previous section. Thanks to new language features, using defined types as iterators is no longer necessary. We will outline the alternative using the following examples, with a more thorough exploration in <a href="b38488ca-86a7-4ecf-9a69-16938576d852.xhtml"><span class="ChapterrefPACKT">Chapter 7</span></a>, <em>New Features from Puppet 4 and</em> <em>5</em>.</p>
<p>The plain country links can now be declared from an Array using the <kbd>each</kbd> function:</p>
<pre>[ 'england', 'ireland', 'germany' ].each |$country| { <br/>  file { "/etc/example_app/conf.d.enabled/${country}": <br/>    ensure =&gt; 'link', <br/>    target =&gt; "../conf.d.available/${country}",<br/>  } <br/>}   </pre>
<p>The regions can be declared from structured data. A hash suffices for this use case:</p>
<pre>$region_data = { <br/>  'england' =&gt; [ 'South East', 'London' ], <br/>  'ireland' =&gt; [ 'Connacht', 'Ulster' ], <br/>  'germany' =&gt; [ 'Berlin', 'Bayern', 'Hamburg' ], <br/>}<br/>$region_data.each |$country, $region_array| {<br/>  $region_array.each |$region| {<br/>    file { "/etc/example_app/conf.d.enabled/${country}/ <br/>      regions/${region}":<br/>      ensure =&gt; link,<br/>      target =&gt; "../../regions.available/${region}",<br/>    }<br/>  }<br/>} </pre>
<p>In new manifests, you should opt for iteration using the <kbd>each</kbd> and <kbd>map</kbd> functions over using defined types for this purpose. You will find examples of the former in older manifest code, however. See <a href="b38488ca-86a7-4ecf-9a69-16938576d852.xhtml"><span class="ChapterrefPACKT">Chapter 7</span></a>, <em>New Features from Puppet 4 and 5</em>, for more information on the topic.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Including classes from defined types</h1>
                </header>
            
            <article>
                
<p>The <kbd>example_app_config</kbd> type that was defined in the previous example is supposed to serve a very specific purpose. Therefore, it assumes that the base directory, <kbd>/etc/example_app</kbd>, and its subdirectories were managed independently, outside the defined type. This was a sound design, but many defined types are meant to be used from lots of independent classes or other defined types. Such defines need to be self-contained.</p>
<p>In our example, the defined type needs to make sure that the following resources are part of the manifest:</p>
<pre>file { [ '/etc/example_app', '/etc/example_app/config.d.enabled' ]:<br/>  ensure =&gt; 'directory',<br/>} </pre>
<p>Just putting this declaration into the body of the define will lead to duplicate resource errors. Each instance of <kbd>example_app_config</kbd> will try to declare the directories by itself. However, we already have discussed a pattern to avoid just that issue we called it the component class.</p>
<p>To make sure that any instance of the <kbd>example_app_config</kbd> type is self-contained and works on its own, wrap the preceding declaration in a class (for example, <kbd>class example_app_config_directories</kbd>) and make sure you include this class right in the body of the define:</p>
<pre>define example_app_config(Array $regions = []) {<br/>  include example_app_config_directories<br/>...<br/>} </pre>
<div class="packt_tip">You can refer to the examples that come with your copy of this book for the definition of the class.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ordering and events among classes</h1>
                </header>
            
            <article>
                
<p>Puppet's classes bear little or no similarity to classes that you find in object-oriented programming languages such as Java or Ruby. There are no methods or attributes. There are no distinct instances of any class. You cannot create interfaces or abstract base classes.</p>
<p>One of the few shared characteristics is the encapsulation aspect. Just like classes from OOP, Puppet's classes hide implementation details. To get Puppet to start managing a subsystem, you just need to include the appropriate class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Passing events between classes and defined types</h1>
                </header>
            
            <article>
                
<p>By sorting all resources into classes, you make it unnecessary (for your co-workers or other collaborators) to know about each single resource. This is beneficial. You can think of the collection of classes and defined types as your interface. You would not want to read all of the manifests that anyone on your project ever wrote.</p>
<p>However, the encapsulation is inconvenient for passing resource events. Say you have a daemon that creates live statistics from your Apache log files. It should subscribe to Apache's configuration files so that it can restart if there are any changes (which might be of consequence to this daemon's operation). In another scenario, you might have Puppet manage some external data for a self-compiled Apache module. If Puppet updates such data, you will want to trigger a restart of the Apache service to reload everything.</p>
<p>Armed with the knowledge that there is a service, <kbd>Service['apache2']</kbd>, defined somewhere in the <kbd>apache</kbd> class, you can just go ahead and have your module data files notify that resource. It would work Puppet does not apply any sort of protection to resources that are declared in foreign classes. However, it would pose a minor maintainability issue.</p>
<p>The reference to the resource is located far from the resource itself. When maintaining the manifest later, you or a coworker might wish to look at the resource when encountering the reference. In the case of Apache, it's not difficult to figure out where to look, but in other scenarios, the location of the reference target can be less obvious.</p>
<div class="packt_tip">Looking up a targeted resource is usually not necessary, but it can be important to find out what that resource actually does. It gets especially important during debugging, if after a change to the manifest, the referenced resource is no longer found.</div>
<p>Besides, this approach will not work for the other scenario, in which your daemon needs to subscribe to configuration changes. You could blindly subscribe the central <kbd>apache2.conf</kbd> file, of course. However, this would not yield the desired results if the responsible class opted to do most of the configuration work inside snippets in <kbd>/etc/apache2/conf.d</kbd>.</p>
<p>Both scenarios can be addressed cleanly and elegantly by directing the <kbd>notify</kbd> or <kbd>subscribe</kbd> parameters at the whole class that is managing the entity in question:</p>
<pre>file { '/var/lib/apache2/sample-module/data01.bin':<br/>  source =&gt; '...',<br/>  notify =&gt; Class['apache'],<br/>}<br/>service { 'apache-logwatch': <br/>  enable    =&gt; true, <br/>  subscribe =&gt; Class['apache'], <br/>}  </pre>
<p>Of course, the signals are now sent (or received) indiscriminately the file not only notifies <kbd>Service['apache2']</kbd>, but also every other resource in the <kbd>apache</kbd> class. This is usually acceptable, because most resources ignore events.</p>
<p>As for the <kbd>logwatch</kbd> daemon, it might refresh itself needlessly if a resource in the <kbd>apache</kbd> class needs a sync action. The odds for this occurrence depend on the implementation of the class. For ideal results, it might be sensible to relocate the configuration file resources into their own class so that the daemon can subscribe to that instead.</p>
<p>With your defined types, you can apply the same rules: subscribe to and notify them as required. Doing so feels quite natural, because they are declared like native resources anyway. This is how you subscribe several instances of the defined type, <kbd>symlink</kbd>:</p>
<pre>$active_countries = [ 'England', 'Ireland', 'Germany' ]<br/>service { 'example-app': <br/>  enable    =&gt; true, <br/>  subscribe =&gt; Symlink[$active_countries], <br/>} </pre>
<p>Granted, this very example is a bit awkward, because it requires all <kbd>symlink</kbd> resource titles to be available in an array variable. In this case, it would be more natural to make the defined type instances notify the service instead:</p>
<pre>symlink { [ 'England', 'Ireland', 'Germany' ]: 
  notify =&gt; Service['example-app'], 
} </pre>
<p>This notation passes a metaparameter to a defined type. The result is that this parameter value is applied to all resources declared inside the define.</p>
<p>If a defined type wraps or contains a <kbd>service</kbd> or <kbd>exec</kbd> type resource, it can also be desirable to notify an instance of that define to refresh the contained resource. The following example assumes that the <kbd>service</kbd> type is wrapped by a defined type called <kbd>protected_service</kbd>:</p>
<pre>file { '/etc/example_app/main.conf':  
  source =&gt; '...',  
  notify =&gt; Protected_service['example-app'],  
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ordering containers</h1>
                </header>
            
            <article>
                
<p>The <kbd>notify</kbd> and <kbd>subscribe</kbd> metaparameters are not the only ones that you can direct at classes and instances of defined types the same holds <kbd>true</kbd> for their siblings, <kbd>before</kbd> and <kbd>require</kbd>. These allow you to define an order for your resources relative to classes, order instances of your defined types, and even order classes among themselves.</p>
<p>The latter works by virtue of the chaining operator:</p>
<pre>include firewall 
include loadbalancing 
Class['firewall'] -&gt; Class['loadbalancing'] </pre>
<p>The effect of this code is that all resources from the <kbd>firewall</kbd> class will be synchronized before any resource from the <kbd>loadbalancing</kbd> class, and failure of any resource in the former class will prevent all resources in the latter from being synchronized.</p>
<div class="packt_infobox">The chaining arrow cannot just be placed in between the <kbd>include</kbd> statements. It works only between resource definitions or resource references.</div>
<p>Because of these ordering semantics, it is actually quite wholesome to require a whole class. You effectively mark the resource in question as being dependent on the class. As a result, it will only be synchronized if the entire subsystem that the class models is successfully synchronized first.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Limitations</h1>
                </header>
            
            <article>
                
<p>Sadly, there is a rather substantial issue with both the ordering of containers and the distribution of refresh events: neither will transcend the <kbd>include</kbd> statements of further classes. Consider the following example:</p>
<pre>class apache {<br/>  include apache::service<br/>  include apache::package<br/>  include apache::config<br/>}<br/>file { '/etc/apache2/conf.d/passwords.conf':<br/>  source  =&gt; '...', <br/>  require =&gt; Class['apache'], <br/>} </pre>
<p>I have often mentioned how the comprehensive <kbd>apache</kbd> class models everything about the Apache server subsystem, and in the previous section, I went on to explain that directing a <kbd>require</kbd> parameter at such a class will make sure that Puppet only touches the dependent resource if the subsystem has been successfully configured.</p>
<p>This is mostly true, but, due to the limitation concerning class boundaries, it doesn't achieve the desired effect in this scenario. The dependent configuration file should actually require the <kbd>Package['apache']</kbd> package, declared in <kbd>class apache::package</kbd>. However, the relationship does not span multiple class inclusions, so this particular dependency will not be part of the resulting catalog at all.</p>
<p>Similarly, any refresh events sent to the <kbd>apache</kbd> class will have no effect; they are distributed to resources declared in the class's body (of which there are none), but are not passed on to included classes. Subscribing to the class will make no sense either, because any resource events generated inside the included classes will not be forwarded by the <kbd>apache</kbd> class.</p>
<p>The bottom line is that relationships to classes cannot be built in utter ignorance of their implementation. If in doubt, you need to make sure that the resources that are of interest are actually declared directly inside the class you are targeting.</p>
<div class="packt_infobox">The discussion revolved around the example of the <kbd>include</kbd> statements in classes, but since it is common to use them in defined types as well; the same limitation applies in this case too.</div>
<p>There is a bright side to this as well. A more correct implementation of the Apache configuration file from the example explained would depend on the package, but would also synchronize itself before the service, and perhaps even notify it (so that Apache restarts if necessary). When all resources are part of the <kbd>apache</kbd> class and you want to adhere to the pattern of interacting with the container only, it would lead to the following declaration:</p>
<pre>file { '/etc/apache2/conf.d/passwords.conf':  
  source  =&gt; '...',  
  require =&gt; Class['apache'],  
  notify  =&gt; Class['apache'],  
}  </pre>
<p>This forms an instant dependency circle: the <kbd>file</kbd> resource requires all parts of the <kbd>apache</kbd> class to be synchronized before it gets processed, but to notify them, they must all be put after the <kbd>file</kbd> resource in the order graph. This cannot work. With the knowledge of the inner structure of the <kbd>apache</kbd> class, the user can pick metaparameter values that actually work:</p>
<pre>file { '/etc/apache2/conf.d/passwords.conf': 
  source  =&gt; '...',  
  require =&gt; Class['apache::package'],  
  notify  =&gt; Class['apache::service'],  
}  </pre>
<p>For the curious, the preceding code shows what the inner classes look like, roughly.</p>
<p>The other good news is that invoking defined types does not pose the same kind of issue that an <kbd>include</kbd> statement of a class does. Events are passed to resources inside defined types just fine, transcending an arbitrary number of stacked invocations. Ordering also works just as expected. Let's keep the example brief:</p>
<pre>class apache {  
  virtual_host { 'example.net': ... } 
  ...  
} </pre>
<p>This <kbd>apache</kbd> class also creates a virtual host using the defined type, <kbd>virtual_host</kbd>. A resource that requires this class will implicitly require all resources from within this <kbd>virtual_host</kbd> instance. A subscriber to the class will receive events from those resources, and events directed at the class will reach the resources of this <kbd>virtual_host</kbd>.</p>
<div class="packt_tip">There is actually a good reason to make the <kbd>include</kbd> statements behave differently in this regard. As classes can be included very generously (thanks to their singleton aspect), it is common for classes to build a vast network of includes. By adding a single <kbd>include</kbd> statement to a manifest, you might unknowingly pull hundreds of classes into this manifest. Assume, for a moment, that relationships and events transcend this whole network. All manner of unintended effects would be the consequence. Dependency circles would be almost inevitable. The whole construct would become utterly unmanageable. The cost of such relationships would also grow exponentially. Refer to the next section.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The performance implications of container relationships</h1>
                </header>
            
            <article>
                
<p>There is another aspect that you should keep in mind whenever you are referencing a container type to build a relationship to it. The Puppet agent will have to build a dependency graph from this. This graph contains all resources as nodes and all relationships as edges. Classes and defined types get expanded to all their declared resources. All relationships to the container are expanded to relationships to each resource.</p>
<p>This is mostly harmless if the other end of the relationship is a native resource. A file that requires a class with five declared resources leads to five dependencies. That does not hurt. It gets more interesting if the same class is required by an instance of a defined type that comprises three resources. Each of these builds a relationship to each of the class's resources, so you end up with 15 edges in the graph.</p>
<p>It gets even more expensive when a container invokes complex defined types, perhaps even recursively.</p>
<p>A more complex graph means more work for the Puppet agent, and its runs will take longer. This is especially annoying when running agents interactively during the debugging or development of your manifest. To avoid the unnecessary effort, consider your relationship declarations carefully, and use them only when they are really appropriate.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mitigating the limitations</h1>
                </header>
            
            <article>
                
<p>The architects of the Puppet language have devised two alternative approaches to solve the ordering issues. We will consider both, because you might encounter them in existing manifests. In new setups, you should always choose the latter variant.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The anchor pattern</h1>
                </header>
            
            <article>
                
<p>The <kbd>anchor</kbd> pattern is the classic workaround for the problem with ordering and signaling in the context of recursive class <kbd>include</kbd> statements. It can be illustrated by the following example class:</p>
<pre>class example_app { <br/>  anchor { 'example_app::begin': <br/>    notify =&gt; Class['example_app_config'], <br/>  } <br/>  include example_app_config <br/>  anchor { 'example_app::end': <br/>   require =&gt; Class['example_app_config'],<br/>  } <br/>} </pre>
<p>Consider a resource that is placed <kbd>before</kbd><kbd>=&gt; Class['example_app']</kbd>. It ends up in the chain before each <kbd>anchor</kbd>, and therefore, also before any resource in <kbd>example_app_config</kbd>, despite the <kbd>include</kbd> limitation. This is because the <kbd>Anchor['example_app::begin']</kbd> pseudo-resource notifies the included class and is therefore ordered before all of its resources. A similar effect works for objects that require the class, by virtue of the <kbd>example::end</kbd> anchor.</p>
<p>The <kbd>anchor</kbd> resource type was created for this express purpose. It is not part of the Puppet core, but has been made available through the <kbd>stdlib</kbd> module instead (the next chapter will familiarize you with modules). Since it also forwards refresh events, it is even possible to notify and subscribe this anchored class, and events will propagate into and out of the included <kbd>example_app_config</kbd> class.</p>
<p>The <kbd>stdlib</kbd> module is available in the Puppet Forge, but more about this in the next chapter. There is a descriptive document for the <kbd>anchor</kbd> pattern to be found online as well, in Puppet documentation at <a href="https://docs.puppet.com/puppet/latest/lang_containment.html"><span class="URLPACKT">http://projects.puppetlabs.com/projects/puppet/wiki/Anchor_Pattern</span></a>. It is somewhat dated, given that the anchor pattern has been supplanted as well by Puppet's ability to contain a class in a container.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The contain function</h1>
                </header>
            
            <article>
                
<p>To make composite classes work directly around the limitations of the <kbd>include</kbd> statement, you can take advantage of the <kbd>contain</kbd> function found in Puppet version 3.4.x or newer.</p>
<p>If the earlier <kbd>apache</kbd> example had been written like the following one, there would have been no issues concerning ordering and refresh events:</p>
<pre>class apache {<br/>  contain apache::service<br/>  contain apache::package<br/>  contain apache::config<br/>}</pre>
<p>The official documentation describes the behavior as follows:</p>
<div class="packt_quote">"A contained class will not be applied before the containing class is begun, and will be finished before the containing class is finished."</div>
<p>This might read like we're now discussing the panacea for the presented class ordering issues here. Should you just be using <kbd>contain</kbd> in place of <kbd>include</kbd> from here on out and never worry about class ordering again? Of course not; this would introduce lots of unnecessary ordering constraints and lead you into unfixable dependency circles very quickly. Do contain classes, but make sure that it makes sense. The contained class should really form a vital part of what the containing class is modeling.</p>
<div class="packt_tip">The quoted documentation refers to classes only, but classes can be contained in defined types just as well. The effect of containment is not limited to ordering aspects either. Refresh events are also correctly propagated.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making classes more flexible through parameters</h1>
                </header>
            
            <article>
                
<p>Up until this point, classes and defines were presented as direct opposites with respect to flexibility; defined types are inherently adaptable through different parameter values, whereas classes model just one static piece of state. As the section title suggests, this is not entirely true. Classes, too, can have parameters. Their definition and declaration become rather similar to those of defined types in this case:</p>
<pre>class apache::config(Integer $max_clients=100) { <br/>  file { '/etc/apache2/conf.d/max_clients.conf':<br/>    content =&gt; "MaxClients ${max_clients}\n",<br/>  }<br/>}</pre>
<p>With a definition like the preceding one, the class can be declared with a parameter value:</p>
<pre>class { 'apache::config':  
  max_clients =&gt; 120, 
}  </pre>
<p>This enables some very elegant designs, but introduces some drawbacks as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The caveats of parameterized classes</h1>
                </header>
            
            <article>
                
<p>The consequence of allowing class parameters is almost obvious: you lose the singleton characteristic. Well, that's not entirely true either, but your freedom in declaring the class gets limited drastically.</p>
<p>Classes that define default values for all parameters can still be declared with the <kbd>include</kbd> statement. This can still be done an arbitrary number of times in the same manifest.</p>
<p>However, the resource like declaration of <kbd>class { 'name': }</kbd> cannot appear more than once for any given class in the same manifest. This is in keeping with the rules for resources and should not be very surprising-after all, it would be very awkward to try to bind different values to a class's parameters in different locations throughout the manifest.</p>
<p>Things become very confusing when mixing <kbd>include</kbd> with the alternative syntax though. It is valid to include a class an arbitrary number of times after it has been declared using the resource-like notation. However, you cannot use the resource style declaration after a class has been declared using <kbd>include</kbd>. That's because the parameters are then determined to assume their default values, and a <kbd>class { 'name': }</kbd> declaration clashes with that.</p>
<p>In a nutshell, the following code works:</p>
<pre>class { 'apache::config': } 
include apache::config </pre>
<p>However, the following code does not work:</p>
<pre>include apache::config 
class { 'apache::config': } </pre>
<p>As a consequence, you effectively cannot add parameters to component classes, because the <kbd>include</kbd> statement is no longer safe to use in large quantities. Therefore, parameters are essentially only useful for comprehensive classes, which usually don't get included from different parts of the manifest.</p>
<div class="packt_infobox">In <a href="3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Combining Classes, Configuration Files, and Extensions into Modules</em>, we will discuss some alternate patterns, some of which exploit class parameters. Also note that <span class="ChapterrefPACKT">Chapter 8</span>, <em>Separation of Code and Data with Hiera</em>, presents a solution that gives you more flexibility with parameterized classes. Using this, you can be more liberal with your class interfaces.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preferring the include keyword</h1>
                </header>
            
            <article>
                
<p>Ever since class parameters have been available, some Puppet users have felt compelled to write (example) code that would make it a point to forgo the <kbd>include</kbd> keyword in favor of resource-like class declarations, such as this:</p>
<pre>class apache {<br/>  class { 'apache::service': }<br/>  class { 'apache::package': }<br/>  class { 'apache::config': }<br/>}</pre>
<p>Doing this is a very bad idea. We cannot stress this enough: one of the most powerful concepts about Puppet's classes is their singleton aspect the ability to include a class in a manifest arbitrarily and without worrying about clashes with other code. The mentioned declaration syntax deprives you of this power, even when the classes in question don't support parameters.</p>
<p>The safest route is to use <kbd>include</kbd> whenever possible, and to avoid the alternate syntax whenever you can. In fact, <span class="ChapterrefPACKT">Chapter 8</span>, <em>Separation of Code and Data with Hiera</em>, introduces the ability to use class parameters without the resource same as class declaration. This way, you can rely solely on <kbd>include</kbd>, even when parameters are in play. These are the safest recommended practices to keep you out of trouble from incompatible class declarations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Classes and defined types are the essential tools to create reusable Puppet code. While classes hold resources that must not be repeated in a manifest, the define is capable of managing a distinct set of adapted resources upon every invocation. It does that by leveraging the parameter values it receives. While classes do support parameters as well, there are some caveats to bear in mind.</p>
<p>To use defined types in your manifest, you declare instances just like resources of native types. Classes are mainly used through the <kbd>include</kbd> statement, although there are alternatives such as the <kbd>class { }</kbd> syntax or the <kbd>contain</kbd> function. There are also some ordering issues with classes that the <kbd>contain</kbd> function can help mitigate. In theory, classes and defines suffice to build almost all the manifests that you will ever need. In practice, you will want to organize your code into larger structures.</p>
<p>The <a href="3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml">Chapter 5</a>, <em>Combining Classes, Configuration Files, and Extensions into Modules</em>, will show you how to do exactly that, and introduce you to a whole range of useful functionality beyond it.</p>


            </article>

            
        </section>
    </body></html>