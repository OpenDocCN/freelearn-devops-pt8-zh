<html><head></head><body>
<div id="_idContainer134">
<h1 class="chapter-number" id="_idParaDest-193"><a id="_idTextAnchor474"/><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 id="_idParaDest-194"><a id="_idTextAnchor475"/><span class="koboSpan" id="kobo.2.1">Getting Started on Azure – Building Solutions with Azure Virtual Machines</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Now that we’ve built our solution end-to-end on the AWS platforms and followed our team’s journey from their initial VM architecture to Kubernetes and then finally culminating with serverless, we’re ready to switch gears and enter an alternate reality where Keyser has saddled up to his dear friends at Microsoft. </span><span class="koboSpan" id="kobo.3.2">In this next set of chapters, we will follow a similar path as in </span><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapters 7</span></em><span class="koboSpan" id="kobo.5.1"> through </span><em class="italic"><span class="koboSpan" id="kobo.6.1">9</span></em><span class="koboSpan" id="kobo.7.1">, but in this alternate version, we’ll work with </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">Microsoft Azure.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">This chapter will pick up where we started our journey on AWS; in </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.10.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.11.1">, where we built a doppelgänger solution using AWS. </span><span class="koboSpan" id="kobo.11.2">In that chapter, we went into great detail about elements of the solution that are 100% cloud agnostic. </span><span class="koboSpan" id="kobo.11.3">This included a detailed explanation of exactly how we use Packer to provision our .NET-based application code to a Linux VM and a detailed explanation of how to set up GitHub Actions for a VM-based </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">CI/CD pipeline.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">Since an overwhelming majority of this remains the same when we move to Azure, we won’t be revisiting these topics in this chapter at the same length. </span><span class="koboSpan" id="kobo.13.2">However, I would encourage you to put a bookmark in </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.14.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.15.1"> and reference </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">it frequently.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">This chapter covers the </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.19.1">Laying </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">the foundation</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Designing </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">the solution</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Building </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">the solution</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Automating </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">the deployment</span></span></li>
</ul>
<h1 id="_idParaDest-195"><a id="_idTextAnchor476"/><span class="koboSpan" id="kobo.27.1">Laying the foundation</span></h1>
<p><span class="koboSpan" id="kobo.28.1">Our team at Söze Enterprises applauds their achievement of responding to the whimsical technical course correction of their fearless leader, Keyser Söze, and marvels at their success and fortune</span><a id="_idIndexMarker761"/><span class="koboSpan" id="kobo.29.1"> in launching their product successfully on AWS. </span><span class="koboSpan" id="kobo.29.2">Here, they used VMs, Kubernetes, and serverless technology. </span><span class="koboSpan" id="kobo.29.3">The comforting orange complexion of the AWS console begins to melt away when suddenly, the air fills with an eerie yet familiar sound: doodle-oo doodle-oo doodle-oo. </span><span class="koboSpan" id="kobo.29.4">An unexpected duo appears – one with shoulder-length brown hair under a black baseball cap and a simple black T-shirt; the other with a nerdy charm with tousled blond hair, thick black-rimmed glasses, and a red and blue plaid flannel over a white Aerosmith T-shirt. </span><span class="koboSpan" id="kobo.29.5">They start the familiar chant: doodle-oo doodle-oo doodle-oo. </span><span class="koboSpan" id="kobo.29.6">Suddenly, we’re transported to another world – another universe, perhaps, where Azure’s deep blue replaces AWS’s bright orange. </span><span class="koboSpan" id="kobo.29.7">Söze Enterprises has partnered with Microsoft for their next-generation autonomous </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">vehicle platform.</span></span></p>
<p><span class="koboSpan" id="kobo.31.1">Just as before, we have inherited a team from one of Söze Enterprises’ other divisions that has a strong core team of C# .NET developers, so we’ll be building version 1.0 of the platform using .NET technologies. </span><span class="koboSpan" id="kobo.31.2">The elusive CEO, Keyser, was seen hobnobbing with Satya Nadella during the glitz and glamor of the Met Gala in New York City over the weekend, and word has come down from corporate that we will be using Microsoft Azure to host the platform. </span><span class="koboSpan" id="kobo.31.3">Since the team doesn’t have a ton of experience with containers and timelines are tight, we’ve decided to build a simple three-tier architecture and host on </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">Azure VMs:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer119">
<span class="koboSpan" id="kobo.33.1"><img alt="Figure 10.1 – Logical architecture for the autonomous vehicle platform" src="image/B21183_10_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.34.1">Figure 10.1 – Logical architecture for the autonomous vehicle platform</span></p>
<p><span class="koboSpan" id="kobo.35.1">The platform will need </span><a id="_idIndexMarker762"/><span class="koboSpan" id="kobo.36.1">a frontend, which will be a web UI built using ASP.NET Core Blazor. </span><span class="koboSpan" id="kobo.36.2">The frontend will be powered by a REST API backend, which will be built using ASP.NET Core Web API. </span><span class="koboSpan" id="kobo.36.3">Having our core functionality encapsulated into a REST API will allow autonomous vehicles to communicate directly with the platform and allow us to expand by adding client interfaces with additional frontend technologies such as native mobile apps and virtual or mixed reality in the future. </span><span class="koboSpan" id="kobo.36.4">The backend will use a PostgreSQL database for persistent storage since it’s lightweight, industry-standard, and </span><a id="_idIndexMarker763"/><span class="No-Break"><span class="koboSpan" id="kobo.37.1">relatively</span></span><span class="No-Break"><a id="_idIndexMarker764"/></span><span class="No-Break"><span class="koboSpan" id="kobo.38.1"> inexpensiv</span><a id="_idTextAnchor477"/><span class="koboSpan" id="kobo.39.1">e.</span></span></p>
<h1 id="_idParaDest-196"><a id="_idTextAnchor478"/><span class="koboSpan" id="kobo.40.1">Designing the solution</span></h1>
<p><span class="koboSpan" id="kobo.41.1">Due to the tight timelines the team is facing, we want to keep the cloud architecture simple. </span><span class="koboSpan" id="kobo.41.2">Therefore, we’ll keep it simple and use the tried and tested services of Microsoft Azure to implement the </span><a id="_idIndexMarker765"/><span class="koboSpan" id="kobo.42.1">platform instead of trying to learn something new. </span><span class="koboSpan" id="kobo.42.2">The first decision we must make is what Azure service each component of our logical architecture will be </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">hosted on.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">Our application architecture consists of three components: a frontend, a backend, and a database. </span><span class="koboSpan" id="kobo.44.2">The frontend and backend are application components and need to be hosted on a cloud service that provides general computing, while the database needs to be hosted on a cloud database service. </span><span class="koboSpan" id="kobo.44.3">There are many options for both types </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">of services:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer120">
<span class="koboSpan" id="kobo.46.1"><img alt="Figure 10.2 – Logical architecture for the autonomous vehicle platform" src="image/B21183_10_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.47.1">Figure 10.2 – Logical architecture for the autonomous vehicle platform</span></p>
<p><span class="koboSpan" id="kobo.48.1">Since we have decided we’re going to use VMs to host our application, we have narrowed down the different services that we can use to host our application, and we have decided that the Azure VM service is the ideal choice for our current situation. </span><span class="koboSpan" id="kobo.48.2">Other options, such as Azure App Service, also use VMs but we want to have total control over the solution and maintain as many cross-platform capabilities as we can in case we ever have to migrate to a different </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">cloud platform:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer121">
<span class="koboSpan" id="kobo.50.1"><img alt="Figure 10.3 – Source control structure of our repository" src="image/B21183_10_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.51.1">Figure 10.3 – Source control structure of our repository</span></p>
<p><span class="koboSpan" id="kobo.52.1">In this solution, we’ll have six parts. </span><span class="koboSpan" id="kobo.52.2">We still have the application code and Packer templates for both the frontend and backend. </span><span class="koboSpan" id="kobo.52.3">Then, we have GitHub Actions to implement our CI/CD process </span><a id="_idIndexMarker766"/><span class="koboSpan" id="kobo.53.1">and Terraform to provision our Azure infrastructure and reference the Packer-built VM images for our </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">Azure VM</span><a id="_idTextAnchor479"/><span class="koboSpan" id="kobo.55.1">s.</span></span></p>
<h2 id="_idParaDest-197"><a id="_idTextAnchor480"/><span class="koboSpan" id="kobo.56.1">Cloud architecture</span></h2>
<p><span class="koboSpan" id="kobo.57.1">In </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.58.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.59.1">, we developed a</span><a id="_idIndexMarker767"/><span class="koboSpan" id="kobo.60.1"> similar solution using AWS and its equivalent offerings concerning VMs. </span><span class="koboSpan" id="kobo.60.2">As a result, our design for Azure will look rather similar. </span><span class="koboSpan" id="kobo.60.3">Many of the cloud services we use on AWS have equivalents to Microsoft Azure. </span><span class="koboSpan" id="kobo.60.4">This is largely because VMs, networks, and network security have stabilized in terms</span><a id="_idIndexMarker768"/><span class="koboSpan" id="kobo.61.1"> of how the industry views them. </span><span class="koboSpan" id="kobo.61.2">Don’t expect to see radical differences in naming conventions and how things work. </span><span class="koboSpan" id="kobo.61.3">When working with this cloud computing paradigm, the differences between platforms are usually very subtle. </span><span class="koboSpan" id="kobo.61.4">Throughout this book, I will attempt to highlight synonymous terms across clouds to help you better translate your conceptual knowledge from one cloud </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">to anot</span><a id="_idTextAnchor481"/><span class="koboSpan" id="kobo.63.1">her.</span></span></p>
<h3><span class="koboSpan" id="kobo.64.1">Virtual network</span></h3>
<p><span class="koboSpan" id="kobo.65.1">VMs must be deployed within a virtual network. </span><span class="koboSpan" id="kobo.65.2">As you may recall from </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.66.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.67.1"> when we provisioned this solution on AWS, we</span><a id="_idIndexMarker769"/><span class="koboSpan" id="kobo.68.1"> needed to set up multiple subnets for our solution to span Availability Zones. </span><span class="koboSpan" id="kobo.68.2">That’s because of the structure of virtual networks on AWS, how the virtual network is scoped to an AWS region, and how a subnet is scoped to an AWS Availability Zone. </span><span class="koboSpan" id="kobo.68.3">Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">is different.</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">On Azure, the virtual network and the subnets are scoped to a region. </span><span class="koboSpan" id="kobo.70.2">Zonal resiliency is built into the virtual network. </span><span class="koboSpan" id="kobo.70.3">Azure has two resiliency modes: one based on fault domains or </span><em class="italic"><span class="koboSpan" id="kobo.71.1">regional</span></em><span class="koboSpan" id="kobo.72.1"> and another based on Availability Zones or </span><em class="italic"><span class="koboSpan" id="kobo.73.1">zonal</span></em><span class="koboSpan" id="kobo.74.1">. </span><span class="koboSpan" id="kobo.74.2">VMs can be provisioned in either of these </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">two modes.</span></span></p>
<p><span class="koboSpan" id="kobo.76.1">To provision a regional VM solution, you need to provision an availability set and specify how many fault domains you want to distribute your VMs across. </span><span class="koboSpan" id="kobo.76.2">When VMs are provisioned within this availability set, the Azure platform takes care to ensure that they are provisioned to hardware that does not share a common source of power and network switch, thus making it less likely that the entire workload will fail in the case of an outage isolated to a single fault domain. </span><span class="koboSpan" id="kobo.76.3">If you don’t use an availability set, Azure will allocate your VMs based on available capacity and make no guarantee that your VMs won’t be in the same </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">fault domain.</span></span></p>
<p><span class="koboSpan" id="kobo.78.1">To provision a zonal VM solution, you simply need to specify which Availability Zone to use to provision your VMs and ensure that you have more than one VM spread across multiple Availability Zones. </span><span class="koboSpan" id="kobo.78.2">An Availability Zone offers much more resiliency than a fault domain as instead of the Azure platform guaranteeing your VM doesn’t share the same power source and network switch, it guarantees your VM is in a different physical data center within the region. </span><span class="koboSpan" id="kobo.78.3">In this book, we will focus on ensuring that our solution achieves </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">zonal resiliency:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer122">
<span class="koboSpan" id="kobo.80.1"><img alt="Figure 10.4 – Resource Azure virtual network architecture" src="image/B21183_10_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.81.1">Figure 10.4 – Resource Azure virtual network architecture</span></p>
<p><span class="koboSpan" id="kobo.82.1">In the preceding diagram, you</span><a id="_idIndexMarker770"/><span class="koboSpan" id="kobo.83.1"> can see that our virtual network and both its subnets can support VMs across all Availability Zones within </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">the region:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer123">
<span class="koboSpan" id="kobo.85.1"><img alt="Figure 10.5 – Isolated subnets for frontend and backend application components" src="image/B21183_10_5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.86.1">Figure 10.5 – Isolated subnets for frontend and backend application components</span></p>
<p><span class="koboSpan" id="kobo.87.1">This means that we don’t need to design our subnets based on the constraints of the cloud platform’s resiliency </span><a id="_idIndexMarker771"/><span class="koboSpan" id="kobo.88.1">boundaries as we do on AWS; we can design our subnets to match our workload’s needs. </span><span class="koboSpan" id="kobo.88.2">In this case, we need a subnet for our solution’s frontend, which hosts the ASP.NET Core Blazor web application, and we need a subnet for our solution’s backend, which hosts the ASP.NET Core Web API. </span><span class="koboSpan" id="kobo.88.3">Whether we choose to provision VMs regionally, taking advantage of Azure’s fault domains, or zonally, taking advantage of Azure’s Availability Zones, does not affect the network design. </span><span class="koboSpan" id="kobo.88.4">Both options are available to us when we decide to </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">provision</span><a id="_idTextAnchor482"/><span class="koboSpan" id="kobo.90.1"> VMs.</span></span></p>
<h3><span class="koboSpan" id="kobo.91.1">Network routing</span></h3>
<p><span class="koboSpan" id="kobo.92.1">In </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.93.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.94.1">, when we set up this solution on AWS, we needed to configure an internet gateway, NAT gateways, and route</span><a id="_idIndexMarker772"/><span class="koboSpan" id="kobo.95.1"> tables for our VMs to have outbound access to the internet. </span><span class="koboSpan" id="kobo.95.2">On Azure, we don’t need to configure equivalent components because Azure provides a default gateway and automatically configures VMs to use it. </span><span class="koboSpan" id="kobo.95.3">If we wanted to block internet access or route internet traffic another way, we would need to configure </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">additional reso</span><a id="_idTextAnchor483"/><span class="koboSpan" id="kobo.97.1">urces.</span></span></p>
<h3><span class="koboSpan" id="kobo.98.1">Load balancing</span></h3>
<p><span class="koboSpan" id="kobo.99.1">When discussing </span><strong class="bold"><span class="koboSpan" id="kobo.100.1">load balancers</span></strong><span class="koboSpan" id="kobo.101.1"> as a component </span><a id="_idIndexMarker773"/><span class="koboSpan" id="kobo.102.1">of our architecture, we will inevitably use some well-established and</span><a id="_idIndexMarker774"/><span class="koboSpan" id="kobo.103.1"> familiar terms, but we will be using them in a different context. </span><span class="koboSpan" id="kobo.103.2">This can be confusing. </span><span class="koboSpan" id="kobo.103.3">Therefore, I hope to tackle the elephant in the room. </span><span class="koboSpan" id="kobo.103.4">Our solution has a frontend – the web application that serves up web pages for the end user’s web browser. </span><span class="koboSpan" id="kobo.103.5">Our solution also has a backend – the REST Web API that our web application calls to talk to the database and perform stateful operations. </span><span class="koboSpan" id="kobo.103.6">Our solution will also leverage two load balancers: one to distribute load across our frontend web servers running the web application and another to distribute load across our backend web servers running the </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">Web API:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer124">
<span class="koboSpan" id="kobo.105.1"><img alt="Figure 10.6 – Too many frontends and backends" src="image/B21183_10_6.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.106.1">Figure 10.6 – Too many frontends and backends</span></p>
<p><span class="koboSpan" id="kobo.107.1">Within the context of each load balancer, each load balancer will have a frontend and backend. </span><span class="koboSpan" id="kobo.107.2">It’s important to note the context when using these terms as the frontend of our solution refers to a </span><a id="_idIndexMarker775"/><span class="koboSpan" id="kobo.108.1">different architectural component at an altogether different architectural granularity. </span><span class="koboSpan" id="kobo.108.2">We need to understand that when we refer to the frontend of our solution, we are talking about all of the components that make up the frontend of our solution function properly, and when we are talking about the frontend of the </span><em class="italic"><span class="koboSpan" id="kobo.109.1">frontend</span></em><span class="koboSpan" id="kobo.110.1"> load balancer, we are talking about the networking endpoint that accepts traffic for the </span><em class="italic"><span class="koboSpan" id="kobo.111.1">frontend</span></em><span class="koboSpan" id="kobo.112.1"> of </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">our solution.</span></span></p>
<p><span class="koboSpan" id="kobo.114.1">In </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.115.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.116.1">, when we set up this solution </span><a id="_idIndexMarker776"/><span class="koboSpan" id="kobo.117.1">on AWS, we used the AWS </span><strong class="bold"><span class="koboSpan" id="kobo.118.1">Application Load Balancer</span></strong><span class="koboSpan" id="kobo.119.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.120.1">ALB</span></strong><span class="koboSpan" id="kobo.121.1">) service. </span><span class="koboSpan" id="kobo.121.2">On Azure, we’ll use the Azure Load Balancer service. </span><span class="koboSpan" id="kobo.121.3">Both services function very similarly but they are structured a little differently and use different terminology to describe </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">similar concepts:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-2">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.123.1">AWS</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.124.1">Azure</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.125.1">Description</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.126.1">ALB</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.127.1">Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">Load Balancer</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.129.1">Load balancer</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.130.1">Listener</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.131.1">Frontend </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">IP Configuration</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.133.1">The singular endpoint that accepts incoming traffic on a </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">load balancer</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.135.1">Target Group</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.136.1">Backend </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">Address Pool</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.138.1">A collection of VMs that incoming traffic is </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">forwarded to</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.140.1">Health Check</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.141.1">Health </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">Probe</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.143.1">An endpoint published by each of the backend VMs that indicates it is healthy and ready to </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">handle traffic</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.145.1">Table 10.1 – Mapping of synonymous load balancer components between AWS and Azure</span></p>
<p><span class="koboSpan" id="kobo.146.1">As we discussed in </span><a href="B21183_04.xhtml#_idTextAnchor239"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.147.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.148.1">, a load balancer provides a singular frontend endpoint and distributes network traffic across a</span><a id="_idIndexMarker777"/><span class="koboSpan" id="kobo.149.1"> multitude of backend VMs. </span><span class="koboSpan" id="kobo.149.2">On AWS, while they call this frontend endpoint a </span><strong class="bold"><span class="koboSpan" id="kobo.150.1">listener</span></strong><span class="koboSpan" id="kobo.151.1">, on Azure, it</span><a id="_idIndexMarker778"/><span class="koboSpan" id="kobo.152.1"> is called the </span><strong class="bold"><span class="koboSpan" id="kobo.153.1">frontend IP configuration</span></strong><span class="koboSpan" id="kobo.154.1">. </span><span class="koboSpan" id="kobo.154.2">Likewise, the backend </span><a id="_idIndexMarker779"/><span class="koboSpan" id="kobo.155.1">VMs are called the </span><strong class="bold"><span class="koboSpan" id="kobo.156.1">target group</span></strong><span class="koboSpan" id="kobo.157.1"> in AWS, while they</span><a id="_idIndexMarker780"/><span class="koboSpan" id="kobo.158.1"> are called the </span><strong class="bold"><span class="koboSpan" id="kobo.159.1">backend address pool</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.160.1">on Azure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer125">
<span class="koboSpan" id="kobo.161.1"><img alt="Figure 10.7 – Resource-isolated subnets for frontend and backend application components" src="image/B21183_10_7.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.162.1">Figure 10.7 – Resource-isolated subnets for frontend and backend application components</span></p>
<p><span class="koboSpan" id="kobo.163.1">Azure Load Balancer uses rules to determine how incoming traffic is routed to </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">backend pools.</span></span></p>
<p><span class="koboSpan" id="kobo.165.1">Azure Load Balancer organizes how it routes incoming traffic using rules. </span><span class="koboSpan" id="kobo.165.2">Each rule has a protocol, a frontend</span><a id="_idIndexMarker781"/><span class="koboSpan" id="kobo.166.1"> component, and a backend component. </span><span class="koboSpan" id="kobo.166.2">The rule’s frontend component configures where and how the network traffic should come into the load balancer. </span><span class="koboSpan" id="kobo.166.3">This includes a port to expose, which frontend IP configuration to expose the port on, and what health probe it should use to determine which backend nodes are healthy and ready to receive traffic. </span><span class="koboSpan" id="kobo.166.4">The backend component of the rule specifies which backend address pool to route traffic to and what port </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">to use.</span></span></p>
<p><span class="koboSpan" id="kobo.168.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.169.1">health probe</span></strong><span class="koboSpan" id="kobo.170.1"> is configured with its own</span><a id="_idIndexMarker782"/><span class="koboSpan" id="kobo.171.1"> protocol, port, and request path. </span><span class="koboSpan" id="kobo.171.2">This endpoint is hit regularly by the load balancer on each of the VMs within the backend address pool to verify they are healthy and ready to receive traffic. </span><span class="koboSpan" id="kobo.171.3">Because our application doesn’t change, regardless of whether we deploy to AWS or Azure, the frontend of our solution – the web application – will continue to use the root path (</span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">/</span></strong><span class="koboSpan" id="kobo.173.1">) and the backend – the REST Web API – will </span><a id="_idIndexMarker783"/><span class="koboSpan" id="kobo.174.1">continue to use the custom health check endpoint we setup </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">at </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">/he</span><a id="_idTextAnchor484"/><span class="koboSpan" id="kobo.177.1">alth</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.179.1">Network security</span></h3>
<p><span class="koboSpan" id="kobo.180.1">In </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.181.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.182.1"> we set up four </span><a id="_idIndexMarker784"/><span class="koboSpan" id="kobo.183.1">security groups in AWS for each logical stop that network traffic makes within our solution architecture. </span><span class="koboSpan" id="kobo.183.2">In Azure, we only need two security groups because Azure Load Balancer is automatically granted access to our VMs using the rules that we configured </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">in it:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer126">
<span class="koboSpan" id="kobo.185.1"><img alt="Figure 10.8 – Frontend node pool network traffic flow" src="image/B21183_10_8.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.186.1">Figure 10.8 – Frontend node pool network traffic flow</span></p>
<p><span class="koboSpan" id="kobo.187.1">From the perspective of VMs handling traffic within the frontend, they will receive traffic on port </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">5000</span></strong><span class="koboSpan" id="kobo.189.1"> using the HTTP protocol. </span><span class="koboSpan" id="kobo.189.2">The C# application will make requests to the REST Web API hosted in the backend, but we’ll be routing all our requests to the backend through the backend load balancer on port </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">80</span></strong><span class="koboSpan" id="kobo.191.1"> using the HTTP protocol. </span><span class="koboSpan" id="kobo.191.2">On Azure, we don’t need to explicitly allow this egress traffic within </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">the network:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer127">
<span class="koboSpan" id="kobo.193.1"><img alt="Figure 10.9 – Backend node pool network traffic flow" src="image/B21183_10_9.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.194.1">Figure 10.9 – Backend node pool network traffic flow</span></p>
<p><span class="koboSpan" id="kobo.195.1">From the perspective of the VMs handling traffic within the backend, they will be receiving traffic on port </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">5000</span></strong><span class="koboSpan" id="kobo.197.1"> using the HTTP protocol. </span><span class="koboSpan" id="kobo.197.2">The C# application code will be making requests to the PostgreSQL database on port </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">5432</span></strong><span class="koboSpan" id="kobo.199.1"> using the HTTPS protocol. </span><span class="koboSpan" id="kobo.199.2">On Azure, we don’t need to explicitly allow this egress traffic within </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">the ne</span><a id="_idTextAnchor485"/><span class="koboSpan" id="kobo.201.1">twork.</span></span></p>
<h3><span class="koboSpan" id="kobo.202.1">Secrets management</span></h3>
<p><span class="koboSpan" id="kobo.203.1">Secrets such as database credentials </span><a id="_idIndexMarker785"/><span class="koboSpan" id="kobo.204.1">or service access keys need to be stored securely. </span><span class="koboSpan" id="kobo.204.2">Each cloud platform has a service that provides this functionality. </span><span class="koboSpan" id="kobo.204.3">On</span><a id="_idIndexMarker786"/><span class="koboSpan" id="kobo.205.1"> Azure, this service is called </span><strong class="bold"><span class="koboSpan" id="kobo.206.1">Azure </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.207.1">Key Vault</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table002-1">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.209.1">AWS</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.210.1">Azure</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.211.1">Description</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.212.1">IAM</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.213.1">Microsoft Entra</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.214.1">Identity provider</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.215.1">Secrets </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">Manager</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.217.1">Key Vault</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.218.1">Secure </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">secret storage</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.220.1">IAM role</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.221.1">User-assigned </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">managed identity</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.223.1">Identity for </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">machine-to-machine interaction</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.225.1">IAM policy</span></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.226.1">Role-based access </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.227.1">control</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.228.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.229.1">RBAC</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">)</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.231.1">Provides permission </span><a id="_idIndexMarker787"/><span class="koboSpan" id="kobo.232.1">to perform specific operations on specific services </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">or resources</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.234.1">IAM </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">role policy</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.236.1">Role assignment</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.237.1">Associates specific permissions with </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">specific identities</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.239.1">Table 10.2 – Mapping synonymous identity and access management components between AWS and Azure</span></p>
<p><span class="koboSpan" id="kobo.240.1">Secrets stored in Azure Key Vault can be accessed by VMs once they have the necessary RBAC granted. </span><span class="koboSpan" id="kobo.240.2">In </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.241.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.242.1">, we used </span><a id="_idIndexMarker788"/><span class="koboSpan" id="kobo.243.1">an AWS IAM role assignment to allow a VM to do this. </span><span class="koboSpan" id="kobo.243.2">Azure works similarly by attaching one or more user-assigned managed identities to the VMs and then creating role assignments for the managed identities so that they have specific roles that grant the </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">necessary permissions:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer128">
<span class="koboSpan" id="kobo.245.1"><img alt="Figure 10.10 – Key Vault architecture" src="image/B21183_10_10.0.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.246.1">Figure 10.10 – Key Vault architecture</span></p>
<p><span class="koboSpan" id="kobo.247.1">Granting the managed identity that is attached to the VMs access to the </span><strong class="bold"><span class="koboSpan" id="kobo.248.1">Key Vault Secrets User</span></strong><span class="koboSpan" id="kobo.249.1"> role will </span><a id="_idIndexMarker789"/><span class="koboSpan" id="kobo.250.1">allow the VMs to read the secret values from Key Vault. </span><span class="koboSpan" id="kobo.250.2">This does not put the secrets on the</span><a id="_idIndexMarker790"/><span class="koboSpan" id="kobo.251.1"> machine. </span><span class="koboSpan" id="kobo.251.2">The VM will need to use the Azure CLI to access the Key </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">Vault secrets</span><a id="_idTextAnchor486"/><span class="koboSpan" id="kobo.253.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.254.1">VMs</span></h3>
<p><span class="koboSpan" id="kobo.255.1">Now that we have everything we need for </span><a id="_idIndexMarker791"/><span class="koboSpan" id="kobo.256.1">our solution, we can finish by talking about where our application components will run: VMs provisioned on Azure’s VM service. </span><span class="koboSpan" id="kobo.256.2">When provisioning VMs on Azure, you have two options. </span><span class="koboSpan" id="kobo.256.3">First, you can provision static VMs. </span><span class="koboSpan" id="kobo.256.4">In this approach, you need to specify key characteristics for every VM. </span><span class="koboSpan" id="kobo.256.5">The second option is to provision a </span><strong class="bold"><span class="koboSpan" id="kobo.257.1">Virtual Machine Scale Set</span></strong><span class="koboSpan" id="kobo.258.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.259.1">VMSS</span></strong><span class="koboSpan" id="kobo.260.1">). </span><span class="koboSpan" id="kobo.260.2">This will </span><a id="_idIndexMarker792"/><span class="koboSpan" id="kobo.261.1">allow you to dynamically scale up and down based on demand as well as auto-heal VMs </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">that fail:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table003">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.263.1">AWS</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.264.1">Azure</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.265.1">Description</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.266.1">EC2</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.267.1">VMs</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.268.1">VM service</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.269.1">AMI</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.270.1">VM image</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.271.1">VM image either from Marketplace or custom build (e.g., using tools such </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">as Packer)</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.273.1">IAM role</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.274.1">User-assigned </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">managed identity</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.276.1">Identity for </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">machine-to-machine interaction</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.278.1">Auto Scaling </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.279.1">group</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.280.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.281.1">ASG</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">)</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.283.1">VMSS</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.284.1">Set of dynamically </span><a id="_idIndexMarker793"/><span class="koboSpan" id="kobo.285.1">provisioned VMs that can be scaled up/down using a VM </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">configuration template</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.287.1">Launch template</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.288.1">VM profile</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.289.1">Configuration template used to create </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">new VMs</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.291.1">Table 10.3 – Mapping synonymous VM service components between AWS and Azure</span></p>
<p><span class="koboSpan" id="kobo.292.1">In </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.293.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.294.1">, we provisioned our</span><a id="_idIndexMarker794"/><span class="koboSpan" id="kobo.295.1"> solution using AWS </span><strong class="bold"><span class="koboSpan" id="kobo.296.1">Elastic Cloud Compute</span></strong><span class="koboSpan" id="kobo.297.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.298.1">EC2</span></strong><span class="koboSpan" id="kobo.299.1">). </span><span class="koboSpan" id="kobo.299.2">Azure VMs share a similar structure to EC2 instances. </span><span class="koboSpan" id="kobo.299.3">Like on AWS, Azure VMs are connected to their corresponding </span><a id="_idIndexMarker795"/><span class="koboSpan" id="kobo.300.1">subnet by way of a virtual network interface. </span><span class="koboSpan" id="kobo.300.2">However, on Azure, we have two types of network</span><a id="_idIndexMarker796"/><span class="koboSpan" id="kobo.301.1"> security rules: </span><strong class="bold"><span class="koboSpan" id="kobo.302.1">network security groups</span></strong><span class="koboSpan" id="kobo.303.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.304.1">NSGs</span></strong><span class="koboSpan" id="kobo.305.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.306.1">application security groups</span></strong><span class="koboSpan" id="kobo.307.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.308.1">ASGs</span></strong><span class="koboSpan" id="kobo.309.1">). </span><span class="koboSpan" id="kobo.309.2">While both are used to control traffic on Azure, NSGs focus</span><a id="_idIndexMarker797"/><span class="koboSpan" id="kobo.310.1"> on specifying lower-level network rules such as port and protocol filtering for network-level resources defined as IP address ranges. </span><span class="koboSpan" id="kobo.310.2">AGSs, on the other hand, provide a higher level of abstraction that allows you to group resources based on the role they play within </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">the application:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer129">
<span class="koboSpan" id="kobo.312.1"><img alt="Figure 10.11 – Azure VM architecture" src="image/B21183_10_11.0.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.313.1">Figure 10.11 – Azure VM architecture</span></p>
<p><span class="koboSpan" id="kobo.314.1">Alternatively, you can use an Azure VMSS to dynamically provision and manage the VMs. </span><span class="koboSpan" id="kobo.314.2">In this approach, you </span><a id="_idIndexMarker798"/><span class="koboSpan" id="kobo.315.1">provide the VMSS with some configuration and parameters on when to scale up and when to scale down, and the VMSS will take care of </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">everything else:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer130">
<span class="koboSpan" id="kobo.317.1"><img alt="Figure 10.12 – Azure VMSS architecture" src="image/B21183_10_12.0.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.318.1">Figure 10.12 – Azure VMSS architecture</span></p>
<p><span class="koboSpan" id="kobo.319.1">Azure VMSS allows you to provide fine-grained configuration for each of the VMs that it will spin up on your behalf. </span><span class="koboSpan" id="kobo.319.2">It also provides a set of policies that allow you to control the behavior of the VMSS</span><a id="_idIndexMarker799"/><span class="koboSpan" id="kobo.320.1"> relating to when instances fail unexpectedly, when Azure needs to update them, or whether to scale up or down the number </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">of V</span><a id="_idTextAnchor487"/><span class="koboSpan" id="kobo.322.1">Ms.</span></span></p>
<h2 id="_idParaDest-198"><a id="_idTextAnchor488"/><span class="koboSpan" id="kobo.323.1">Deployment architecture</span></h2>
<p><span class="koboSpan" id="kobo.324.1">Now that we have a</span><a id="_idIndexMarker800"/><span class="koboSpan" id="kobo.325.1"> good idea of what our cloud architecture is going to look like for our solution on Azure, we need to come up with a plan for how to provision our environments and deploy </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">our c</span><a id="_idTextAnchor489"/><span class="koboSpan" id="kobo.327.1">ode.</span></span></p>
<h3><span class="koboSpan" id="kobo.328.1">VM configuration</span></h3>
<p><span class="koboSpan" id="kobo.329.1">In our solution, we have two VM roles: the frontend role, which is</span><a id="_idIndexMarker801"/><span class="koboSpan" id="kobo.330.1"> responsible for handling web page requests from the end user’s web browser, and the backend role, which is responsible for handling REST API requests from the web application. </span><span class="koboSpan" id="kobo.330.2">Each of these roles has a different code and different configuration that needs to be set. </span><span class="koboSpan" id="kobo.330.3">Each will require its own Packer template to build a VM image that we can use to launch a VM </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">on Azure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer131">
<span class="koboSpan" id="kobo.332.1"><img alt="Figure 10.13 – Packer pipeline to build a VM image for the frontend" src="image/B21183_10_13.0.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.333.1">Figure 10.13 – Packer pipeline to build a VM image for the frontend</span></p>
<p><span class="koboSpan" id="kobo.334.1">A GitHub Actions workflow that triggers off changes to the frontend application code and the frontend packer template will execute </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">packer build</span></strong><span class="koboSpan" id="kobo.336.1"> and create a new VM image for the </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">solution’s frontend.</span></span></p>
<p><span class="koboSpan" id="kobo.338.1">Both the frontend and the backend will have identical GitHub Actions workflows that execute </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">packer build</span></strong><span class="koboSpan" id="kobo.340.1">. </span><span class="koboSpan" id="kobo.340.2">The key difference between the workflows is the code bases that they execute against. </span><span class="koboSpan" id="kobo.340.3">Both</span><a id="_idIndexMarker802"/><span class="koboSpan" id="kobo.341.1"> the frontend and the backend might have slightly different operating system configurations, and both require different deployment packages for their respective </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">application components:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer132">
<span class="koboSpan" id="kobo.343.1"><img alt="Figure 10.14 – Packer pipeline to build a VM image for the backend" src="image/B21183_10_14.0.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.344.1">Figure 10.14 – Packer pipeline to build a VM image for the backend</span></p>
<p><span class="koboSpan" id="kobo.345.1">It’s important to note that the application code will be baked into the VM image rather than copied to an already running VM. </span><span class="koboSpan" id="kobo.345.2">This means that to update the software running on the VMs, each VM will need to be restarted so that it can be restarted with a new VM image containing the latest copy of </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.347.1">This approach makes the VM image itself an immutable deployment artifact that is versioned and updated each time</span><a id="_idIndexMarker803"/><span class="koboSpan" id="kobo.348.1"> there is a release of the application code that needs to </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">be depl</span><a id="_idTextAnchor490"/><span class="koboSpan" id="kobo.350.1">oyed.</span></span></p>
<h3><span class="koboSpan" id="kobo.351.1">Cloud environment configuration</span></h3>
<p><span class="koboSpan" id="kobo.352.1">Once the VM images have been built for </span><a id="_idIndexMarker804"/><span class="koboSpan" id="kobo.353.1">both the frontend and the backend, we can execute the final workflow that will both provision and deploy our solution </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">to Azure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer133">
<span class="koboSpan" id="kobo.355.1"><img alt="Figure 10.15 – VM images as inputs to the Terraform code, which provisions the environment on Azure" src="image/B21183_10_15.0.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.356.1">Figure 10.15 – VM images as inputs to the Terraform code, which provisions the environment on Azure</span></p>
<p><span class="koboSpan" id="kobo.357.1">The Terraform code base will have two input variables for the version of the VM image for both the frontend and the backend. </span><span class="koboSpan" id="kobo.357.2">When new versions of the application software need to be deployed, the input parameters for these versions will be incremented to reflect the target version for deployment. </span><span class="koboSpan" id="kobo.357.3">When the workflow is executed, </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">terraform apply </span></strong><span class="koboSpan" id="kobo.359.1">will simply replace the existing VMs with VMs using the new </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">VM i</span><a id="_idTextAnchor491"/><span class="koboSpan" id="kobo.361.1">mage.</span></span></p>
<p><span class="koboSpan" id="kobo.362.1">Now that we have a solid plan for how we will implement both the cloud architecture using Azure and the deployment architecture using GitHub Actions, let’s start building! </span><span class="koboSpan" id="kobo.362.2">In the next section, we’ll break down the HCL code that we’ll use to implement the Terraform and </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">Packer solutions.</span></span></p>
<h1 id="_idParaDest-199"><a id="_idTextAnchor492"/><span class="koboSpan" id="kobo.364.1">Building the solution</span></h1>
<p><span class="koboSpan" id="kobo.365.1">Now that we have a solid</span><a id="_idIndexMarker805"/><span class="koboSpan" id="kobo.366.1"> design for our solution, we can </span><a id="_idIndexMarker806"/><span class="koboSpan" id="kobo.367.1">begin building it. </span><span class="koboSpan" id="kobo.367.2">As discussed in the previous section, we’ll be using an Azure VM. </span><span class="koboSpan" id="kobo.367.3">As we did with AWS in </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.368.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.369.1">, we’ll need to package our application into VM images using Packer and then provision an environment that </span><a id="_idIndexMarker807"/><span class="koboSpan" id="kobo.370.1">provisions an environment using these </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">VM</span><a id="_idTextAnchor493"/><span class="koboSpan" id="kobo.372.1"> images.</span></span></p>
<h2 id="_idParaDest-200"><a id="_idTextAnchor494"/><span class="koboSpan" id="kobo.373.1">Packer</span></h2>
<p><span class="koboSpan" id="kobo.374.1">In this section, we’ll learn how</span><a id="_idIndexMarker808"/><span class="koboSpan" id="kobo.375.1"> to implement our Packer template provisioners so that we can install our .NET application</span><a id="_idIndexMarker809"/><span class="koboSpan" id="kobo.376.1"> code on a Linux VM. </span><span class="koboSpan" id="kobo.376.2">If you skipped </span><em class="italic"><span class="koboSpan" id="kobo.377.1">Chapters 7</span></em><span class="koboSpan" id="kobo.378.1"> through </span><em class="italic"><span class="koboSpan" id="kobo.379.1">9</span></em><span class="koboSpan" id="kobo.380.1"> due to a lack of interest in AWS, I can’t hold that against you – particularly if your primary interest in reading this book is working on the Microsoft Azure cloud platform. </span><span class="koboSpan" id="kobo.380.2">However, I would encourage you to review the corresponding section within </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.381.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.382.1"> to see how we use Packer’s provisioners to configure a Debian-based Linux VM with our .NET </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">applica</span><a id="_idTextAnchor495"/><span class="koboSpan" id="kobo.384.1">tion code.</span></span></p>
<h3><span class="koboSpan" id="kobo.385.1">Azure plugin</span></h3>
<p><span class="koboSpan" id="kobo.386.1">As we discussed in </span><a href="B21183_04.xhtml#_idTextAnchor239"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.387.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.388.1">, Packer – like Terraform – is an extensible command-line executable. </span><span class="koboSpan" id="kobo.388.2">Each </span><a id="_idIndexMarker810"/><span class="koboSpan" id="kobo.389.1">cloud platform</span><a id="_idIndexMarker811"/><span class="koboSpan" id="kobo.390.1"> provides a plugin for Packer that encapsulates the integration with </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">its services:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.392.1">
packer {
  required_plugins {
    azure = {
      source  = "github.com/hashicorp/azure"
      version = "~&gt; 2.0.0"
    }
  }
}</span></pre> <p><span class="koboSpan" id="kobo.393.1">In </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.394.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.395.1">, we saw how to declare the Packer plugin for AWS as a required plugin. </span><span class="koboSpan" id="kobo.395.2">The preceding code demonstrates how to declare Azure’s plugin instead – at the time of writing, the latest version </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">2.0.0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.399.1">The Azure plugin for Packer provides an </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">azure-arm</span></strong><span class="koboSpan" id="kobo.401.1"> builder that will generate Azure VM images by creating a new VM from a base image, executing the provisioners, taking a snapshot of the Azure managed disk, and creating an Azure managed image from it. </span><span class="koboSpan" id="kobo.401.2">Like the AWS plugin, this behavior is encapsulated within the </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">Azure builder.</span></span></p>
<p><span class="koboSpan" id="kobo.403.1">Just as the plugin for AWS encapsulated the logic to build VMs on AWS and its configuration was in AWS-centric terminology, so does the Azure plugin encapsulate all the logic to build VMs on Azure, and its configuration is in Azure-centric terminology. </span><span class="koboSpan" id="kobo.403.2">Packer does not try to create a standard builder interface across cloud platforms – rather, it isolates the cloud-specific configuration within the builders. </span><span class="koboSpan" id="kobo.403.3">This keeps things simple for users who know the target platform well and allows the builder to take advantage of any platform-specific features without additional layers of complexity by trying to rationalize the </span><a id="_idIndexMarker812"/><span class="koboSpan" id="kobo.404.1">syntax across </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">every platform.</span></span></p>
<p><span class="koboSpan" id="kobo.406.1">As a result, the structure of the AWS and Azure builders is radically different in almost every way – from how they authenticate to how they look at marketplace images. </span><span class="koboSpan" id="kobo.406.2">There are some common fields and </span><a id="_idIndexMarker813"/><span class="koboSpan" id="kobo.407.1">similarities, but they are very </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">different animals.</span></span></p>
<p><span class="koboSpan" id="kobo.409.1">The first big difference is how they pass authentication credentials. </span><span class="koboSpan" id="kobo.409.2">As we saw in </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.410.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.411.1">, the AWS plugin allows us to use environment variables to pass in the AWS access key and secret key to authenticate with AWS. </span><span class="koboSpan" id="kobo.411.2">The Azure provider does not support this method and requires you to pass in all four attributes to authenticate using a Microsoft Entra (formerly Azure Active Directory) service principal. </span><span class="koboSpan" id="kobo.411.3">Those four attributes are </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.413.1">Tenant ID</span></strong><span class="koboSpan" id="kobo.414.1">: Unique identifier for the Microsoft </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">Entra tenant</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.416.1">Subscription ID</span></strong><span class="koboSpan" id="kobo.417.1">: Unique identifier for the Microsoft </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">Azure subscription</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.419.1">Client ID</span></strong><span class="koboSpan" id="kobo.420.1">: Unique identifier for the Microsoft Entra service principal that we will use as the identity </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">of Terraform</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.422.1">Client secret</span></strong><span class="koboSpan" id="kobo.423.1">: Secret key for the Microsoft Entra </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">service principal</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.425.1">The following code shows how the four Microsoft Azure credential attributes are passed into the Azure builder using </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">input variables:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.427.1">
source "azure-arm" "vm" {
client_id       = var.arm\_client\_id
client\_secret   = var.arm\_client\_secret
subscription\_id = var.arm\_subscription\_id
tenant\_id       = var.arm\_tenant\_id
...
</span><span class="koboSpan" id="kobo.427.2">}</span></pre> <p><span class="koboSpan" id="kobo.428.1">The following code shows how we reference the Azure marketplace version of the Ubuntu 22.04 </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">Virtual Machine:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.430.1">
source "azure-arm" "vm" {
  ...
</span><span class="koboSpan" id="kobo.430.2">  image_offer     = "0001-com-ubuntu-server-jammy"
  image_publisher = "canonical"
  image_sku       = "22_04-lts"
  ...
</span><span class="koboSpan" id="kobo.430.3">}</span></pre> <p><span class="koboSpan" id="kobo.431.1">Notice how, unlike in the AWS version, where we used a data source of </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">amazon-ami</span></strong><span class="koboSpan" id="kobo.433.1"> to look up the same image</span><a id="_idIndexMarker814"/><span class="koboSpan" id="kobo.434.1"> in a specific AWS region, we don’t need to do this on Microsoft</span><a id="_idIndexMarker815"/><span class="koboSpan" id="kobo.435.1"> Azure. </span><span class="koboSpan" id="kobo.435.2">Because of the way Azure structures marketplace images, there’s no need to look up the region-specific unique identifier for the </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">VM image.</span></span></p>
<p><span class="koboSpan" id="kobo.437.1">The final part of the Azure builder should look very familiar to the </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">AWS version:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.439.1">
source "azure-arm" "vm" {
  ...
</span><span class="koboSpan" id="kobo.439.2">  location                     = var.azure_primary_location
  communicator                 = "ssh"
  os_type                      = "Linux"
  vm_size                      = var.vm_size
  allowed_inbound_ip_addresses = [var.agent_ipaddress]
}</span></pre> <p><span class="koboSpan" id="kobo.440.1">In the preceding code, we see the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">communicator</span></strong><span class="koboSpan" id="kobo.442.1"> attribute set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">ssh</span></strong><span class="koboSpan" id="kobo.444.1">, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">vm_size</span></strong><span class="koboSpan" id="kobo.446.1"> attribute that </span><a id="_idIndexMarker816"/><span class="koboSpan" id="kobo.447.1">corresponds to the AWS equivalent, </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">instance_type</span></strong><span class="koboSpan" id="kobo.449.1">, and an </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">allowed_inbound_ip_addresses</span></strong><span class="koboSpan" id="kobo.451.1"> attribute that corresponds to the AWS equivalent, </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">temporary_security_group_source_cidrs</span></strong><span class="koboSpan" id="kobo.453.1">, which pokes a hole in the security group to allow the</span><a id="_idIndexMarker817"/><span class="koboSpan" id="kobo.454.1"> machine that GitHub Actions is executing on access to the temporary VM that </span><a id="_idTextAnchor496"/><span class="No-Break"><span class="koboSpan" id="kobo.455.1">Packer provisions.</span></span></p>
<h3><span class="koboSpan" id="kobo.456.1">Operating system configuration</span></h3>
<p><span class="koboSpan" id="kobo.457.1">To configure the </span><a id="_idIndexMarker818"/><span class="koboSpan" id="kobo.458.1">operating system, we must install software dependencies (such as .NET 6.0), copy and deploy our application code’s deployment package to the correct location in the local filesystem, configure a Linux service that runs on boot, and set up a local user and group with necessary access for the service to </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">run as.</span></span></p>
<p><span class="koboSpan" id="kobo.460.1">I expanded on these steps in detail in the corresponding section in </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.461.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.462.1">, so I encourage you to review this section if you want to r</span><a id="_idTextAnchor497"/><span class="koboSpan" id="kobo.463.1">efresh </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">your memory.</span></span></p>
<h3><span class="koboSpan" id="kobo.465.1">Platform-specific build tasks</span></h3>
<p><span class="koboSpan" id="kobo.466.1">Packer provides a way for you to execute provisioners only on particular builders. </span><span class="koboSpan" id="kobo.466.2">This allows you to accommodate</span><a id="_idIndexMarker819"/><span class="koboSpan" id="kobo.467.1"> platform-specific differences even within the operating </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">system configuration.</span></span></p>
<p><span class="koboSpan" id="kobo.469.1">In Microsoft Azure, we need to execute a platform-specific command as the last and final step before Packer shuts down the VM and creates the image. </span><span class="koboSpan" id="kobo.469.2">Those of you with experience setting up Microsoft Windows VM images will be familiar with a utility called </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">sysprep</span></strong><span class="koboSpan" id="kobo.471.1">. </span><span class="koboSpan" id="kobo.471.2">This tool is used to prepare a VM so that we can have an image created from its disk. </span><span class="koboSpan" id="kobo.471.3">Although we are not </span><a id="_idIndexMarker820"/><span class="koboSpan" id="kobo.472.1">using a Windows operating system, Microsoft Azure needs us to execute a similar command so that we can prepare our Linux VM to have an </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">image made:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.474.1">
provisioner "shell" {
  execute_command = local.execute_command
  inline = ["/usr/sbin/waagent -force -deprovision+user &amp;&amp; export HISTSIZE=0 &amp;&amp; sync"]
  only = ["azure-arm"]
}</span></pre> <p><span class="koboSpan" id="kobo.475.1">The archaic </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">waagent</span></strong><span class="koboSpan" id="kobo.477.1"> command is of little importance. </span><span class="koboSpan" id="kobo.477.2">You just need to know that this command needs to be executed last for the VM image that Packer builds to be bootable when you launch a new VM from the image. </span><span class="koboSpan" id="kobo.477.3">However, do take notice of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">only</span></strong><span class="koboSpan" id="kobo.479.1"> attribute, which takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">list</span></strong><span class="koboSpan" id="kobo.481.1"> value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">string</span></strong><span class="koboSpan" id="kobo.483.1">. </span><span class="koboSpan" id="kobo.483.2">The only value we have set in this </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">list</span></strong><span class="koboSpan" id="kobo.485.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">azure-arm</span></strong><span class="koboSpan" id="kobo.487.1">. </span><span class="koboSpan" id="kobo.487.2">This indicates to Packer that this provisioner only needs to be executed when we’re building images using that plugin. </span><span class="koboSpan" id="kobo.487.3">As we know, the same Packer template can be used to do multi-targeting, which means you can build multiple images in the same template while targeting multiple different cloud platforms or regions. </span><span class="koboSpan" id="kobo.487.4">This means you can build the same VM image simultaneously on AWS, Azure, and Google Cloud. </span><span class="koboSpan" id="kobo.487.5">You could even build the same VM image on AWS in all 30+ regions. </span><span class="koboSpan" id="kobo.487.6">This isn’t exactly practical as there are much better ways to replicate VM images across regions</span><a id="_idTextAnchor498"/><span class="koboSpan" id="kobo.488.1">, but it can </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">be done.</span></span></p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor499"/><span class="koboSpan" id="kobo.490.1">Terraform</span></h2>
<p><span class="koboSpan" id="kobo.491.1">As we discussed in our design, our solution</span><a id="_idIndexMarker821"/><span class="koboSpan" id="kobo.492.1"> is made up of two application components: the frontend and the </span><a id="_idIndexMarker822"/><span class="koboSpan" id="kobo.493.1">backend. </span><span class="koboSpan" id="kobo.493.2">Each has an application code base that needs to be deployed. </span><span class="koboSpan" id="kobo.493.3">Since this is the first time we will be using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">azurerm</span></strong><span class="koboSpan" id="kobo.495.1"> provider, we’ll look at the basic provider setup and the configuration of the backend before we cover the nuts and bolts of each compone</span><a id="_idTextAnchor500"/><span class="koboSpan" id="kobo.496.1">nt of </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">our architecture.</span></span></p>
<h3><span class="koboSpan" id="kobo.498.1">Provider setup</span></h3>
<p><span class="koboSpan" id="kobo.499.1">We need to specify all the </span><a id="_idIndexMarker823"/><span class="koboSpan" id="kobo.500.1">providers that we intend to use in this solution within the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">required_providers</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.502.1"> block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.503.1">
terraform {
  required_providers {
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "~&gt; 3.75.0"
    }
    cloudinit = {
      source  = "hashicorp/cloudinit"
      version = "~&gt; 2.3.2"
    }
  }
  backend "azurerm" {
  }
}</span></pre> <p><span class="koboSpan" id="kobo.504.1">We must also configure the Azure provider. </span><span class="koboSpan" id="kobo.504.2">Unlike the AWS provider, the Azure provider is not scoped to a particular</span><a id="_idIndexMarker824"/><span class="koboSpan" id="kobo.505.1"> region. </span><span class="koboSpan" id="kobo.505.2">This means you can provision resources across all Azure regions without declaring different Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">provider blocks:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.507.1">
provider "azurerm" {
  features {}
}</span></pre> <p><span class="koboSpan" id="kobo.508.1">The Azure provider requires some additional parameters to specify the credentials to use to connect to Azure, but because these are sensitive values, we don’t want to embed them in the code. </span><span class="koboSpan" id="kobo.508.2">We’ll pass those values in later when we automate the deployment using the standard Azure credentials </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">environment variables:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.510.1">Tenant </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.511.1">ID</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">ARM_TENANT_ID</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.514.1">Subscription </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.515.1">ID</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">ARM_SUBSCRIPTION_ID</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.518.1">Client </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.519.1">ID</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">ARM_CLIENT_ID</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.522.1">Client </span><a id="_idTextAnchor501"/></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.523.1">secret</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">ARM_CLIENT_SECRET</span></strong></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.526.1">Backend</span></h3>
<p><span class="koboSpan" id="kobo.527.1">Because we will be using a CI/CD pipeline to provision and maintain our environment in the long term, we need to set </span><a id="_idIndexMarker825"/><span class="koboSpan" id="kobo.528.1">up a remote backend for our Terraform state. </span><span class="koboSpan" id="kobo.528.2">Because our solution will be hosted on Azure, we’ll use the Azure Blob storage backend to store our </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">Terraform state.</span></span></p>
<p><span class="koboSpan" id="kobo.530.1">Just like the Azure provider, we don’t want to hard code the backend configuration in our code, so we’ll simply set up a placeholder for </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">the backend:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.532.1">
terraform {
  ...
</span><span class="koboSpan" id="kobo.532.2">  backend "azurerm" {
  }
}</span></pre> <p><span class="koboSpan" id="kobo.533.1">We’ll configure the backend’s parameters using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">-backend-config</span></strong><span class="koboSpan" id="kobo.535.1"> parameters when we run </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">terraform i</span><a id="_idTextAnchor502"/><span class="koboSpan" id="kobo.537.1">nit</span></strong><span class="koboSpan" id="kobo.538.1"> in our </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">CI/CD pipeline.</span></span></p>
<h3><span class="koboSpan" id="kobo.540.1">Input variables</span></h3>
<p><span class="koboSpan" id="kobo.541.1">It’s good practice to pass in short names that identify the application’s name and the application’s environment. </span><span class="koboSpan" id="kobo.541.2">This allows you to</span><a id="_idIndexMarker826"/><span class="koboSpan" id="kobo.542.1"> embed consistent naming conventions across the resources that make up your solution. </span><span class="koboSpan" id="kobo.542.2">This makes it easier to identify and track resources from the </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">Azure portal.</span></span></p>
<p><span class="koboSpan" id="kobo.544.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">primary_region</span></strong><span class="koboSpan" id="kobo.546.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">vnet_cidr_block</span></strong><span class="koboSpan" id="kobo.548.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">az_count</span></strong><span class="koboSpan" id="kobo.550.1"> input variables drive key architectural characteristics of the deployment. </span><span class="koboSpan" id="kobo.550.2">They can’t be hard-coded as it would limit the reusability of the Terraform </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.552.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">vnet_cidr_block</span></strong><span class="koboSpan" id="kobo.554.1"> input variable establishes the virtual network address space, which is often tightly regulated by an enterprise governance body. </span><span class="koboSpan" id="kobo.554.2">There is usually a process to ensure that teams across an organization do not use IP address ranges that conflict, thus making it impossible in the future to allow those two applications to integrate or integrate with shared network resources within </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">the enterprise.</span></span></p>
<p><span class="koboSpan" id="kobo.556.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">az_count</span></strong><span class="koboSpan" id="kobo.558.1"> input variable allows us to configure how much redundancy we want within our solution. </span><span class="koboSpan" id="kobo.558.2">This will affect the high availability of the solution but also the cost of the deployment. </span><span class="koboSpan" id="kobo.558.3">As you can imagine, cost is also a tightly regulated characteristic of cloud </span><a id="_idTextAnchor503"/><span class="No-Break"><span class="koboSpan" id="kobo.559.1">infrastructure </span></span><span class="No-Break"><a id="_idIndexMarker827"/></span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">deployments.</span></span></p>
<h3><span class="koboSpan" id="kobo.561.1">Consistent naming and tagging</span></h3>
<p><span class="koboSpan" id="kobo.562.1">Unlike the AWS console, Azure is designed in </span><a id="_idIndexMarker828"/><span class="koboSpan" id="kobo.563.1">such a way that it is extremely easy to get an application-centric view of your deployment. </span><span class="koboSpan" id="kobo.563.2">For this, you can use </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">resource groups:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.565.1">
resource "aws_vpc" "main" {
  cidr_block = var.vpc_cidr_block
  tags = {
    Name        = "${var.application_name}-${var.environment_name}-network"
    application = var.application_name
    environment = var.environment_name
  }
}
resource "azurerm_virtual_network" "main" {
  ...
</span><span class="koboSpan" id="kobo.565.2">  tags = {
    application = var.application_name
    environment = var.environment_name
  }
}</span></pre> <p><span class="koboSpan" id="kobo.566.1">It’s still important to tag the resources that you deploy that indicate what application and what environment they belong to. </span><span class="koboSpan" id="kobo.566.2">This helps with other reporting needs, such as budgets and compliance. </span><span class="koboSpan" id="kobo.566.3">Almost</span><a id="_idIndexMarker829"/><span class="koboSpan" id="kobo.567.1"> all resources within the Azure provider have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">map</span></strong><span class="koboSpan" id="kobo.569.1"> attribute called </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">tags</span></strong><span class="koboSpan" id="kobo.571.1">. </span><span class="koboSpan" id="kobo.571.2">Unlike AWS, each resource has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">name</span></strong><span class="koboSpan" id="kobo.573.1"> value as a </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">required attribute.</span></span></p>
<h3><span class="koboSpan" id="kobo.575.1">Virtual network</span></h3>
<p><span class="koboSpan" id="kobo.576.1">Just as we did in </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.577.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.578.1">, we </span><a id="_idIndexMarker830"/><span class="koboSpan" id="kobo.579.1">need to construct a virtual network and keep its address space as tight as possible to avoid gobbling up unnecessary address space for the broader organization in </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">the future:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.581.1">
resource "azurerm_virtual_network" "main" {
  name                = "vnet-${var.application_name}-${var.environment_name}"
  location            = azurerm_resource_group.main.location
  resource_group_name = azurerm_resource_group.main.name
  address_space       = [var.vnet_cidr_block]
}</span></pre> <p><span class="koboSpan" id="kobo.582.1">Network creation in Azure is simpler than what we did with AWS because we don’t have to segment our subnets based on </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">Availability Zone:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.584.1">
resource "azurerm_subnet" "frontend" {
  name                 = "snet-frontend"
  resource_group_name  = azurerm_resource_group.main.name
  virtual_network_name = azurerm_virtual_network.main.name
  address_prefixes     = [cidrsubnet(var.vnet_cidr_block, 2, 1)]
}</span></pre> <h3><span class="koboSpan" id="kobo.585.1">Load balancing</span></h3>
<p><span class="koboSpan" id="kobo.586.1">As we discussed in the design, the Azure Load Balancer service is structured quite a bit differently than AWS’s</span><a id="_idIndexMarker831"/> <span class="No-Break"><span class="koboSpan" id="kobo.587.1">equivalent offering:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.588.1">
resource "azurerm_public_ip" "frontend" {
  name                = "pip-lb-${var.application_name}-${var.environment_name}-frontend"
  location            = azurerm_resource_group.main.location
  resource_group_name = azurerm_resource_group.main.name
  allocation_method   = "Static"
  sku                 = "Standard"
  zones               = [1, 2, 3]
}
resource "azurerm_lb" "frontend" {
  name                = "lb-${var.application_name}-${var.environment_name}-frontend"
  location            = azurerm_resource_group.main.location
  resource_group_name = azurerm_resource_group.main.name
  sku                 = "Standard"
  frontend_ip_configuration {
    name                 = "PublicIPAddress"
    public_ip_address_id = azurerm_public_ip.frontend.id
    zones                = [1, 2, 3]
  }
}</span></pre> <p><span class="koboSpan" id="kobo.589.1">It’s important to call out that to achieve zonal resiliency, we need to ensure that all components of our architecture </span><a id="_idIndexMarker832"/><span class="koboSpan" id="kobo.590.1">are deployed in a zone-resilient way. </span><span class="koboSpan" id="kobo.590.2">This often requires setting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">zones</span></strong><span class="koboSpan" id="kobo.592.1"> attribute and specifying which Availability Zones we want to </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">provision into.</span></span></p>
<p><span class="koboSpan" id="kobo.594.1">The backend configuration of Azure Load Balancer is a simple logical container for the backend </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">address pool:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.596.1">
resource "azurerm_lb_backend_address_pool" "frontend" {
  loadbalancer_id = azurerm_lb.frontend.id
  name            = "frontend-pool"
}</span></pre> <p><span class="koboSpan" id="kobo.597.1">This logical container must be linked to either static VMs or </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">a VMSS:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.599.1">
resource "azurerm_network_interface_backend_address_pool_association" "frontend" {
  count = var.az_count
  network_interface_id    = azurerm_network_interface.frontend[count.index].id
  ip_configuration_name   = "internal"
  backend_address_pool_id = azurerm_lb_backend_address_pool.frontend.id
}</span></pre> <p><span class="koboSpan" id="kobo.600.1">In the preceding backend address pool association resource, we are iterating over </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">var.az_count</span></strong><span class="koboSpan" id="kobo.602.1">. </span><span class="koboSpan" id="kobo.602.2">This is the same number that we iterate over the VMs, which allows us to put a single VM into each Availability Zone. </span><span class="koboSpan" id="kobo.602.3">Unlike AWS, where the load balancer rules are split between a listener </span><a id="_idIndexMarker833"/><span class="koboSpan" id="kobo.603.1">and a target group configuration, an Azure load balancer rule combines the two and then links them to a corresponding </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">health probe:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.605.1">
resource "azurerm_lb_probe" "frontend_probe_http" {
  loadbalancer_id = azurerm_lb.frontend.id
  name            = "http"
  protocol        = "Http"
  port            = 5000
  request_path    = "/"
}
resource "azurerm_lb_rule" "frontend_http" {
  loadbalancer_id                = azurerm_lb.frontend.id
  name                           = "HTTP"
  protocol                       = "Tcp"
  frontend_port                  = 80
  backend_port                   = 5000
  frontend_ip_configuration_name = "PublicIPAddress"
  probe_id                       = azurerm_lb_probe.frontend_probe_http.id
  backend_address_pool_ids       = [azurerm_lb_backend_address_pool.frontend.id]
  disable_outbound_snat          = true
}</span></pre> <p><span class="koboSpan" id="kobo.606.1">Notice how the load balancer rule connects many of the components, including the frontend IP configuration, the listener on AWS, the health probe, and the backend address pool – the target group </span><a id="_idIndexMarker834"/><span class="No-Break"><span class="koboSpan" id="kobo.607.1">on AWS.</span></span></p>
<h3><span class="koboSpan" id="kobo.608.1">Network security</span></h3>
<p><span class="koboSpan" id="kobo.609.1">First, we need to set up the </span><a id="_idIndexMarker835"/><span class="koboSpan" id="kobo.610.1">logical ASG for each application architectural component. </span><span class="koboSpan" id="kobo.610.2">We’ll have one for the frontend and one for </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">the backend:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.612.1">
resource "azurerm_application_security_group" "frontend" {
  name                = "asg-${var.application_name}-${var.environment_name}-frontend"
  resource_group_name = azurerm_resource_group.main.name
  location            = azurerm_resource_group.main.location
}</span></pre> <p><span class="koboSpan" id="kobo.613.1">Next, we need to create NSGs that allow the necessary traffic into each of </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">the ASGs:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.615.1">
resource "azurerm_network_security_group" "frontend" {
  name                = "nsg-${var.application_name}-${var.environment_name}-frontend"
  resource_group_name = azurerm_resource_group.main.name
  location            = azurerm_resource_group.main.location
}
resource "azurerm_network_security_rule" "frontend_http" {
  resource_group_name                        = azurerm_resource_group.main.name
  network_security_group_name                = azurerm_network_security_group.frontend.name
  name                                       = "allow-http"
  priority                                   = "2001"
  access                                     = "Allow"
  direction                                  = "Inbound"
  protocol                                   = "Tcp"
  source_port_range                          = "*"
  destination_port_range                     = "5000"
  source_address_prefix                      = "*"
  destination_address_prefix                 = "*"
  destination_application_security_group_ids = [azurerm_application_security_group.frontend.id]
}</span></pre> <h3><span class="koboSpan" id="kobo.616.1">Secrets management</span></h3>
<p><span class="koboSpan" id="kobo.617.1">First, we’ll set up </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">Key</span></span><span class="No-Break"><a id="_idIndexMarker836"/></span><span class="No-Break"><span class="koboSpan" id="kobo.619.1"> Vault:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.620.1">
resource "azurerm_key_vault" "main" {
  name                       = "kv-${var.application_name}-${var.environment_name}"
  location                   = azurerm_resource_group.main.location
  resource_group_name        = azurerm_resource_group.main.name
  tenant_id                  = data.azurerm_client_config.current.tenant_id
  soft_delete_retention_days = 7
  purge_protection_enabled   = false
  sku_name                   = "standard"
  enable_rbac_authorization  = true
}</span></pre> <p><span class="koboSpan" id="kobo.621.1">Then, we’ll set up a</span><a id="_idIndexMarker837"/><span class="koboSpan" id="kobo.622.1"> managed identity for each application </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">architectural component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.624.1">
resource "azurerm_user_assigned_identity" "frontend" {
  name                = "${var.application_name}-${var.environment_name}-frontend"
  location            = azurerm_resource_group.main.location
  resource_group_name = azurerm_resource_group.main.name
}</span></pre> <p><span class="koboSpan" id="kobo.625.1">Next, we’ll grant the managed identity the necessary privileges using Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">role assignments:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.627.1">
resource "azurerm_role_assignment" "frontend_keyvault" {
  scope                = azurerm_key_vault.main.id
  role_definition_name = "Key Vault Secrets User"
  principal_id         = azurerm_user_assigned_identity.frontend.principal_id
}</span></pre> <h3><span class="koboSpan" id="kobo.628.1">VMs</span></h3>
<p><span class="koboSpan" id="kobo.629.1">First, we’ll obtain the VM image from our input variables. </span><span class="koboSpan" id="kobo.629.2">We built this VM image with Packer and provisioned it into a </span><a id="_idIndexMarker838"/><span class="koboSpan" id="kobo.630.1">different Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">resource group:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.632.1">
data "azurerm_image" "frontend" {
  name                = var.frontend_image.name
  resource_group_name = var.frontend_image.resource_group_name
}</span></pre> <p><span class="koboSpan" id="kobo.633.1">Then, we’ll create the network interface for each VM by iterating over the </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">var.az_count</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.635.1">input variable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.636.1">
resource "azurerm_network_interface" "frontend" {
  count = var.az_count
  name                = "nic-${var.application_name}-${var.environment_name}-frontend${count.index}"
  location            = azurerm_resource_group.main.location
  resource_group_name = azurerm_resource_group.main.name
  ip_configuration {
    name                          = "internal"
    subnet_id                     =</span><strong class="source-inline"> </strong><span class="koboSpan" id="kobo.637.1">azurerm_subnet.frontend.id
    private_ip_address_allocation = "Dynamic"
  }
}</span></pre> <p><span class="koboSpan" id="kobo.638.1">Finally, we’ll set up the VM with all the necessary attributes and link it to the network interface, the VM image, and the </span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">managed identity:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.640.1">
resource "azurerm_linux_virtual_machine" "frontend" {
  count = var.az_count
  name                = "vm-${var.application_name}-${var.environment_name}-frontend${count.index}"
  resource_group_name = azurerm_resource_group.main.name
  location            = azurerm_resource_group.main.location
  size                = "Standard_F2"
  admin_username      = var.admin_username
  zone                = count.index + 1
  network_interface_ids = [
    azurerm_network_interface.frontend[count.index].id
  ]
  admin_ssh_key {
    username   = var.admin_username
    public_key = tls_private_key.ssh.public_key_openssh
  }
  os_disk {
    caching              = "ReadWrite"
    storage_account_type = "Standard_LRS"
  }
  source_image_id = data.azurerm_image.frontend.id
  user_data       = data.cloudinit_config.frontend.rendered
}</span></pre> <p><span class="koboSpan" id="kobo.641.1">With that, we’ve implemented</span><a id="_idIndexMarker839"/><span class="koboSpan" id="kobo.642.1"> the Packer and Terraform solutions and have a working code base that will build VM images for both our frontend and backend application components and provision our cloud environment into Azure. </span><span class="koboSpan" id="kobo.642.2">In the next section, we’ll dive into the YAML and Bash and implement the GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">Actions workflows.</span></span></p>
<h1 id="_idParaDest-202"><a id="_idTextAnchor504"/><span class="koboSpan" id="kobo.644.1">Automating the deployment</span></h1>
<p><span class="koboSpan" id="kobo.645.1">As we discussed in our design, our solution is made up of two application components: the frontend and the backend. </span><span class="koboSpan" id="kobo.645.2">Each has a code base consisting of application code and operating system configuration </span><a id="_idIndexMarker840"/><span class="koboSpan" id="kobo.646.1">encapsulated within a Packer template. </span><span class="koboSpan" id="kobo.646.2">These two application components are then deployed into a cloud environment on Azure that’s defined within our Terraform </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.648.1">Just as we did in </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.649.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.650.1"> with the AWS solution, there is an additional code base that we have to discuss: our automation pipelines on </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">GitHub Actions.</span></span></p>
<p><span class="koboSpan" id="kobo.652.1">In </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.653.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.654.1">, we went over the folder structure for our code base and where our GitHub Actions fit in so that we know that our automation pipelines are called workflows, and they’re stored in </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">/.github/workflows</span></strong><span class="koboSpan" id="kobo.656.1">. </span><span class="koboSpan" id="kobo.656.2">Each of our code bases is stored in its respective folder. </span><span class="koboSpan" id="kobo.656.3">Our solutions source code repository’s folder structure will look </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">like this:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">github</span></strong></span><ul><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">workflows</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">dotnet</span></strong></span><ul><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">backend</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">frontend</span></strong></span></li></ul></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">packer</span></strong></span><ul><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">backend</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">frontend</span></strong></span></li></ul></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">terraform</span></strong></span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.668.1">As per our design, we will have GitHub Actions workflows that will execute Packer and build VM images for both the frontend (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">packer-frontend.yaml</span></strong><span class="koboSpan" id="kobo.670.1">) and the backend (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">packer-backend.yaml</span></strong><span class="koboSpan" id="kobo.672.1">). </span><span class="koboSpan" id="kobo.672.2">We’ll also have workflows that will run </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">terraform plan</span></strong><span class="koboSpan" id="kobo.674.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">terraform apply</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">github</span></strong></span><ul><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">workflows</span></strong></span><ul><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">packer-backend.yaml</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">packer-frontend.yaml</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">terraform-apply.yaml</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">terraform-plan.yaml</span></strong></span></li></ul></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.684.1">In </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.685.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.686.1">, we went into greater detail on the GitFlow process and how it interacts with our GitHub Actions </span><a id="_idIndexMarker841"/><span class="koboSpan" id="kobo.687.1">workflows, so for now, let’s dig into how these pipelines will differ when targeting the </span><span class="No-Break"><span class="koboSpan" id="kobo.688.1">Azure platform.</span></span></p>
<h2 id="_idParaDest-203"><a id="_idTextAnchor505"/><span class="koboSpan" id="kobo.689.1">Packer</span></h2>
<p><span class="koboSpan" id="kobo.690.1">In </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.691.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.692.1">, we went into great detail about each step of the GitHub Actions workflow that executes Packer to build </span><a id="_idIndexMarker842"/><span class="koboSpan" id="kobo.693.1">VM images. </span><span class="koboSpan" id="kobo.693.2">Thanks to the nature of Packer’s cloud-agnostic architecture, this overwhelmingly stays the same. </span><span class="koboSpan" id="kobo.693.3">The only thing that changes is the final step where we </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">execute Packer.</span></span></p>
<p><span class="koboSpan" id="kobo.695.1">Because Packer needs to be configured to build a VM on Microsoft Azure, we need to pass in different input variables that are Azure-specific. </span><span class="koboSpan" id="kobo.695.2">This includes the Microsoft Azure credential attributes, an Azure region, and an Azure resource </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">group name.</span></span></p>
<p><span class="koboSpan" id="kobo.697.1">Just as we did with the input variables for the Packer template for AWS, we must ensure that all Azure input variables are prefixed with </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">azure_</span></strong><span class="koboSpan" id="kobo.699.1">. </span><span class="koboSpan" id="kobo.699.2">This will help if we ever want to introduce multi-targeting as many cloud platforms will have similar required inputs, such as target region and VM size. </span><span class="koboSpan" id="kobo.699.3">While most clouds will have similar required inputs, the input values are </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">not interchangeable.</span></span></p>
<p><span class="koboSpan" id="kobo.701.1">For example, both Azure and AWS require you to specify the region that you want Packer to provide the temporary VM into and the resulting VM image to be stored. </span><span class="koboSpan" id="kobo.701.2">On Azure, the region has a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">westus2</span></strong><span class="koboSpan" id="kobo.703.1">, while on AWS, it has a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">us-west-2</span></strong><span class="koboSpan" id="kobo.705.1">. </span><span class="koboSpan" id="kobo.705.2">They may seem very similar, but they are miles apart (pun intended). </span><span class="koboSpan" id="kobo.705.3">Azure West US 2 region is completely different than AWS’s West US 2 region – in fact, besides just being on different cloud platforms, they are physically different locations, with Azure’s West US 2 region being located in Washington State and AWS’s West US 2 region being located in Oregon. </span><span class="koboSpan" id="kobo.705.4">Neighbors, yes, the same thing – </span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">hardly.</span></span></p>
<p><span class="koboSpan" id="kobo.707.1">This goes back to Packer’s strategy of isolating platform-specific configuration within the builders. </span><span class="koboSpan" id="kobo.707.2">Therefore, if we are going to do multi-targeting, the AWS plugin is going to need input variables that are AWS-specific and the Azure plugin is going to need input variables that are Azure-specific. </span><span class="koboSpan" id="kobo.707.3">Hence, when we merge these plugins into one Packer template, we’ll need input variables </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">for both.</span></span></p>
<p><span class="koboSpan" id="kobo.709.1">As a result, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">aws_primary_region</span></strong><span class="koboSpan" id="kobo.711.1">, which has a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">us-west-2</span></strong><span class="koboSpan" id="kobo.713.1">, can sit right next to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">azure_primary_region</span></strong><span class="koboSpan" id="kobo.715.1">, which has a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">westus2</span></strong><span class="koboSpan" id="kobo.717.1">, without any conflicts or confusion. </span><span class="koboSpan" id="kobo.717.2">Likewise, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">aws_instance_type</span></strong><span class="koboSpan" id="kobo.719.1"> with a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">t2.small</span></strong><span class="koboSpan" id="kobo.721.1"> can sit right next to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">azure_vm_size</span></strong><span class="koboSpan" id="kobo.723.1"> with a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">Standard_DS2_v2</span></strong><span class="koboSpan" id="kobo.725.1">. </span><span class="koboSpan" id="kobo.725.2">The differences can get even more radical as you take advantage of more platform-specific capabilities within </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">the builders.</span></span></p>
<p><span class="koboSpan" id="kobo.727.1">The GitHub Actions workflow YAML files are identical to Azure, except for the additional input variables that need to </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">be specified:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.729.1">
- id: build
  name: Packer Build
  env:
    PKR_VAR_arm_subscription_id: ${{ vars.ARM_SUBSCRIPTION_ID }}
    PKR_VAR_arm_tenant_id: ${{ vars.ARM_TENANT_ID }}
    PKR_VAR_arm_client_id: ${{ vars.PACKER_ARM_CLIENT_ID }}
    PKR_VAR_arm_client_secret: ${{ secrets.PACKER_ARM_CLIENT_SECRET }}
    PKR_VAR_image_version: ${{ steps.image-version.outputs.version }}
    PKR_VAR_agent_ipaddress: ${{ steps.agent-ipaddress.outputs.ipaddress }}
  working-directory: ${{ env.WORKING_DIRECTORY }}
  run: |
    packer init ./
    packer build -var-file=variables.pkrvars.hcl ./</span></pre> <p><span class="koboSpan" id="kobo.730.1">The preceding code references</span><a id="_idIndexMarker843"/><span class="koboSpan" id="kobo.731.1"> the four Azure credential attributes, which are stored as GitHub Actions variables and secrets, and transfers them to Packer using environment variables with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">PKR_VAR_</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.733.1"> prefix.</span></span></p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor506"/><span class="koboSpan" id="kobo.734.1">Terraform</span></h2>
<p><span class="koboSpan" id="kobo.735.1">With both of our VM images built and</span><a id="_idIndexMarker844"/><span class="koboSpan" id="kobo.736.1"> their versions input into our </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">tfvars</span></strong><span class="koboSpan" id="kobo.738.1"> file, our Terraform automation pipeline is ready to take the reigns and not only provision our environment but deploy our solution as well (although not technically). </span><span class="koboSpan" id="kobo.738.2">The deployment was technically done within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">packer build</span></strong><span class="koboSpan" id="kobo.740.1"> process, with the physical deployment packages being copied to the home directory and the Linux service setup primed and ready. </span><span class="koboSpan" id="kobo.740.2">Terraform is finishing the job by actually launching VMs using </span><span class="No-Break"><span class="koboSpan" id="kobo.741.1">these images.</span></span></p>
<p><span class="koboSpan" id="kobo.742.1">In </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.743.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.744.1">, we went into great detail about each step of the GitHub Actions workflow that executes Terraform to provision the cloud environment and deploy the application code. </span><span class="koboSpan" id="kobo.744.2">Thanks to the nature of</span><a id="_idIndexMarker845"/><span class="koboSpan" id="kobo.745.1"> Terraform’s cloud-agnostic architecture, this overwhelmingly stays the same. </span><span class="koboSpan" id="kobo.745.2">The only thing that changes is the final step where we </span><span class="No-Break"><span class="koboSpan" id="kobo.746.1">execute Terraform.</span></span></p>
<p><span class="koboSpan" id="kobo.747.1">Just like we did in </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.748.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.749.1"> with the AWS provider, we can set the authentication context using environment variables that are specific to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">azurerm</span></strong><span class="koboSpan" id="kobo.751.1"> provider. </span><span class="koboSpan" id="kobo.751.2">In this case, the four Azure credentials attributes are passed in with the following </span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">environment variables:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.753.1">Tenant </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.754.1">ID</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.755.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">ARM_TENANT_ID</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.757.1">Subscription </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.758.1">ID</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">ARM_SUBSCRIPTION_ID</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.761.1">Client </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.762.1">ID</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.763.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">ARM_CLIENT_ID</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.765.1">Client </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.766.1">secret</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">ARM_CLIENT_SECRET</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.769.1">Just like we did in </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.770.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.771.1"> with the AWS provider, we need to configure the Azure-specific backend that stores the Terraform state using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">-backend-config</span></strong><span class="koboSpan" id="kobo.773.1"> command-line arguments to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">terraform init</span></strong><span class="koboSpan" id="kobo.775.1"> command. </span><span class="koboSpan" id="kobo.775.2">Unlike AWS, which only specifies an S3 bucket name to configure the backend to save the Terraform state to S3, to configure the Azure backend, we need to specify three fields to triangulate a location in Azure Blob storage to save the Terraform state – a resource group, storage account, and Blob </span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">storage container.</span></span></p>
<p><span class="koboSpan" id="kobo.777.1">The hierarchy of Azure resources looks </span><span class="No-Break"><span class="koboSpan" id="kobo.778.1">like this:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.779.1">Resource group</span></span><ul><li><span class="No-Break"><span class="koboSpan" id="kobo.780.1">Storage account</span></span><ul><li><span class="koboSpan" id="kobo.781.1">Blob </span><span class="No-Break"><span class="koboSpan" id="kobo.782.1">storage container</span></span><ul><li><span class="koboSpan" id="kobo.783.1">Terraform </span><span class="No-Break"><span class="koboSpan" id="kobo.784.1">state files</span></span></li></ul></li></ul></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.785.1">Like with the AWS provider, the backend uses a </span><em class="italic"><span class="koboSpan" id="kobo.786.1">key</span></em><span class="koboSpan" id="kobo.787.1"> and the Terraform workspace name to uniquely identify the location to store </span><span class="No-Break"><span class="koboSpan" id="kobo.788.1">state files:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.789.1">
- id: apply
  name: Terraform Apply
  env:
    ARM_SUBSCRIPTION_ID: ${{ vars.ARM_SUBSCRIPTION_ID }}
    ARM_TENANT_ID: ${{ vars.ARM_TENANT_ID }}
    ARM_CLIENT_ID: ${{ vars.TERRAFORM_ARM_CLIENT_ID }}
    ARM_CLIENT_SECRET: ${{ secrets.TERRAFORM_ARM_CLIENT_SECRET }}
    BACKEND_RESOURCE_GROUP_NAME: ${{ vars.BACKEND_RESOURCE_GROUP_NAME }}
    BACKEND_STORAGE_ACCOUNT_NAME: ${{ vars.BACKEND_STORAGE_ACCOUNT_NAME }}
    BACKEND_STORAGE_CONTAINER_NAME: ${{ vars.BACKEND_STORAGE_CONTAINER_NAME }}
    TF_BACKEND_KEY: ${{ env.APPLICATION_NAME }}-${{ env.ENVIRONMENT_NAME }}
  working-directory: ${{ env.WORKING_DIRECTORY }}
  run: |
    terraform init \
      -backend-config="resource_group_name=$BACKEND_RESOURCE_GROUP_NAME" \
      -backend-config="storage_account_name=$BACKEND_STORAGE_ACCOUNT_NAME" \
      -backend-config="container_name=$BACKEND_STORAGE_CONTAINER_NAME" \
      -backend-config="key=$TF_BACKEND_KEY"
    terraform apply -auto-approve</span></pre> <p><span class="koboSpan" id="kobo.790.1">Notice how, unlike with the AWS solution, we don’t need to perform a targeted </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">terraform apply</span></strong><span class="koboSpan" id="kobo.792.1">. </span><span class="koboSpan" id="kobo.792.2">This is because we don’t need to do dynamic calculations based on the number of Availability Zones in the region to configure our virtual network. </span><span class="koboSpan" id="kobo.792.3">This is due to Azure Virtual Network and its subnets spanning all Availability Zones within the region whereas, on AWS, a subnet is constrained to a specific Availability Zone within the parent virtual </span><span class="No-Break"><span class="koboSpan" id="kobo.793.1">network’s region.</span></span></p>
<p><span class="koboSpan" id="kobo.794.1">These subtle architectural </span><a id="_idIndexMarker846"/><span class="koboSpan" id="kobo.795.1">differences between the cloud platforms can create radical structural changes even when deploying the same solution using the same technologies. </span><span class="koboSpan" id="kobo.795.2">It is a sobering reminder that while knowledge of the core concepts we looked at in </span><em class="italic"><span class="koboSpan" id="kobo.796.1">Chapters 4</span></em><span class="koboSpan" id="kobo.797.1"> through </span><em class="italic"><span class="koboSpan" id="kobo.798.1">6</span></em><span class="koboSpan" id="kobo.799.1"> will help us transcend to a multi-cloud point of view, to implement practical solutions, we need to </span><a id="_idTextAnchor507"/><span class="koboSpan" id="kobo.800.1">understand the subtle nuances of </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">each platform.</span></span></p>
<h1 id="_idParaDest-205"><a id="_idTextAnchor508"/><span class="koboSpan" id="kobo.802.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.803.1">In this chapter, we built a multi-tier cloud architecture using Azure VMs with a fully operation GitFlow process and an end-to-end CI/CD pipeline using </span><span class="No-Break"><span class="koboSpan" id="kobo.804.1">GitHub Actions.</span></span></p>
<p><span class="koboSpan" id="kobo.805.1">In the next chapter, our fearless leader at Söze Enterprises will be throwing us into turmoil with some big new ideas, and we’ll have to respond to his call to action. </span><span class="koboSpan" id="kobo.805.2">It turns out our CEO, Keyser, has been up late watching some YouTube videos about the next big thing – containers – and after talking with his pal Satya on his superyacht, he has decided that we need to refactor our whole solution to run on Docker and Kubernetes. </span><span class="koboSpan" id="kobo.805.3">Luckily, the good people at Microsoft have a service that might help us out: </span><strong class="bold"><span class="koboSpan" id="kobo.806.1">Azure Kubernetes </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.807.1">Service</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.808.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.809.1">AKS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">).</span></span></p>
</div>
</body></html>