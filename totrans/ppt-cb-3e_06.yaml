- en: Chapter 6. Managing Resources and Files
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"The art of simplicity is a puzzle of complexity".* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
- en: '|   | --Douglas Horton |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Distributing cron jobs efficiently
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling when resources are applied
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using host resources
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using exported host resources
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using multiple file sources
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributing and merging directory trees
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleaning up old files
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auditing resources
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Temporarily disabling resources
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we introduced virtual and exported resources. Virtual
    and exported resources are ways to manage the way in which resources are applied
    to a node. In this chapter, we will deal with when and how to apply resources.
    In some cases, you may only wish to apply a resource off hours, while in others,
    you may wish to only audit the resource but change nothing. In other cases, you
    may wish to apply completely different resources based on which node is using
    the code. As we will see, Puppet has the flexibility to deal with all these scenarios.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Distributing cron jobs efficiently
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you have many servers executing the same cron job, it's usually a good
    idea not to run them all at the same time. If all the jobs access a common server
    (for example, when running backups), it may put too much load on that server,
    and even if they don't, all the servers will be busy at the same time, which may
    affect their capacity to provide other services.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: As usual, Puppet can help; this time, using the `inline_template` function to
    calculate a unique time for each job.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s how to have Puppet schedule the same job at a different time for each
    machine:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify your `site.pp` file as follows:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Run Puppet:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Run `crontab` to see how the job has been configured:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want to distribute the hour of the cron job runs across all our nodes. We
    choose something that is unique across all the machines and convert it to a number.
    This way, the value will be distributed across the nodes and will not change per
    node.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: We can do the conversion using Ruby's `sum` method, which computes a numerical
    value from a string that is unique to the machine (in this case, the machine's
    hostname). The `sum` function will generate a large integer (in the case of the
    string `cookbook`, the sum is 855), and we want values for `hour` between 0 and
    23, so we use Ruby's `%` (modulo) operator to restrict the result to this range.
    We should get a reasonably good (though not statistically uniform) distribution
    of values, depending on your hostnames. Another option here is to use the `fqdn_rand()`
    function, which works in much the same way as our example.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: If all your machines have the same name (it does happen), don't expect this
    trick to work! In this case, you can use some other string that is unique to the
    machine, such as `ipaddress` or `fqdn`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have several cron jobs per machine and you want to run them a certain
    number of hours apart, add this number to the `hostname.sum` resource before taking
    the modulus. Let''s say we want to run the `dump_database` job at some arbitrary
    time and the `run_backup` job an hour later, this can be done using the following
    code snippet:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The two jobs will end up with different `hour` values for each machine Puppet
    runs on, but `run_backup` will always be one hour after `dump_database`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'Most cron implementations have directories for hourly, daily, weekly, and monthly
    tasks. The directories `/etc/cron.hourly`, `/etc/cron.daily`, `/etc/cron.weekly`,
    and `/etc/cron.monthly` exist on both our Debian and Enterprise Linux machines.
    These directories hold executables, which will be run on the referenced schedule
    (hourly, daily, weekly, or monthly). I find it better to describe all the jobs
    in these folders and push the jobs as `file` resources. An admin on the box searching
    for your script will be able to find it with `grep` in these directories. To use
    the same trick here, we would push a cron task into `/etc/cron.hourly` and then
    verify that the hour is the correct hour for the task to run. To create the cron
    jobs using the cron directories, follow these steps:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a `cron` class in `modules/cron/init.pp`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Include the `cron` class in your cookbook node in `site.pp`:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a template to hold the cron task:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, run Puppet:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Verify that the script has the same value we calculated before, `15`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, this job will run every hour but only when the hour, returned by `$(date
    +%H)`, is equal to `15` will the rest of the script run. Creating your cron jobs
    as file resources in a large organization makes it easier for your fellow administrators
    to find them. When you have a very large number of machines, it can be advantageous
    to add another random wait at the beginning of your job. You would need to modify
    the line before `echo run-backup` and add the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will sleep a maximum of `600` seconds but will sleep a different amount
    each time it runs (assuming your random number generator is working). This sort
    of random wait is useful when you have thousands of machines, all running the
    same task and you need to stagger the runs as much as possible.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Running Puppet from cron* recipe in [Chapter 2](ch02.html "Chapter 2. Puppet
    Infrastructure"), *Puppet Infrastructure*
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling when resources are applied
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we looked at what Puppet can do, and the order that it does things
    in, but not when it does them. One way to control this is to use the `schedule`
    metaparameter. When you need to limit the number of times a resource is applied
    within a specified period, `schedule` can help. For example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The most important thing to understand about `schedule` is that it can only
    stop a resource being applied. It doesn't guarantee that the resource will be
    applied with a certain frequency. For example, the `exec` resource shown in the
    preceding code snippet has `schedule => daily`, but this just represents an upper
    limit on the number of times the `exec` resource can run per day. It won't be
    applied more than once a day. If you don't run Puppet at all, the resource won't
    be applied at all. Using the hourly schedule, for instance, is meaningless on
    a machine configured to run the agent every 4 hours (via the `runinterval` configuration
    setting).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'That being said, `schedule` is best used to restrict resources from running
    when they shouldn''t, or don''t need to; for example, you might want to make sure
    that `apt-get update` isn''t run more than once an hour. There are some built-in
    schedules available for you to use:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '`hourly`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`daily`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`weekly`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`monthly`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`never`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, you can modify these and create your own custom schedules, using the
    `schedule` resource. We'll see how to do this in the following example. Let's
    say we want to make sure that an `exec` resource representing a maintenance job
    won't run during office hours, when it might interfere with production.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we''ll create a custom `schedule` resource and assign this
    to the resource:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify your `site.pp` file as follows:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Run Puppet. What you''ll see will depend on the time of the day. If it''s currently
    outside the office hours period you defined, Puppet will apply the resource as
    follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the time is within the office hours period, Puppet will do nothing:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A schedule consists of three bits of information:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: The `period` (`hourly`, `daily`, `weekly`, or `monthly`)
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `range` (defaults to the whole period, but can be a smaller part of it)
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `repeat` count (how often the resource is allowed to be applied within the
    range; the default is 1 or once per period)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our custom schedule named `outside-office-hours` supplies these three parameters:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `period` is `daily`, and `range` is defined as an array of two time intervals:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The schedule named `outside-office-hours` is now available for us to use with
    any resource, just as though it were built into Puppet such as the `daily` or
    `hourly` schedules. In our example, we assign this schedule to the `exec` resource
    using the `schedule` metaparameter:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Without this `schedule` parameter, the resource would be applied every time
    Puppet runs. With it, Puppet will check the following parameters to decide whether
    or not to apply the resource:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Whether the time is in the permitted range
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the resource has already been run the maximum permitted number of times
    in this period
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, let''s consider what happens if Puppet runs at 4 p.m., 5 p.m.,
    and 6 p.m. on a given day:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '**4 p.m.**: It''s outside the permitted time range, so Puppet will do nothing'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**5 p.m.**: It''s inside the permitted time range, and the resource hasn''t
    been run yet in this period, so Puppet will apply the resource'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**6 p.m.**: It''s inside the permitted time range, but the resource has already
    been run the maximum number of times in this period, so Puppet will do nothing'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And so on until the next day.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `repeat` parameter governs how many times the resource will be applied
    given the other constraints of the schedule. For example, to apply a resource
    no more than six times an hour, use a schedule as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Remember that this won't guarantee that the job is run six times an hour. It
    just sets an upper limit; no matter how often Puppet runs or anything else happens,
    the job won't be run if it has already run six times this hour. If Puppet only
    runs once a day, the job will just be run once. So `schedule` is best used to
    make sure things don't happen at certain times (or don't exceed a given frequency).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Using host resources
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's not always practical or convenient to use DNS to map your machine names
    to IP addresses, especially in cloud infrastructures, where those addresses may
    change all the time. However, if you use entries in the `/etc/hosts` file instead,
    you then have the problem of how to distribute these entries to all machines and
    keep them up to date.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Here's a better way to do it; Puppet's host resource type controls a single
    `/etc/hosts` entry, and you can use this to map a hostname to an IP address easily
    across your whole network. For example, if all your machines need to know the
    address of the main database server, you can manage it with a `host` resource.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create an example `host` resource:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify your `site.pp` file as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run Puppet:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Puppet will check the `target` file (usually `/etc/hosts`) to see whether the
    host entry already exists, and if not, add it. If an entry for that hostname already
    exists with a different address, Puppet will change the address to match the manifest.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Organizing your host resources into classes can be helpful. For example, you
    could put the host resources for all your DB servers into one class called `admin::dbhosts`,
    which is included by all web servers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Where machines may need to be defined in multiple classes (for example, a database
    server might also be a repository server), virtual resources can solve this problem.
    For example, you could define all your hosts as virtual in a single class:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You could then realize the hosts you need in the various classes:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using exported host resources
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example, we used the spaceship syntax to collect virtual host
    resources for hosts of type database or type web. You can use the same trick with
    exported resources. The advantage to using exported resources is that as you add
    more database servers, the collector syntax will automatically pull in the newly
    created exported host entries for those servers. This makes your `/etc/hosts`
    entries more dynamic.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be using exported resources. If you haven't already done so, set up
    puppetdb and enable storeconfigs to use puppetdb as outlined in [Chapter 2](ch02.html
    "Chapter 2. Puppet Infrastructure"), *Puppet Infrastructure*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we will configure database servers and clients to communicate
    with each other. We'll make use of exported resources to do the configuration.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new database module, `db`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a new class for your database servers, `db::server`:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a new class for your database clients:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Apply the database server module to some nodes, in `site.pp`, for example:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Run Puppet on the nodes with the database server module to create the exported
    resources.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Apply the database client module to cookbook:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run Puppet:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Verify the host entries in `/etc/hosts`:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `db::server` class, we create an exported host resource:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This resource uses the fully qualified domain name (`$::fqdn`) of the node on
    which it is applied. We also use the short hostname (`$::hostname`) as an alias
    of the node. Aliases are printed after `fqdn` in `/etc/hosts`. We use the node's
    `$::ipaddress` fact as the IP address for the host entry. Finally, we add a tag
    to the resource so that we can collect based on that tag later.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: The important thing to remember here is that if the ip address should change
    for the host, the exported resource will be updated, and nodes that collect the
    exported resource will update their host records accordingly.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'We created a collector in `db::client`, which only collects exported host resources
    that have been tagged with `''db::server''`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We applied the `db::server` class for a couple of nodes, dbserver1 and dbserver2,
    which we then collected on cookbook by applying the `db::client` class. The host
    entries were placed in `/etc/hosts` (the default file). We can see that the host
    entry contains both the fqdn and the short hostname for dbserver1 and dbserver2.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using exported resources in this manner is very useful. Another similar system
    would be to create an NFS server class, which creates exported resources for the
    mount points that it exports (via NFS). You can then use tags to have clients
    collect the appropriate mount points from the server. In the previous example,
    we made use of a tag to aid in our collection of exported resources. It is worth
    noting that there are several tags automatically added to resources when they
    are created, one of which is the scope where the resource was created.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Using multiple file sources
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A neat feature of Puppet's `file` resource is that you can specify multiple
    values for the `source` parameter. Puppet will search them in order. If the first
    source isn't found, it moves on to the next, and so on. You can use this to specify
    a default substitute if the particular file isn't present, or even a series of
    increasingly generic substitutes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet `file` 资源的一个优点是可以为 `source` 参数指定多个值。Puppet 会按顺序进行查找。如果找不到第一个源，它会继续查找下一个，以此类推。你可以利用这一点指定默认替代文件，或者甚至指定一系列逐渐通用的替代文件。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'This example demonstrates using multiple file sources:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例展示了如何使用多个文件源：
- en: 'Create a new greeting module as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式创建一个新的问候模块：
- en: '[PRE31]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create the file `modules/greeting/files/hello.txt` with the following contents:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件 `modules/greeting/files/hello.txt`，内容如下：
- en: '[PRE32]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create the file `modules/greeting/files/universal.txt` with the following contents:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件 `modules/greeting/files/universal.txt`，内容如下：
- en: '[PRE33]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the class to a node:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类添加到节点：
- en: '[PRE34]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Run Puppet:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Puppet：
- en: '[PRE35]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Check the contents of the `/tmp/greeting` file:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 `/tmp/greeting` 文件的内容：
- en: '[PRE36]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now remove the `hello.txt` file from your Puppet repository and rerun the agent:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从 Puppet 仓库中移除 `hello.txt` 文件，并重新运行代理：
- en: '[PRE37]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'On the first Puppet run, puppet searches for the available file sources in
    the order given:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次运行 Puppet 时，Puppet 按照给定的顺序搜索可用的文件源：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The file `hello.txt` is first in the list, and is present, so Puppet uses that
    as the source for `/tmp/greeting`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`hello.txt` 文件位于列表的第一位，并且存在，因此 Puppet 使用该文件作为 `/tmp/greeting` 的来源：'
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'On the second Puppet run, `hello.txt` is missing, so Puppet goes on to look
    for the next file, `universal.txt`. This is present, so it becomes the source
    for `/tmp/greeting`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次运行 Puppet 时，`hello.txt` 缺失，因此 Puppet 会继续查找下一个文件 `universal.txt`。该文件存在，因此它成为
    `/tmp/greeting` 的来源：
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: There's more...
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'You can use this trick anywhere you have a `file` resource. A common example
    is a service that is deployed on all nodes, such as rsyslog. The `rsyslog` configuration
    is the same on every host except for the rsyslog server. Create an `rsyslog` class
    with a file resource for the `rsyslog` configuration file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何使用 `file` 资源的地方使用这个技巧。一个常见的例子是部署在所有节点上的服务，如 rsyslog。除了 rsyslog 服务器外，所有主机的
    `rsyslog` 配置都是相同的。创建一个包含 `rsyslog` 配置文件的 `rsyslog` 类并使用 `file` 资源：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Then, you put the default configuration in `rsyslog.conf`. For your rsyslog
    server, `logger`, create an `rsyslog.conf.logger` file. On the machine logger,
    `rsyslog.conf.logger` will be used before `rsyslog.conf` because it is listed
    first in the array of sources.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将默认配置放入 `rsyslog.conf` 中。对于你的 rsyslog 服务器 `logger`，创建一个 `rsyslog.conf.logger`
    文件。在机器 `logger` 上，`rsyslog.conf.logger` 会先于 `rsyslog.conf` 被使用，因为它在文件源数组中的顺序靠前。
- en: See also
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见：
- en: The *Passing parameters to classes* recipe in [Chapter 3](ch03.html "Chapter 3. Writing
    Better Manifests"), *Writing Better Manifests*
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 3 章](ch03.html "第 3 章. 编写更好的清单")中的*向类传递参数*配方，*编写更好的清单*'
- en: Distributing and merging directory trees
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分发和合并目录树
- en: As we saw in the previous chapter, the file resource has a `recurse` parameter,
    which allows Puppet to transfer entire directory trees. We used this parameter
    to copy an admin user's dotfiles into their home directory. In this section, we'll
    show how to use `recurse` and another parameter `sourceselect` to extend our previous
    example.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一章所见，文件资源具有 `recurse` 参数，这使得 Puppet 可以传输整个目录树。我们使用此参数将管理员用户的点文件复制到他们的主目录。在本节中，我们将展示如何使用
    `recurse` 和另一个参数 `sourceselect` 来扩展我们之前的示例。
- en: How to do it...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'Modify our admin user example as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如下修改我们的管理员用户示例：
- en: 'Remove the `$dotfiles` parameter, remove the condition based on `$dotfiles`.
    Add a second source to the home directory `file` resource:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除 `$dotfiles` 参数，删除基于 `$dotfiles` 的条件。向主目录 `file` 资源添加第二个源：
- en: '[PRE42]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create a base directory and copy all the system default files from `/etc/skel`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基础目录并从 `/etc/skel` 复制所有系统默认文件：
- en: '[PRE43]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create a new `admin_user` resource, one that will not have a directory defined:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `admin_user` 资源，定义时不包括目录：
- en: '[PRE44]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Run Puppet:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Puppet：
- en: '[PRE45]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: If a `file` resource has the `recurse` parameter set on it, and it is a directory,
    Puppet will deploy not only the directory itself, but all its contents (including
    subdirectories and their contents). As we saw in the previous example, when a
    file has more than one source, the first source file found is used to satisfy
    the request. This applies to directories as well.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By specifying the parameter `sourceselect` as ''all'', the contents of all
    the source directories will be combined. For example, add `thomas admin_user`
    back into your node definition in `site.pp` for cookbook:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now run Puppet again on cookbook:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Because we previously applied the `thomas admin_user` to cookbook, the user
    existed. The two files defined in the `thomas` directory on the Puppet server
    were already in the home directory, so only the additional files, `.bash_logout`,
    `.bash_profile`, and `.emacs` were created. Using these two parameters together,
    you can have default files that can be overridden easily.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you want to deploy files to an existing directory but remove any files
    which aren't managed by Puppet. A good example would be if you are using `mcollective`
    in your environment. The directory holding client credentials should only have
    certificates that come from Puppet.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'The `purge` parameter will do this for you. Define the directory as a resource
    in Puppet:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The combination of `recurse` and `purge` will remove all files and subdirectories
    in `/etc/mcollective/ssl/clients` that are not deployed by Puppet. You can then
    deploy your own files to that location by placing them in the appropriate directory
    on the Puppet server.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'If there are subdirectories that contain files you don''t want to purge, just
    define the subdirectory as a Puppet resource, and it will be left alone:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be aware that, at least in current implementations of Puppet, recursive file
    copies can be quite slow and place a heavy memory load on the server. If the data
    doesn't change very often, it might be better to deploy and unpack a `tar` file
    instead. This can be done with a file resource for the `tar` file and an exec,
    which requires the file resource and unpacks the archive. Recursive directories
    are less of a problem when filled with small files. Puppet is not a very efficient
    file server, so creating large tar files and distributing them with Puppet is
    not a good idea either. If you need to copy large files around, using the Operating
    Systems packager is a better solution.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up old files
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Puppet's `tidy` resource will help you clean up old or out-of-date files, reducing
    disk usage. For example, if you have Puppet reporting enabled as described in
    the section on generating reports, you might want to regularly delete old report
    files.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get started.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify your `site.pp` file as follows:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Run Puppet:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How it works...
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Puppet searches the specified path for any files matching the `age` parameter;
    in this case, `2w` (two weeks). It also searches subdirectories (`recurse => true`).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Any files matching your criteria will be deleted.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can specify file ages in seconds, minutes, hours, days, or weeks by using
    a single character to specify the time unit, as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '`60s`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`180m`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`24h`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`30d`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`4w`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can specify that files greater than a given size should be removed, as
    follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This removes files of 100 megabytes and over. For kilobytes, use `k`, and for
    bytes, use `b`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that if you specify both age and size parameters, they are treated as
    independent criteria. For example, if you specify the following, Puppet will remove
    all files that are either at least one day old, or at least 512 KB in size:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: age => "1d",
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: size => "512k",
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Auditing resources
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dry run mode, using the `--noop` switch, is a simple way to audit any changes
    to a machine under Puppet's control. However, Puppet also has a dedicated audit
    feature, which can report changes to resources or specific attributes.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s an example showing Puppet''s auditing capabilities:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify your `site.pp` file as follows:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Run Puppet:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works...
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `audit` metaparameter tells Puppet that you want to record and monitor certain
    things about the resource. The value can be a list of the parameters that you
    want to audit.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, when Puppet runs, it will now record the owner and mode of the
    `/etc/passwd` file. In future runs, Puppet will spot whether either of these has
    changed. For example, if you run:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Puppet will pick up this change and log it on the next run:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: There's more...
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This feature is very useful to audit large networks for any changes to machines,
    either malicious or accidental. It''s also very handy to keep an eye on things
    that aren''t managed by Puppet, for example, application code on production servers.
    You can read more about Puppet''s auditing capability here:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[http://puppetlabs.com/blog/all-about-auditing-with-puppet/](http://puppetlabs.com/blog/all-about-auditing-with-puppet/)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'If you just want to audit everything about a resource, use `all`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: See also
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Noop - the don't change anything option* recipe in [Chapter 10](ch10.html
    "Chapter 10. Monitoring, Reporting, and Troubleshooting"), *Monitoring, Reporting,
    and Troubleshooting*
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Temporarily disabling resources
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes you want to disable a resource for the time being so that it doesn''t
    interfere with other work. For example, you might want to tweak a configuration
    file on the server until you have the exact settings you want, before checking
    it into Puppet. You don''t want Puppet to overwrite it with an old version in
    the meantime, so you can set the `noop` metaparameter on the resource:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: How to do it...
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This example shows you how to use the `noop` metaparameter:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify your `site.pp` file as follows:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Run Puppet:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: How it works...
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `noop` metaparameter is set to `true`, so for this particular resource,
    it's as if you had to run Puppet with the `--noop` flag. Puppet noted that the
    resource would have been applied, but otherwise did nothing.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'The nice thing with running the agent in test mode (`-t`) is that Puppet output
    a diff of what it would have done if the `noop` was not present (you can tell
    puppet to show the diff''s without using `-t` with `--show_diff`; `-t` implies
    many different settings):'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This can be very useful when debugging a template; you can work on your changes
    and then see what they would look like on the node without actually applying them.
    Using the diff, you can see whether your updated template produces the correct
    output.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
