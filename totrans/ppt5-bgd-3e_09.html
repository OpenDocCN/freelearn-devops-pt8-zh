<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Managing files with templates"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Managing files with templates</h1></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><span class="emphasis"><em>Simplicity does not precede complexity, but follows it.</em></span></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<span class="attribution"><span class="emphasis"><em>Alan Perlis</em></span></span></td></tr></table></div><p>In this chapter, we'll learn about an important and powerful feature of Puppet: the <span class="strong"><strong>template</strong></span>. We'll see how to use a simple template to interpolate the values of Puppet variables, facts, and Hiera data into a file, and we'll also introduce more complex templates using iteration and conditional statements to generate dynamic configuration files.</p><div class="mediaobject"><img src="graphics/8880_09_01.jpg" alt="Managing files with templates"/></div><div class="section" title="What are templates?"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec48"/>What are templates?</h1></div></div></div><p>In previous chapters, we've <a id="id404" class="indexterm"/>used Puppet to manage the <span class="strong"><strong>contents of files</strong></span> on the node by various means, including setting the contents to a literal string using the <code class="literal">content</code> attribute, and copying a file from a Puppet module using the <code class="literal">source</code> attribute. While these methods are very useful, they are limited in one respect: they can only use <span class="strong"><strong>static text</strong></span>, rather than building the contents of the file dynamically, based on Puppet data.</p><div class="section" title="The dynamic data problem"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec139"/>The dynamic data problem</h2></div></div></div><p>To see why this is a <a id="id405" class="indexterm"/>problem, consider a common Puppet file management task such as a backup script. There are a number of site- and node-specific things the backup script needs to know: the local directories to back up, the destination to copy them to, and any credentials needed to access the backup storage. While we could insert these into the script as literal values, this is rather inflexible. We might have to maintain several versions of the script, each identical to the others except for a backup location, for example. This is clearly less than satisfactory.</p><p>Consider a configuration file for an application where some of the settings depend on specific information about the node: the available memory, perhaps. Obviously, we don't want to have to maintain multiple versions of an almost identical config file, each containing a suitable value for all the different sizes of memory we may come across. We have a way of obtaining that information directly in Puppet, as we've seen in <a class="link" href="ch05.html" title="Chapter 5. Variables, expressions, and facts">Chapter 5</a>, <span class="emphasis"><em>Variables, expressions, and facts</em></span>, and we also have a flexible, powerful database for configuration data, as we saw in <a class="link" href="ch06.html" title="Chapter 6. Managing data with Hiera">Chapter 6</a>, <span class="emphasis"><em>Managing data with Hiera</em></span>. The question is how we can insert this data dynamically into text files.</p></div><div class="section" title="Puppet template syntax"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec140"/>Puppet template syntax</h2></div></div></div><p>Puppet's <span class="strong"><strong>template</strong></span> <a id="id406" class="indexterm"/>mechanism is one way to achieve this. A template is simply an ordinary text file, containing special placeholder markers which Puppet will replace with the relevant data values. The following example shows what these markers look like (<code class="literal">aws_credentials.epp</code>):</p><div class="informalexample"><pre class="programlisting">aws_access_key_id = &lt;%= $aws_access_key %&gt;</pre></div><p>Everything outside the <code class="literal">&lt;%=</code> and <code class="literal">%&gt;</code> delimiters is literal text and will be rendered as-is by Puppet.</p><p>The text inside the delimiters, however, is interpreted as a Puppet expression (in this case, just the variable <code class="literal">$aws_access_key</code>), which will be evaluated when the template is compiled, and the result will be interpolated into the text.</p><p>For example, if the variable <code class="literal">$aws_access_key</code> has the value <code class="literal">AKIAIAF7V6N2PTOIZVA2</code>, then when the template is processed by Puppet the resulting output text will look like the following:</p><div class="informalexample"><pre class="programlisting">aws_access_key_id = AKIAIAF7V6N2PTOIZVA2</pre></div><p>You can have as many of these delimited expressions (called <span class="strong"><strong>tags</strong></span>) in the template as you like, and they will all be evaluated <a id="id407" class="indexterm"/>and interpolated when the template is used.</p><p>Puppet's template mechanism is called <span class="strong"><strong>EPP</strong></span> (for <span class="strong"><strong>Embedded Puppet</strong></span>), and template files have the extension <code class="literal">.epp</code>.</p></div></div></div>
<div class="section" title="Using templates in your manifests"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec49"/>Using templates in your manifests</h1></div></div></div><p>Since the end result <a id="id408" class="indexterm"/>of a template is a file, you won't be surprised that we use Puppet's <code class="literal">file</code> resource to work with templates. In fact, we use an attribute of the <code class="literal">file</code> resource that you've seen before: the <code class="literal">content</code> attribute.</p><div class="section" title="Referencing template files"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec141"/>Referencing template files</h2></div></div></div><p>Recall from <a id="id409" class="indexterm"/>
<a class="link" href="ch02.html" title="Chapter 2. Creating your first manifests">Chapter 2</a>, <span class="emphasis"><em>Creating your first manifests</em></span>, that you can use the <code class="literal">content</code> attribute to set a file's contents to a literal string:</p><div class="informalexample"><pre class="programlisting">file { '/tmp/hello.txt':
  content =&gt; "hello, world\n",
}</pre></div><p>And, of course, you can interpolate the value of Puppet expressions into that string:</p><div class="informalexample"><pre class="programlisting">file { "/usr/local/bin/${task}":
  content =&gt; "echo I am ${task}\n",
  mode    =&gt; '0755',
}</pre></div><p>So far, so familiar, but we can take one further step and replace the literal string with a call to the <code class="literal">epp()</code> function (<code class="literal">file_epp.pp</code>):</p><div class="informalexample"><pre class="programlisting">file { '/usr/local/bin/backup':
  content =&gt; epp('/examples/backup.sh.epp',
    {
      'data_dir' =&gt; '/examples',
      }
  ),
  mode    =&gt; '0755',
}</pre></div><p>Puppet will compile the template file referenced by <code class="literal">backup.sh.epp</code>, replacing any tags with the value of their expressions, and the resulting text will be written to the file <code class="literal">/usr/local/bin/backup</code>. The template file might look something like the following (<code class="literal">backup.sh.epp</code>):</p><div class="informalexample"><pre class="programlisting">&lt;%- | String $data_dir | -%&gt;
#!/bin/bash
mkdir -p /backup
tar cvzf /backup/backup.tar.gz &lt;%= $data_dir %&gt;</pre></div><p>You can use the <code class="literal">epp()</code> function anywhere a string is expected, but it's most common to use it to manage a file, as <a id="id410" class="indexterm"/>shown in the example.</p><p>To reference a template file from within a module (for example, in our NTP module from <a class="link" href="ch07.html" title="Chapter 7. Mastering modules">Chapter 7</a>, <span class="emphasis"><em>Mastering modules</em></span>), put the file in the <code class="literal">modules/pbg_ntp/templates/</code> directory, and prefix the filename with <code class="literal">pbg_ntp/</code>, as in the following example:</p><div class="informalexample"><pre class="programlisting">file { '/etc/ntp.conf':
  content =&gt; epp('pbg_ntp/ntp.conf.epp'),
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip40"/>Tip</h3><p>
<span class="strong"><strong>Remember</strong></span>
</p><p>Don't include <code class="literal">templates/</code> as part of the path. Puppet knows it's a template, so it will automatically look in the <code class="literal">templates/</code> directory of the named module.</p></div></div></div><div class="section" title="Inline templates"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec142"/>Inline templates</h2></div></div></div><p>Your template text <a id="id411" class="indexterm"/>need not be in a separate file: if it's a short template, you can <a id="id412" class="indexterm"/>put it in a literal string in your Puppet manifest and use the <code class="literal">inline_epp()</code> function to compile it (<code class="literal">file_inline_epp.pp</code>):</p><div class="informalexample"><pre class="programlisting">$web_root = '/var/www'
$backup_dir = '/backup/www'

file { '/usr/local/bin/backup':
  content =&gt; inline_epp('rsync -a &lt;%= $web_root %&gt;/ &lt;%= $backup_dir %&gt;/'),
  mode    =&gt; '0755',
}</pre></div><p>Note that we used a <span class="strong"><strong>single-quoted string</strong></span> to specify the inline template text. If we'd used a double-quoted string, Puppet would have interpolated the values of <code class="literal">$web_root</code> and <code class="literal">$backup_dir</code> <span class="emphasis"><em>before</em></span> processing the template, which is not what we want.</p><p>In general, though, it's <a id="id413" class="indexterm"/>better and more readable to use a separate template file for all but the simplest templates.</p></div><div class="section" title="Template tags"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec143"/>Template tags</h2></div></div></div><p>The tag we've been <a id="id414" class="indexterm"/>using in the examples so far in this chapter is known as an <span class="strong"><strong>expression-printing tag</strong></span>:</p><div class="informalexample"><pre class="programlisting">&lt;%= $aws_access_key %&gt;</pre></div><p>Puppet expects the contents of this tag to have a value, which will then be inserted into the template in place of the tag.</p><p>A <span class="strong"><strong>non-printing tag</strong></span> is very similar, but will not generate any output. It has no <code class="literal">=</code> sign in the opening delimiter:</p><div class="informalexample"><pre class="programlisting">&lt;% notice("This has no effect on the template output") %&gt;</pre></div><p>You can also use a <span class="strong"><strong>comment tag</strong></span> to add text which will be removed when Puppet compiles the template:</p><div class="informalexample"><pre class="programlisting">&lt;%# This is a comment, and it will not appear in the output of the template %&gt;</pre></div></div><div class="section" title="Computations in templates"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec144"/>Computations in templates</h2></div></div></div><p>So far, we've simply <a id="id415" class="indexterm"/>interpolated the value of a variable into our template, but we can do more. Template tags can contain any valid Puppet expression.</p><p>It's very common for certain values in config files to be <span class="strong"><strong>computed</strong></span> from other values, such as the amount of physical memory on the node. We saw an example of this in <a class="link" href="ch05.html" title="Chapter 5. Variables, expressions, and facts">Chapter 5</a>, <span class="emphasis"><em>Variables, expressions, and facts</em></span>, where we computed a config value based on the value of <code class="literal">$facts['memory']['system']['total_bytes']</code>.</p><p>Naturally, whatever we can do in Puppet code, we can also do in a template, so here's the same computation in template form (<code class="literal">template_compute.epp</code>):</p><div class="informalexample"><pre class="programlisting">innodb_buffer_pool_size=&lt;%= $facts['memory']['system']['total_bytes'] * 3/4 %&gt;</pre></div><p>The generated output (on my Vagrant box) is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo puppet epp render --environment pbg /examples/template_compute.epp</strong></span>
innodb_buffer_pool_size=780257280</pre></div><p>You're not restricted to numerical computations; you can do anything a Puppet expression can do, including <a id="id416" class="indexterm"/>string manipulation, array and hash lookups, fact references, function calls, and so on.</p></div><div class="section" title="Conditional statements in templates"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec145"/>Conditional statements in templates</h2></div></div></div><p>You might not be very <a id="id417" class="indexterm"/>impressed with templates so far, pointing <a id="id418" class="indexterm"/>out that you can already interpolate the values of Puppet expressions in strings, and hence files, without using a template. That said, templates allow you to interpolate data into much bigger files than it would be practical or desirable to create with a literal string in your Puppet manifest.</p><p>Templates also allow you to do something else very useful: <span class="strong"><strong>include or exclude sections of text</strong></span> based on the result of some Puppet conditional expression.</p><p>We've already met conditional statements in manifests in <a class="link" href="ch05.html" title="Chapter 5. Variables, expressions, and facts">Chapter 5</a>, <span class="emphasis"><em>Variables, expressions, and facts</em></span>, where we used them to conditionally include sets of Puppet resources (<code class="literal">if.pp</code>):</p><div class="informalexample"><pre class="programlisting">if $install_perl {
  ...
} else {
  ...
}</pre></div><p>Since the content of template tags is just Puppet code, you can use an <code class="literal">if </code>statement in a template too. Here's a similar example to the previous one, but this time controlling inclusion of a block of configuration in a template (<code class="literal">template_if.epp</code>):</p><div class="informalexample"><pre class="programlisting">&lt;% if $ssl_enabled { -%&gt;
  ## SSL directives
  SSLEngine on
  SSLCertificateFile      "&lt;%= $ssl_cert %&gt;"
  SSLCertificateKeyFile   "&lt;%= $ssl_key %&gt;"
  ...
&lt;% } -%&gt;</pre></div><p>This looks a little more complicated, but it's actually exactly the same logic as in the previous example. We have an <code class="literal">if</code> statement which tests the value of a Boolean variable, <code class="literal">$ssl_enabled</code>, and depending on the result, the following block is either included or excluded.</p><p>You can see that the <code class="literal">if </code>statement and the closing <code class="literal">}</code> are enclosed in non-printing tags, so they generate no output themselves, and as Puppet compiles the template, it will execute the Puppet code within the tags and that will determine the output. If <code class="literal">$ssl_enabled</code> is true, the file generated by the template will contain the following:</p><div class="informalexample"><pre class="programlisting">  ## SSL directives
  SSLEngine on
  SSLCertificateFile      "&lt;%= $ssl_cert %&gt;"
  SSLCertificateKeyFile   "&lt;%= $ssl_key %&gt;"
  ...</pre></div><p>Otherwise, this part of the template will be omitted. This is a very useful way of conditionally including blocks in a configuration file.</p><p>Just as with <code class="literal">if</code> statements <a id="id419" class="indexterm"/>in manifest files, you can also use <code class="literal">else</code> to include an <a id="id420" class="indexterm"/>alternative block instead, if the conditional statement is false.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip41"/>Tip</h3><p>Notice that the closing tags in the previous example had an extra leading hyphen: <code class="literal">-%&gt;</code>.</p><p>When you use this syntax, Puppet suppresses any trailing whitespace and linebreak after the tag. It's common to use this syntax with non-printing template tags, because otherwise you'd end up with empty lines in the output.</p></div></div></div></div>
<div class="section" title="Iteration in templates"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec50"/>Iteration in templates</h1></div></div></div><p>If we can generate <a id="id421" class="indexterm"/>parts of a file from Puppet expressions, and also include or exclude <a id="id422" class="indexterm"/>parts of the file depending on conditions, could we generate parts of the file with a Puppet loop? That is to say, could we <span class="strong"><strong>iterate over an array or hash</strong></span>, generating template content for each element? Indeed we can. This is a very powerful mechanism which enables us to generate files of arbitrary size, based on Puppet variables, or Hiera and Facter data.</p><div class="section" title="Iterating over Facter data"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec146"/>Iterating over Facter data</h2></div></div></div><p>Our first example <a id="id423" class="indexterm"/>generates part of the config file for an application which captures network packet data. To tell it which interfaces to listen on, we need to generate a list of all the live network interfaces on the node.</p><p>How can we generate this output? We know Facter can give us a list of all the network interfaces available, with <code class="literal">$facts['networking']['interfaces']</code>. This is actually a hash, where the key is the name of the interface, and the value is a hash of the interface's attributes, such as the IP address and netmask.</p><p>You may recall from <a class="link" href="ch05.html" title="Chapter 5. Variables, expressions, and facts">Chapter 5</a>, <span class="emphasis"><em>Variables, expressions, and facts</em></span> that in order to iterate over a hash, we use a syntax like the following:</p><div class="informalexample"><pre class="programlisting">HASH.each | KEY, VALUE | {
  BLOCK
}</pre></div><p>So let's apply this pattern to the Facter data and see what the output looks like (<code class="literal">template_iterate.epp</code>):</p><div class="informalexample"><pre class="programlisting">&lt;% $facts['networking']['interfaces'].each |String $interface, Hash $attrs| { -%&gt;
interface &lt;%= $interface %&gt;;
&lt;% } -%&gt;</pre></div><p>Each time round the loop, the values of <code class="literal">$interface</code> and <code class="literal">$attrs</code> will be set to the next key and value of the hash returned by <code class="literal">$facts['networking']['interfaces']</code>. As it happens, we will not be using the value of <code class="literal">$attrs</code>, but we still need to declare it as part of the loop syntax.</p><p>Each time round the loop, the <a id="id424" class="indexterm"/>value of <code class="literal">$interface</code> is set to the name of the next interface in the list, and a new output line like the following is generated:</p><div class="informalexample"><pre class="programlisting">interface em1;</pre></div><p>At the end of the loop, we have generated as many output lines as we have interfaces, which is the desired result. Here's the final output, on a node with lots of network interfaces:</p><div class="informalexample"><pre class="programlisting">interface em1;
interface em2;
interface em3;
interface em4;
interface em5;
interface lo;</pre></div></div><div class="section" title="Iterating over structured facts"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec147"/>Iterating over structured facts</h2></div></div></div><p>The next configuration <a id="id425" class="indexterm"/>data required for our application is a list of IP addresses associated with the node, which we can generate in a similar way to the previous example.</p><p>We can use more or less the same Puppet code as in the previous example, only this time we will be using each interface's <code class="literal">$attrs</code> hash to get the IP address of the associated interface.</p><p>The following example shows how this works (<code class="literal">template_iterate2.epp</code>):</p><div class="informalexample"><pre class="programlisting">&lt;% $facts['networking']['interfaces'].each |String $interface, Hash $attrs| { -%&gt;
local_address &lt;%= $attrs['bindings'][0]['address'] %&gt;;
&lt;% } -%&gt;</pre></div><p>The loop is the same as in the previous example, but this time each output line contains, not the value of <code class="literal">$interface</code>, but the value of <code class="literal">$attrs['bindings'][0]['address']</code>, which contains the IP address of each interface.</p><p>Here's the <a id="id426" class="indexterm"/>final output:</p><div class="informalexample"><pre class="programlisting">local_address 10.170.81.11;
local_address 75.76.222.21;
local_address 204.152.248.213;
local_address 66.32.100.81;
local_address 189.183.255.6;
local_address 127.0.0.1;</pre></div></div><div class="section" title="Iterating over Hiera data"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec148"/>Iterating over Hiera data</h2></div></div></div><p>In <a class="link" href="ch06.html" title="Chapter 6. Managing data with Hiera">Chapter 6</a>, <span class="emphasis"><em>Managing data with Hiera</em></span> we used a Hiera array of users to generate Puppet resources for each <a id="id427" class="indexterm"/>user. Let's use the same Hiera data now to build a dynamic configuration file using iteration in a template.</p><p>The SSH daemon <code class="literal">sshd</code> can be configured to allow SSH access only by a list of named users (with the <code class="literal">AllowUsers</code> directive), and, indeed, it's good practice to do this.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip42"/>Tip</h3><p>
<span class="strong"><strong>Security tip</strong></span>
</p><p>Most servers accessible from the public Internet regularly receive brute-force login attempts for random usernames, and dealing with these can use up a lot of resources. If <code class="literal">sshd</code> is configured to allow only specified users, it can quickly reject any users not in this list, without having to process the request further.</p></div></div><p>If our users are listed in Hiera, then it's easy to use a template to generate this <code class="literal">AllowUsers</code> list for the <code class="literal">sshd_config</code> file.</p><p>Just as we did when generating Puppet <code class="literal">user </code>resources, we will make a call to <code class="literal">lookup()</code> to get the array of users, and iterate over this using <code class="literal">each</code>. The following example shows what this looks like in the template (<code class="literal">template_hiera.epp</code>):</p><div class="informalexample"><pre class="programlisting">AllowUsers&lt;% lookup('users').each | $user | { -%&gt;
 &lt;%= $user -%&gt;
&lt;% } %&gt;</pre></div><p>Note the leading space on the second line, which results in the usernames in the output being space-separated. Note also the use of the leading hyphen to the closing tag (<code class="literal">-%&gt;</code>) which, as we saw earlier in the chapter, will suppress any trailing whitespace on the line.</p><p>Here's the result<a id="id428" class="indexterm"/>:</p><div class="informalexample"><pre class="programlisting">AllowUsers katy lark bridget hsing-hui charles</pre></div></div><div class="section" title="Working with templates"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec149"/>Working with templates</h2></div></div></div><p>One potential problem <a id="id429" class="indexterm"/>with templates (since they can include Puppet code, variables, and Hiera data) is that it's not always clear from the Puppet manifest what <span class="strong"><strong>variables</strong></span> the template is going to use. Conversely, it's not easy to see from the template code where any referenced variables are coming from. This can make it hard to maintain or update templates, and also to debug any problems caused by incorrect data being fed into the template.</p><p>Ideally, we would like to be able to specify in the Puppet code exactly what variables the template is going to receive, and this list would also appear in the template itself. For extra credit, we would like to be able to specify the <span class="strong"><strong>data type</strong></span> of input variables, in just the same way that we do for classes and defined resource types (see <a class="link" href="ch08.html" title="Chapter 8. Classes, roles, and profiles">Chapter 8</a>, <span class="emphasis"><em>Classes, roles, and profiles</em></span>, for more about this.)</p><p>The good news is that EPP templates allow you to declare the parameters you want passed to your template, along with the required data types, in exactly the same way as you can for classes. While it's not compulsory to declare parameters for your EPP templates, it's a very good idea to do so. With declared and typed parameters, you will be able to catch most data errors at the template compilation stage, which makes troubleshooting much easier.</p></div><div class="section" title="Passing parameters to templates"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec150"/>Passing parameters to templates</h2></div></div></div><p>To declare parameters <a id="id430" class="indexterm"/>for a template, list them between pipe characters (<code class="literal">|</code>) inside a non-printing tag, as shown in the following example (<code class="literal">template_params.epp</code>):</p><div class="informalexample"><pre class="programlisting">&lt;% | String[1] $aws_access_key,
     String[1] $aws_secret_key,
| -%&gt;
aws_access_key_id = &lt;%= $aws_access_key %&gt;
aws_secret_access_key = &lt;%= $aws_secret_key %&gt;</pre></div><p>When you declare parameters in a template, you must pass those parameters explicitly, in hash form, as the second argument to the <code class="literal">epp()</code> function call. The following example shows how to do this (<code class="literal">epp_params.pp</code>):</p><div class="informalexample"><pre class="programlisting">file { '/root/aws_credentials':
  content =&gt; epp('/examples/template_params.epp',
    {
      'aws_access_key' =&gt; 'AKIAIAF7V6N2PTOIZVA2',
      'aws_secret_key' =&gt; '7IBpXjoYRVbJ/rCTVLaAMyud+i4co11lVt1Df1vt',
    }
  ),
}</pre></div><p>This form of the <code class="literal">epp()</code> function call takes two parameters: the path to the template file, and a hash containing all the required template parameters. The keys to the hash are the parameter names, and the values are the values. (These need not be literal values; they could be Hiera lookups, for example.)</p><p>It's very likely that you will <a id="id431" class="indexterm"/>be using Hiera data in templates, and although in our previous <code class="literal">AllowUsers </code>example we called <code class="literal">lookup()</code> directly from the template to look up the data, this isn't really the best way to do it. Now that we know how to declare and pass parameters to templates, we should do the same thing with Hiera data.</p><p>Here is an updated version of the <code class="literal">AllowUsers</code> example where we do the Hiera lookup in the manifest, as part of the <code class="literal">epp()</code> call. First, we need to declare a <code class="literal">$users</code> parameter in the template (<code class="literal">template_hiera_params.epp</code>):</p><div class="informalexample"><pre class="programlisting">&lt;% | Array[String] $users | -%&gt;
AllowUsers&lt;% $users.each | $user | { -%&gt;
 &lt;%= $user -%&gt;
&lt;% } %&gt;</pre></div><p>Then, when we compile the template with <code class="literal">epp()</code>, we pass in the Hiera data by calling <code class="literal">lookup()</code> in the parameters hash (<code class="literal">epp_hiera.pp</code>):</p><div class="informalexample"><pre class="programlisting">file { '/tmp/sshd_config_example':
  content =&gt; epp('/examples/template_hiera_params.epp',
    {
      'users' =&gt; lookup('users'),
    }
  ),
}</pre></div><p>If you have declared a parameter list in the template, you must pass it exactly those parameters in the <code class="literal">epp()</code> call, and no others. EPP templates declare parameters in the same way as classes do: parameters can be given default values, and any parameter without a default value is mandatory.</p><p>It's clear from the previous example that declaring parameters makes it much easier to see what information the template is going to use from the calling code, and we now have the benefit of automated checking of the parameters and their types.</p><p>Note, however, that even templates with a parameter list can still access any Puppet variable or fact in the template body; Puppet does not prevent the template from using variables which have not been <a id="id432" class="indexterm"/>declared as parameters, or getting data directly from Hiera. It should be clear by now, though, that bypassing the parameter checking machinery in this way is a bad idea.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip43"/>Tip</h3><p>
<span class="strong"><strong>Best practices</strong></span>
</p><p>Use EPP templates for dynamically-generated files, declare typed parameters in the template, and pass those parameters as a hash to the <code class="literal">epp()</code> function. To make your template code easier to understand and maintain, always pass data explicitly to the template. If the template needs to look up Hiera data, do the lookup in your Puppet manifest and have the template declare a parameter to receive the data.</p></div></div></div><div class="section" title="Validating template syntax"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec151"/>Validating template syntax</h2></div></div></div><p>We've seen in this chapter <a id="id433" class="indexterm"/>that templates can contain complex logic and iteration that can generate almost any output required. The downside of this power and flexibility is that it can be difficult to read and debug template code.</p><p>Fortunately, Puppet includes a tool to check and validate your templates on the command line: <code class="literal">puppet epp validate</code>. To use it, run the following command against your template file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>puppet epp validate /examples/template_params.epp</strong></span>
</pre></div><p>If there is no output, the template is valid. If the template contains an error, you will see an error message, something like the following:</p><div class="informalexample"><pre class="programlisting">Error: Syntax error at '%' at /examples/template_params.epp:3:4
Error: Errors while validating epp
Error: Try 'puppet help epp validate' for usage</pre></div></div><div class="section" title="Rendering templates on the command line"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec152"/>Rendering templates on the command line</h2></div></div></div><p>As any <a id="id434" class="indexterm"/>programmer knows, even programs with valid syntax don't necessarily produce the correct results. It can be very useful to see exactly what output the template is going to produce, and Puppet also provides a tool to do this: <code class="literal">puppet epp render</code>.</p><p>To use it, run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>puppet epp render --values "{ 'aws_access_key' =&gt; 'foo', 'aws_secret_key' =&gt; 'bar' }" /examples/template_params.epp</strong></span>
aws_access_key_id = foo
aws_secret_access_key = bar</pre></div><p>The <code class="literal">--values</code> argument allows you to pass in a hash of parameter-value pairs, just as you would when calling the <code class="literal">epp()</code> function in your Puppet manifest.</p><p>Alternatively, you <a id="id435" class="indexterm"/>can use the <code class="literal">--values_file</code> argument to reference a Puppet manifest file containing the hash of parameters:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>echo "{ 'aws_access_key' =&gt; 'foo', 'aws_secret_key' =&gt; 'bar' }" &gt;params.pp</strong></span>
<span class="strong"><strong>puppet epp render --values_file params.pp /examples/template_params.epp</strong></span>
aws_access_key_id = foo
aws_secret_access_key = bar</pre></div><p>You can pass parameters both on the command line with <code class="literal">--values</code>, and from a file with <code class="literal">--values_file</code>, simultaneously. Parameters given on the command line will take priority over those from the file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>puppet epp render --values_file params.pp --values "{ 'aws_access_key' =&gt; 'override' }" /examples/template_params.epp</strong></span>
aws_access_key_id = override
aws_secret_access_key = bar</pre></div><p>You can also use <code class="literal">puppet epp render</code> to test inline template code, using the <code class="literal">-e</code> switch to pass in a literal template string:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>puppet epp render --values "{ 'name' =&gt; 'Dave' }" -e 'Hello, &lt;%= $name %&gt;'</strong></span>
Hello, Dave</pre></div><p>Just as when testing your manifests, you can also use <code class="literal">puppet apply</code> to test your templates directly, using a command similar to the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo puppet apply -e "file { '/tmp/result': content =&gt; epp('/examples/template_iterate.epp')}"</strong></span>
</pre></div><p>One advantage of this approach is that all Puppet variables, facts, and Hiera data will be available to your template.</p></div><div class="section" title="Legacy ERB templates"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec153"/>Legacy ERB templates</h2></div></div></div><p>You'll probably <a id="id436" class="indexterm"/>come across references to a different type of Puppet template in older code and documentation: the <span class="strong"><strong>ERB template</strong></span>. ERB (for <a id="id437" class="indexterm"/>Embedded Ruby) was the only template mechanism provided in Puppet up until version 3.5, when EPP support was added, and EPP has now replaced ERB as Puppet's default template format.</p><p>ERB template syntax looks quite similar to EPP. The following example is a snippet from an ERB template:</p><div class="informalexample"><pre class="programlisting">AllowUsers &lt;%= @users.join(' ') %&gt;&lt;%= scope['::ubuntu'] == 'yes' ? ',ubuntu' : '' %&gt;</pre></div><p>The difference is that the template language inside the tags, is Ruby, not Puppet. Early versions of Puppet were rather limited in language features (for example, there was no <code class="literal">each</code> function to iterate over variables), so it was common to use Ruby code embedded in templates to work around this.</p><p>This required some <a id="id438" class="indexterm"/>complicated plumbing to manage the interface between Puppet and Ruby; for example, accessing variables in non-local scope in ERB templates requires the use of the <code class="literal">scope </code>hash, as in the previous example. Similarly, in order to access Puppet functions such as <code class="literal">strftime()</code>, you have to call:</p><div class="informalexample"><pre class="programlisting">scope.call_function('strftime', ...)</pre></div><p>ERB templates also do not <a id="id439" class="indexterm"/>support declared parameters or type checking. I recommend you use only EPP templates in your own code.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec51"/>Summary</h1></div></div></div><p>In this chapter we've looked at one of the most powerful tools in Puppet's toolbox, the template file. We've examined the EPP tag syntax and seen the different kinds of tags available, including printing and non-printing tags.</p><p>We've learned that not only can you simply insert values from variables into templates, but that you can also include or exclude whole blocks of text, depending on the value of Puppet expressions, or generate templates of arbitrary size by iterating over arrays and hashes.</p><p>We've looked at some real-life examples of dynamically generating config files from Facter and Hiera data, and seen seen how to declare typed parameters in the template file, and pass in values for those parameters when calling the <code class="literal">epp()</code> function in your Puppet manifest.</p><p>We've seen how to check the syntax of templates using <code class="literal">puppet epp validate</code>, and how to render the output of a template using <code class="literal">puppet epp render</code>, passing in canned values for the template parameters using <code class="literal">--values</code> and <code class="literal">--values_file</code>, or using <code class="literal">puppet apply</code> to render the template directly.</p><p>Finally, we've touched on legacy ERB templates, where they come from, how they compare to EPP templates, and why, although you may still encounter ERB templates in the wild, you should only use EPP in your own code.</p><p>In the next chapter, we'll explore the popular topic of containers, and look at how to manage the Docker engine and Docker containers with Puppet, and deal with the vexed issue of how to manage configuration in containers.</p></div></body></html>