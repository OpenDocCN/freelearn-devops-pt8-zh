<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Developing with App Engine</h1>
                </header>
            
            <article>
                
<p>When working on Google Cloud, you will naturally require access to a cloud environment. In the upcoming chapters, we will learn how to build App Engine applications that reside in Google Cloud.</p>
<p>As we now have a good understanding of the various components that make up a <span><strong>Google App Engine</strong> (</span><strong>GAE</strong>) environment, in this chapter we will look at how to use GAE to engineer applications that meet defined requirements. We will begin by building a simple app to demonstrate the process of deploying code on App Engine. We will then learn how to perform application updates. Finally, we will explore how to use the features of Stackdriver Logging to assist with the analysis of defects. All of these lessons will be accompanied by examples and activities so that you can apply these GAE concepts and principles on your own.</p>
<p>GAE supports a number of language runtimes; in this chapter, we will utilize Python to demonstrate Google Cloud's capabilities. Working with different languages can be intimidating; however, the purpose of this chapter is not to teach you Python, but rather to explore using GAE in different scenarios.</p>
<p>In this chapter, we will cover the following:</p>
<ul>
<li>Building an application on GAE</li>
<li>Understanding deployment strategies</li>
<li><span>Troubleshooting App Engine deployments</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building an application on GAE</h1>
                </header>
            
            <article>
                
<p>To get started, we will consider what tools and assets we need to commence building our first GAE example application.</p>
<p><span>For this section, we will be taking our source code and deploying it on GAE. As part of this process, we will explore the application structure and how this relates to the deployed system. While using the code, we will observe what information is available and displayed within Google's Cloud Console.</span></p>
<p><span>In addition to this, we will look at deploying the application (to discuss what is meant by the default version), how this relates to code, and deploying multiple versions. Finally, we will perform a rollback on the system code deployed to illustrate accomplishing this task and what it means in terms of available versions. But first, let's learn about the Qwiklabs environment that we will be using in this chapter.<br/></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Qwiklabs</h1>
                </header>
            
            <article>
                
<p>Qwiklabs (<a href="https://qwiklabs.com">https://qwiklabs.com</a>) provides a Cloud sandbox in which Google Cloud projects can run. The aim of using an environment such as Qwiklabs is to give you a close representation of real-world tools and services. A transient Google Cloud account, to facilitate this process, assigns a time-restricted sandbox environment. Once created, the Google Cloud project will provide you with access to all of the relevant access permissions and services that you can expect in a project that has been provisioned in a typical manner.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started</h1>
                </header>
            
            <article>
                
<p>We will assume you have either registered on Google Cloud or have a valid Qwiklabs account that enables you to access a Google Cloud sandbox environment. Feel free to follow along without an account, but it will be more interesting if you can join in the exercises as we discuss them.</p>
<p>Our first look at Google's Cloud Console might seem intimidating; however, the interface provides an excellent way to navigate the numerous services on offer. Launch App Engine from the left-hand navigation menu, and we will take a tour of it.</p>
<p><span>To commence development, let's use the existing App Engine code provided by Google to understand how a basic application should appear. To do this, follow these steps:</span></p>
<ol>
<li><span>From your Google Cloud account, select the <span class="packt_screen">App Engine</span> menu item to begin creating an application.</span></li>
<li><span>The initial screen will be displayed, called the <strong><span class="packt_screen">Dashboard</span></strong>, and from here you can see an aggregation of all things associated with App Engine; for example, services, task queues, and firewall rules.</span></li>
<li>Now select the<span> </span><span class="packt_screen">Create Application</span><span> </span>button:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1139 image-border" src="assets/2627beed-3b60-4665-ba49-8e76d6723789.png" style=""/></div>
<p>The next thing we need to decide is which region our application will reside in<span>. Let's take a look at how to do this next.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Selecting a region</h1>
                </header>
            
            <article>
                
<p>Looking at the following onscreen list, it is clear that there are many options available. Typically considered the standard practice is to select a region as close as possible to where the data is to be accessed. In this example, that criterion won't apply for our demonstration, so perform the following steps:</p>
<ol>
<li><span>Choose <span class="packt_screen">us-east1</span> as the region.</span></li>
</ol>
<ol start="2">
<li>Select <span>the <span class="packt_screen">Create app</span> button:</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1140 image-border" src="assets/25b7c74a-1a0e-46cb-a47e-99fef39cd38f.png" style=""/></div>
<p class="mce-root">Now we need to decide which language runtime we are going to use. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Selecting a language runtime and environment</h1>
                </header>
            
            <article>
                
<p><span>For our first simple example, we will use the Python runtime. To do this, perform the following steps:</span></p>
<ol>
<li><span>Select the <span class="packt_screen">Language</span> drop-down list.</span></li>
<li><span>From the various languages that appear, click on <span class="packt_screen">Python</span></span>.</li>
<li>From the<span> </span><span class="packt_screen">Environment</span><span> </span>drop-down list, select<span> </span><span class="packt_screen">Standard</span><span> </span>(<span>this is the default option, but</span><span> </span><span>it</span><span> </span><span>can also be changed later</span><span> </span><span>in the development cycle):</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1141 image-border" src="assets/562d78fd-64ec-4357-a6c0-f624550f179d.png" style=""/></div>
<div class="packt_tip">Be aware that there are multiple language runtimes available. If you are unfamiliar with Python, don't worry: its layout and features are very accessible. In most instances, using an alternative language will follow the same process we've outlined; however, the language specification will be different from that described for the Python example.</div>
<p>Once completed, we can explore using the <strong>Google Cloud SDK</strong><span> (</span><strong>GCloud SDK</strong><span>)</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with the GCloud SDK</h1>
                </header>
            
            <article>
                
<p>The GCloud SDK provides a simple way to authenticate against Google Cloud. Having the SDK available locally (that is, local to your environment) provides significant benefits, so it is an excellent option to include if you wish to integrate with other Google Cloud services:</p>
<ol>
<li>Select the <span class="packt_screen">App Engine</span> menu option from the left-hand side of Google's Cloud Console.</li>
<li>In the following screen, we will need to choose the required resources for our project:</li>
</ol>
<p> </p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-989 image-border" src="assets/881f1335-1f87-4583-96c4-65661ffdfa64.png" style=""/></div>
<ol start="3">
<li>We will not be needing the Cloud SDK, as we will be using Cloud Shell, which includes a preloaded cloud SDK. So skip this screen by selecting the <span class="packt_screen">I'LL DO THIS LATER</span> option.</li>
</ol>
<div class="packt_tip">From the preceding deployment screen, you will also be given a command-line prompt to deploy code using <kbd>gcloud</kbd> commands. Learning how to use the <kbd>gcloud sdk</kbd> command to perform different tasks is highly recommended. </div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Congratulations! At this point, you have successfully created your first GAE application on Google Cloud. As you can see, this process is pretty simple and is aimed at ensuring developers minimize the time necessary for infrastructure management:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-990 image-border" src="assets/c720933f-258d-493f-b73c-b7329abd6f76.png" style=""/></div>
<p>Take a moment to remember that, for each application created, a similar process to create your infrastructure will be required. As you can see, there is nothing complicated about this process; on successful completion, it produces an important message that indicates the overall status.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building and deploying a sample application</h1>
                </header>
            
            <article>
                
<p>In this section, we will deploy a standard <kbd>Hello World</kbd> application to GAE. Luckily, the engineers at Google have our back, and we can use some sample code. For the next build and deploy stage in this process, we will examine this sample code. </p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>To commence the process, follow these steps:</p>
<ol>
<li>Open a Cloud Shell window in your project and clone the sample code for App Engine from the Google Cloud repository. </li>
</ol>
<div class="packt_tip">If you ever need to code an application on Google Cloud, it is more efficient to check the Google sample repository first to see whether the sample code exists as a template.</div>
<ol start="2">
<li>From the open Cloud Shell window, enter the following on the command line:</li>
</ol>
<pre style="padding-left: 60px"><strong>git clone https://github.com/GoogleCloudPlatform/python-docs-samples</strong></pre>
<ol start="3">
<li>The code location is in a directory named <kbd>hello_world</kbd>. So, enter the following to move to the correct source directory:</li>
</ol>
<pre style="padding-left: 60px"><strong>cd python-docs-samples/appengine/standard/hello_world</strong></pre>
<ol start="4">
<li>Now that we have some source code available, let's investigate what is in this directory by performing a directory listing from the Cloud Shell prompt:</li>
</ol>
<pre style="padding-left: 60px"><strong>ls -la</strong></pre>
<p>Notably, there are two Python files and the <kbd>app.yaml</kbd> file. A structure such as this is common, so it's worth outlining what these files do:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr style="height: 34.8594px">
<td style="height: 34.8594px">
<p><strong>Filename</strong></p>
</td>
<td style="height: 34.8594px">
<p><strong>Purpose</strong></p>
</td>
<td style="height: 34.8594px">
<p><strong>Description</strong></p>
</td>
</tr>
<tr style="height: 32px">
<td style="height: 32px">
<p><kbd>main.py</kbd></p>
</td>
<td style="height: 32px">
<p>Application</p>
</td>
<td style="height: 32px">
<p><span>This file, written in Python, represents the source code to be run, and outputs a <kbd>Hello, World!</kbd> </span><span>message to the user.</span></p>
</td>
</tr>
<tr style="height: 32px">
<td style="height: 32px">
<p><kbd>main_test.py</kbd></p>
</td>
<td style="height: 32px">
<p>Unit testing</p>
</td>
<td style="height: 32px">
<p>This file is a test case for the main source file to ensure a managed response is returned as expected.</p>
</td>
</tr>
<tr style="height: 32px">
<td style="height: 32px">
<p><kbd>app.yaml</kbd></p>
</td>
<td style="height: 32px">
<p>Configuration</p>
</td>
<td style="height: 32px">
<p>This file is the configuration file for the application. The contents of the data include a reference to the language runtime, API version, and URL to be accessed.</p>
</td>
</tr>
</tbody>
</table>
<ol start="5"/>
<ol start="5">
<li>To deploy the source code to GAE, enter the following on the Cloud Shell command line to use your code:</li>
</ol>
<pre style="padding-left: 60px"><strong>gcloud app deploy ./app.yaml</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="6">
<li>As the deployment command processes configuration information, on completion it will provide a URL from which you can access the running application:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-873 image-border" src="assets/43286884-5499-4a7c-aef7-82eebb242ba8.png" style=""/></div>
<div class="packt_infobox"><br/>
To view the application deployed use <kbd>gcloud app browse</kbd> from Cloud Shell or use the App Engine Dashboard to see the assigned URL.<br/>
<br/>
Once App Engine has completed its deployment, the application is accessible from the browser. Typically the URL to access your deployed application will be in the form <kbd>[PROJECT_ID].appspot.com</kbd>. If you have used a custom domain, the <kbd>PROJECT ID</kbd> section will be replaced with the custom domain.</div>
<ol start="7">
<li>Access this URL via the browser; this should display the <kbd>Hello, World!</kbd> message from our application, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1142 image-border" src="assets/2802f45e-f385-4a94-b133-f2d28b472319.png" style=""/></div>
<p> </p>
<ol start="8">
<li>Now take a look at the updated GAE dashboard to observe what changes are apparent once the application is deployed:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1143 image-border" src="assets/272a77c6-f9a9-49ff-af2e-b622fa10d617.png" style=""/></div>
<ol start="9">
<li>From the dashboard, we can see all the relevant telemetry for our application. We now have an excellent working knowledge of GAE and how to deploy a simple application on Google Cloud.</li>
</ol>
<p>Great job! We have gone through a lot of information quickly, so let's slow down a little and recap what we have learned so far in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Wrapping up</h1>
                </header>
            
            <article>
                
<p>In <span>the <kbd>Hello World!</kbd> example, we learned about the following aspects of deploying code on GAE:</span></p>
<ul>
<li><span>We looked at how to create a simple GAE application; we did this using the Google Cloud console to initiate the build and deploy process.</span></li>
<li><span>We saw there were multiple regions available and where this information can be accessed.</span></li>
<li><span>We selected a GAE Standard environment and the Python language runtime for our application, noting that we can also use alternatives if desired.</span></li>
<li><span>We cloned the Google Cloud repository to gain access to some Python-based example code.</span></li>
<li><span>We explored the system within the catalog and saw that we have three files available, taking the time to outline the purpose of each of the source files used.</span></li>
<li><span>Finally, we deployed our code via Cloud Shell and accessed the running application via a browser interface from the URL presented on completion of the deployment process.</span></li>
</ul>
<p><span>As you have seen in this first section on App Engine, it is a very straightforward process to deploy code. Within this environment, working with GAE provides a level of simplicity that developers crave.</span></p>
<p><span>The ability to avoid infrastructure management overhead can significantly improve efficiency and lends itself to a greater emphasis on specific development</span> activities. Throughout the next section, we will explore how GAE handles various deployment strategies.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding deployment strategies </h1>
                </header>
            
            <article>
                
<div>
<p>GAE allows new versions to deploy and more besides, performing more complex operations such as traffic splitting. As we have already deployed a simple application from the command line, let's continue with this code base and look at how to implement a new version using the GAE management console.</p>
<p>Understanding the mechanism behind the GAE console used to control the flow of code is invaluable. Being able to deploy a new system via a rollout provides a good layer of control over the application environment. Taking this to the next level, we can also split traffic between versions to perform sophisticated A/B testing.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a new version</h1>
                </header>
            
            <article>
                
<p><span>Back in the Cloud Shell, still working with our source code, we will edit the <kbd>main.py</kbd> file and change the message to read as follows: <kbd>Hello, Serverless World!</kbd>. These simple changes will represent our new version of the application.</span></p>
<div class="packt_tip">Google Cloud Shell also includes a code editor based on Eclipse Orion to perform straightforward file edits. The inclusion of this editor can be tremendously helpful for situations where you need to view files within a project. Alternatively, Cloud Shell also includes other editors (for example, Vim and Nano), so feel free to use something that reflects your personal preference. </div>
<p><span>In the previous section, you will have noticed that, after editing our source file, we then used the GCloud SDK to deploy the code. Now that we have amended the source code, follow the same process</span> again:</p>
<ol>
<li>From the Cloud Shell, run the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>gcloud app deploy ./app.yaml</strong></pre>
<ol start="2">
<li>A new application version has been deployed without needing any additional work.</li>
<li>Look back at the Google Cloud Console and the <span class="packt_screen">Versions</span> menu.</li>
</ol>
<p>We can see that a new version of the application has been deployed and is available from the list:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1144 image-border" src="assets/f8f5c6ea-dac2-44b8-843e-e63109bf4d5e.png" style=""/></div>
<p class="CDPAlignLeft CDPAlign"><span>Note that, in the preceding output, the traffic allocation has automatically switched to the new version. This behavior is acceptable in most situations; however, if you don't want the traffic to be automatically promoted to the latest version for the deployment of new code, use the</span> <kbd>--no-promote</kbd> <span>flag option.</span></p>
<div>
<p>Observe that the version string used represents a timestamp for the application. Additionally, both versions of the application remain easily accessible from the consoleâ€”the default version tracks which revision traffic used. If you wish to switch to a specific version string, you can specify this as part of the deploy process using the <kbd>--version</kbd> flag option.</p>
<p>At this point, you might want to contrast this simple deployment process with a typical infrastructure project where this ease of use is not as apparent. The ease with which GAE is deployed is stunningly effortless and exquisitely modeled so it only exposes an element of the development that is required.</p>
<p>Now that we have a deployment, we can look at some of the excellent features App Engine provides as standard, starting with traffic management.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Traffic splitting</h1>
                </header>
            
            <article>
                
<p>Now that we have two versions running, wouldn't it be great if we could divide the traffic between them? Consider how useful this option is when working with an environment such as testing (for example, A/B) or production (for example, phased rollout). Again this level of simplicity should not be misunderstood; this is an incredibly powerful option and will undoubtedly be one that is used time and time again.</p>
<p>To split traffic, follow these steps:</p>
<ol>
<li>Go into the GAE Cloud Console and, u<span>nder the <span class="packt_screen">Versions</span> menu, l</span>ook for the <span class="packt_screen">Split traffic</span> option for the specific version and select it.</li>
<li>Now a list of options will be available to split our traffic, as outlined in the previous chapter (that is,<span> <span class="packt_screen">IP address</span>, <span class="packt_screen">Cookie</span>, or</span> <span class="packt_screen">Random</span>):</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1145 image-border" src="assets/698e50f9-a9fb-459a-ad6d-de3eccc0093d.png" style=""/></div>
<p>We can see that our new application version has defaulted to accept 100% of the traffic allocation. For demonstration purposes, we would like it to only receive 25%. To do this, perform the following steps:</p>
<ol>
<li>Select an alternate application version that will consume 75% of traffic by clicking on the <span class="packt_screen">Add version</span> button. You will see that we still have the original version of the deployed application available, so let's divert the traffic to that.</li>
<li>Now select the remaining percentage from the box next to the versions:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1146 image-border" src="assets/f059a569-9e8d-4ed9-b35d-7c675b35b498.png" style=""/></div>
<ol start="3">
<li>Once the traffic splitting ratio has been selected, select the <span class="packt_screen">Save</span> button and GAE will indicate that it is dynamically updating the traffic splitting configuration in your project.</li>
<li>Return to the <span class="packt_screen">Versions</span> screen to see the project actually dividing traffic between the applications chosen, in the proportions previously selected:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1147 image-border" src="assets/12211944-846d-4c7a-9c16-070b60584474.png" style=""/></div>
<div class="packt_infobox">As we expected, the preceding actions, for example, traffic splitting, are also achievable using the GCloud SDK. To achieve the same result with the SDK, use the <kbd>gcloud app set-traffic</kbd> option to provide a flexible way to get the desired outcome from a script or command-line interface.</div>
<p>Now that we know how to initiate traffic splitting between application versions, let's move on how to migrate traffic. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Migrating traffic</h1>
                </header>
            
            <article>
                
<p>Finally, for this section, we want to migrate all traffic back to the original deployed version of our application. By now, I suspect that you already have an idea of how to achieve this.</p>
<p>At the top of the <span class="packt_screen">Versions</span> screen, there is a <span class="packt_screen">MIGRATE TRAFFIC</span> option. We will use this to move all of the existing traffic flow back to the original version, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1148 image-border" src="assets/21482395-fea0-40d1-ab98-5c44e9255a53.png" style=""/></div>
<div class="packt_infobox"><span>Note that the original application currently accepts 75% of the traffic and the new version only accepts 25% of traffic.</span></div>
<p>The migration will ensure traffic is directed to the selected default version. In this type of migration, the destination instance can only be a single version:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1149 image-border" src="assets/4ba3c6cb-dd8d-49ed-89fd-a35d255c1b1e.png" style=""/></div>
<p>The migration of traffic between application versions is straightforward using GAE. To reinforce what we have learned, we will summarize our understanding next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Wrapping up</h1>
                </header>
            
            <article>
                
<p>In this section, we learned how to control deployment on GAE. We used several built-in tools and learned how to use them when working with our application:</p>
<ul>
<li>We saw how GAE instigates version control on the application.</li>
<li>We observed real-time traffic splitting on GAE, accessed at the push of a button.</li>
<li>We utilized the migrating traffic option to perform a simplistic application rollback.</li>
</ul>
<p>In this section, we explored how traffic splitting can be an invaluable developer tool for testing application functionality. In this regard, working with GAE is refreshingly simple as it provides a sophisticated means of performing A/B testing without any additional setup or requirements.</p>
<p>Additionally, we performed a version rollback that allowed us to quickly move between traffic-serving versions to a designated default version. In this scenario, we did not need to think about how to manage the underlying infrastructure; the heavy lifting was performed for us by GAE. In the next section, we will look at how we can make the build and deploy process more consistent and less error-prone.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Troubleshooting App Engine deployments</h1>
                </header>
            
            <article>
                
<p>In this section, we are going to undertake a more detailed examination of troubleshooting an application by using Stackdriver Logging. Stackdriver collates application information in a <em>single pane of glass</em> to enable data to be analyzed by developers.</p>
<p>Debugging an application can be time-consuming and requires a great deal of skill to establish the signal from the noise. Logs for GAE are fully available in Stackdriver, and learning to use this tool can prove to be a valuable aid for identifying defects within an application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building and deploying</h1>
                </header>
            
            <article>
                
<p><span>Open Stackdriver Logging from Google's Cloud Console to present the main page of information relating to logs collated on Google Cloud. Stackdriver Logging has two modes: </span></p>
<ul>
<li><span>Basic mode</span></li>
<li><span>Advanced filter</span></li>
</ul>
<p><span>Basic mode is the default, and, in our example, we will use this to display some vital information about the application deployed. The advanced filter provides the user with the ability to build bespoke filters for use against logged information.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Basic mode</h1>
                </header>
            
            <article>
                
<p>The first thing we need to do in Stackdriver Logging is filter the information and restrict it to the GAE application, so that it relates specifically to the part of the system we have an interest in:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1150 image-border" src="assets/fb50d884-12f0-4e4f-9c6f-c270f7cfb915.png" style=""/></div>
<p>In the preceding screenshot, the filter amendment includes <span class="packt_screen">GAE Application</span> and <span class="packt_screen">All logs</span>. As is evident from the information displayed, this is a very detailed overview of the activities that have occurred on GAE. For example, we can see several references to, for example, <kbd>CreateApplication</kbd>, <kbd>CreateVersion</kbd>, and <kbd>UpdateService</kbd> activities. Each of these activities has an associated payload with more detail, so gleaning further information where necessary is supported.</p>
<p>Additionally, the (HTTP) response codes received for the pages are also displayed in the logs, meaning a metric to monitor the availability of the application can easily be created based on the log information. A metric such as <em>How many times have I received a 404 in the past hour</em> is quite useful. Aggregating metrics is a smart way to perform application analysis, so only the frequency of incident occurrence provides the basis for investigation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advanced filter</h1>
                </header>
            
            <article>
                
<p><span>In some instances, a more bespoke filter is required to investigate an operation on GAE. In this instance, use the advanced filter. The advanced log filter is accessed via the drop-down filter and presents a more productive interface from which you can select information from the logs consumed within Stackdriver.</span></p>
<p><span>For example, in this mode, selecting the <kbd>CreateApplication</kbd> item populates the advanced filter and enables a more targeted list of entries to be displayed based on the criteria submitted by the user.</span></p>
<p><span>Stackdriver is an enormously valuable service when used to manage an application proactively:</span></p>
<ul>
<li><span><strong>Stackdriver Logging</strong>: Access log information for the analysis of issues</span></li>
<li><span><strong>Stackdriver Monitoring</strong>: Access monitoring information for general questions</span></li>
<li><span><strong>Stackdriver Trace</strong>: Access trace information for latency issues</span></li>
<li><span><strong>Stackdriver Debug</strong>: Access application details for defect issues</span></li>
</ul>
<p><span>The first defense layer involves integrating logging to supply a detailed and accurate view of deployed applications. Examples of this include Stackdriver Monitoring, Trace, and Debug, which utilize information about the application to assist ongoing maintenance activities and enhancements to deployed artifacts.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Wrapping up</h1>
                </header>
            
            <article>
                
<p><span>In this section, we highlighted the first steps in using Stackdriver Logging in conjunction with GAE. We will be exploring this Stackdriver capability in further detail as we move on to more advanced topics:</span></p>
<ul>
<li><span>We created a <em>basic</em> mode filter to see specific GAE information.</span></li>
<li><span><span>We switched to an <em>advanced</em> filter to take a more granular view of GAE application log information.</span></span></li>
<li><span>We outlined some Stackdriver functionality and discussed at a high level how to use the key features.</span></li>
</ul>
<p><span>Learning how to use Stackdriver on Google Cloud is fundamental to increasing developer productivity. The ability to aggregate information from multiple services in an easy-to-access dashboard is both compelling and useful as application complexity increases over time.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we covered a lot of material in order to work through some typical examples of using GAE. By now, you should have a good understanding of how the architecture and its associated components interact and can prevent the situational reinvention of the wheel.</p>
<p class="mce-root">We began with a discussion of how to deploy an application within the GAE environment. Working with version control and source configuration to support multiple environments was also covered. Finally, we looked at different deployment strategies and took our first look at Stackdriver Logging.</p>
<p class="mce-root">We have seen that GAE is very good at hosting applications that are responsible for managing solutions requiring HTTP(s)/API access. Both GAE Standard and Flex provide compelling cases for serverless applications in Google Cloud. From a developer perspective, there is very little in the way of infrastructure management required.</p>
<p class="mce-root">In the next chapter, we will expand our view of Google Cloud serverless products and start looking at event-based options. When looking at alternatives, it is always good to consider how one type of use case is more beneficial than another. Now that we have explored applications, we will take a look at more granular requirements and introduce event processing via functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>There are three versions of GAE. True or false?</li>
<li>What traffic splitting options are available with GAE?</li>
<li>What filter logging options are present for Stackdriver Logging?</li>
<li>When creating an App Engine application, you need to select a Zone. <span>True or false</span></li>
<li>Traffic migration offers a simple way to perform an application rollback. <span>True or false?</span></li>
<li>What is the command to perform a command-line deployment of GAE?</li>
<li>What common properties does an App Engine deployment contain in its URL?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li><strong>Google Cloud Shell</strong>: <a href="https://cloud.google.com/shell/docs/launching-cloud-shell">https://cloud.google.com/shell/docs/launching-cloud-shell</a></li>
<li><strong>Google Cloud Shell Editor</strong>: <a href="https://cloud.google.com/blog/products/gcp/introducing-google-cloud-shels-new-code-editor">https://cloud.google.com/blog/products/gcp/introducing-google-cloud-shels-new-code-editor</a></li>
<li><strong>Google app services</strong>: <a href="https://cloud.google.com/sdk/gcloud/reference/app/services/">https://cloud.google.com/sdk/gcloud/reference/app/services/</a></li>
</ul>


            </article>

            
        </section>
    </body></html>