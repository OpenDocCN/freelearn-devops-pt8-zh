- en: The Puppet Beginners Advanced Parts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After our in-depth discussions on both the manifest structure elements (class
    and define) and encompassing structure (modules), you are in a great position
    to write manifests for all of your agents. Make sure that you get Forge modules
    that will allow them to do your work for you. Then go ahead and add site-specific
    modules that implement Forge modules to your needs. Finally, you will have composite
    classes for the `node` blocks to be used, or rather, included.
  prefs: []
  type: TYPE_NORMAL
- en: These concepts are quite a bit to take in. It's now time to decelerate a bit,
    lean back, and tackle simpler code structures and ideas. You are about to learn
    some techniques that you are not going to need every day. They can make difficult
    scenarios much easier, though. So, it might be a good idea to come back to this
    chapter again after you have spent some time in the field. You might find that
    some of your designs can be simplified with these tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, these are the techniques that will be presented:'
  prefs: []
  type: TYPE_NORMAL
- en: Building dynamic configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing file snippets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using virtual resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-node configuration with exported resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting defaults for resource parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding antipatterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building dynamic configuration files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the introduction, I stated that the techniques that you are now learning
    are not frequently required. That was true, except for this one topic. Templates
    are actually a cornerstone of configuration management with Puppet.
  prefs: []
  type: TYPE_NORMAL
- en: Templates are an alternative way to manage configuration files, or any files
    really. You have synchronized files from the master to an agent that handled some
    Apache configuration settings. These are not templates, technically. They are
    merely static files that have been prepared and are ready for carbon copying.
  prefs: []
  type: TYPE_NORMAL
- en: These static files suffice in many situations, but sometimes, you will want
    the master to manage very specific configuration values for each agent. These
    values can be quite individual. For example, an Apache server usually requires
    a `MaxClients` setting. Appropriate values depend on many aspects, including hardware
    specifications and characteristics of the web application that is being run. It
    would be impractical to prepare all possible choices as distinct files in the
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Learning the template syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Templates make short work of such scenarios. With Puppet 4 EPP (embedded Puppet)
    templates were introduced. The older ERB (embedded Ruby) templates are still available
    and fully functional. If you know your way around PHP or JSP, you will quickly
    get the hang of EPP or ERB Puppet templates. The following EPP template will produce
    `Hello,world!` three times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following ERB template does the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This template will also produce lots of empty lines, because the text between
    the `<%` and `%>` tags gets removed from the output but the final line breaks
    do not. To make the EPP engine do just that, change the closing tag to `-%>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This example is not very helpful for configuration files, of course. To include
    dynamic values in the output, enclose Ruby expressions in a `<%=tag` pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, the iterator value is part of each line of the output. You can also use
    member variables that are prefixed with the `$` sign and use the full namespace
    to the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'These variables are populated with the values from the Puppet manifest variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Variables that are used in a template must be defined in the same scope or scopes
    from which the template is used. The next section explains how this works.
  prefs: []
  type: TYPE_NORMAL
- en: In Puppet 3.x, variable values are mostly strings, arrays, or hashes. To write
    efficient templates, it is helpful to occasionally glance at the methods available
    for the respective Ruby classes. In Puppet 4, variables have more diverse values.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways to use Puppet variables in ERB templates:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prefixing the variable with the `@` sign: This means that the variable is global,
    or it was defined in the same class where the template is used. This works with
    Puppet 2.7, Puppet 3, and Puppet 4'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the `scope.lookupvar(''variablewithscopename'')` function: This allows
    you to refer to any variable in any class of the module. Please do not look up
    variables in other modules; it will build an invisible dependency on the other
    module. The syntax works with Puppet 2, Puppet 3, and Puppet 4'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using `scope[''variablewithscope'']`: In Puppet 3, the scope hash can be used
    directly. The behavior is similar to `scope.lookupvar`. This will work with Puppet
    3 and Puppet 4'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using templates in practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Templates have their own place in modules. You can place them freely in the
    `templates/` subtree of the module. The `epp` function locates them using a simple
    descriptor: `epp(''cacti/apache/cacti.conf.epp'')`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This expression evaluates the content of the template found in `modules/cacti/templates/apache/cacti.conf.epp`.
    The first path element (without a leading slash) is the module name. The rest
    of the path gets translated to the `templates/` tree in the module. The function
    is commonly used to generate the value of a `file` resource''s `content` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Many templates expect some variables to be defined in their scope. The easiest
    way to make sure that this happens is to wrap the respective `file` resource in
    a parameterized container. Files that are **singletons** with a well-known name,
    such as `/etc/ssh/sshd_config`, should be managed through a parameterized class.
    Configuration items that can inhabit multiple files, such as `/etc/logrotate.d/*`Â or
    `/etc/apache2/conf.d/*`, are well suited to being wrapped in defined types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There is one main difference between EPP templates in classes compared to EPP
    templates in defines. EPP templates in classes can directly use the class variables
    with the namespace. A defined resource type does not have a fixed namespace. Therefore,
    it is required to add a mapping hash to the `epp` function, where we specify the
    variable inside the template and the corresponding variable inside the define.
  prefs: []
  type: TYPE_NORMAL
- en: Afterwards, one can use the variables directly inside the template (`$pattern,
    $max_days, $options`).
  prefs: []
  type: TYPE_NORMAL
- en: 'For a quick and dirty string transformation of your data, you can also use
    the `inline_epp` function in your manifest. This is often found on the right-hand
    side of a variable assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This example assumes that the `$my_array` Puppet variable in the `my_class`
    class holds an array value.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding performance bottlenecks from templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using templates, both through the `epp` and `inline_epp` functions, be
    aware that each invocation implies a performance penalty for your Puppet master.
    During the compilation of the catalog, Puppet must initialize the EPP engine for
    any template it encounters. The EPP evaluation happens in an individual environment
    that is derived from the respective scope of the `epp` function invocation.
  prefs: []
  type: TYPE_NORMAL
- en: It is, therefore, not even important how complex your templates are. If your
    manifest requires frequent expansion of a very short template, it generates an
    enormous overhead for each initialization. Especially in the case of an easy `inline_epp`
    function, such as the one mentioned previously, it can be worthwhile to invest
    some more effort into creating a parser function instead, as seen in [Chapter
    5](3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml), *Combining Classes, Configuration
    Files, and Extensions into Modules*. A function can perform variable value transformation
    without incurring the cumulative penalty.
  prefs: []
  type: TYPE_NORMAL
- en: On the bright side, using templates is quite economic for the agent, who receives
    the whole textual file content right inside the catalog. There is no need to make
    an additional call to the master and retrieve file metadata. On a high-latency
    network, this can be a noticeable saving.
  prefs: []
  type: TYPE_NORMAL
- en: There is no silver bullet here. Don't let the performance implications deter
    you from turning specific configuration files into templates. Template-based solutions
    will often make your module more maintainable, which will usually offset performance
    implications; hardware is constantly getting cheaper, after all. Just don't be
    wasteful with frequent (and simple) expansions.
  prefs: []
  type: TYPE_NORMAL
- en: Managing file snippets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next technique that we are going to discuss helps you solve conflicts in
    your manifests and build some elegant solutions in special situations. This mostly
    refers to configuration files where one is either not able to manage the whole
    file or where a file is constructed from different subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Puppet offers several ways to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: Single line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single entry in a section
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building from multiple snippets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other resource types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you deal with a configuration file, where a user may add additional content?
    What we have seen so far is management of complete configuration files, where
    changes will get reset. But think about the users `.bashrc` file, where the system
    administrator wants to ensure that the user is making use of a specific proxy.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, one can specify this globally in a `/etc/profile.d/` snippet. This
    is more meant to be a showcase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Puppet has a specific resource type which is able to manage a single line entry
    in a configuration file: the `file_line` resource type. This resource type is
    not a core resource type but is delivered by `stdlib` module.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, the line will be added at the bottom of the file, if
    it is missing. If the line is already available, Puppet will not change the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please remember that the `file_line` resource type expects that the file is
    already present on the system. If one is unsure about this, it is best practice
    to also manage the existence of the file without specifying content or source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Single entry in a section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: But what if one needs to configure a line within a configuration file which
    consists of sections? In this case, it is not a good idea to add the line at the
    bottom of the file.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the `ini_setting` resource type will be helpful. This resource
    type is not part of Puppet core, but is shipped with `puppetlabs-inifile` module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The previous example will check whether the agent section has an entry report
    `= true` and add it if it is missing. If the whole section is not yet there, it
    will also add the section. If the whole file is missing, the `ini_setting` resource
    type will also create the file.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, the `ini_setting` assumes that section names are put into brackets
    and that the `=` sign is used as a setting-value separator.
  prefs: []
  type: TYPE_NORMAL
- en: The resource type allows the adoption of `section_prefix` and `section_suffix`
    and `key_value_separator`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: But managing all single entries in `ssh_config` file is very ineffective, as
    one must provide all single entries within single recourse type declarations.
    In this specific case, it is feasible to build the configuration file from snippets.
  prefs: []
  type: TYPE_NORMAL
- en: Building from multiple snippets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is one main difference between building a file from snippets compared
    to the `file_line` and `ini_setting` resource type. The latter two just manage
    single entries in a file, whereas managing a file from snippets manages the complete
    configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: This is very useful if one does not know beforehand how many entries are needed.
    For example, dynamically scaling haproxy backends or adding backup entries for
    a database server where the number of databases is yet unknown.
  prefs: []
  type: TYPE_NORMAL
- en: The most common solution for file snippets is theÂ `puppetlabs-concat` module.
    The `concat` module needs at least one `no-noop` run, as it must manage the `concat`
    script on the nodes. This script is needed to build the final configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, it is required to mention to `concat` which file it is about to manage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This prepares `concat` to be able to build the file from `concat_fragments`.
    All fragments should be put into a specific order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using virtual resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next technique that we are going to discuss helps you solve conflicts in
    your manifests and build some elegant solutions in special situations.
  prefs: []
  type: TYPE_NORMAL
- en: Remember the uniqueness constraint that was introduced in [Chapter 1](8a22dc0e-3fe2-4153-b60e-935b7e6d9f94.xhtml),
    *Writing Your First Manifests,*Â any resource must be declared at most once in
    a manifest. There cannot be two classes or defined type instances that declare
    the same `file`, `package`, or any other type of resource. Each resource must
    have a unique type/name combination. This applies to instances of defined types
    as well as native resources.
  prefs: []
  type: TYPE_NORMAL
- en: This can pose issues when multiple modules need a common resource, such as an
    installed package, or perhaps even independent settings in the same configuration
    file. A component class for such resources, as introduced in [Chapter 4](daf11a18-5de2-4c3c-9880-e9a242ffb35b.xhtml),
    *Combining Resources in Classes and Defined Types*, will resolve basic conflicts
    of this kind. It can be included an arbitrary number of times in the same manifest.
  prefs: []
  type: TYPE_NORMAL
- en: This can be impractical when the number of shared resources is fairly large.
    Imagine that you find yourself in a situation where a large number of different
    Puppet nodes require software from a significant set of `yum` repositories. Puppet
    will happily manage the repository configuration on the agents through its `yumrepo`
    type. However, you don't actually want all these repositories configured on every
    last machine they do incur maintenance overhead, after all. It would, instead,
    be desirable for each node to automatically receive the configuration for all
    repositories it requires for its packages, but not more.
  prefs: []
  type: TYPE_NORMAL
- en: 'When solving this using component classes, you would wrap each repository in
    a distinct class. The class names should closely resemble (and most likely contain)
    the name of the respective repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Package resources that rely on one or more such repositories will need to be
    accompanied by appropriate `include` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is possible, but it is less than ideal. Puppet does offer an alternative
    way to avoid duplicate resource declarations in the form of virtual resources.
    It allows you to add a resource declaration to your manifest without adding the
    resource to the actual catalog. The virtual resource must be **realized** or **collected**
    for this purpose. As with class inclusion, this realization of virtual resources
    can happen arbitrarily in the same manifest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our previous example can, therefore, use a simpler structure with just one
    class to declare all the `yum` repositories as virtual resources with tag parameter
    set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@` prefix marks the `yumrepo` resources as virtual. This class can be
    safely included by all nodes. It will not affect the catalog until the resources
    are realized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `realize` function converts the referenced virtual resources to real ones,
    which get added to the catalog. Granted, this is not much better than the previous
    code that relied on the component classes. The virtual resources do make the intent
    clearer, at least. Realizing them is less ambiguous than some `include` statements;
    a class can contain many resources and even more `include` statements.
  prefs: []
  type: TYPE_NORMAL
- en: This `define` structure is actually possible with component classes as well.
    The class names can be passed as a parameter or from a central data structure.
    The `include` function will accept variable values for class names.
  prefs: []
  type: TYPE_NORMAL
- en: Realizing resources more flexibly using collectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of invoking the `realize` function, you can also rely on a different
    syntactic construct, which is the `collector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is more flexible than the function call at the cost of a slight performance
    penalty. It can be used as a reference to the realized resource(s) in certain
    contexts. For example, you can add ordering constraints with the chaining operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It is even possible to change values of resource attributes during collection.
    There is a whole section dedicated to such overrides later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the collector is based on an expression, you can conveniently realize a
    whole range of resources. This can be quite dynamic sometimes, you will create
    virtual resources that are already being realized by a rather indiscriminate collector.
    Let''s look at a common example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With no expression, the collection encompasses all virtual resources of the
    given type. This allows you to collect them all, without worrying about their
    explicit titles or attributes. This might seem redundant, because then it makes
    no sense to declare the resources as virtual in the first place. However, keep
    in mind that the collector might appear in some select manifests only, while the
    virtual resources can be safely added to all your nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be a little more selective, it can be useful to group virtual resources
    based on their **tags**. We haven''t discussed tags yet. Each resource is tagged
    with several identifiers. Each tag is just a simple string. You can tag a resource
    manually by defining the `tag` metaparameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The named tag is then added to the resource. Puppet implicitly tags all resources
    with the name of the declaring class, the containing module, and a range of other
    useful meta information. For example, if your user module divides the `user` resources
    into classes such as `administrators`, `developers`, `qa`, and other roles, you
    can make certain nodes or classes select all users of a given role with a collection
    based on the class name tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the tags actually form an array. The `==` comparison will look for
    the presence of the `developers` element in the `tag` array in this context. Have
    a look at another example to make this more clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This way, you can collect all users who are members of the `sys` group.
  prefs: []
  type: TYPE_NORMAL
- en: If you prefer function calls over the more cryptic collector syntax, you can
    keep using the `realize` function alongside collectors. This works without issues.
    Remember that each resource can be realized multiple times, even in both ways,
    simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: If you are wondering, the manifest for a given agent can only realize virtual
    resources that are declared inside this same agent's manifest. Virtual resources
    do not leak into other manifests. Consequently, there can be no deliberate transfer
    of resources from one manifest to another, either. However, there is yet another
    concept that allows such an exchange; this is described in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-node configuration with exported resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Puppet is commonly used to configure whole clusters of servers or HPC workers.
    Any configuration management system makes this task very efficient in comparison
    to manual care. Manifests can be shared between similar nodes. Configuration items
    that require individual customization per node are modeled individually. The whole
    process is very natural and direct.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, there are certain configuration tasks that do not lend themselves
    well to the paradigm of the central definition of all states. For example, a cluster
    setup might include the sharing of a generated key or registering IP addresses
    of peer nodes as they become available. An automatic setup should include an exchange
    of such shared information. Puppet can help out with this as well.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very good fit. It saves a metalayer, because you don't need to implement
    the setup of an information exchange system in Puppet. The sharing is secure,
    relying on Puppet's authentication and encryption infrastructure. There is logging
    and central control over the deployment of the shared configuration. Puppet retains
    its role as the central source for all system details; it serves as a hub for
    a secure exchange of information.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting and collecting resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Puppet approaches the problem of sharing configuration information among multiple
    agent nodes by way of exported resources. The concept is simple. The manifest
    of **node A** can contain one or more resources that are purely virtual and not
    for realization in the manifest of this **node A**. Other nodes, such as **B**
    and **C**, can import some or all of these resources. Then, the resources become
    part of the catalogs of these remote nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b0d63641-0c9a-4bd2-8308-29e622d732d8.png)'
  prefs: []
  type: TYPE_IMG
- en: The syntax to import and export resources is very similar to that of virtual
  prefs: []
  type: TYPE_NORMAL
- en: resources. An exported resource is declared by prepending the resource type
  prefs: []
  type: TYPE_NORMAL
- en: 'name with two `@` characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The importing manifests collect these resources using an expression, which is
    again similar to the collection of virtual resources, but with double-angled
  prefs: []
  type: TYPE_NORMAL
- en: 'brackets, `<` and `>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Tags are a very common way to take fine-grained control over the distribution
    of such exported resources.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the master to store exported resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The only recommendable way to enable support for exported resources is PuppetDB.
    It is a REST API that stores different kinds of data that the Puppet master deals
    with during regular operation in a PostgreSQL database. This includes catalog
    requests from agents (including their valuable facts), reports from catalog applications,
    and exported resources.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2](7cafeeab-0e5c-4848-9eb0-1bae38ed3525.xhtml), *Puppet Server and
    Agents*, detailed a manual installation of the master. Let''s add the PuppetDB
    with more style through Puppet! On the Forge, you will find a convenient module
    that will make this easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'On the master node, the setup now becomes a one-line invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As our test master uses a nonstandard SSL certificate that is named `master.example.net`
    (instead of its FQDN), it must be configured for `puppetdb` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The ensuing catalog run is quite impressive. Puppet installs the PostgreSQL
    backend, the Jetty server, and the actual PuppetDB package, and it configures
    everything and starts the services up all in one go. After applying this short
    manifest, you have added a complex piece of infrastructure to your Puppet setup.
    You can now use exported resources for a variety of helpful tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting SSH host keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For homegrown interactions between clustered machines, SSH can be an invaluable
    tool. File transfer and the remote execution of arbitrary commands is easily possible
    thanks to the ubiquitous `sshd` service. For security reasons, each host generates
    a unique key in order to identify itself. Of course, such public key authentication
    systems can only really work with a trust network, or the presharing of public
    keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Puppet can do the latter quite nicely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Interested nodes collect keys with the known pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, SSH servers can be authenticated through the respective keys that Puppet
    safely stores in its database. As always, the Puppet master is the fulcrum of
    security.
  prefs: []
  type: TYPE_NORMAL
- en: As a matter of fact, some `ssh` modules from the Puppet Forge will use this
    kind of construct to do this work for you.
  prefs: []
  type: TYPE_NORMAL
- en: Managing hosts files locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many sites can rely on a local DNS infrastructure. Resolving names to local
    IP addresses is easy with such setups. However, small networks, or sites that
    consist of many independent clusters with little shared infrastructure, will have
    to rely on names in `/etc/hosts` instead.
  prefs: []
  type: TYPE_NORMAL
- en: You can maintain a central hosts file per network cell, or you can make
  prefs: []
  type: TYPE_NORMAL
- en: 'Puppet maintain each entry in each hosts file separately. The latter approach
    has some advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Changes are automatically distributed through the Puppet agent network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Puppet copes with unmanaged lines in the hosts files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A manually maintained registry is prone to becoming outdated every once in a
    while. It will also obliterate local additions in any hosts files on the agent
    machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The manifest implementation of the superior approach with exported resources
    is very similar to the `sshkey` example from the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the same principle, only now, each node exports its `$ipaddress` fact
    value alongside its name and not a public key. The import also works the same
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Automating custom configuration items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do you remember the Cacti module that you created during the previous chapter?
    It makes it very simple to configure all monitored devices in the manifest of
    the Cacti server. However, as this is possible, wouldn''t it be even better if
    each node in your network was registered automatically with Cacti? It''s simple:
    make the devices export their respective `cacti_device` resources for the server
    to collect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The Cacti server, apart from including the `cacti` class, just needs to collect
    the devices now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If one Cacti server handles all your machines, you can just omit the `tag`
    comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Once the module supports other Cacti resources, you can handle them in the same
    way. Let's look at an example from another popular monitoring solution.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying the configuration of Nagios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Puppet comes with support to manage the complete configuration of **Nagios**
    (and compatible versions of **Icinga**). Each configuration section can be represented
    by a distinct Puppet resource with types such as `nagios_host` or `nagios_service`.
  prefs: []
  type: TYPE_NORMAL
- en: There is an endeavour to remove this support from core Puppet. This does not
    mean that support will be discontinued, however. It will just move to yet another
    excellent Puppet module.
  prefs: []
  type: TYPE_NORMAL
- en: Each of your machines can export their individual `nagios_host` resources alongside
    their `host` and `cacti_device` resources. However, thanks to the diverse Nagios
    support, you can do even better.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that you have a module or class to wrap SSH handling (you are using
    a Forge module for the actual management, of course), you can handle monitoring
    from inside your own SSH server class. By adding the export to this class, you
    make sure that nodes that include the class (and only these nodes) will also get
    monitoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You probably know the drill by now, but let''s repeat the mantra once more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: With this collection, the Nagios host configures itself with all services that
    the agent manifests create.
  prefs: []
  type: TYPE_NORMAL
- en: For large Nagios configurations, you might want to consider reimplementing the
    Nagios types yourself, using simple defines that build the configuration from
    templates. The native types can be slower than the `file` resources in this case,
    because they have to parse the whole Nagios configuration on each run. The `file`
    resources can be much cheaper, as they rely on content-agnostic checksums.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining your central firewall
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Speaking of useful features that are not part of the core of Puppet, you can
    manage the rules of your `iptables` firewall, of course. You need the `puppetlabs-firewall`
    module to make the appropriate types available. Then, each machine can (among
    other useful things) export its own required port forwarding to the firewall machines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `$public_ip_address` value is not a Facter fact, of course. Your node will
    have to be configured with the appropriate information. You can refer toÂ [Chapter
    7](b38488ca-86a7-4ecf-9a69-16938576d852.xhtml), *New Features from Puppet 4 and
    5*, for a good way to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The title of a firewall rule resource conventionally begins with a three-digit
    index for ordering purposes. The firewall machines collect all these rules naturally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the possibilities for modeling distributed systems through exported
    Puppet resources are manifold. The simple pattern that we've iterated for several
    resource types suffices for a wide range of use cases. Combined with defined resource
    types, it allows you to flexibly enable your manifests to work together in order
    to form complex cluster setups with relatively little effort. The larger your
    clusters, the more work Puppet lifts from you through exports and collections.
  prefs: []
  type: TYPE_NORMAL
- en: Removing obsolete exports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a node manifest stops exporting any resource, that resource's record is
    removed from PuppetDB once the node's catalog is compiled. This usually happens
    when the agent checks in with the master.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you take an agent out of commission permanently, this will never
    happen. That's why you will need to remove those exports from the DB manually.
    Otherwise, other nodes will keep importing the old resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'To clean such records from PuppetDB, use the `puppet node deactivate` command
    on the master server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Setting defaults for resource parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both exported and virtual resources are declared once, and are then collected
    in different contexts. The syntax is very similar, as are the concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, a central definition of a resource cannot be safely realized on all
    of your nodes, though; for example, consider the set of all your `user` resources.
    You will most likely wish to manage the user ID that is assigned to each account
    in order to make them consistent across your networks.
  prefs: []
  type: TYPE_NORMAL
- en: This is often solved through LDAP or similar directories, but that is not possible
    for some sites.
  prefs: []
  type: TYPE_NORMAL
- en: Even if all accounts on almost all machines will be able to use their designated
    ID, there are likely to be some exceptions. On a few older machines, some IDs
    are probably being used for other purposes already, which cannot be changed easily.
    On such machines, creating users with these IDs will fail.
  prefs: []
  type: TYPE_NORMAL
- en: The accounts can be created if duplicate IDs are allowed, but that is not a
    solution to this problem duplicates are usually not desirable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, Puppet has a convenient way to express such exceptions. To give
    the nonstandard UID, `2066`, to the user, `felix`, realize the resource with an
    attribute value specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: You can pass any property, parameter, or metaparameter that applies to the
  prefs: []
  type: TYPE_NORMAL
- en: resource type in question. A value that you specify this way is final and cannot
    be overridden again.
  prefs: []
  type: TYPE_NORMAL
- en: This language feature is more powerful than the preceding example lets on. This
    is because the override is not limited to virtual and exported resources. You
    can override any resource from anywhere in your manifest. This allows for some
    remarkable constructs and shortcuts.
  prefs: []
  type: TYPE_NORMAL
- en: Consider, for example, the Cacti module that you created during the previous
    chapter. It declares a `package` resource in order to make sure that the software
    is installed. To that end, it specifies `ensure => installed`. If any user of
    your module needs Puppet to keep their packages up to date, this is not adequate
    though. The clean solution for this case is to add some parameters to the module's
    classes which allow the user to choose the `ensure` property value for the package
    and other resources. However, this is not really practical. Complex modules can
    manage hundreds of properties, and exposing them all through parameters would
    form a horribly confusing interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The override syntax can provide a simple and elegant workaround here. The manifest
    that achieves the desired result is very straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: For all its simplicity, this manifest will be hard to decipher for collaborators
    who are not familiar with the collector/override syntax. This is not the only
    problem with overrides. You cannot override the same attribute multiple times.
    This is actually a good thing, because any rules that resolve such conflicting
    overrides make it extremely difficult to predict the actual semantics of a manifest
    that contains multiple overrides of this kind.
  prefs: []
  type: TYPE_NORMAL
- en: Relying on this override syntax too much will make your manifests prone to conflicts.
    Combining the wrong classes will make the compiler stop creating the catalog.
    Even if you manage to avoid all conflicts, the manifests will become rather chaotic.
    It can be difficult to locate all active overrides for a given node. The resulting
    behavior of any class or define becomes hard to predict.
  prefs: []
  type: TYPE_NORMAL
- en: All things considered, it's safest to use overrides very sparingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The collectors are especially dangerous when used without a selector expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Not only will it realize all virtual resources of the given type. It will also
    force surprising attribute values on both virtual and regular resources of the
    same type.
  prefs: []
  type: TYPE_NORMAL
- en: Saving redundancy using resource defaults
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final language construct that this chapter introduces can save you quite
  prefs: []
  type: TYPE_NORMAL
- en: 'some typing, or rather, it saves you from copying and pasting. Writing a long,
    repetitive manifest is not what costs you lots of time, of course. However, a
    briefer manifest is often more readable, and hence, more maintainable. You achieve
    this by defining resource defaults; attribute values that are used for resources
    that don''t choose their own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: By default, each grant should apply to all databases and comprise all privileges.
    This allows you to define each actual `mysql_grant` resource quite sparsely. Otherwise,
    you will have to specify the `privileges` property for all resources. The `options`
    attribute will be especially repetitive, because they are identical for all grants
    in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the ensure property is repetitive as well, but it was not included.
    It is considered good practice to exempt this attribute from resource defaults.
  prefs: []
  type: TYPE_NORMAL
- en: The `mysql_grant` resource type is not available in core Puppet. It's part of
    the `puppetlabs-mysql` module on the Forge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite the convenience that this approach offers, it should not be used at
    each apparent opportunity. It has some downsides that you should keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: The defaults can be surprising if they apply to resources that are declared
    at a lexical distance from the defaults' definition (such as several screens further
    down the manifest file)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The defaults transcend the inclusion of classes and instantiation of defines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These two aspects form a dangerous combination. Defaults from a composite class
    can affect very distant parts of a manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Files declared in the `webserver` class should belong to a default user. However,
    this default takes effect recursively in the included classes as well. The `owner`
    attribute is a property: a resource that defines no value, for it just ignores
    its current state. A value that is specified in the manifest will be enforced
    by the agent. Often, you do not care about the owner of a managed file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'However, because of the default `owner` attribute, Puppet will now mandate
    that this file belongs to `www-data`. To avoid this, you will have to unset the
    default by overwriting it with `undef`, which is Puppet''s analog to the `nil`
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This can also be done in individual resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: However, doing this constantly is hardly feasible. The latter option is especially
    unattractive, because it leads to more complexity in the manifest code, instead
    of simplifying it. After all, not defining a default `owner` attribute will be
    the cleaner way here.
  prefs: []
  type: TYPE_NORMAL
- en: The semantics that make defaults take effect in so many manifest areas is known
    as **dynamic scoping**. It used to apply to variable values as well and is generally
    considered harmful. One of the most decisive changes in Puppet 3.0 was the removal
    of dynamic variable scoping, in fact. Resource defaults still use it, but it is
    expected that this will change in a future release as well.
  prefs: []
  type: TYPE_NORMAL
- en: Resource defaults should be used with consideration and care. For some properties,
    such as `file mode`, `owner`, and `group`, they should usually be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding antipatterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Speaking of things to avoid, there is a language feature that we will only
    address in order to advise great caution. Puppet comes with a function called
    `defined`, which allows you to query the compiler about resources that have been
    declared in the manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem with the concept is that it cannot ever be reliable. Even if the
    resource appears in the manifest, the compiler might encounter it later than the
    `if` condition. This is potentially very problematic, because some modules will
    try to make themselves portable through this construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The module author supposes that this resource definition will be skipped if
  prefs: []
  type: TYPE_NORMAL
- en: the manifest declares `Package['apache2']` somewhere else. As explained, this
    method will only be effective if the block is evaluated late enough during the
    compiler run. The conflict can still occur if the compiler encounters the other
    declaration after this one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The manifest''s behavior becomes outright unpredictable if a manifest contains
    multiple occurrences of the same query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The first block that is seen wins. This can even shift if unrelated parts of
    the manifest are restructured. You cannot predict whether a given manifest will
    use `ensure=>latest` for the `apache2` package or just use `installed`. The results
    become even more bizarre if such a block wants a resource removed through `ensure=>absent`,
    while the other does not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `defined` function has long been considered harmful, but there is no adequate
    alternative yet. The `ensure_resource` function from the `stdlib` module tries
    to make the scenario less problematic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: By relying on this function instead of the preceding antipattern based around
    the `defined` function, you will avoid the unpredictable behavior of conflicting
    declarations. Instead, this will cause the compiler to fail when the declarations
    are passed to `ensure_resource`. This is still not a clean practice, though. Failed
    compilation is not a desirable alternative either.
  prefs: []
  type: TYPE_NORMAL
- en: Both functions should be avoided in favor of clean module structures with non-ambiguous
    resource declarations. More details on how to ensure reusable, composable, and
    stackable classes will be provided in [Chapter 9](0a0cf4b0-23fa-48fd-abf9-77ed851bb581.xhtml),
    *Puppet Roles and Profiles.*
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A template is a frequent occurrence and is one of the best ways for Puppet to
    manage dynamic file content. Evaluating each template requires extra effort from
    the compiler, but the gain in flexibility is usually worth it. Variables in templates
    have to be declared using the Puppet variable syntax with full namespace, or by
    prodding a hash with variable inside templates and classes.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of virtual resources is much less ubiquitous. Virtual resources
    allow you to flexibly add certain entities to a node's catalog. The collector
    syntax that is used for this can also be used to override attribute values, which
    works for non-virtual resources as well.
  prefs: []
  type: TYPE_NORMAL
- en: Once PuppetDB is installed and configured, you can also export resources so
    that other node manifests can receive their configuration information. This allows
    you to model distributed systems quite elegantly.
  prefs: []
  type: TYPE_NORMAL
- en: The resource defaults are just a syntactic shortcut that help keep your manifest
    concise. They have to be used with care, though. Some language features, such
    as the `defined` function (and its module-based successor, which is the `ensure_resource`
    function), should be avoided if possible.
  prefs: []
  type: TYPE_NORMAL
- en: "[Chapter 7\uFEFF](b38488ca-86a7-4ecf-9a69-16938576d852.xhtml), *New Features\
    \ from Puppet 4 and 5*, gives you an overview and introduction to the roles and\
    \ profiles pattern, which is best practice for combining upstream modules with\
    \ platform implementations."
  prefs: []
  type: TYPE_NORMAL
