- en: The Puppet Beginners Advanced Parts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After our in-depth discussions on both the manifest structure elements (class
    and define) and encompassing structure (modules), you are in a great position
    to write manifests for all of your agents. Make sure that you get Forge modules
    that will allow them to do your work for you. Then go ahead and add site-specific
    modules that implement Forge modules to your needs. Finally, you will have composite
    classes for the `node` blocks to be used, or rather, included.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: These concepts are quite a bit to take in. It's now time to decelerate a bit,
    lean back, and tackle simpler code structures and ideas. You are about to learn
    some techniques that you are not going to need every day. They can make difficult
    scenarios much easier, though. So, it might be a good idea to come back to this
    chapter again after you have spent some time in the field. You might find that
    some of your designs can be simplified with these tools.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, these are the techniques that will be presented:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Building dynamic configuration files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing file snippets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using virtual resources
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-node configuration with exported resources
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting defaults for resource parameters
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding antipatterns
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building dynamic configuration files
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the introduction, I stated that the techniques that you are now learning
    are not frequently required. That was true, except for this one topic. Templates
    are actually a cornerstone of configuration management with Puppet.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Templates are an alternative way to manage configuration files, or any files
    really. You have synchronized files from the master to an agent that handled some
    Apache configuration settings. These are not templates, technically. They are
    merely static files that have been prepared and are ready for carbon copying.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: These static files suffice in many situations, but sometimes, you will want
    the master to manage very specific configuration values for each agent. These
    values can be quite individual. For example, an Apache server usually requires
    a `MaxClients` setting. Appropriate values depend on many aspects, including hardware
    specifications and characteristics of the web application that is being run. It
    would be impractical to prepare all possible choices as distinct files in the
    module.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Learning the template syntax
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Templates make short work of such scenarios. With Puppet 4 EPP (embedded Puppet)
    templates were introduced. The older ERB (embedded Ruby) templates are still available
    and fully functional. If you know your way around PHP or JSP, you will quickly
    get the hang of EPP or ERB Puppet templates. The following EPP template will produce
    `Hello,world!` three times:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following ERB template does the same:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This template will also produce lots of empty lines, because the text between
    the `<%` and `%>` tags gets removed from the output but the final line breaks
    do not. To make the EPP engine do just that, change the closing tag to `-%>`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This example is not very helpful for configuration files, of course. To include
    dynamic values in the output, enclose Ruby expressions in a `<%=tag` pair:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, the iterator value is part of each line of the output. You can also use
    member variables that are prefixed with the `$` sign and use the full namespace
    to the variable.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'These variables are populated with the values from the Puppet manifest variables:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Variables that are used in a template must be defined in the same scope or scopes
    from which the template is used. The next section explains how this works.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: In Puppet 3.x, variable values are mostly strings, arrays, or hashes. To write
    efficient templates, it is helpful to occasionally glance at the methods available
    for the respective Ruby classes. In Puppet 4, variables have more diverse values.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways to use Puppet variables in ERB templates:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Prefixing the variable with the `@` sign: This means that the variable is global,
    or it was defined in the same class where the template is used. This works with
    Puppet 2.7, Puppet 3, and Puppet 4'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the `scope.lookupvar(''variablewithscopename'')` function: This allows
    you to refer to any variable in any class of the module. Please do not look up
    variables in other modules; it will build an invisible dependency on the other
    module. The syntax works with Puppet 2, Puppet 3, and Puppet 4'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using `scope[''variablewithscope'']`: In Puppet 3, the scope hash can be used
    directly. The behavior is similar to `scope.lookupvar`. This will work with Puppet
    3 and Puppet 4'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using templates in practice
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Templates have their own place in modules. You can place them freely in the
    `templates/` subtree of the module. The `epp` function locates them using a simple
    descriptor: `epp(''cacti/apache/cacti.conf.epp'')`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'This expression evaluates the content of the template found in `modules/cacti/templates/apache/cacti.conf.epp`.
    The first path element (without a leading slash) is the module name. The rest
    of the path gets translated to the `templates/` tree in the module. The function
    is commonly used to generate the value of a `file` resource''s `content` property:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Many templates expect some variables to be defined in their scope. The easiest
    way to make sure that this happens is to wrap the respective `file` resource in
    a parameterized container. Files that are **singletons** with a well-known name,
    such as `/etc/ssh/sshd_config`, should be managed through a parameterized class.
    Configuration items that can inhabit multiple files, such as `/etc/logrotate.d/*` or
    `/etc/apache2/conf.d/*`, are well suited to being wrapped in defined types:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There is one main difference between EPP templates in classes compared to EPP
    templates in defines. EPP templates in classes can directly use the class variables
    with the namespace. A defined resource type does not have a fixed namespace. Therefore,
    it is required to add a mapping hash to the `epp` function, where we specify the
    variable inside the template and the corresponding variable inside the define.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的EPP模板与定义中的EPP模板之间有一个主要的区别。类中的EPP模板可以直接使用带命名空间的类变量。而定义的资源类型没有固定的命名空间。因此，需要向`epp`函数添加一个映射哈希，其中我们指定模板中的变量和定义中对应的变量。
- en: Afterwards, one can use the variables directly inside the template (`$pattern,
    $max_days, $options`).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，可以直接在模板中使用变量（`$pattern, $max_days, $options`）。
- en: 'For a quick and dirty string transformation of your data, you can also use
    the `inline_epp` function in your manifest. This is often found on the right-hand
    side of a variable assignment:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于快速且简便的数据字符串转换，你还可以在清单中使用`inline_epp`函数。这个函数通常出现在变量赋值的右侧：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This example assumes that the `$my_array` Puppet variable in the `my_class`
    class holds an array value.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例假设`my_class`类中的`$my_array` Puppet变量包含一个数组值。
- en: Avoiding performance bottlenecks from templates
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免模板中的性能瓶颈
- en: When using templates, both through the `epp` and `inline_epp` functions, be
    aware that each invocation implies a performance penalty for your Puppet master.
    During the compilation of the catalog, Puppet must initialize the EPP engine for
    any template it encounters. The EPP evaluation happens in an individual environment
    that is derived from the respective scope of the `epp` function invocation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用模板时，无论是通过`epp`还是`inline_epp`函数，都需要注意每次调用都会对Puppet主服务器带来性能损耗。在编译目录时，Puppet必须为它遇到的每个模板初始化EPP引擎。EPP评估发生在一个独立的环境中，该环境来自于`epp`函数调用的相应作用域。
- en: It is, therefore, not even important how complex your templates are. If your
    manifest requires frequent expansion of a very short template, it generates an
    enormous overhead for each initialization. Especially in the case of an easy `inline_epp`
    function, such as the one mentioned previously, it can be worthwhile to invest
    some more effort into creating a parser function instead, as seen in [Chapter
    5](3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml), *Combining Classes, Configuration
    Files, and Extensions into Modules*. A function can perform variable value transformation
    without incurring the cumulative penalty.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，模板的复杂度并不重要。如果你的清单需要频繁扩展一个非常简短的模板，那么每次初始化都会产生巨大的开销。特别是在使用简单的`inline_epp`函数时，如前所述，值得投入更多的精力来创建一个解析函数，正如在[第5章](3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml)中所看到的，*将类、配置文件和扩展合并为模块*。函数可以在不增加累积性能损失的情况下执行变量值转换。
- en: On the bright side, using templates is quite economic for the agent, who receives
    the whole textual file content right inside the catalog. There is no need to make
    an additional call to the master and retrieve file metadata. On a high-latency
    network, this can be a noticeable saving.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从积极的一面看，使用模板对于代理来说非常经济，因为代理可以直接在目录中接收到完整的文本文件内容。无需额外调用主服务器并检索文件元数据。在高延迟的网络环境下，这能带来明显的节省。
- en: There is no silver bullet here. Don't let the performance implications deter
    you from turning specific configuration files into templates. Template-based solutions
    will often make your module more maintainable, which will usually offset performance
    implications; hardware is constantly getting cheaper, after all. Just don't be
    wasteful with frequent (and simple) expansions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有万能的解决方案。不要让性能影响阻止你将特定的配置文件转换为模板。基于模板的解决方案通常会使你的模块更具可维护性，通常可以抵消性能上的影响；毕竟，硬件价格一直在下降。只要避免频繁（且简单）的扩展，就不会浪费资源。
- en: Managing file snippets
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理文件片段
- en: The next technique that we are going to discuss helps you solve conflicts in
    your manifests and build some elegant solutions in special situations. This mostly
    refers to configuration files where one is either not able to manage the whole
    file or where a file is constructed from different subclasses.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要讨论的技术帮助你解决清单中的冲突，并在特殊情况下构建一些优雅的解决方案。这主要指的是配置文件，其中一个文件可能无法完全管理，或者文件是由不同子类构建的。
- en: 'Puppet offers several ways to accomplish this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet提供了几种方法来实现这一点：
- en: Single line
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单行
- en: Single entry in a section
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个条目在一个部分中
- en: Building from multiple snippets
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从多个片段构建
- en: Other resource types
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他资源类型
- en: How do you deal with a configuration file, where a user may add additional content?
    What we have seen so far is management of complete configuration files, where
    changes will get reset. But think about the users `.bashrc` file, where the system
    administrator wants to ensure that the user is making use of a specific proxy.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Normally, one can specify this globally in a `/etc/profile.d/` snippet. This
    is more meant to be a showcase.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Puppet has a specific resource type which is able to manage a single line entry
    in a configuration file: the `file_line` resource type. This resource type is
    not a core resource type but is delivered by `stdlib` module.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the previous example, the line will be added at the bottom of the file, if
    it is missing. If the line is already available, Puppet will not change the file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Please remember that the `file_line` resource type expects that the file is
    already present on the system. If one is unsure about this, it is best practice
    to also manage the existence of the file without specifying content or source:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Single entry in a section
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: But what if one needs to configure a line within a configuration file which
    consists of sections? In this case, it is not a good idea to add the line at the
    bottom of the file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: This is where the `ini_setting` resource type will be helpful. This resource
    type is not part of Puppet core, but is shipped with `puppetlabs-inifile` module.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The previous example will check whether the agent section has an entry report
    `= true` and add it if it is missing. If the whole section is not yet there, it
    will also add the section. If the whole file is missing, the `ini_setting` resource
    type will also create the file.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Normally, the `ini_setting` assumes that section names are put into brackets
    and that the `=` sign is used as a setting-value separator.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: The resource type allows the adoption of `section_prefix` and `section_suffix`
    and `key_value_separator`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will produce the following output:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: But managing all single entries in `ssh_config` file is very ineffective, as
    one must provide all single entries within single recourse type declarations.
    In this specific case, it is feasible to build the configuration file from snippets.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Building from multiple snippets
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is one main difference between building a file from snippets compared
    to the `file_line` and `ini_setting` resource type. The latter two just manage
    single entries in a file, whereas managing a file from snippets manages the complete
    configuration file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: This is very useful if one does not know beforehand how many entries are needed.
    For example, dynamically scaling haproxy backends or adding backup entries for
    a database server where the number of databases is yet unknown.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: The most common solution for file snippets is the `puppetlabs-concat` module.
    The `concat` module needs at least one `no-noop` run, as it must manage the `concat`
    script on the nodes. This script is needed to build the final configuration file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'First, it is required to mention to `concat` which file it is about to manage:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This prepares `concat` to be able to build the file from `concat_fragments`.
    All fragments should be put into a specific order:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using virtual resources
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next technique that we are going to discuss helps you solve conflicts in
    your manifests and build some elegant solutions in special situations.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Remember the uniqueness constraint that was introduced in [Chapter 1](8a22dc0e-3fe2-4153-b60e-935b7e6d9f94.xhtml),
    *Writing Your First Manifests,* any resource must be declared at most once in
    a manifest. There cannot be two classes or defined type instances that declare
    the same `file`, `package`, or any other type of resource. Each resource must
    have a unique type/name combination. This applies to instances of defined types
    as well as native resources.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: This can pose issues when multiple modules need a common resource, such as an
    installed package, or perhaps even independent settings in the same configuration
    file. A component class for such resources, as introduced in [Chapter 4](daf11a18-5de2-4c3c-9880-e9a242ffb35b.xhtml),
    *Combining Resources in Classes and Defined Types*, will resolve basic conflicts
    of this kind. It can be included an arbitrary number of times in the same manifest.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: This can be impractical when the number of shared resources is fairly large.
    Imagine that you find yourself in a situation where a large number of different
    Puppet nodes require software from a significant set of `yum` repositories. Puppet
    will happily manage the repository configuration on the agents through its `yumrepo`
    type. However, you don't actually want all these repositories configured on every
    last machine they do incur maintenance overhead, after all. It would, instead,
    be desirable for each node to automatically receive the configuration for all
    repositories it requires for its packages, but not more.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'When solving this using component classes, you would wrap each repository in
    a distinct class. The class names should closely resemble (and most likely contain)
    the name of the respective repositories:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Package resources that rely on one or more such repositories will need to be
    accompanied by appropriate `include` statements:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is possible, but it is less than ideal. Puppet does offer an alternative
    way to avoid duplicate resource declarations in the form of virtual resources.
    It allows you to add a resource declaration to your manifest without adding the
    resource to the actual catalog. The virtual resource must be **realized** or **collected**
    for this purpose. As with class inclusion, this realization of virtual resources
    can happen arbitrarily in the same manifest.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Our previous example can, therefore, use a simpler structure with just one
    class to declare all the `yum` repositories as virtual resources with tag parameter
    set:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `@` prefix marks the `yumrepo` resources as virtual. This class can be
    safely included by all nodes. It will not affect the catalog until the resources
    are realized:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `realize` function converts the referenced virtual resources to real ones,
    which get added to the catalog. Granted, this is not much better than the previous
    code that relied on the component classes. The virtual resources do make the intent
    clearer, at least. Realizing them is less ambiguous than some `include` statements;
    a class can contain many resources and even more `include` statements.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: This `define` structure is actually possible with component classes as well.
    The class names can be passed as a parameter or from a central data structure.
    The `include` function will accept variable values for class names.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Realizing resources more flexibly using collectors
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of invoking the `realize` function, you can also rely on a different
    syntactic construct, which is the `collector`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is more flexible than the function call at the cost of a slight performance
    penalty. It can be used as a reference to the realized resource(s) in certain
    contexts. For example, you can add ordering constraints with the chaining operator:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It is even possible to change values of resource attributes during collection.
    There is a whole section dedicated to such overrides later in this chapter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'As the collector is based on an expression, you can conveniently realize a
    whole range of resources. This can be quite dynamic sometimes, you will create
    virtual resources that are already being realized by a rather indiscriminate collector.
    Let''s look at a common example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With no expression, the collection encompasses all virtual resources of the
    given type. This allows you to collect them all, without worrying about their
    explicit titles or attributes. This might seem redundant, because then it makes
    no sense to declare the resources as virtual in the first place. However, keep
    in mind that the collector might appear in some select manifests only, while the
    virtual resources can be safely added to all your nodes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'To be a little more selective, it can be useful to group virtual resources
    based on their **tags**. We haven''t discussed tags yet. Each resource is tagged
    with several identifiers. Each tag is just a simple string. You can tag a resource
    manually by defining the `tag` metaparameter:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The named tag is then added to the resource. Puppet implicitly tags all resources
    with the name of the declaring class, the containing module, and a range of other
    useful meta information. For example, if your user module divides the `user` resources
    into classes such as `administrators`, `developers`, `qa`, and other roles, you
    can make certain nodes or classes select all users of a given role with a collection
    based on the class name tag:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note that the tags actually form an array. The `==` comparison will look for
    the presence of the `developers` element in the `tag` array in this context. Have
    a look at another example to make this more clear:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些标签实际上形成了一个数组。`==` 比较将查找此上下文中 `tag` 数组中是否存在 `developers` 元素。看一下另一个例子，让这个概念更加清晰：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This way, you can collect all users who are members of the `sys` group.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，你可以收集所有属于 `sys` 组的用户。
- en: If you prefer function calls over the more cryptic collector syntax, you can
    keep using the `realize` function alongside collectors. This works without issues.
    Remember that each resource can be realized multiple times, even in both ways,
    simultaneously.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢函数调用而非较为晦涩的收集器语法，你可以继续使用 `realize` 函数和收集器一起使用。这样不会有问题。记住，每个资源可以多次实现，甚至可以同时以两种方式实现。
- en: If you are wondering, the manifest for a given agent can only realize virtual
    resources that are declared inside this same agent's manifest. Virtual resources
    do not leak into other manifests. Consequently, there can be no deliberate transfer
    of resources from one manifest to another, either. However, there is yet another
    concept that allows such an exchange; this is described in the next section.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道，给定代理的清单只能实现该代理清单中声明的虚拟资源。虚拟资源不会泄漏到其他清单中。因此，资源不能从一个清单故意转移到另一个清单中。不过，还有另外一个概念可以实现这样的交换；它将在下一节中描述。
- en: Cross-node configuration with exported resources
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用导出资源进行跨节点配置
- en: Puppet is commonly used to configure whole clusters of servers or HPC workers.
    Any configuration management system makes this task very efficient in comparison
    to manual care. Manifests can be shared between similar nodes. Configuration items
    that require individual customization per node are modeled individually. The whole
    process is very natural and direct.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 常用于配置整个服务器集群或 HPC 工作节点。与手动管理相比，任何配置管理系统都能使这项任务变得更加高效。相似节点之间可以共享清单。需要为每个节点单独定制的配置项会被单独建模。整个过程非常自然且直接。
- en: On the other hand, there are certain configuration tasks that do not lend themselves
    well to the paradigm of the central definition of all states. For example, a cluster
    setup might include the sharing of a generated key or registering IP addresses
    of peer nodes as they become available. An automatic setup should include an exchange
    of such shared information. Puppet can help out with this as well.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有一些配置任务不太适合所有状态的中央定义范式。例如，集群设置可能包括共享生成的密钥，或在对等节点变得可用时注册其 IP 地址。自动化设置应包括此类共享信息的交换。Puppet
    也可以帮助处理这个问题。
- en: This is a very good fit. It saves a metalayer, because you don't need to implement
    the setup of an information exchange system in Puppet. The sharing is secure,
    relying on Puppet's authentication and encryption infrastructure. There is logging
    and central control over the deployment of the shared configuration. Puppet retains
    its role as the central source for all system details; it serves as a hub for
    a secure exchange of information.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常合适的匹配。它节省了一个元层，因为你不需要在 Puppet 中实现信息交换系统的设置。共享是安全的，依赖于 Puppet 的身份验证和加密基础设施。还有日志记录和集中控制共享配置的部署。Puppet
    保持其作为所有系统详细信息的中央源的角色；它充当了安全信息交换的中心。
- en: Exporting and collecting resources
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导出和收集资源
- en: Puppet approaches the problem of sharing configuration information among multiple
    agent nodes by way of exported resources. The concept is simple. The manifest
    of **node A** can contain one or more resources that are purely virtual and not
    for realization in the manifest of this **node A**. Other nodes, such as **B**
    and **C**, can import some or all of these resources. Then, the resources become
    part of the catalogs of these remote nodes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 通过导出资源的方法来解决多个代理节点之间共享配置信息的问题。这个概念很简单。**节点 A** 的清单可以包含一个或多个纯虚拟资源，这些资源不在
    **节点 A** 的清单中实现。其他节点，例如 **B** 和 **C**，可以导入其中的一部分或全部资源。然后，这些资源成为这些远程节点的目录的一部分。
- en: '![](img/b0d63641-0c9a-4bd2-8308-29e622d732d8.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0d63641-0c9a-4bd2-8308-29e622d732d8.png)'
- en: The syntax to import and export resources is very similar to that of virtual
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 导入和导出资源的语法与虚拟资源的语法非常相似。
- en: resources. An exported resource is declared by prepending the resource type
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 资源。导出资源通过在资源类型前添加前缀来声明。
- en: 'name with two `@` characters:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 带有两个 `@` 字符的名称：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The importing manifests collect these resources using an expression, which is
    again similar to the collection of virtual resources, but with double-angled
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 导入清单使用表达式收集这些资源，这与收集虚拟资源类似，但使用了双角括号
- en: 'brackets, `<` and `>`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 括号，`<` 和 `>`：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tags are a very common way to take fine-grained control over the distribution
    of such exported resources.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 标签是控制这种导出资源分发的非常常见的方式。
- en: Configuring the master to store exported resources
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置主节点以存储导出的资源
- en: The only recommendable way to enable support for exported resources is PuppetDB.
    It is a REST API that stores different kinds of data that the Puppet master deals
    with during regular operation in a PostgreSQL database. This includes catalog
    requests from agents (including their valuable facts), reports from catalog applications,
    and exported resources.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一推荐的启用导出资源支持的方式是 PuppetDB。它是一个 REST API，用于将 Puppet 主机在常规操作过程中处理的各种数据存储在 PostgreSQL
    数据库中。这包括来自代理的清单请求（包括其重要的事实数据）、清单应用程序的报告和导出资源。
- en: '[Chapter 2](7cafeeab-0e5c-4848-9eb0-1bae38ed3525.xhtml), *Puppet Server and
    Agents*, detailed a manual installation of the master. Let''s add the PuppetDB
    with more style through Puppet! On the Forge, you will find a convenient module
    that will make this easy:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 2 章](7cafeeab-0e5c-4848-9eb0-1bae38ed3525.xhtml)，*Puppet 服务器和代理*，详细描述了手动安装主机的过程。现在通过
    Puppet 以更优雅的方式添加 PuppetDB！在 Forge 上，你将找到一个便捷的模块来轻松实现这一点：'
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'On the master node, the setup now becomes a one-line invocation:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在主节点上，设置现在变成了一个简单的命令行调用：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As our test master uses a nonstandard SSL certificate that is named `master.example.net`
    (instead of its FQDN), it must be configured for `puppetdb` as well:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的测试主机使用的是一个非标准的 SSL 证书，名为 `master.example.net`（而不是其完全限定域名 FQDN），因此也必须为 `puppetdb`
    进行配置：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The ensuing catalog run is quite impressive. Puppet installs the PostgreSQL
    backend, the Jetty server, and the actual PuppetDB package, and it configures
    everything and starts the services up all in one go. After applying this short
    manifest, you have added a complex piece of infrastructure to your Puppet setup.
    You can now use exported resources for a variety of helpful tasks.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 随后的清单运行相当令人印象深刻。Puppet 安装了 PostgreSQL 后端、Jetty 服务器和实际的 PuppetDB 包，并一次性完成了所有配置和启动服务。在应用了这个简短的清单之后，你已经将一个复杂的基础设施组件添加到你的
    Puppet 设置中。现在，你可以利用导出的资源来执行各种有用的任务。
- en: Exporting SSH host keys
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导出 SSH 主机密钥
- en: For homegrown interactions between clustered machines, SSH can be an invaluable
    tool. File transfer and the remote execution of arbitrary commands is easily possible
    thanks to the ubiquitous `sshd` service. For security reasons, each host generates
    a unique key in order to identify itself. Of course, such public key authentication
    systems can only really work with a trust network, or the presharing of public
    keys.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于集群机器之间的自定义交互，SSH 可以是一个宝贵的工具。通过无处不在的 `sshd` 服务，文件传输和远程执行任意命令变得轻松可行。出于安全原因，每个主机都会生成一个唯一的密钥来识别自己。当然，这种公钥认证系统只有在信任网络中，或者预先共享公钥的情况下才能真正工作。
- en: 'Puppet can do the latter quite nicely:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 可以很好地完成后者的工作：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Interested nodes collect keys with the known pattern:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 感兴趣的节点会收集带有已知模式的密钥：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, SSH servers can be authenticated through the respective keys that Puppet
    safely stores in its database. As always, the Puppet master is the fulcrum of
    security.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，SSH 服务器可以通过 Puppet 安全存储在其数据库中的相应密钥进行身份验证。像往常一样，Puppet 主机是安全的支点。
- en: As a matter of fact, some `ssh` modules from the Puppet Forge will use this
    kind of construct to do this work for you.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，一些来自 Puppet Forge 的 `ssh` 模块会使用这种结构来为你完成这项工作。
- en: Managing hosts files locally
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地管理主机文件
- en: Many sites can rely on a local DNS infrastructure. Resolving names to local
    IP addresses is easy with such setups. However, small networks, or sites that
    consist of many independent clusters with little shared infrastructure, will have
    to rely on names in `/etc/hosts` instead.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 许多站点可以依赖本地的 DNS 基础设施。通过这种设置，解析名称为本地 IP 地址是很容易的。然而，小型网络，或者由许多独立集群组成且基础设施共享较少的站点，必须依赖
    `/etc/hosts` 中的名称。
- en: You can maintain a central hosts file per network cell, or you can make
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为每个网络单元维护一个中心化的主机文件，或者你可以
- en: 'Puppet maintain each entry in each hosts file separately. The latter approach
    has some advantages:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 会分别维护每个主机文件中的每一项条目。后一种方法有一些优势：
- en: Changes are automatically distributed through the Puppet agent network
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改会通过 Puppet 代理网络自动分发
- en: Puppet copes with unmanaged lines in the hosts files
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet 处理主机文件中未管理的行
- en: A manually maintained registry is prone to becoming outdated every once in a
    while. It will also obliterate local additions in any hosts files on the agent
    machines.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'The manifest implementation of the superior approach with exported resources
    is very similar to the `sshkey` example from the previous section:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is the same principle, only now, each node exports its `$ipaddress` fact
    value alongside its name and not a public key. The import also works the same
    way:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Automating custom configuration items
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do you remember the Cacti module that you created during the previous chapter?
    It makes it very simple to configure all monitored devices in the manifest of
    the Cacti server. However, as this is possible, wouldn''t it be even better if
    each node in your network was registered automatically with Cacti? It''s simple:
    make the devices export their respective `cacti_device` resources for the server
    to collect:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The Cacti server, apart from including the `cacti` class, just needs to collect
    the devices now:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If one Cacti server handles all your machines, you can just omit the `tag`
    comparison:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Once the module supports other Cacti resources, you can handle them in the same
    way. Let's look at an example from another popular monitoring solution.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying the configuration of Nagios
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Puppet comes with support to manage the complete configuration of **Nagios**
    (and compatible versions of **Icinga**). Each configuration section can be represented
    by a distinct Puppet resource with types such as `nagios_host` or `nagios_service`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: There is an endeavour to remove this support from core Puppet. This does not
    mean that support will be discontinued, however. It will just move to yet another
    excellent Puppet module.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Each of your machines can export their individual `nagios_host` resources alongside
    their `host` and `cacti_device` resources. However, thanks to the diverse Nagios
    support, you can do even better.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that you have a module or class to wrap SSH handling (you are using
    a Forge module for the actual management, of course), you can handle monitoring
    from inside your own SSH server class. By adding the export to this class, you
    make sure that nodes that include the class (and only these nodes) will also get
    monitoring:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You probably know the drill by now, but let''s repeat the mantra once more:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: With this collection, the Nagios host configures itself with all services that
    the agent manifests create.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: For large Nagios configurations, you might want to consider reimplementing the
    Nagios types yourself, using simple defines that build the configuration from
    templates. The native types can be slower than the `file` resources in this case,
    because they have to parse the whole Nagios configuration on each run. The `file`
    resources can be much cheaper, as they rely on content-agnostic checksums.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining your central firewall
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Speaking of useful features that are not part of the core of Puppet, you can
    manage the rules of your `iptables` firewall, of course. You need the `puppetlabs-firewall`
    module to make the appropriate types available. Then, each machine can (among
    other useful things) export its own required port forwarding to the firewall machines:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `$public_ip_address` value is not a Facter fact, of course. Your node will
    have to be configured with the appropriate information. You can refer to [Chapter
    7](b38488ca-86a7-4ecf-9a69-16938576d852.xhtml), *New Features from Puppet 4 and
    5*, for a good way to do this.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'The title of a firewall rule resource conventionally begins with a three-digit
    index for ordering purposes. The firewall machines collect all these rules naturally:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see, the possibilities for modeling distributed systems through exported
    Puppet resources are manifold. The simple pattern that we've iterated for several
    resource types suffices for a wide range of use cases. Combined with defined resource
    types, it allows you to flexibly enable your manifests to work together in order
    to form complex cluster setups with relatively little effort. The larger your
    clusters, the more work Puppet lifts from you through exports and collections.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Removing obsolete exports
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a node manifest stops exporting any resource, that resource's record is
    removed from PuppetDB once the node's catalog is compiled. This usually happens
    when the agent checks in with the master.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: However, if you take an agent out of commission permanently, this will never
    happen. That's why you will need to remove those exports from the DB manually.
    Otherwise, other nodes will keep importing the old resources.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'To clean such records from PuppetDB, use the `puppet node deactivate` command
    on the master server:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Setting defaults for resource parameters
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both exported and virtual resources are declared once, and are then collected
    in different contexts. The syntax is very similar, as are the concepts.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, a central definition of a resource cannot be safely realized on all
    of your nodes, though; for example, consider the set of all your `user` resources.
    You will most likely wish to manage the user ID that is assigned to each account
    in order to make them consistent across your networks.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: This is often solved through LDAP or similar directories, but that is not possible
    for some sites.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Even if all accounts on almost all machines will be able to use their designated
    ID, there are likely to be some exceptions. On a few older machines, some IDs
    are probably being used for other purposes already, which cannot be changed easily.
    On such machines, creating users with these IDs will fail.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The accounts can be created if duplicate IDs are allowed, but that is not a
    solution to this problem duplicates are usually not desirable.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, Puppet has a convenient way to express such exceptions. To give
    the nonstandard UID, `2066`, to the user, `felix`, realize the resource with an
    attribute value specification:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You can pass any property, parameter, or metaparameter that applies to the
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: resource type in question. A value that you specify this way is final and cannot
    be overridden again.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: This language feature is more powerful than the preceding example lets on. This
    is because the override is not limited to virtual and exported resources. You
    can override any resource from anywhere in your manifest. This allows for some
    remarkable constructs and shortcuts.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Consider, for example, the Cacti module that you created during the previous
    chapter. It declares a `package` resource in order to make sure that the software
    is installed. To that end, it specifies `ensure => installed`. If any user of
    your module needs Puppet to keep their packages up to date, this is not adequate
    though. The clean solution for this case is to add some parameters to the module's
    classes which allow the user to choose the `ensure` property value for the package
    and other resources. However, this is not really practical. Complex modules can
    manage hundreds of properties, and exposing them all through parameters would
    form a horribly confusing interface.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'The override syntax can provide a simple and elegant workaround here. The manifest
    that achieves the desired result is very straightforward:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: For all its simplicity, this manifest will be hard to decipher for collaborators
    who are not familiar with the collector/override syntax. This is not the only
    problem with overrides. You cannot override the same attribute multiple times.
    This is actually a good thing, because any rules that resolve such conflicting
    overrides make it extremely difficult to predict the actual semantics of a manifest
    that contains multiple overrides of this kind.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Relying on this override syntax too much will make your manifests prone to conflicts.
    Combining the wrong classes will make the compiler stop creating the catalog.
    Even if you manage to avoid all conflicts, the manifests will become rather chaotic.
    It can be difficult to locate all active overrides for a given node. The resulting
    behavior of any class or define becomes hard to predict.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: All things considered, it's safest to use overrides very sparingly.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'The collectors are especially dangerous when used without a selector expression:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Not only will it realize all virtual resources of the given type. It will also
    force surprising attribute values on both virtual and regular resources of the
    same type.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Saving redundancy using resource defaults
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final language construct that this chapter introduces can save you quite
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'some typing, or rather, it saves you from copying and pasting. Writing a long,
    repetitive manifest is not what costs you lots of time, of course. However, a
    briefer manifest is often more readable, and hence, more maintainable. You achieve
    this by defining resource defaults; attribute values that are used for resources
    that don''t choose their own:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: By default, each grant should apply to all databases and comprise all privileges.
    This allows you to define each actual `mysql_grant` resource quite sparsely. Otherwise,
    you will have to specify the `privileges` property for all resources. The `options`
    attribute will be especially repetitive, because they are identical for all grants
    in this example.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Note that the ensure property is repetitive as well, but it was not included.
    It is considered good practice to exempt this attribute from resource defaults.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: The `mysql_grant` resource type is not available in core Puppet. It's part of
    the `puppetlabs-mysql` module on the Forge.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite the convenience that this approach offers, it should not be used at
    each apparent opportunity. It has some downsides that you should keep in mind:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: The defaults can be surprising if they apply to resources that are declared
    at a lexical distance from the defaults' definition (such as several screens further
    down the manifest file)
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The defaults transcend the inclusion of classes and instantiation of defines
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These two aspects form a dangerous combination. Defaults from a composite class
    can affect very distant parts of a manifest:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Files declared in the `webserver` class should belong to a default user. However,
    this default takes effect recursively in the included classes as well. The `owner`
    attribute is a property: a resource that defines no value, for it just ignores
    its current state. A value that is specified in the manifest will be enforced
    by the agent. Often, you do not care about the owner of a managed file:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'However, because of the default `owner` attribute, Puppet will now mandate
    that this file belongs to `www-data`. To avoid this, you will have to unset the
    default by overwriting it with `undef`, which is Puppet''s analog to the `nil`
    value:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This can also be done in individual resources:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: However, doing this constantly is hardly feasible. The latter option is especially
    unattractive, because it leads to more complexity in the manifest code, instead
    of simplifying it. After all, not defining a default `owner` attribute will be
    the cleaner way here.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: The semantics that make defaults take effect in so many manifest areas is known
    as **dynamic scoping**. It used to apply to variable values as well and is generally
    considered harmful. One of the most decisive changes in Puppet 3.0 was the removal
    of dynamic variable scoping, in fact. Resource defaults still use it, but it is
    expected that this will change in a future release as well.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Resource defaults should be used with consideration and care. For some properties,
    such as `file mode`, `owner`, and `group`, they should usually be avoided.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding antipatterns
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Speaking of things to avoid, there is a language feature that we will only
    address in order to advise great caution. Puppet comes with a function called
    `defined`, which allows you to query the compiler about resources that have been
    declared in the manifest:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The problem with the concept is that it cannot ever be reliable. Even if the
    resource appears in the manifest, the compiler might encounter it later than the
    `if` condition. This is potentially very problematic, because some modules will
    try to make themselves portable through this construct:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The module author supposes that this resource definition will be skipped if
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: the manifest declares `Package['apache2']` somewhere else. As explained, this
    method will only be effective if the block is evaluated late enough during the
    compiler run. The conflict can still occur if the compiler encounters the other
    declaration after this one.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'The manifest''s behavior becomes outright unpredictable if a manifest contains
    multiple occurrences of the same query:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The first block that is seen wins. This can even shift if unrelated parts of
    the manifest are restructured. You cannot predict whether a given manifest will
    use `ensure=>latest` for the `apache2` package or just use `installed`. The results
    become even more bizarre if such a block wants a resource removed through `ensure=>absent`,
    while the other does not.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'The `defined` function has long been considered harmful, but there is no adequate
    alternative yet. The `ensure_resource` function from the `stdlib` module tries
    to make the scenario less problematic:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: By relying on this function instead of the preceding antipattern based around
    the `defined` function, you will avoid the unpredictable behavior of conflicting
    declarations. Instead, this will cause the compiler to fail when the declarations
    are passed to `ensure_resource`. This is still not a clean practice, though. Failed
    compilation is not a desirable alternative either.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Both functions should be avoided in favor of clean module structures with non-ambiguous
    resource declarations. More details on how to ensure reusable, composable, and
    stackable classes will be provided in [Chapter 9](0a0cf4b0-23fa-48fd-abf9-77ed851bb581.xhtml),
    *Puppet Roles and Profiles.*
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A template is a frequent occurrence and is one of the best ways for Puppet to
    manage dynamic file content. Evaluating each template requires extra effort from
    the compiler, but the gain in flexibility is usually worth it. Variables in templates
    have to be declared using the Puppet variable syntax with full namespace, or by
    prodding a hash with variable inside templates and classes.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: The concept of virtual resources is much less ubiquitous. Virtual resources
    allow you to flexibly add certain entities to a node's catalog. The collector
    syntax that is used for this can also be used to override attribute values, which
    works for non-virtual resources as well.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Once PuppetDB is installed and configured, you can also export resources so
    that other node manifests can receive their configuration information. This allows
    you to model distributed systems quite elegantly.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: The resource defaults are just a syntactic shortcut that help keep your manifest
    concise. They have to be used with care, though. Some language features, such
    as the `defined` function (and its module-based successor, which is the `ensure_resource`
    function), should be avoided if possible.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: "[Chapter 7\uFEFF](b38488ca-86a7-4ecf-9a69-16938576d852.xhtml), *New Features\
    \ from Puppet 4 and 5*, gives you an overview and introduction to the roles and\
    \ profiles pattern, which is best practice for combining upstream modules with\
    \ platform implementations."
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
