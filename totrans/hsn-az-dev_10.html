<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Reactive Architecture with Event Grid</h1>
                </header>
            
            <article>
                
<p>Azure Event Grid is another cloud component that represents serverless services in Azure. It can be considered an events gateway, able to both make our solution work faster and to reverse control, so our services don't have to wait for others, burning available resources just to be idle. It's also a great routing tool, able to quickly distribute load and multiply it, allowing jobs to be finished faster.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Azure Event Grid and reactive architecture</li>
<li>Connecting to other services through Azure Event Grid</li>
<li>Security features of Azure Event Grid</li>
<li>Publishing custom events to Azure Event Grid</li>
<li>Integrating Azure Functions with Azure Event Grid</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To perform exercises from this chapter you will need:</p>
<ul>
<li>An Azure subscription</li>
<li><span>An IDE compatible with Visual Studio 2017</span></li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Azure Event Grid and reactive architecture</h1>
                </header>
            
            <article>
                
<p>When working with multiple services in the cloud, you often need to have a centralized service responsible for routing events to a different endpoint. This makes the exchange of data a piece of cake—you do not have to maintain different URLs of APIs, as you can leverage a common event schema and custom routing configuration based on, for example, event type. In Azure, such a service is called Azure Event Grid—a serverless event gateway, which is one of the newer cloud components available. With a pay-as-you-go pricing model, you can quickly build a reactive architecture that inverts communication between your services and makes them passive. In this chapter, you will learn how to work with Event Grid<em> </em>and integrate it with other Azure components.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Reactive architecture</h1>
                </header>
            
            <article>
                
<p>To get started, let's consider the architecture shown in the <span>following </span>diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/198227b6-5af2-44f8-babc-b9fc8118346e.png" style="width:21.42em;height:18.92em;" width="352" height="311"/></p>
<p class="mce-root">In this diagram, you can see an example flow of uploading, for instance, an image for an avatar from a user. A file is transferred through an <strong>Azure App Service</strong> and put into <strong>Azure Blob Storage</strong>. Then, it is processed by <strong>Azure Functions</strong>. While such a setup is perfectly fine, consider the following disadvantage—to be able to process the image, <strong>Azure Functions</strong> has to be notified about the fact that a new file was uploaded.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">Since<strong> Azure Blob Storage</strong> is unable to do so (at least with the functionality available publicly), the only way to achieve that is to pool a storage and somehow maintain processed files. While conceptually, this is not rocket science, you have to bear in mind that, in the cloud, <span>when you use a resource, </span>you pay for the time taken. So basically, in the preceding scenario, you would be paying even if no file was uploaded to the storage, since a trigger in <strong>Azure Functions</strong> (here, a Blob trigger) will have to maintain a state of files available and check at intervals whether something new appeared, so you will often pay for nothing. Now, consider the following change:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/1d08e54c-a233-44d3-9b47-f7c584026339.png" style="width:29.33em;height:21.17em;" width="423" height="305"/></p>
<p>As you can see, I put an <strong>Azure Event Grid</strong><em> </em>between <strong>Azure Blob Storage<em> </em></strong>and <strong>Azure Functions</strong>. What has it changed? Well, functions processing a Blob do not have to pool storage to get info about uploaded files. This is possible thanks to version 2 of Azure Storage (you can find a link to a description in <em>Further reading</em><strong> </strong>section)—it can publish events to <strong>Azure Event Grid</strong> so they can <span>then</span><span> </span><span>be forwarded to all subscribers of that particular event type. Thanks to this, </span><strong>Azure Functions</strong><em> </em><span>can remain passive—they will be called by </span><strong>Azure Event Grid</strong><em> </em>when needed, <span>so if nothing is uploaded, you will pay nothing. This is, of course, an element of serverless</span><em> </em><span>architecture—being able to pay for usage makes such a setup possible.</span></p>
<div class="packt_infobox">Remember that you will not be charged if you <span>only</span><span> </span><span>use the Consumption plan in Azure Functions. If you have to use an App Service Plan</span><em> </em><span>for your functions, you will not be able to save money with the preceding architecture—on the other hand, you will save some compute power, which could be used for other workloads, so reactive architecture</span> concept<span>s will still be valid.</span></div>
<p>This is what we call <strong>reactive architecture</strong>—a model where your components can remain idle and wait for upcoming requests. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Topics and event subscriptions</h1>
                </header>
            
            <article>
                
<p>There are five main topics when it comes to working with Azure Event Grid:</p>
<ul>
<li>Events</li>
<li>Event handlers</li>
<li>Event sources</li>
<li>Topics</li>
<li>Event subscriptions</li>
</ul>
<p>In this section, we will go through each of them to build a better understanding of this service.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Event sources</h1>
                </header>
            
            <article>
                
<p>Currently, Azure Event Grid<em> </em>supports the following event sources:</p>
<ul>
<li>Azure Blob Storage</li>
<li>Azure Media Services</li>
<li>Azure Subscriptions</li>
<li>Resource Groups</li>
<li>Azure Event Hubs</li>
<li>Azure IoT Hub</li>
<li>Azure Service Bus</li>
<li>Custom topics</li>
<li>Container Registry</li>
<li>Storage <strong>General-purpose v2</strong> (<strong>GPv2</strong>)</li>
</ul>
<p>As you can see, there are plenty of different services integrated and available when working with Event Grid. While we know which event sources we can use, we still have not defined what an event source<strong> </strong>actually is. Take a look at the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/f0ef7d40-e691-4fc4-afc1-45e10a8a09a9.png" style="width:26.92em;height:7.75em;" width="418" height="120"/></p>
<p>In this scenario, a file uploaded to <strong>Azure Blob Storage</strong><em> </em>triggers an event, which is then fetched by <strong>Azure Event Grid</strong><em> </em>and passed further to the consumer. The event source<strong> </strong>is the origin of an event that was then handled by Event Grid. When working with this service, all event sources have a way to publish an event and communicate with <strong>Azure Event Grid</strong>. There is also one extra event source possible—it is Custom topics. It is possible to publish your own custom events directly to an Event Grid<em> </em>endpoint—we will cover that later in this chapter.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Event handlers</h1>
                </header>
            
            <article>
                
<p>In the previous example, we covered event sources. Let's take a similar scenario:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/a0826e92-15b9-4cce-be5b-2ed15a92845a.png" style="width:28.08em;height:20.08em;" width="422" height="302"/></p>
<p>Once more, we have <strong>Azure Blob Storage</strong><em> </em>as a publisher, but this time, events are forwarded to both <strong>Azure Functions</strong><em> </em>and <strong>Azure Event Hub</strong>. In that architecture, services presented on the right are event handlers. Here is a list of currently supported services:</p>
<ul>
<li>Azure Functions</li>
<li>Azure Logic Apps</li>
<li>Azure Automation</li>
<li>WebHooks</li>
<li>Azure Queue Storage</li>
<li>Hybrid Connections</li>
<li>Azure Event Hubs</li>
<li>Microsoft Flow</li>
</ul>
<p>So what actually is an event handler? You can think about it as a processor of an event—based on the configuration, Azure Event Grid<em> </em>will forward events to handlers, where they will be deserialized and analyzed.</p>
<div class="packt_infobox">In general, Azure Event Grid<em> </em>uses a common event schema when delivering events to handlers. What is more, it can deliver more than just one event at the time—you have to be prepared for a possible batch of events. </div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Topics and subscriptions</h1>
                </header>
            
            <article>
                
<p>A topic is a general messaging concept that allows for one-to-many communication. It works with subscriptions in the following way—you publish a message to a topic in a messaging service, and then subscribe to it with your consumers. In Azure Event Grid,<em> </em>you are responsible for creating a topic—that means that you have to publish a custom application that handles communication between publishers and the Event Grid<em> </em>endpoint. You can have a single application, or many of them—this depends on your design and expected throughput. Additionally, you have to configure subscriptions—in the next section, you will see how to do that, and how to set up proper filtering. The general structure could look like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/10a33702-ca0a-4e89-8bc3-db2bb540c0b1.png" style="width:26.25em;height:23.75em;" width="400" height="362"/></p>
<p>The left side of the preceding diagram represents publishers and a topic (the line between a publisher and <strong>Azure Event Grid</strong>) and subscriptions with handlers. Each line is a different topic and subscription. The whole configuration and routing resides within Event Grid and can be managed there.</p>
<div class="packt_infobox">Azure Event Grid<em> </em>takes care of retrying undelivered messages. This can be configured with a custom policy that defines the rules for retrying. Additionally, when a custom topic is used, events have to be published in batches to make it work.</div>
<p>To sum up, we can define both a topic and a subscription as follows:</p>
<ul>
<li><strong>Topic</strong>: A channel between a service and Azure Event Grid, which allows the former to push an event to the Azure service</li>
<li><strong>Subscription</strong>: A channel between Azure Event Grid and a service, which is used to retrieve events in the former</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Connecting services through Azure Event Grid</h1>
                </header>
            
            <article>
                
<p>Now that you know something about what Azure Event Grid<em> </em>is and how it works, we will try to test it and create a working solution. We will start by creating an instance in Azure Portal and configuring it to accept and route events. You will see also what the schema of an event is and how to leverage it so you can send custom events that will be handled by Event Grid.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating Azure Event Grid in Azure Portal</h1>
                </header>
            
            <article>
                
<p>To get started with Azure Event Grid, do the following<em> </em>in Azure Portal:</p>
<ol>
<li>Click on + <span class="packt_screen">Create a resource</span><strong> </strong>and search for <kbd>Event Grid</kbd>. From the list, select <span class="packt_screen">Event Grid Topic</span><strong> </strong>and click <span class="packt_screen">Create</span>.</li>
<li class="CDPAlignLeft CDPAlign">You will see a really simple form, where you have to enter the name of an instance of a service:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/d4c8bc6b-8043-462f-9e2b-8b4fe92d5775.png" style="width:29.33em;height:26.25em;" width="426" height="381"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="3">
<li>When you click <span class="packt_screen">Create </span>and wait a moment, an instance of a service will be created. Once it is finished, you can go to your resource to see an empty instance:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/2b1bb9eb-5975-40d3-97d5-2354005ed02e.png" width="973" height="739"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>As you can see, there is no subscription created yet. What is more, there is also no topic, which is what would send events to our instance. Before we proceed, let's take a look what we have on the <span class="packt_screen">Overview</span><strong> </strong>blade. Besides the option to create a subscription, there is also one other important thing—<span class="packt_screen">Topic Endpoint</span>. You will use this to publish events from your custom topics. There is also one important blade—<span class="packt_screen">Access keys</span>. When you click on it, you will see two keys that can be used to authorize access to Azure Event Grid:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/4bc31311-144d-4a98-b89c-6e592ae736c7.png" width="1030" height="189"/></p>
<p>Now let's try to create a topic with a subscription. To do so, we will use the following code snippet:</p>
<pre>$myEndpoint = "&lt;my-endpoint&gt;"<br/><br/>Set-AzureRmContext -Subscription "&lt;subcription-name&gt;"<br/><br/>New-AzureRmEventGridSubscription `<br/>  -Endpoint $myEndpoint `<br/>  -EventSubscriptionName "&lt;event-subscription-name&gt;"<br/>  -ResourceGroupName "&lt;rg-name&gt;"</pre>
<p>This PowerShell code should create a Resource Group topic that will push events to an endpoint defined in the <kbd>$myEndpoint</kbd><strong> </strong>variable. However, if you execute the code, the following error will occur:</p>
<pre>New-AzureRmEventGridSubscription : Long running operation failed with status 'Failed'. Additional Info:'The attempt to validate the provided endpoint &lt;your-endpoint&gt;. For more details, visit https://aka.ms/esvalidation.'</pre>
<p>What has happened? Well, it turns out that we cannot create a subscription, because our endpoint is not validated. How can we validate our endpoint so it will be possible to create a subscription? I will explain shortly.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Azure Event Grid security</h1>
                </header>
            
            <article>
                
<p>Besides access tokens, Azure Event Grid<em> </em><span>also</span><span> </span><span>checks whether or not an endpoint is valid and secure. This validation will not happen for the following handler types:</span></p>
<ul>
<li>Azure Logic Apps</li>
<li>Azure Automation</li>
<li>Azure Functions when <kbd>EventGridTrigger</kbd> is used</li>
</ul>
<p>The rest of the endpoints (and especially those triggered by an HTTP request) have to be validated to be used. Here is how that kind of validation is processed:</p>
<ol>
<li>Firstly, <kbd><span>SubscriptionValidationEvent</span></kbd><strong><span> </span></strong>is sent to an endpoint containing multiple fields, such as topic, validation code, and others. Additionally, a special <kbd><span>aeg-event-type: SubscriptionValidation</span></kbd><span> header is sent.</span></li>
<li>Secondly, Event Grid<em> </em>expects a success response containing a validation code that was sent in the request.</li>
</ol>
<p>Here is an example of a validation event:</p>
<pre>[{<br/>  "id": "3d178aaf-364c-67b-bq0c-e34519da4eww",<br/>  "topic": "/subscriptions/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",<br/>  "subject": "",<br/>  "data": {<br/>    "validationCode": "512d38b6-c7b8-40c8-89fe-f46f9e9622b6",<br/>    "validationUrl": "&lt;validation-url&gt;"<br/>  },<br/>  "eventType": "Microsoft.EventGrid.SubscriptionValidationEvent",<br/>  "eventTime": "2018-08-10T10:20:19.4556811Z",<br/>  "metadataVersion": "1",<br/>  "dataVersion": "1"<br/>}]</pre>
<p>In this scenario, to validate an endpoint, you would have to return the following response:</p>
<pre>{<br/>  "validationResponse": "512d38b6-c7b8-40c8-89fe-f46f9e9622b6"<br/>}</pre>
<p>After that, you should be able to create a subscription.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<div class="packt_tip">As you may have noticed, the validation event <span>also </span><span>contains the </span><kbd>validationUrl</kbd><strong> </strong><span>property. It allows you to manually validate a subscription, instead of redeploying code with a proper application logic.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a subscription</h1>
                </header>
            
            <article>
                
<p>Now that you are familiar with endpoint validation topic, we can try to create a subscription once more:</p>
<ol>
<li>To do so, I created a function that is triggered by an HTTP request. I wrote it quickly in CSX, so I did not have to compile and deploy it manually:</li>
</ol>
<pre style="padding-left: 90px">#r "Newtonsoft.Json"<br/><br/>using System.Net;<br/>using Newtonsoft.Json;<br/><br/>public static async Task&lt;HttpResponseMessage&gt; Run(HttpRequestMessage req, TraceWriter log)<br/>{<br/> var @event = JsonConvert.DeserializeObject(await req.Content.ReadAsStringAsync());<br/> log.Info(@event.ToString());<br/><br/> return req.CreateResponse(HttpStatusCode.OK);<br/>}</pre>
<p style="padding-left: 60px">Thanks to the preceding code, I can see that a validation event was sent to an endpoint. Now, depending on the version of toolset you have, you will have the <kbd>validationUrl</kbd> value in the payload.</p>
<ol start="2">
<li>To leverage this feature, you will have to install the Event Grid extension for Azure CLI 2.0—a link for download can be found in the <em>Further reading</em><strong> </strong>section. To progress without this feature, we will have to change the code of our function a little bit:</li>
</ol>
<pre style="padding-left: 90px">#r "Newtonsoft.Json"<br/><br/>using System.Net;<br/>using Newtonsoft.Json;<br/><br/>public static async Task&lt;HttpResponseMessage&gt; Run(HttpRequestMessage req, TraceWriter log)<br/>{<br/> var @event = JsonConvert.DeserializeObject&lt;ValidationEvent[]&gt;(await req.Content.ReadAsStringAsync())[0];<br/><br/> return req.CreateResponse(HttpStatusCode.OK, new {validationResponse = @event.Data.ValidationCode} );<br/>}<br/><br/>public class ValidationEvent {<br/> public ValidationEventData Data {get;set;}<br/>}<br/><br/>public class ValidationEventData {<br/> public string ValidationCode {get;set;}<br/>}</pre>
<ol start="3">
<li>Note that I am deserializing the validation event as <kbd>ValidationEvent[]</kbd>, so it is actually an array of events. It is important to bear this in mind to avoid possible issues.</li>
</ol>
<div class="packt_tip">If events were sent to an endpoint that wasn't validated, the batch will be divided into two parts, one with a single validation event, and the second one with the actual events.</div>
<ol start="4">
<li>Now, if you execute PowerShell code that failed earlier, you should be able to create a subscription. To check whether it all works correctly, you can run the following command:</li>
</ol>
<pre style="padding-left: 90px"><strong>Get-AzureRmEventGridSubscription</strong></pre>
<ol start="5">
<li>Here, you can see the result in my case:</li>
</ol>
<pre style="padding-left: 90px">PS C:\Users\kamz&gt; Get-AzureRmEventGridSubscription<br/><br/> Name Topic ProvisioningState SubjectBeginsWith SubjectEndsWith Endpoint<br/> ---- ----- ----------------- ----------------- --------------- --------<br/>rg-subscription /subscriptions/&lt;id&gt; Succeeded https://handsonazure-function.azurewebsites.net/api/HttpTriggerCSharp1</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<div class="packt_tip">Note that subscriptions created with the API are not visible in the Portal. This should be changed soon, but as long as this issue persists, stick mainly to the <strong>command-line interface</strong> (<strong>CLI</strong>) for maintaining Azure Event Grid.</div>
<ol start="6">
<li>Now if, for example, <span>you</span> create a resource in the resource group that publishes events to Event Grid, an event similar to the following will occur:</li>
</ol>
<pre style="padding-left: 90px"> {<br/>    "subject": "/subscriptions/.../Microsoft.Storage/storageAccounts/handsonazure",<br/>    "eventType": "Microsoft.Resources.ResourceWriteSuccess",<br/>    "eventTime": "2018-08-10T08:51:32.3888833Z",<br/>    "id": "37f85f91-1af9-4ee3-84a6-ee1955c74edc",<br/>    "data": {<br/>      "authorization": {<br/>        "scope": "/subscriptions/.../handsonazure-rg/providers/Microsoft.Storage/storageAccounts/handsonazure",<br/>        "action": "Microsoft.Storage/storageAccounts/write",<br/>        "evidence": {<br/>          "role": "Subscription Admin"<br/>        }<br/>      },<br/>      "claims": {<br/>        "aud": "https://management.core.windows.net/",<br/>        (...)<br/>    } <br/>  }<br/>}</pre>
<ol start="7">
<li>It is also possible to create a connection like this without the CLI—if you go to your resource group, you will see the <span class="packt_screen">Events</span><strong> </strong>blade:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="Images/472bce37-777f-447a-bf83-9e5ef01f0d37.png" width="879" height="415"/></div>
<ol start="8">
<li>When you click on the <span class="packt_screen">+ Event subscription</span><strong> </strong>button, you will see a form that makes the whole process much easier. You can use this form if you prefer configuring services in the Portal, instead of the CLI:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/8d2f27cd-aeea-4492-98db-df2e14edafd3.png" style="width:40.25em;height:46.25em;" width="721" height="829"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Publishing custom events to Azure Event Grid</h1>
                </header>
            
            <article>
                
<p>So far, we have talked about integrating Azure Event Grid<em> </em>with already built-in publishers and topics, using Resource Group as an example. I mentioned at the beginning of this chapter that this service is capable of handling custom topics, making it a really flexible solution that can act as an event gateway. In this section, we will cover this topic and try to use Event Grid<em> </em>as our router for handling and maintaining the routing of our events.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Event gateway concept</h1>
                </header>
            
            <article>
                
<p>Let's look at the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/98da7232-06aa-48bf-aaa6-8dd549b96873.png" style="width:27.08em;height:26.58em;" width="410" height="402"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Here, you have a single events producer and four different handlers. Now, if you imagine that <strong>Publisher </strong>publishes only custom events, you can see that Event Grid<em> </em>is able to distribute them among <kbd>N</kbd> different handlers (which do not have to be the same type—it can be a mix of any supported handlers available). Of course, this concept can <span>also</span><span> </span><span>be used with publishers such as Resource Group, Azure Blob Storage, or Azure Event Hub—personally, I think that it is slightly more useful for custom scenarios. Let's take an example—you are publishing an <kbd>OrderCreated</kbd></span><kbd><strong> </strong></kbd><span>event. With Azure Event Grid,</span><em> </em><span>you could now distribute it to different handlers:</span></p>
<ul>
<li><kbd>OrderConfirmation</kbd>: For example, for sending a confirmation via a mail message</li>
<li><kbd>OrderProcessor</kbd>: For handling the actual logic of processing an order</li>
<li><kbd>OrderNotification</kbd>: For notifying someone that there is an order that has to be validated</li>
</ul>
<p>Of course, the preceding steps rely only on your logic—it should, however, give you a hint of what can be done with routing and distributing events using Azure Event Grid.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Handling a custom event</h1>
                </header>
            
            <article>
                
<p>Before we send a custom event, we have to take a look at the Event Grid<em> </em>event schema:</p>
<pre>[<br/>  {<br/>    "topic": string,<br/>    "subject": string,<br/>    "id": string,<br/>    "eventType": string,<br/>    "eventTime": string,<br/>    "data":{<br/>      object-unique-to-each-publisher<br/>    },<br/>    "dataVersion": string,<br/>    "metadataVersion": string<br/>  }<br/>]</pre>
<p>As you can see, it is a simple JSON array, containing many different events. Let's describe each field here:</p>
<ul>
<li><kbd>topic</kbd>: This defines a full path to an event source (for example, Azure Blob Storage).</li>
<li><kbd>subject</kbd>:<strong> </strong>This defines a path to an event subject (so, <span>in the case of publishing events from a resource group, this could be</span> a full path to an Azure resource, or, in the case of Azure Blob Storage, this would be a Blob path).</li>
<li><kbd>id</kbd>: This is the unique identifier of an event.</li>
<li><kbd>eventType</kbd>: A type of a published event (such as <kbd>Microsoft.Resources.ResourceWriteSuccess</kbd>).</li>
<li><kbd>eventTime</kbd>: This defines when an event was published using the publisher's UTC time.</li>
<li><kbd>data</kbd>: The payload of an event.</li>
<li><kbd>dataVersion</kbd>: An event schema version defined by the publisher.</li>
<li><kbd>metadataVersion</kbd>: A revision number of event metadata schema version, provided by Event Grid.</li>
</ul>
<p>Now, if you want to publish an event, you will have to do the following:</p>
<ul>
<li>Always use an array of events, even if you are publishing a single one</li>
<li>Either use an empty topic or use the following syntax, which reflects the fact, that each topic is also an Azure resource <kbd>/subscriptions/&lt;subscription-id&gt;/resourceGroups/&lt;resource-group&gt;/providers/Microsoft.EventGrid/topics/&lt;eventgrid-name&gt;</kbd></li>
<li>Use <kbd>aeg-sas-key</kbd><strong> </strong>or <kbd>aeg-sas-token</kbd><strong> </strong>to authorize a request by providing a key from the <span class="packt_screen">Access keys</span><strong> </strong>blade</li>
</ul>
<p>Here, you can find an example request:</p>
<pre>POST /api/events HTTP/1.1<br/>Host: handsonazure-eventgrid.westeurope-1.eventgrid.azure.net<br/>Content-Type: application/json<br/>aeg-sas-key: &lt;sas-key&gt;<br/>Cache-Control: no-cache<br/><br/>[<br/>  {<br/>    "subject": "example",<br/>    "id": "1",<br/>    "eventType": "SectionFinished",<br/>    "eventTime": "2018-08-12T07:41:00.9584103Z",<br/>    "data":{<br/>      "section": 3<br/>    },<br/>    "dataVersion": "1"<br/>  }<br/>]</pre>
<p>If everything is correct, you should see an <kbd>HTTP 200</kbd> response. Now, you may wonder how you can receive such a request. If you go to your instance of Azure Event Grid<em> </em>and click on the <span class="packt_screen">+</span> <span class="packt_screen">Event Subscription<strong> </strong></span>button, you will see a form where you can create a new subscription:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/22049e7c-6258-4cdc-9c69-54051b9eca68.png" style="width:40.75em;height:48.58em;" width="725" height="863"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>You saw this form before, when we were discussing creating a subscription directly from a resource group. There are, however, some important things to mention:</p>
<ul>
<li><span class="packt_screen">Subscribe to all event types</span><strong>:</strong> You have an option to either route all events types to an endpoint, or just to the ones defined by you (you will be able to enter any event type you wish once you uncheck the checkbox). This is very useful for the proper events routing.</li>
<li><span class="packt_screen">Endpoint Type</span>: You have a choice of different endpoints, including WebHook, Azure Event Hub,<em> </em>and Hybrid Connections.</li>
<li><span class="packt_screen">Event Schema</span>: You can choose to use either Event Grid<em> </em>schema or a more common Cloud Events schema, the latter of which is an open standard specification and can be used to introduce a custom schema for all the components in your system.</li>
<li><span class="packt_screen">FILTERS</span>: You can additionally filter events of a specific type by filtering them with the subject field value.</li>
</ul>
<p>When you fill all values, click on <span class="packt_screen">Create</span><strong> </strong>to actually create it.</p>
<div class="packt_infobox">Remember that an endpoint has to be validated to successfully create a subscription!</div>
<p>Now, if you send an example request, you should be able to receive it in your handler (in my case, Azure Functions):</p>
<pre>2018-08-12T08:17:25.263 [Info] Function started (Id=8216a64d-19c5-436f-8cce-69fc49a3cff2)<br/>2018-08-12T08:17:25.404 [Info] [<br/>  {<br/>    "subject": "example",<br/>    "id": "1",<br/>    "eventType": "SectionFinished",<br/>    "eventTime": "2018-08-12T07:41:00.9584103Z",<br/>    "data": {<br/>      "section": 3<br/>    },<br/>    "dataVersion": "1",<br/>    "metadataVersion": "1",<br/>    "topic": "/subscriptions/.../resourceGroups/handsonazure-rg/providers/Microsoft.EventGrid/topics/handsonazure-eventgrid"<br/>  }<br/>]<br/>2018-08-12T08:17:25.404 [Info] Function completed (Success, Id=8216a64d-19c5-436f-8cce-69fc49a3cff2, Duration=138ms)</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>You may wonder what will happen if your event handler doesn't return a success response to Azure Event Grid. In that scenario, a retry will be performed.</p>
<div class="packt_tip packt_infobox">Azure Event Grid<em> </em>considers only <kbd>HTTP 200</kbd> and <kbd>HTTP 202</kbd> responses as successful.</div>
<p class="mce-root">By default, Event Grid<em> </em>uses <span>an exponential backoff retry policy. This means that each consecutive retry will be performed with an increased delay between that one, and the next retry. You can customize this behaviour by providing a custom retry policy. A link to that feature</span><span> can be found in the <em>Further reading</em><strong> </strong>section.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Integrating Azure Functions with Azure Event Grid</h1>
                </header>
            
            <article>
                
<p>The last thing that we'll cover for Azure Event Grid<em> </em>is integration with Azure Functions. As mentioned earlier, if you use Event Grid<em> </em>to publish events to Azure Functions triggered by an HTTP trigger, you will have to validate an endpoint. This is not the best solution, but fortunately, it is possible to use <kbd>EventGridTrigger</kbd>, which allows us to skip the endpoint validation step when configuring services. This topic itself is quite big, so we will not cover each and every problem possible; however, I will point you to the specific parts of the documentation, which will help you understand the topic even better.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">EventGridTrigger in Azure Functions</h1>
                </header>
            
            <article>
                
<p>In general, the easiest way to integrate Azure Functions<em> </em>with Azure Event Grid<em> </em>is to use <kbd>HttpTrigger</kbd>:</p>
<pre>[FunctionName("HttpTriggerCSharp")]<br/>public static async Task&lt;HttpResponseMessage&gt; Run(<br/>    [HttpTrigger(AuthorizationLevel.Function, "get", "post", Route = null)]HttpRequestMessage req, <br/>    TraceWriter log)<br/>{<br/>    (...)<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>This is the most generic setup. It provides direct access to a request message and enables you to control its specific parts. There is, however, an alternative to the preceding setup—we can instead use <kbd>EventGridTrigger</kbd>:</p>
<pre>[FunctionName("EventGridTriggerCSharp")]<br/>public static void Run([EventGridTrigger]JObject eventGridEvent, TraceWriter log)<br/>{<br/>  log.Info(eventGridEvent.ToString(Formatting.Indented));<br/>}</pre>
<p>With <kbd>EventGridTrigger</kbd> here, you can directly access the payload of a request, which is pretty useful if you are not interested in the remaining part of it. Additionally, you do not have to validate an endpoint. The preceding function can be used a bit differently if you use version 2 of the Azure Functions<em> </em>runtime:</p>
<pre>[FunctionName("EventGridTest")]<br/>public static void EventGridTest([EventGridTrigger]EventGridEvent eventGridEvent, TraceWriter log)<br/>{<br/>  log.Info(eventGridEvent.Data.ToString());<br/>}</pre>
<p>As you can see, instead of binding to <kbd>JObject</kbd><strong> </strong>here, you can access a well defined <kbd>EventGridEvent</kbd>.</p>
<div class="packt_tip">It is possible to use <kbd>EventGridEvent</kbd><strong> </strong>even with version 1 of the Azure Functions<em> </em>runtime. To do so, you have to manually reference <kbd>Microsoft.Azure.EventGrid.Models.EventGridEvent</kbd> by installing the <kbd>Microsoft.Azure.EventGrid</kbd> NuGet package. </div>
<p>You can easily create a function triggered by Event Grid<em> </em>using Azure Portal, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/e3636ccf-9ead-4ccd-bedd-db65711b6fc3.png" style="width:43.08em;height:28.33em;" width="705" height="464"/></div>
<p>After creating the function, you will see a code snippet from where you can start working on the function. The important thing is to add the Event Grid subscription, which you will have to use to integrate the function with Azure Event Grid:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/a13c9291-e875-4438-adca-f2d4f2ffdbfb.png" style="width:50.58em;height:20.17em;" width="880" height="351"/></p>
<p class="mce-root"/>
<div class="packt_tip packt_infobox">The generated code depends on the runtime version of your Function App—in my example, I used version 1, so I <span>used </span><kbd>JObject</kbd> instead of <kbd>EventGridEvent</kbd>.</div>
<p>When you click on it, you will see a form that you can fill to create a subscription. In fact, it is very similar to the form you saw previously when creating a subscription from within the Event Grid<em> </em>instance:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/4d4af097-bb14-4c90-b2ee-efcbef7b9292.png" style="width:38.17em;height:43.08em;" width="577" height="651"/></div>
<p>The only difference is that some fields are filled automatically. After creation of a subscription, you can test it by sending, for example, a custom event to Event Grid. What is more, a newly created subscription should be visible on the <span class="packt_screen">Overview</span><strong> </strong>blade of your Azure Event Grid<em> </em>instance:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/f7c40c36-81da-40b2-9839-7a00387a67db.png" style="width:41.08em;height:49.58em;" width="629" height="758"/></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Testing Azure Event Grid and Azure Functions</h1>
                </header>
            
            <article>
                
<p>You are probably thinking about the options for testing Azure Event Grid<em> </em>and Azure Functions<em> </em>locally. In fact, currently, you have two ways of doing this:</p>
<ul>
<li>Capturing and resending events to your application</li>
<li>Using ngrok, available at <a href="https://ngrok.com/">https://ngrok.com/</a>, to forward requests to your local computer</li>
</ul>
<p>Which of these methods you choose will depend on your capabilities (for example, ngrok exposes your computer's port, so it can be a security concern), so you will have to figure out by yourself what the best option is. Both methods are described in the link mentioned in the <em>Further reading</em><strong> </strong>section. However, there is one interesting feature of Azure Functions, which can be used to test Event Grid locally. It can be found under the following endpoint:</p>
<pre>http://localhost:7071/admin/extensions/EventGridExtensionConfig?functionName={functionname} </pre>
<p>Here you can find an example request:</p>
<pre>POST /admin/extensions/EventGridExtensionConfig?functionName=Function1 HTTP/1.1<br/>Host: localhost:7071<br/>Content-Type: application/json<br/>aeg-event-type: Notification<br/>Cache-Control: no-cache<br/><br/>[<br/>  {<br/>    "subject": "example",<br/>    "id": "1",<br/>    "eventType": "SectionFinished",<br/>    "eventTime": "2018-08-12T07:41:00.9584103Z",<br/>    "data":{<br/>      "section": 3<br/>    },<br/>    "dataVersion": "1",<br/>  }<br/>]</pre>
<p>Note one important thing here—you have to set <kbd>aeg-event-type</kbd> to <kbd>Notification</kbd>. If you fail to do so, you will receive an <kbd>HTTP 400</kbd> response. With such a setup, you can emulate how your function will behave when deployed to Azure. </p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learned what reactive architecture <span>is </span>and how to use it with Azure Event Grid. You integrated different event producers with event handlers, and used custom topics to publish custom events. What is more, you now have the knowledge of how to integrate Azure Event Grid with Azure Functions<em> </em>and test it locally.</p>
<p>This chapter ends the second part of the book, which has been on serverless<em> </em>services and architectures. In the next part, we will cover different storage options and messaging and monitoring services, which will broaden your proficiency with Azure even more.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What are the supported event schemas in Azure Event Grid?</li>
<li>How can you authorize a request to an Event Grid<em> </em>endpoint when posting a custom event?</li>
<li>What has to be returned when validating an endpoint?</li>
<li>When <span>will an</span> endpoint not have to be validated?</li>
<li>What happens if an endpoint doesn't return a success response?</li>
<li>How can you filter events in Azure Event Grid?</li>
<li>How can you test Event Grid<em> </em>integration with Azure Functions?</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li>Azure Storage V2 accounts: <a href="https://docs.microsoft.com/en-us/azure/storage/common/storage-account-options#general-purpose-v2-accounts">https://docs.microsoft.com/en-us/azure/storage/common/storage-account-options#general-purpose-v2-accounts</a></li>
<li>Azure CLI: <a href="https://docs.microsoft.com/en-us/cli/azure/azure-cli-extensions-list?view=azure-cli-latest">https://docs.microsoft.com/en-us/cli/azure/azure-cli-extensions-list?view=azure-cli-latest</a></li>
<li>CloudEvents standard specification: <a href="https://cloudevents.io/">https://cloudevents.io/</a></li>
<li>Event delivery in Azure Event Grid: <a href="https://docs.microsoft.com/en-us/azure/event-grid/manage-event-delivery">https://docs.microsoft.com/en-us/azure/event-grid/manage-event-delivery</a></li>
<li>Azure Function Azure Event Grid binding: <a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-event-grid">https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-event-grid</a></li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>