<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;LXC Code Integration with Python"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. LXC Code Integration with Python</h1></div></div></div><p>This chapter will introduce you to the Python bindings provided by both the LXC and libvirt APIs. We'll explore which container functionalities are possible and which are not, using the upstream <code class="literal">lxc-dev</code> and <code class="literal">python-libvirt</code> packages on Ubuntu and the <code class="literal">lxc-devel</code> and <code class="literal">libvirt-python</code> packages on CentOS.</p><p>To gain the most out of this chapter, some knowledge of Python is required. If you are a developer, this chapter is probably the most important one for you.</p><p>In this chapter, we'll cover the following topics in this order:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Building and managing containers using the <code class="literal">lxc</code> Python bindings</li><li class="listitem" style="list-style-type: disc">Creating and orchestrating containers using the libvirt Python bindings</li><li class="listitem" style="list-style-type: disc">Using LXC as a backend for development and testing with Vagrant</li><li class="listitem" style="list-style-type: disc">Developing a simple frontend RESTful API to LXC, using the Bottle micro framework and the <code class="literal">lxc</code> libraries</li></ul></div><div class="section" title="LXC Python bindings"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec24"/>LXC Python bindings</h1></div></div></div><p>LXC comes with stable C API and Python bindings for both Python 2.x and 3.x versions. Let's explore some of the functionalities that are available to us using Python 2.7.6, by writing a code that will cover most of the features provided by the userspace tools we saw in earlier chapters.</p><div class="section" title="Installing the LXC Python bindings and preparing the development environment on Ubuntu and CentOS"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec36"/>Installing the LXC Python bindings and preparing the development environment on Ubuntu and CentOS</h2></div></div></div><p>Let's start by installing all the necessary packages that will allow us to write a functioning Python code. This includes the LXC API libraries and a Python development environment with <code class="literal">ipython</code> and <code class="literal">virtualenv</code>.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To prepare an Ubuntu host, run the following commands:<pre class="programlisting">
<span class="strong"><strong>root@ubuntu:~# apt-get update &amp;&amp; apt-get upgrade &amp;&amp; reboot</strong></span>
<span class="strong"><strong>root@ubuntu:~# apt-get install python-pip python-dev ipython</strong></span>
<span class="strong"><strong>root@ubuntu:~# apt-get install lxc-dev=2.0.3-0ubuntu1~ubuntu14.04.1 &#13;
liblxc1=2.0.3-0ubuntu1~ubuntu14.04.1 cgroup-lite=1.11~ubuntu14.04.2&#13;</strong></span>

<span class="strong"><strong>root@ubuntu:~# apt-get install &#13;
lxc-templates=2.0.3-0ubuntu1~ubuntu14.04.1&#13;
lxc1=2.0.3-0ubuntu1~ubuntu14.04.1 &#13;
python3-lxc=2.0.3-0ubuntu1~ubuntu14.04.1</strong></span>
</pre><p>The preceding commands will ensure we are running the latest Ubuntu packages, along with tools such as <code class="literal">pip</code>, to install and manage Python packages, and the <code class="literal">ipython</code> tool for interactive programming in Python. On CentOS, install the following packages to provide the same functionality:</p><pre class="programlisting">
<span class="strong"><strong>[root@centos ~]# yum update &amp;&amp; reboot</strong></span>
<span class="strong"><strong>[root@centos ~]# yum install python-devel python-pip lxc &#13;
lxc-devel lxc-templates libcgroup-devel ipython</strong></span>
</pre></li><li class="listitem">At this point, let's create a Linux bridge for the containers to connect to later on:<pre class="programlisting">
<span class="strong"><strong>[root@centos ~]# brctl addbr virbr0</strong></span>
</pre><p>For the examples in this chapter, we are going to use a separate Python virtual environment to keep the dependency requirements for our project separate. We can do this by utilizing the <code class="literal">virtualenv</code> package.</p></li><li class="listitem">Let's install it first with <code class="literal">pip</code>:<pre class="programlisting">
<span class="strong"><strong>root@ubuntu:~# pip install virtualenv</strong></span>
</pre></li><li class="listitem">Next, let's create a working directory for our project and activate the virtual environment:<pre class="programlisting">
<span class="strong"><strong>root@ubuntu:~# mkdirlxc_python</strong></span>
<span class="strong"><strong>root@ubuntu:~# virtualenv lxc_python</strong></span>
<span class="strong"><strong>New python executable in /root/lxc_python/bin/python</strong></span>
<span class="strong"><strong>Installing setuptools, pip, wheel...done.</strong></span>
<span class="strong"><strong>root@ubuntu:~#&#13;</strong></span>
<span class="strong"><strong>root@ubuntu:~# source lxc_python/bin/activate</strong></span>
<span class="strong"><strong>(lxc_python) root@ubuntu:~# cd lxc_python</strong></span>
<span class="strong"><strong>(lxc_python) root@ubuntu:~/lxc_python#</strong></span>
</pre></li><li class="listitem">With the virtual environment activated, let's install the Python LXC API bindings package and list what is present in our development environment using <code class="literal">pip</code>:<pre class="programlisting">
<span class="strong"><strong>(lxc_python) root@ubuntu:~/lxc_python# pip install lxc-python2</strong></span>
<span class="strong"><strong>(lxc_python) root@ubuntu:~/lxc_python# pip freeze</strong></span>
<span class="strong"><strong>lxc-python2==0.1</strong></span>
<span class="strong"><strong>(lxc_python) root@ubuntu:~/lxc_python#</strong></span>
</pre></li></ol></div><p>With this, we have all the required packages, libraries, and tools for creating and using LXC containers with Python. Let's have some fun writing Python code!</p></div><div class="section" title="Building our first container with Python"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec37"/>Building our first container with Python</h2></div></div></div><p>Let's start the <code class="literal">ipython</code> tool and import the LXC library we installed earlier:</p><pre class="programlisting">
<span class="strong"><strong>(lxc_python) root@ubuntu:~/lxc_python# ipython</strong></span>
<span class="strong"><strong>In [1]: import lxc</strong></span>
</pre><p>Next, we need to create the <code class="literal">container</code> object using the <code class="literal">Container</code> class and by specifying a name:</p><pre class="programlisting">
<span class="strong"><strong>In [2]: container = def build():Container("python_container")</strong></span>
<span class="strong"><strong>In [3]: type(container)</strong></span>
<span class="strong"><strong>Out[3]: lxc.Container</strong></span>
</pre><p>Now that we have a <code class="literal">container</code> object, we can use the <code class="literal">create</code> method to build our first container.</p><p>The <code class="literal">container.create()</code> method definition along with the explanation for each parameter is as follows:</p><p><span class="strong"><strong>Definition</strong></span>: <code class="literal">container.create(self, template=None, flags=0, args=())</code>, creates a new <code class="literal">rootfs</code> for the container. The Following is a description of the parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">template</code>: This parameter must be a valid template name in order to be passed.</li><li class="listitem" style="list-style-type: disc"><code class="literal">flags</code>: This is optional. It is an integer representing the optional create flags to be passed.</li><li class="listitem" style="list-style-type: disc"><code class="literal">args</code>: This is optional. It is a tuple of arguments to pass to the template. It can also be provided as a dictionary.</li></ul></div><p>Creating an Ubuntu container is as easy as running the following code:</p><pre class="programlisting">
<span class="strong"><strong>In [4]: container.create("ubuntu")&#13;
&#13;
Checking cache download in /var/cache/lxc/trusty/rootfs-amd64 ...&#13;</strong></span>
<span class="strong"><strong>Copy /var/cache/lxc/trusty/rootfs-amd64 to /var/lib/lxc/python_container/rootfs ...</strong></span>
<span class="strong"><strong>Copying rootfs to /var/lib/lxc/python_container/rootfs ...</strong></span>
<span class="strong"><strong>Generating locales...</strong></span>
<span class="strong"><strong>en_US.UTF-8... up-to-date</strong></span>
<span class="strong"><strong>Generation complete.</strong></span>
<span class="strong"><strong>Creating SSH2 RSA key; this may take some time ...</strong></span>
<span class="strong"><strong>Creating SSH2 DSA key; this may take some time ...</strong></span>
<span class="strong"><strong>Creating SSH2 ECDSA key; this may take some time ...</strong></span>
<span class="strong"><strong>Creating SSH2 ED25519 key; this may take some time ...</strong></span>
<span class="strong"><strong>update-rc.d: warning: default stop runlevel arguments (0 1 6) do not match ssh Default-Stop values (none)</strong></span>
<span class="strong"><strong>invoke-rc.d: policy-rc.d denied execution of start.</strong></span>
<span class="strong"><strong>Current default time zone: 'Etc/UTC'</strong></span>
<span class="strong"><strong>Local time is now: Tue Sep 20 16:30:31 UTC 2016.</strong></span>
<span class="strong"><strong>Universal Time is now: Tue Sep 20 16:30:31 UTC 2016.</strong></span>
<span class="strong"><strong>##</strong></span>
<span class="strong"><strong># The default user is 'ubuntu' with password 'ubuntu'!</strong></span>
<span class="strong"><strong># Use the 'sudo' command to run tasks as root in the container.</strong></span>
<span class="strong"><strong>##</strong></span>
<span class="strong"><strong>Out[4]: True</strong></span>
</pre><p>An output of <code class="literal">True</code> indicates that the operation was successful in defining the container.</p></div><div class="section" title="Gathering container information with Python"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec38"/>Gathering container information with Python</h2></div></div></div><p>Now that we've built our first LXC container, let's examine a few of its properties.</p><p>First, let's check the container's name:</p><pre class="programlisting">
<span class="strong"><strong>In [5]: container.name</strong></span>
<span class="strong"><strong>Out[5]: u'python_container'</strong></span>
</pre><p>Also check its state:</p><pre class="programlisting">
<span class="strong"><strong>In [6]: container.state</strong></span>
<span class="strong"><strong>Out[6]: u'STOPPED'</strong></span>
</pre><p>Let's list all containers currently present on the host OS:</p><pre class="programlisting">
<span class="strong"><strong>In [7]: lxc.list_containers()</strong></span>
<span class="strong"><strong>Out[7]: (u'python_container')</strong></span>
</pre><p>The preceding <code class="literal">containers()</code> method returns a tuple containing the container names. In this case, just the single container we've just built.</p><p>By default, when we build LXC containers with the userspace tools such as <code class="literal">lxc-create</code>, the root filesystem and the configuration file are located in <code class="literal">/var/lib/lxc/containername/</code>. Let's see where the root filesystem for the container we built is, by calling the <code class="literal">get_config_path()</code> and <code class="literal">get_config_item()</code> methods on the <code class="literal">container</code> object:</p><pre class="programlisting">
<span class="strong"><strong>In [8]: container.get_config_path()</strong></span>
<span class="strong"><strong>Out[8]: u'/var/lib/lxc'</strong></span>
<span class="strong"><strong>In [9]: container.get_config_item('lxc.rootfs')</strong></span>
<span class="strong"><strong>Out[9]: u'/var/lib/lxc/python_container/rootfs'</strong></span>
</pre><p>From the output of the <code class="literal">get_config_path()</code> method, we can observe that the default LXC config location is the same as the one if the <code class="literal">lxc-create</code> command was used to build the container.</p><p>In the preceding code example, we also passed the <code class="literal">lxc.rootfs</code> configuration option to the <code class="literal">get_config_item()</code> method to obtain the root filesystem location, which is also in line with the default, if using the command line tools.</p><p>We can pass various configuration parameters to the <code class="literal">get_config_item()</code> method to obtain the container's current settings. Let's query for the <code class="literal">memory.limit_in_bytes</code> option:</p><pre class="programlisting">
<span class="strong"><strong>In [10]: &#13;
container.get_config_item('lxc.cgroup.memory.limit_in_bytes')</strong></span>
<span class="strong"><strong>Out[10]: u''</strong></span>
</pre><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>To list all available methods and variables on the <code class="literal">container</code> object we created, in <code class="literal">ipython</code>, type <code class="literal">container</code> and press the <span class="emphasis"><em>
<span class="strong"><strong>Tab</strong></span>
</em></span> key once. To get more information about a method, function, or variable, type its name followed by question mark, for example, <code class="literal">container.get_ips?</code>.</p></div></div><p>You can experiment further by opening the container's configuration file as shown from the preceding output and pass it as a parameter to the <code class="literal">get_config_item()</code> method.</p><p>To obtain the IP configuration of our container, we can call the <code class="literal">get_ips()</code> method with no arguments, as the following:</p><pre class="programlisting">
<span class="strong"><strong>In [11]: container.get_ips()</strong></span>
<span class="strong"><strong>Out[11]: ()</strong></span>
</pre><p>Since the container is not running and no memory limits have been applied, the output is an empty string and an empty tuple, respectively. Working with a stopped container is not very interesting; let's explore what we can do in Python with a running container.</p></div><div class="section" title="Starting containers, applying changes, and listing configuration options with Python"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec39"/>Starting containers, applying changes, and listing configuration options with Python</h2></div></div></div><p>Let's check if the container is running by printing the value of the running Boolean on the <code class="literal">container</code> object:</p><pre class="programlisting">
<span class="strong"><strong>In [12]: container.running</strong></span>
<span class="strong"><strong>Out[12]: False</strong></span>
</pre><p>To start the container, we can use the <code class="literal">start()</code> method. The docstring for that method reads as follows:</p><pre class="programlisting">
<span class="strong"><strong>start(useinit = False, daemonize=True, close_fds=False, cmd = (,)) -&gt;boolean</strong></span>
</pre><p>Start the container and return <code class="literal">True</code> on success. When set, <code class="literal">useinit</code> will make LXC use <code class="literal">lxc-init</code> to start the container. The container can be started in the foreground with <code class="literal">daemonize=False</code>. All <code class="literal">fds</code> may also be closed by passing <code class="literal">close_fds=True</code>. Looks easy enough. Let's start our container by daemonizing it and not using the <code class="literal">lxc-init</code> manager, but the Python interpreter instead:</p><pre class="programlisting">
<span class="strong"><strong>In [13]: container.start(useinit = False, daemonize = True)</strong></span>
<span class="strong"><strong>Out[13]: True</strong></span>
</pre><p>Just as earlier, an output of <code class="literal">True</code> indicates that the operation was executed successfully. Let's use the <code class="literal">wait()</code> method to wait for the container to reach the <code class="literal">RUNNING</code> state, or to timeout in 5 seconds:</p><pre class="programlisting">
<span class="strong"><strong>In [14]: container.wait("RUNNING", 5)</strong></span>
<span class="strong"><strong>Out[14]: True</strong></span>
</pre><p>The output indicates that the container is now running. Let's double-check by printing the values of the running and state variables:</p><pre class="programlisting">
<span class="strong"><strong>In [15]: container.running</strong></span>
<span class="strong"><strong>Out[15]: True</strong></span>
<span class="strong"><strong>In [16]: container.state</strong></span>
<span class="strong"><strong>Out[16]: u'RUNNING'</strong></span>
</pre><p>In a separate terminal, let's use the LXC userspace tools to examine the container we built with the Python library:</p><pre class="programlisting">
<span class="strong"><strong>root@ubuntu:~# lxc-ls -f</strong></span>
<span class="strong"><strong>NAME             STATE   AUTOSTART GROUPS IPV4      IPV6</strong></span>
<span class="strong"><strong>python_container RUNNING 0         -      10.0.3.29 -</strong></span>
<span class="strong"><strong>root@ubuntu:~#</strong></span>
</pre><p>The output of the <code class="literal">lxc-ls</code> command confirms what the <code class="literal">container.state</code> variable returned.</p><p>Let's obtain the PID of the container in our Python shell:</p><pre class="programlisting">
<span class="strong"><strong>In [17]: container.init_pid</strong></span>
<span class="strong"><strong>Out[17]: 4688L</strong></span>
</pre><p>The PID in this case is <code class="literal">4688</code>; we can confirm if it matches what's currently running on the host system by executing the following command:</p><pre class="programlisting">
<span class="strong"><strong>root@ubuntu:~# psaxfw</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>4683 ?Ss     0:00 /usr/bin/python /usr/bin/ipython</strong></span>
<span class="strong"><strong>4688 ?Ss     0:00  \_ /sbin/init</strong></span>
<span class="strong"><strong>5405 ?        S      0:00      \_ upstart-socket-bridge --daemon</strong></span>
<span class="strong"><strong>6224 ?        S      0:00      \_ upstart-udev-bridge --daemon</strong></span>
<span class="strong"><strong>6235 ?Ss     0:00      \_ /lib/systemd/systemd-udevd --daemon</strong></span>
<span class="strong"><strong>6278 ?        S      0:00      \_ upstart-file-bridge --daemon</strong></span>
<span class="strong"><strong>6280 ?Ssl    0:00      \_ rsyslogd</strong></span>
<span class="strong"><strong>6375 ?Ss     0:00      \_ dhclient -1 -v -pf /run/dhclient.eth0.pid -lf /var/lib/dhcp/dhclient.eth0.leases eth0</strong></span>
<span class="strong"><strong>6447 pts/3    Ss+    0:00      \_ /sbin/getty -8 38400 tty4</strong></span>
<span class="strong"><strong>6450 pts/1    Ss+    0:00      \_ /sbin/getty -8 38400 tty2</strong></span>
<span class="strong"><strong>6451 pts/2    Ss+    0:00      \_ /sbin/getty -8 38400 tty3</strong></span>
<span class="strong"><strong>6462 ?Ss     0:00      \_ /usr/sbin/sshd -D</strong></span>
<span class="strong"><strong>6468 ?Ss     0:00      \_ cron</strong></span>
<span class="strong"><strong>6498 pts/4    Ss+    0:00      \_ /sbin/getty -8 38400 console</strong></span>
<span class="strong"><strong>6501 pts/0    Ss+    0:00      \_ /sbin/getty -8 38400 tty1</strong></span>
<span class="strong"><strong>root@ubuntu:~#</strong></span>
</pre><p>No real surprises here. Notice how the main process that started the container's <code class="literal">init</code> system is <code class="literal">python</code> and not <code class="literal">lxc-init</code>, because that is what we passed as an argument to the <code class="literal">start()</code> method earlier.</p><p>Now that our container is running, we can get some more information from it. Let's start by obtaining its IP address:</p><pre class="programlisting">
<span class="strong"><strong>In [18]: container.get_ips()</strong></span>
<span class="strong"><strong>Out[18]: (u'10.0.3.29',)</strong></span>
</pre><p>The result is a tuple, containing the IP addresses of all interfaces for the container, in this case just one IP.</p><p>We can programmatically attach to the container and run commands just like we saw in the <a class="link" href="ch03.html" title="Chapter 3. Command-Line Operations Using Native and Libvirt Tools"><span>Chapter 3</span></a>, <span class="emphasis"><em> Command-line Operations Using Native and Libvirt Tools</em></span>, with the <code class="literal">lxc-attach</code> command, by invoking the <code class="literal">attach_wait()</code> method, as follows:</p><pre class="programlisting">
<span class="strong"><strong>In [19]: container.attach_wait(lxc.attach_run_command, ["ifconfig", "eth0"])</strong></span>
<span class="strong"><strong>eth0      Link encap:EthernetHWaddr 00:16:3e:ea:1c:38</strong></span>
<span class="strong"><strong>inet addr:10.0.3.29  Bcast:10.0.3.255  Mask:255.255.255.0</strong></span>
<span class="strong"><strong>inet6addr: fe80::216:3eff:feea:1c38/64 Scope:Link</strong></span>
<span class="strong"><strong>      UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</strong></span>
<span class="strong"><strong>      RX packets:53 errors:0 dropped:0 overruns:0 frame:0</strong></span>
<span class="strong"><strong>      TX packets:52 errors:0 dropped:0 overruns:0 carrier:0</strong></span>
<span class="strong"><strong>collisions:0 txqueuelen:1000</strong></span>
<span class="strong"><strong>      RX bytes:5072 (5.0 KB)  TX bytes:4892 (4.8 KB)</strong></span>
<span class="strong"><strong>Out[19]: 0L</strong></span>
</pre><p>The <code class="literal">attach_wait()</code> method takes a function as its argument, in the preceding example, the built-in <code class="literal">lxc.attach_run_command</code>, but it can be any other function in Python that you wrote. We also specified a list consisting of the command we want to execute and its arguments.</p><p>We can also specify the namespace context the command should run in. For example, to list all files in the container's mount namespace designated by the <code class="literal">CLONE_NEWNS</code> flag, we can pass the <code class="literal">namespaces</code> parameter:</p><pre class="programlisting">
<span class="strong"><strong>In [20]: container.attach_wait(lxc.attach_run_command, ["ls", "-la"], namespaces=(lxc.CLONE_NEWNS))</strong></span>
<span class="strong"><strong>total 68</strong></span>
<span class="strong"><strong>drwxr-xr-x  21 root root 4096 Sep 20 18:51 .</strong></span>
<span class="strong"><strong>drwxr-xr-x  21 root root 4096 Sep 20 18:51 ..</strong></span>
<span class="strong"><strong>drwxr-xr-x   2 root root 4096 Sep 14 15:20 bin</strong></span>
<span class="strong"><strong>drwxr-xr-x   2 root root 4096 Apr 10  2014 boot</strong></span>
<span class="strong"><strong>drwxr-xr-x   7 root root 1140 Sep 20 18:51 dev</strong></span>
<span class="strong"><strong>drwxr-xr-x  65 root root 4096 Sep 20 18:51 etc</strong></span>
<span class="strong"><strong>drwxr-xr-x   3 root root 4096 Sep 20 16:30 home</strong></span>
<span class="strong"><strong>drwxr-xr-x  12 root root 4096 Sep 14 15:19 lib</strong></span>
<span class="strong"><strong>drwxr-xr-x   2 root root 4096 Sep 14 15:19 lib64</strong></span>
<span class="strong"><strong>drwxr-xr-x   2 root root 4096 Sep 14 15:18 media</strong></span>
<span class="strong"><strong>drwxr-xr-x   2 root root 4096 Apr 10  2014 mnt</strong></span>
<span class="strong"><strong>drwxr-xr-x   2 root root 4096 Sep 14 15:18 opt</strong></span>
<span class="strong"><strong>dr-xr-xr-x 143 root root    0 Sep 20 18:51 proc</strong></span>
<span class="strong"><strong>drwx------   2 root root 4096 Sep 14 15:18 root</strong></span>
<span class="strong"><strong>drwxr-xr-x  10 root root  420 Sep 20 18:51 run</strong></span>
<span class="strong"><strong>drwxr-xr-x   2 root root 4096 Sep 14 15:20 sbin</strong></span>
<span class="strong"><strong>drwxr-xr-x   2 root root 4096 Sep 14 15:18 srv</strong></span>
<span class="strong"><strong>dr-xr-xr-x  13 root root    0 Sep 20 18:51 sys</strong></span>
<span class="strong"><strong>drwxrwxrwt   2 root root 4096 Sep 20 19:17 tmp</strong></span>
<span class="strong"><strong>drwxr-xr-x  10 root root 4096 Sep 14 15:18 usr</strong></span>
<span class="strong"><strong>drwxr-xr-x  11 root root 4096 Sep 14 15:18 var</strong></span>
<span class="strong"><strong>Out[20]: 0L</strong></span>
</pre><p>We can run commands by specifying multiple <code class="literal">namespaces</code> flags. In the next example, we list all processes in the container by explicitly specifying the mount and process namespaces with the <code class="literal">CLONE_NEWNS</code> and <code class="literal">CLONE_NEWPID</code> flags, respectively:</p><pre class="programlisting">
<span class="strong"><strong>In [21]: container.attach_wait(lxc.attach_run_command, ["ps", "axfw"], namespaces=(lxc.CLONE_NEWNS + lxc.CLONE_NEWPID))</strong></span>
<span class="strong"><strong>PID TTY      STAT   TIME COMMAND</strong></span>
<span class="strong"><strong>1751 pts/0    R+     0:00psaxfw</strong></span>
<span class="strong"><strong>1 ?Ss     0:00 /sbin/init</strong></span>
<span class="strong"><strong>670 ?        S      0:00 upstart-socket-bridge --daemon</strong></span>
<span class="strong"><strong>1487 ?        S      0:00 upstart-udev-bridge --daemon</strong></span>
<span class="strong"><strong>1498 ?Ss     0:00 /lib/systemd/systemd-udevd --daemon</strong></span>
<span class="strong"><strong>1541 ?        S      0:00 upstart-file-bridge --daemon</strong></span>
<span class="strong"><strong>1543 ?Ssl    0:00 rsyslogd</strong></span>
<span class="strong"><strong>1582 ?Ss     0:00 dhclient -1 -v -pf /run/dhclient.eth0.pid -lf /var/lib/dhcp/dhclient.eth0.leases eth0</strong></span>
<span class="strong"><strong> 1654 lxc/tty4 Ss+    0:00 /sbin/getty -8 38400 tty4</strong></span>
<span class="strong"><strong> 1657 lxc/tty2 Ss+    0:00 /sbin/getty -8 38400 tty2</strong></span>
<span class="strong"><strong> 1658 lxc/tty3 Ss+    0:00 /sbin/getty -8 38400 tty3</strong></span>
<span class="strong"><strong>1669 ?Ss     0:00 /usr/sbin/sshd -D</strong></span>
<span class="strong"><strong>1675 ?Ss     0:00 cron</strong></span>
<span class="strong"><strong> 1705 lxc/console Ss+   0:00 /sbin/getty -8 38400 console</strong></span>
<span class="strong"><strong> 1708 lxc/tty1 Ss+    0:00 /sbin/getty -8 38400 tty1</strong></span>
<span class="strong"><strong>Out[21]: 0L</strong></span>
</pre><p>Using the <code class="literal">set_config_item()</code> and <code class="literal">get_config_item()</code> methods, we can apply configuration changes and query them on a running container. To demonstrate this, let's specify a memory limit for the container and then obtain the newly set value:</p><pre class="programlisting">
<span class="strong"><strong>In [22]: container.set_config_item("lxc.cgroup.memory.limit_in_bytes", "536870912")</strong></span>
<span class="strong"><strong>Out[22]: True</strong></span>
<span class="strong"><strong>In [23]: container.get_config_item('lxc.cgroup.memory.limit_in_bytes')</strong></span>
<span class="strong"><strong>Out[23]: [u'536870912']</strong></span>
</pre><p>The preceding changes will not persist when a container restarts; to make the changes permanent, we can write them in the configuration file using the <code class="literal">append_config_item()</code> and <code class="literal">save_config()</code> methods:</p><pre class="programlisting">
<span class="strong"><strong>In [24]: container.append_config_item("lxc.cgroup.memory.limit_in_bytes", "536870912")</strong></span>
<span class="strong"><strong>Out[24]: True</strong></span>
<span class="strong"><strong>In [25]: container.save_config()</strong></span>
<span class="strong"><strong>Out[25]: True</strong></span>
</pre><p>To verify this, the <code class="literal">lxc.cgroup.memory.limit_in_bytes</code> parameter was saved in the configuration file; let's examine it:</p><pre class="programlisting">
<span class="strong"><strong>root@ubuntu:~# cat /var/lib/lxc/python_container/config</strong></span>
<span class="strong"><strong>lxc.include = /usr/share/lxc/config/ubuntu.common.conf</strong></span>
<span class="strong"><strong># Container specific configuration</strong></span>
<span class="strong"><strong>lxc.rootfs = /var/lib/lxc/python_container/rootfs</strong></span>
<span class="strong"><strong>lxc.rootfs.backend = dir</strong></span>
<span class="strong"><strong>lxc.utsname = python_container</strong></span>
<span class="strong"><strong>lxc.arch = amd64</strong></span>
<span class="strong"><strong># Network configuration</strong></span>
<span class="strong"><strong>lxc.network.type = veth</strong></span>
<span class="strong"><strong>lxc.network.link = lxcbr0</strong></span>
<span class="strong"><strong>lxc.network.flags = up</strong></span>
<span class="strong"><strong>lxc.network.hwaddr = 00:16:3e:ea:1c:38</strong></span>
<span class="strong"><strong>lxc.cgroup.memory.limit_in_bytes = 536870912</strong></span>
<span class="strong"><strong>root@ubuntu:~#</strong></span>
</pre><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>The last line in the configuration file is the one we appended with the two Python calls.</p></div></div><p>In addition to the <code class="literal">set_config_item()</code> method, the Python bindings also provide the <code class="literal">set_cgroup_item()</code> and <code class="literal">get_cgroup_item()</code> methods for specifically manipulating the cgroup parameters. Let's set and get the same <code class="literal">memory.limit_in_bytes</code> option using those two calls:</p><pre class="programlisting">
<span class="strong"><strong>In [26]: container.get_cgroup_item("memory.limit_in_bytes")</strong></span>
<span class="strong"><strong>Out[26]: u'536870912'</strong></span>
<span class="strong"><strong>In [27]: container.set_cgroup_item("memory.limit_in_bytes", "268435456")</strong></span>
<span class="strong"><strong>Out[27]: True</strong></span>
<span class="strong"><strong>In [28]: container.get_cgroup_item("memory.limit_in_bytes")</strong></span>
<span class="strong"><strong>Out[28]: u'268435456'</strong></span>
</pre></div><div class="section" title="Changing container state with Python"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec40"/>Changing container state with Python</h2></div></div></div><p>In <a class="link" href="ch03.html" title="Chapter 3. Command-Line Operations Using Native and Libvirt Tools"><span>Chapter 3</span></a>, <span class="emphasis"><em>Command-Line Operations Using Native and Libvirt Tools</em></span>, we saw how to freeze and unfreeze LXC containers to preserve their state using the <code class="literal">lxc-freeze</code> and <code class="literal">lxc-unfreeze</code> commands. We can do the same with the <code class="literal">freeze()</code> and <code class="literal">unfreeze()</code> methods. To freeze the container, execute the following:</p><pre class="programlisting">
<span class="strong"><strong>In [29]: container.freeze()</strong></span>
<span class="strong"><strong>Out[29]: u'FROZEN'</strong></span>
</pre><p>Check the status as follows:</p><pre class="programlisting">
<span class="strong"><strong>In [30]: container.state</strong></span>
<span class="strong"><strong>Out[30]: u'FROZEN'</strong></span>
</pre><p>We can examine the cgroup file as well, to confirm the change took place:</p><pre class="programlisting">
<span class="strong"><strong>root@ubuntu:~# cat /sys/fs/cgroup/freezer/lxc/python_container/freezer.state</strong></span>
<span class="strong"><strong>FROZEN</strong></span>
<span class="strong"><strong>root@ubuntu:~#</strong></span>
</pre><p>To unfreeze the container and check the new state, call the <code class="literal">unfreeze()</code> method:</p><pre class="programlisting">
<span class="strong"><strong>In [31]: container.unfreeze()</strong></span>
<span class="strong"><strong>Out[31]: True</strong></span>
<span class="strong"><strong>In [32]: container.state</strong></span>
<span class="strong"><strong>Out[32]: u'RUNNING'</strong></span>
<span class="strong"><strong>root@ubuntu:~# cat /sys/fs/cgroup/freezer/lxc/python_container/freezer.state</strong></span>
<span class="strong"><strong>THAWED</strong></span>
<span class="strong"><strong>root@ubuntu:~#</strong></span>
</pre></div><div class="section" title="Stopping containers with Python"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec41"/>Stopping containers with Python</h2></div></div></div><p>The Python bindings provide a convenient way of stopping containers with the <code class="literal">stop()</code> method. Let's stop our container and check its state:</p><pre class="programlisting">
<span class="strong"><strong>In [33]: container.stop()</strong></span>
<span class="strong"><strong>Out[33]: True</strong></span>
<span class="strong"><strong>In [34]: container.state</strong></span>
<span class="strong"><strong>Out[34]: u'STOPPED'</strong></span>
</pre><p>Finally, list all the containers on the host:</p><pre class="programlisting">
<span class="strong"><strong>root@ubuntu:~# lxc-ls -f</strong></span>
<span class="strong"><strong>NAME             STATE   AUTOSTART GROUPS IPV4 IPV6</strong></span>
<span class="strong"><strong>python_container STOPPED 0         -      -    -</strong></span>
<span class="strong"><strong>root@ubuntu:~#</strong></span>
</pre></div><div class="section" title="Cloning containers with Python"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec42"/>Cloning containers with Python</h2></div></div></div><p>With the container in a <code class="literal">STOPPED</code> state, let's run the <code class="literal">clone()</code> method and create a copy:</p><pre class="programlisting">
<span class="strong"><strong>In [35]: cloned_container = container.clone("cloned_container")</strong></span>
<span class="strong"><strong>In [35]: True</strong></span>
</pre><p>Listing the available containers with the <code class="literal">list_containers()</code> method on the <code class="literal">lxc</code> object, we get a tuple:</p><pre class="programlisting">
<span class="strong"><strong>In [36]: lxc.list_containers()</strong></span>
<span class="strong"><strong>Out[36]: (u'cloned_container', u'python_container')</strong></span>
</pre><p>To confirm on the host OS, execute the following:</p><pre class="programlisting">
<span class="strong"><strong>root@ubuntu:~# lxc-ls -f</strong></span>
<span class="strong"><strong>NAME             STATE   AUTOSTART GROUPS IPV4 IPV6</strong></span>
<span class="strong"><strong>cloned_container STOPPED 0         -      -    -</strong></span>
<span class="strong"><strong>python_container STOPPED 0         -      -    -</strong></span>
<span class="strong"><strong>root@ubuntu:~#</strong></span>
</pre><p>To find where the root filesystem for the cloned container is, we can call the <code class="literal">get_config_item()</code> method on the new <code class="literal">container</code> object:</p><pre class="programlisting">
<span class="strong"><strong>In [37]: cloned_container.get_config_item('lxc.rootfs')</strong></span>
<span class="strong"><strong>Out[37]: u'/var/lib/lxc/cloned_container/rootfs'</strong></span>
</pre><p>Two directories now exist in the default container path:</p><pre class="programlisting">
<span class="strong"><strong>root@ubuntu:~# ls -la /var/lib/lxc</strong></span>
<span class="strong"><strong>total 20</strong></span>
<span class="strong"><strong>drwx------  5 root root 4096 Sep 20 19:51 .</strong></span>
<span class="strong"><strong>drwxr-xr-x 47 root root 4096 Sep 16 13:40 ..</strong></span>
<span class="strong"><strong>drwxrwx---  3 root root 4096 Sep 20 19:51 cloned_container</strong></span>
<span class="strong"><strong>drwxrwx---  3 root root 4096 Sep 20 16:30 python_container</strong></span>
<span class="strong"><strong>root@ubuntu:~#</strong></span>
</pre><p>Finally, let's start the cloned container and ensure it's running:</p><pre class="programlisting">
<span class="strong"><strong>In [38]: cloned_container.start()</strong></span>
<span class="strong"><strong>Out[38]: True</strong></span>
<span class="strong"><strong>In [39]: cloned_container.state</strong></span>
<span class="strong"><strong>Out[39]: u'RUNNING'</strong></span>
</pre></div><div class="section" title="Destroying containers with Python and cleaning up the virtual environment"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec43"/>Destroying containers with Python and cleaning up the virtual environment</h2></div></div></div><p>Before we can remove or destroy containers in Python, just like with the command line tools, we need to stop them first:</p><pre class="programlisting">
<span class="strong"><strong>In [40]: cloned_container.stop()</strong></span>
<span class="strong"><strong>Out[40]: True</strong></span>
<span class="strong"><strong>In [41]: container.stop()</strong></span>
<span class="strong"><strong>Out[41]: True</strong></span>
</pre><p>Invoke the <code class="literal">destroy()</code> method on the <code class="literal">container</code> object to delete the root filesystem and free all resources used by it:</p><pre class="programlisting">
<span class="strong"><strong>In [42]: cloned_container.destroy()</strong></span>
<span class="strong"><strong>Out[42]: True</strong></span>
<span class="strong"><strong>In [43]: container.destroy()</strong></span>
<span class="strong"><strong>Out[43]: True</strong></span>
</pre><p>List the containers through the <code class="literal">list_containers()</code> method to now return an empty tuple:</p><pre class="programlisting">
<span class="strong"><strong>In [44]: lxc.list_containers()</strong></span>
<span class="strong"><strong>Out[44]: ()</strong></span>
</pre><p>Lastly, let's deactivate the Python virtual environment we created earlier – note that the files will still be present on the disk:</p><pre class="programlisting">
<span class="strong"><strong>(lxc_python) root@ubuntu:~/lxc_python# deactivate</strong></span>
<span class="strong"><strong>root@ubuntu:~/lxc_python# cd ..</strong></span>
<span class="strong"><strong>root@ubuntu:~#</strong></span>
</pre></div></div></div>
<div class="section" title="Libvirt Python bindings"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Libvirt Python bindings</h1></div></div></div><p>In <a class="link" href="ch03.html" title="Chapter 3. Command-Line Operations Using Native and Libvirt Tools"><span>Chapter 3</span></a>, <span class="emphasis"><em>Command-Line Operations Using Native and Libvirt Tools</em></span>, we explored an alternative way of working with LXC through the use of the libvirt userspace tools. Libvirt provides Python bindings that we can use to write applications, with the main benefit of uniformity with other virtualization technologies. It's quite convenient to write Python applications for KVM, XEN, and LXC using just one common library.</p><p>In this section, we are going to explore some of the Python methods provided by the libvirt library to create and control LXC containers.</p><div class="section" title="Installing the libvirt Python development packages"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec44"/>Installing the libvirt Python development packages</h2></div></div></div><p>Let's start by installing the required packages and starting the service.</p><p>On Ubuntu, run the following:</p><pre class="programlisting">
<span class="strong"><strong>root@ubuntu:~# apt-get install python-libvirt debootstrap</strong></span>
<span class="strong"><strong>root@ubuntu:~# service libvirt-bin start</strong></span>
</pre><p>On CentOS, the library and the service are named differently:</p><pre class="programlisting">
<span class="strong"><strong>[root@centos ~]# yum install libvirt libvirt-python debootstrap</strong></span>
<span class="strong"><strong>[root@centos ~]# service libvirtd start</strong></span>
</pre><p>Since libvirt does not provide templates to work with, we need to create our own root filesystem:</p><pre class="programlisting">
<span class="strong"><strong>root@ubuntu:~# debootstrap --arch=amd64 --include="openssh-server vim" stable ~/container http://httpredir.debian.org/debian/ </strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>root@ubuntu:~#</strong></span>
</pre><p>Activate the Python virtual environment and start the interpreter:</p><pre class="programlisting">
<span class="strong"><strong>root@ubuntu:~# source lxc_python/bin/activate</strong></span>
<span class="strong"><strong>(lxc_python) root@ubuntu:~# ipython</strong></span>
<span class="strong"><strong>In [1]:</strong></span>
</pre></div><div class="section" title="Building LXC containers with libvirt Python"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec45"/>Building LXC containers with libvirt Python</h2></div></div></div><p>It's time to import the library and call the <code class="literal">open()</code> method to create a connection to the LXC driver. The argument that we pass to the <code class="literal">open()</code> method should look familiar – we used it in <a class="link" href="ch03.html" title="Chapter 3. Command-Line Operations Using Native and Libvirt Tools"><span>Chapter 3</span></a>, <span class="emphasis"><em>Command-Line Operations Using Native and Libvirt Tools</em></span>, when exporting the <code class="literal">LIBVIRT_DEFAULT_URI</code> environment variable, telling libvirt that LXC is going to be the default virtualization driver:</p><pre class="programlisting">
<span class="strong"><strong>In [1]: import libvirt</strong></span>
<span class="strong"><strong>In [2]: lxc_conn = libvirt.open('lxc:///')</strong></span>
</pre><p>After specifying the default virtualization driver and URI, we can use the next two methods to return the name and path of the driver we set:</p><pre class="programlisting">
<span class="strong"><strong>In [3]: lxc_conn.getType()</strong></span>
<span class="strong"><strong>Out[3]: 'LXC'</strong></span>
<span class="strong"><strong>In [4]: lxc_conn.getURI()</strong></span>
<span class="strong"><strong>Out[4]: 'lxc:///'</strong></span>
</pre><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>To get a list of the available methods and variables on the <code class="literal">lxc_conn</code> object we created earlier, type <code class="literal">lxc_conn</code>. and press the <span class="emphasis"><em>
<span class="strong"><strong>Tab</strong></span>
</em></span> key. To get more information about a method, function, or variable, type its name followed by a question mark, for example, <code class="literal">lxc_conn.getURI?</code>.</p></div></div><p>We can use the <code class="literal">getInfo()</code> method to extract hardware information about the host node:</p><pre class="programlisting">
<span class="strong"><strong>In [5]: lxc_conn.getInfo()</strong></span>
<span class="strong"><strong>Out[5]: ['x86_64', 1996L, 2, 3000, 1, 2, 1, 1]</strong></span>
</pre><p>The result is a list with the following values:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>
<p><span class="strong"><strong>Member</strong></span></p>
</td><td>
<p><span class="strong"><strong>Description</strong></span></p>
</td></tr><tr><td>
<p><code class="literal">list[0]</code></p>
</td><td>
<p>String indicating the CPU model</p>
</td></tr><tr><td>
<p><code class="literal">list[1]</code></p>
</td><td>
<p>Memory size in megabytes</p>
</td></tr><tr><td>
<p><code class="literal">list[2]</code></p>
</td><td>
<p>The number of active CPUs</p>
</td></tr><tr><td>
<p><code class="literal">list[3]</code></p>
</td><td>
<p>Expected CPU frequency in MHz</p>
</td></tr><tr><td>
<p><code class="literal">list[4]</code></p>
</td><td>
<p>The number of NUMA nodes, <code class="literal">1</code> for uniform memory access</p>
</td></tr><tr><td>
<p><code class="literal">list[5]</code></p>
</td><td>
<p>Number of CPU sockets per node</p>
</td></tr><tr><td>
<p><code class="literal">list[6]</code></p>
</td><td>
<p>Number of cores per socket</p>
</td></tr><tr><td>
<p><code class="literal">list[7]</code></p>
</td><td>
<p>Number of threads per core</p>
</td></tr></tbody></table></div><p>To build a container, we need to define it first in a XML file. Let's use the following example and assign it to the <code class="literal">domain_xml</code> string variable:</p><pre class="programlisting">
<span class="strong"><strong>In [6]: domain_xml = '''</strong></span>
<span class="strong"><strong>&lt;domain type='lxc'&gt;</strong></span>
<span class="strong"><strong>  &lt;name&gt;libvirt_python&lt;/name&gt;</strong></span>
<span class="strong"><strong>  &lt;memory unit='KiB'&gt;524288&lt;/memory&gt;</strong></span>
<span class="strong"><strong>  &lt;currentMemory unit='KiB'&gt;524288&lt;/currentMemory&gt;</strong></span>
<span class="strong"><strong>  &lt;vcpu placement='static'&gt;1&lt;/vcpu&gt;</strong></span>
<span class="strong"><strong>  &lt;os&gt;</strong></span>
<span class="strong"><strong>    &lt;type arch='x86_64'&gt;exe&lt;/type&gt;</strong></span>
<span class="strong"><strong>    &lt;init&gt;/sbin/init&lt;/init&gt;</strong></span>
<span class="strong"><strong>  &lt;/os&gt;</strong></span>
<span class="strong"><strong>  &lt;clock offset='utc'/&gt;</strong></span>
<span class="strong"><strong>  &lt;on_poweroff&gt;destroy&lt;/on_poweroff&gt;</strong></span>
<span class="strong"><strong>  &lt;on_reboot&gt;restart&lt;/on_reboot&gt;</strong></span>
<span class="strong"><strong>  &lt;on_crash&gt;destroy&lt;/on_crash&gt;</strong></span>
<span class="strong"><strong>  &lt;devices&gt;</strong></span>
<span class="strong"><strong>    &lt;emulator&gt;/usr/lib/libvirt/libvirt_lxc&lt;/emulator&gt;</strong></span>
<span class="strong"><strong>    &lt;filesystem type='mount' accessmode='passthrough'&gt;</strong></span>
<span class="strong"><strong>      &lt;sourcedir='/root/container/'/&gt;</strong></span>
<span class="strong"><strong>      &lt;targetdir='/'/&gt;</strong></span>
<span class="strong"><strong>    &lt;/filesystem&gt;</strong></span>
<span class="strong"><strong>    &lt;interface type='bridge'&gt;</strong></span>
<span class="strong"><strong>      &lt;mac address='00:17:3e:9f:33:f7'/&gt;</strong></span>
<span class="strong"><strong>      &lt;source bridge='lxcbr0'/&gt;</strong></span>
<span class="strong"><strong>      &lt;link state='up'/&gt;</strong></span>
<span class="strong"><strong>    &lt;/interface&gt;</strong></span>
<span class="strong"><strong>    &lt;console type='pty' /&gt;</strong></span>
<span class="strong"><strong>  &lt;/devices&gt;</strong></span>
<span class="strong"><strong>&lt;/domain&gt;</strong></span>
<span class="strong"><strong>'''</strong></span>
</pre><p>With the preceding XML configuration assigned to a variable, we can use the <code class="literal">defineXML()</code> method to define the container. This method takes the XML definition as an argument and defines the container, but does not start it:</p><pre class="programlisting">
<span class="strong"><strong>In [7]: container = lxc_conn.defineXML(domain_xml)</strong></span>
</pre><p>Let's verify the container was successfully defined on the host:</p><pre class="programlisting">
<span class="strong"><strong>root@ubuntu:~# virsh --connect lxc:/// list --all</strong></span>
<span class="strong"><strong>Id    Name                           State</strong></span>
<span class="strong"><strong>----------------------------------------------------</strong></span>
<span class="strong"><strong>-     libvirt_python                 shut off</strong></span>
<span class="strong"><strong>root@ubuntu:~#</strong></span>
</pre><p>We can use the <code class="literal">listDefinedDomains()</code> method to list all the defined but not the running domains, which returns a list:</p><pre class="programlisting">
<span class="strong"><strong>In [8]: lxc_conn.listDefinedDomains()</strong></span>
<span class="strong"><strong>Out[8]: ['libvirt_python']</strong></span>
</pre></div><div class="section" title="Starting containers and running basic operations with libvirt Python"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec46"/>Starting containers and running basic operations with libvirt Python</h2></div></div></div><p>To start the previously defined container, we need to call the <code class="literal">create()</code> method:</p><pre class="programlisting">
<span class="strong"><strong>In [9]: container.create()</strong></span>
<span class="strong"><strong>Out[9]: 07</strong></span>
</pre><p>To verify the container is running on the host, after calling the <code class="literal">create()</code> method, we'll execute the following:</p><pre class="programlisting">
<span class="strong"><strong>root@ubuntu:~# virsh --connect lxc:/// list --all</strong></span>
<span class="strong"><strong>Id    Name                           State</strong></span>
<span class="strong"><strong>----------------------------------------------------</strong></span>
<span class="strong"><strong>23749 libvirt_python                 running</strong></span>
<span class="strong"><strong>root@ubuntu:~#</strong></span>
</pre><p>There are quite a few methods for obtaining information about the container. We can fetch the XML definition by calling the <code class="literal">XMLDesc()</code> method on the <code class="literal">container</code> object:</p><pre class="programlisting">
<span class="strong"><strong>In [10]: container.XMLDesc()</strong></span>
<span class="strong"><strong>Out[10]: "&lt;domain type='lxc' id='25535'&gt;\n  &lt;name&gt;libvirt_python&lt;/name&gt;\n  &lt;uuid&gt;6a46bd23-f0df-461b-85e7-19fd36be90df&lt;/uuid&gt;\n  &lt;memory unit='KiB'&gt;524288&lt;/memory&gt;\n  &lt;currentMemory unit='KiB'&gt;524288&lt;/currentMemory&gt;\n  &lt;vcpu placement='static'&gt;1&lt;/vcpu&gt;\n  &lt;resource&gt;\n    &lt;partition&gt;/machine&lt;/partition&gt;\n  &lt;/resource&gt;\n  &lt;os&gt;\n    &lt;type arch='x86_64'&gt;exe&lt;/type&gt;\n    &lt;init&gt;/sbin/init&lt;/init&gt;\n  &lt;/os&gt;\n  &lt;clock offset='utc'/&gt;\n  &lt;on_poweroff&gt;destroy&lt;/on_poweroff&gt;\n  &lt;on_reboot&gt;restart&lt;/on_reboot&gt;\n  &lt;on_crash&gt;destroy&lt;/on_crash&gt;\n  &lt;devices&gt;\n    &lt;emulator&gt;/usr/lib/libvirt/libvirt_lxc&lt;/emulator&gt;\n    &lt;filesystem type='mount' accessmode='passthrough'&gt;\n      &lt;source dir='/root/container/'/&gt;\n      &lt;target dir='/'/&gt;\n    &lt;/filesystem&gt;\n    &lt;interface type='bridge'&gt;\n      &lt;mac address='00:17:3e:9f:33:f7'/&gt;\n      &lt;source bridge='lxcbr0'/&gt;\n      &lt;target dev='vnet0'/&gt;\n      &lt;link state='up'/&gt;\n    &lt;/interface&gt;\n    &lt;console type='pty' tty='/dev/pts/1'&gt;\n      &lt;source path='/dev/pts/1'/&gt;\n      &lt;target type='lxc' port='0'/&gt;\n      &lt;alias name='console0'/&gt;\n    &lt;/console&gt;\n  &lt;/devices&gt;\n  &lt;seclabel type='none'/&gt;\n&lt;/domain&gt;\n"</strong></span>
</pre><p>Let's verify that the container is running by calling the <code class="literal">isAlive()</code> function that returns a Boolean:</p><pre class="programlisting">
<span class="strong"><strong>In [11]: lxc_conn.isAlive()</strong></span>
<span class="strong"><strong>Out[11]: 1</strong></span>
</pre><p>We can obtain the container ID that should match the ID we received back by running the preceding <code class="literal">virsh</code> command:</p><pre class="programlisting">
<span class="strong"><strong>In [12]: lxc_conn.listDomainsID()</strong></span>
<span class="strong"><strong>Out[12]: [23749]</strong></span>
</pre><p>No surprise here, the ID is the same.</p><p>The next code snippet iterates over a list of defined containers and returns a list of domain objects from which we print their name, by calling the <code class="literal">listAllDomains()</code> method:</p><pre class="programlisting">
<span class="strong"><strong>In [13]: domains = lxc_conn.listAllDomains(0)</strong></span>
<span class="strong"><strong>In [13]: for domain in domains:</strong></span>
<span class="strong"><strong>....:     print('  '+domain.name())</strong></span>
<span class="strong"><strong>....:</strong></span>
<span class="strong"><strong>libvirt_python</strong></span>
</pre><p>The API provides two methods to lookup a container, by name and by ID, and assigns it to an object variable:</p><pre class="programlisting">
<span class="strong"><strong>In [14]: container = lxc_conn.lookupByName("libvirt_python")</strong></span>
<span class="strong"><strong>In [15]: container = lxc_conn.lookupByID(23749)</strong></span>
</pre><p>This is useful when we want to work with containers that already exist. The <code class="literal">container</code> object can now be used as usual, by calling its methods.</p></div><div class="section" title="Collecting container information with libvirt Python"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec47"/>Collecting container information with libvirt Python</h2></div></div></div><p>Let's collect information about the memory of the container. The <code class="literal">maxMemory()</code> method returns the maximum memory configured on the container:</p><pre class="programlisting">
<span class="strong"><strong>In [16]: container.maxMemory()</strong></span>
<span class="strong"><strong>Out[16]: 524288L</strong></span>
</pre><p>Collecting memory statistics is done with the <code class="literal">memoryStats()</code> method, which returns a dictionary object:</p><pre class="programlisting">
<span class="strong"><strong>In [17]: container.memoryStats()</strong></span>
<span class="strong"><strong>Out[17]: {'actual': 524288L, 'rss': 1388L, 'swap_in': 1388L}</strong></span>
</pre><p>When we defined our container earlier in the XML file, we specified the OS type of the domain to be <code class="literal">exe</code>, meaning the container will execute the specified binary. To obtain that on a running container, call the <code class="literal">OSType()</code> method:</p><pre class="programlisting">
<span class="strong"><strong>In [18]: container.OSType()</strong></span>
<span class="strong"><strong>Out[18]: 'exe'</strong></span>
</pre><p>Finally, to get more information on the container, we can call the <code class="literal">info()</code> function:</p><pre class="programlisting">
<span class="strong"><strong>In [19]: container.info()</strong></span>
<span class="strong"><strong>Out[19]: [1, 524288L, 1352L, 1, 8080449759L]</strong></span>
</pre><p>The result is a list with the following values:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>
<p><span class="strong"><strong>Member</strong></span></p>
</td><td>
<p><span class="strong"><strong>Description</strong></span></p>
</td></tr><tr><td>
<p><code class="literal">list[0]</code></p>
</td><td>
<p>String indicating the state of the container</p>
</td></tr><tr><td>
<p><code class="literal">list[1]</code></p>
</td><td>
<p>Max container memory</p>
</td></tr><tr><td>
<p><code class="literal">list[2]</code></p>
</td><td>
<p>Current memory utilization</p>
</td></tr><tr><td>
<p><code class="literal">list[3]</code></p>
</td><td>
<p>Number of CPUs</p>
</td></tr><tr><td>
<p><code class="literal">list[4]</code></p>
</td><td>
<p>CPU time</p>
</td></tr></tbody></table></div><p>With the container running, let's look at how we can stop it and clean up the environment next.</p></div><div class="section" title="Stopping and deleting LXC containers with libvirt Python"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec48"/>Stopping and deleting LXC containers with libvirt Python</h2></div></div></div><p>Before we can destroy the container, let's verify its state and name.</p><pre class="programlisting">
<span class="strong"><strong>In [20]: container.isActive()</strong></span>
<span class="strong"><strong>Out[20]: 1</strong></span>
<span class="strong"><strong>In [21]: container.name()</strong></span>
<span class="strong"><strong>Out[21]: 'libvirt_python'</strong></span>
</pre><p>To stop it, call the <code class="literal">destroy()</code> method on the <code class="literal">container</code> object:</p><pre class="programlisting">
<span class="strong"><strong>In [22]: container.destroy()</strong></span>
<span class="strong"><strong>Out[22]: 0</strong></span>
</pre><p>Let's verify the container is not running on the host before we can delete it:</p><pre class="programlisting">
<span class="strong"><strong>root@ubuntu:~# virsh --connect lxc:/// list --all</strong></span>
<span class="strong"><strong>Id    Name                           State</strong></span>
<span class="strong"><strong>----------------------------------------------------</strong></span>
<span class="strong"><strong>-     libvirt_python                 shut off</strong></span>
<span class="strong"><strong>root@ubuntu:~#</strong></span>
</pre><p>To delete the container, we invoke the <code class="literal">undefine()</code> method:</p><pre class="programlisting">
<span class="strong"><strong>In [23]: container.undefine()</strong></span>
<span class="strong"><strong>Out[23]: 0</strong></span>
<span class="strong"><strong>root@ubuntu:~# virsh --connect lxc:/// list --all</strong></span>
<span class="strong"><strong>Id    Name                           State</strong></span>
<span class="strong"><strong>----------------------------------------------------</strong></span>
<span class="strong"><strong>root@ubuntu:~#</strong></span>
</pre><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>It's important to note that not all methods, functions, and variables are available to the libvirt LXC driver, even though they can be listed in the ipython interpreter after importing the libvirt library. This is due to the libvirt support for multiple hypervisors such as KVM and XEN. Keep this in mind when exploring the rest of the API calls.</p></div></div></div></div>
<div class="section" title="Vagrant and LXC"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Vagrant and LXC</h1></div></div></div><p>Vagrant is a great open source project that provides a way for building isolated development environments, utilizing various virtualization technologies such as KVM and LXC, through the use of plugins.</p><p>In this section, we are going to briefly touch on how to set up a Vagrant development environment using LXC for isolation.</p><p>Let's start by downloading and installing Vagrant on Ubuntu:</p><pre class="programlisting">
<span class="strong"><strong>root@ubuntu:~# cd /usr/src/</strong></span>
<span class="strong"><strong>root@ubuntu:/usr/src# wget https://releases.hashicorp.com/vagrant/1.8.5/vagrant_1.8.5_x86_64.deb</strong></span>
<span class="strong"><strong>--2016-09-26 21:11:56-- https://releases.hashicorp.com/vagrant/1.8.5/vagrant_1.8.5_x86_64.deb</strong></span>
<span class="strong"><strong>Resolving releases.hashicorp.com (releases.hashicorp.com)... 151.101.44.69</strong></span>
<span class="strong"><strong>Connecting to releases.hashicorp.com (releases.hashicorp.com)|151.101.44.69|:443... connected.</strong></span>
<span class="strong"><strong>HTTP request sent, awaiting response... 200 OK</strong></span>
<span class="strong"><strong>Length: 76325224 (73M) [application/x-debian-package]</strong></span>
<span class="strong"><strong>Saving to: 'vagrant_1.8.5_x86_64.deb'</strong></span>
<span class="strong"><strong>100%[============================================================&#13;
================================&gt;] 76,325,224   104MB/s   in 0.7s</strong></span>
<span class="strong"><strong>2016-09-26 21:11:57 (104 MB/s) - 'vagrant_1.8.5_x86_64.deb' saved [76325224/76325224]</strong></span>
<span class="strong"><strong>root@ubuntu:/usr/src#</strong></span>
</pre><p>Installing the package is trivial:</p><pre class="programlisting">
<span class="strong"><strong>root@ubuntu:/usr/src# dpkg --install vagrant_1.8.5_x86_64.deb</strong></span>
<span class="strong"><strong>Selecting previously unselected package vagrant.</strong></span>
<span class="strong"><strong>(Reading database ... 60326 files and directories currently installed.)</strong></span>
<span class="strong"><strong>Preparing to unpack vagrant_1.8.5_x86_64.deb ...</strong></span>
<span class="strong"><strong>Unpacking vagrant (1:1.8.5) ...</strong></span>
<span class="strong"><strong>Setting up vagrant (1:1.8.5) ...</strong></span>
<span class="strong"><strong>root@ubuntu:/usr/src#</strong></span>
</pre><p>On CentOS, the steps are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Run the following command for downloading and installing Vagrant:<pre class="programlisting">
<span class="strong"><strong>      [root@centos ~]# cd /usr/src/</strong></span>
<span class="strong"><strong>      [root@centossrc]# wget   &#13;
      https://releases.hashicorp.com/vagrant/1.8.5/&#13;
      vagrant_1.8.5_x86_64.rpm</strong></span>
<span class="strong"><strong>--2016-09-26 21:16:06-- &#13;
      https://releases.hashicorp.com/vagrant/1.8.5/&#13;
      vagrant_1.8.5_x86_64.rpm</strong></span>
<span class="strong"><strong>      Resolving releases.hashicorp.com (releases.hashicorp.com)...     &#13;
      151.101.44.69</strong></span>
<span class="strong"><strong>      Connecting to releases.hashicorp.com       &#13;
      (releases.hashicorp.com)|151.101.44.69|:443... connected.</strong></span>
<span class="strong"><strong>      HTTP request sent, awaiting response... 200 OK</strong></span>
<span class="strong"><strong>      Length: 75955433 (72M) []</strong></span>
<span class="strong"><strong>      Saving to: 'vagrant_1.8.5_x86_64.rpm'</strong></span>
<span class="strong"><strong>      100%   &#13;
      [========================================================&#13;
      =====================================&gt;] &#13;
      75,955,433  104MB/s   in 0.7s</strong></span>
<span class="strong"><strong>      2016-09-26 21:16:07 (104 MB/s) - 'vagrant_1.8.5_x86_64.rpm' saved &#13;
      [75955433/75955433]</strong></span>
<span class="strong"><strong>      [root@centossrc]# rpm --install vagrant_1.8.5_x86_64.rpm</strong></span>
</pre></li><li class="listitem">Next, create a new bridge if it does not already exist, for LXC to attach to:<pre class="programlisting">
<span class="strong"><strong>      [root@centossrc]# brctladdbr lxcbr0</strong></span>
</pre></li><li class="listitem">It's time to install the LXC plugin:<pre class="programlisting">
<span class="strong"><strong>      root@ubuntu:/usr/src# vagrant plugin install vagrant-lxc</strong></span>
<span class="strong"><strong>      Installing the 'vagrant-lxc' plugin. This can take a few minutes...</strong></span>
<span class="strong"><strong>      Installed the plugin 'vagrant-lxc (1.2.1)'!</strong></span>
<span class="strong"><strong>      root@ubuntu:/usr/src#</strong></span>
</pre></li><li class="listitem">If all went well, list the installed Vagrant plugins:<pre class="programlisting">
<span class="strong"><strong>      root@ubuntu:/usr/src# vagrant plugin list</strong></span>
<span class="strong"><strong>      vagrant-lxc (1.2.1)</strong></span>
<span class="strong"><strong>      vagrant-share (1.1.5, system)</strong></span>
<span class="strong"><strong>      root@ubuntu:/usr/src#</strong></span>
</pre></li><li class="listitem">With the LXC plugin installed, create a new project directory:<pre class="programlisting">
<span class="strong"><strong>      root@ubuntu:/usr/src# mkdirmy_project</strong></span>
<span class="strong"><strong>      root@ubuntu:/usr/src# cd my_project/</strong></span>
</pre></li><li class="listitem">Next, initialize a new Vagrant environment by specifying the type of box, or virtual machine image we are going to use. In the following example, we are going to use the Ubuntu Precise LXC image from the <code class="literal">fgremh</code> repository:<pre class="programlisting">
<span class="strong"><strong>root@ubuntu:/usr/src/my_project# vagrant init fgrehm/precise64-lxc</strong></span>
<span class="strong"><strong>A `Vagrantfile` has been placed in this directory. You are now</strong></span>
<span class="strong"><strong>ready to `vagrant up` your first virtual environment! Please read</strong></span>
<span class="strong"><strong>the comments in the Vagrantfile as well as documentation on</strong></span>
<span class="strong"><strong>`vagrantup.com` for more information on using Vagrant.</strong></span>
<span class="strong"><strong>root@ubuntu:/usr/src/my_project#</strong></span>
</pre><p>As the output indicates, a new <code class="literal">Vagrantfile</code> was created in the project directory:</p><pre class="programlisting">
<span class="strong"><strong>root@ubuntu:/usr/src/my_project# ls -alh</strong></span>
<span class="strong"><strong>total 12K</strong></span>
<span class="strong"><strong>drwxr-xr-x 2 root root 4.0K Sep 26 21:45 .</strong></span>
<span class="strong"><strong>drwxr-xr-x 5 root root 4.0K Sep 26 21:18 ..</strong></span>
<span class="strong"><strong>-rw-r--r-- 1 root root 3.0K Sep 26 21:45 Vagrantfile</strong></span>
<span class="strong"><strong>root@ubuntu:/usr/src/my_project#</strong></span>
</pre><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>For a list of Vagrant boxes you can visit: <a class="ulink" href="https://atlas.hashicorp.com/boxes/search">https://atlas.hashicorp.com/boxes/search</a>.</p></div></div><p>Let's take a look at <code class="literal">Vagrantfile</code>:</p><pre class="programlisting">
<span class="strong"><strong>      root@ubuntu:/usr/src/my_project# cat Vagrantfile | grep -v "#" &#13;
      | sed '/^$/d'</strong></span>
<span class="strong"><strong>Vagrant.configure("2") do |config|</strong></span>
<span class="strong"><strong>config.vm.box = "fgrehm/precise64-lxc"</strong></span>
<span class="strong"><strong>end</strong></span>
<span class="strong"><strong>root@ubuntu:/usr/src/my_project#</strong></span>
</pre></li><li class="listitem">The configuration is very minimal, specifying the image that the Vagrant machine will use. Let's start the container, by explicitly specifying the provider:<pre class="programlisting">
<span class="strong"><strong>root@ubuntu:/usr/src/my_project# vagrant up --provider=lxc</strong></span>
<span class="strong"><strong>Bringing machine 'default' up with 'lxc' provider...</strong></span>
<span class="strong"><strong>==&gt;default: Importing base box 'fgrehm/precise64-lxc'...</strong></span>
<span class="strong"><strong>==&gt;default: Checking if box 'fgrehm/precise64-lxc' is up to date...</strong></span>
<span class="strong"><strong>==&gt;default: Setting up mount entries for shared folders...</strong></span>
<span class="strong"><strong>default: /vagrant =&gt; /usr/src/my_project</strong></span>
<span class="strong"><strong>==&gt;default: Starting container...</strong></span>
<span class="strong"><strong>==&gt;default: Waiting for machine to boot. This may take a few &#13;
      minutes...</strong></span>
<span class="strong"><strong>default: SSH address: 10.0.3.181:22</strong></span>
<span class="strong"><strong>default: SSH username: vagrant</strong></span>
<span class="strong"><strong>default: SSH auth method: private key</strong></span>
<span class="strong"><strong>default:</strong></span>
<span class="strong"><strong>default: Vagrant insecure key detected. Vagrant will automatically &#13;
      replace</strong></span>
<span class="strong"><strong>default: this with a newly generated keypair for better security.</strong></span>
<span class="strong"><strong>default:</strong></span>
<span class="strong"><strong>default: Inserting generated public key within guest...</strong></span>
<span class="strong"><strong>default: Removing insecure key from the guest if it's present...</strong></span>
<span class="strong"><strong>default: Key inserted! Disconnecting and reconnecting using new SSH &#13;
      key...</strong></span>
<span class="strong"><strong>==&gt;default: Machine booted and ready!</strong></span>
<span class="strong"><strong>root@ubuntu:/usr/src/my_project#</strong></span>
</pre></li><li class="listitem">To verify that we have a running LXC container, execute the following on the command line:<pre class="programlisting">
<span class="strong"><strong>root@ubuntu:/usr/src/my_project# lxc-ls -f</strong></span>
<span class="strong"><strong>NAME                      STATE   AUTOSTART GROUPS IPV4      IPV6</strong></span>
<span class="strong"><strong>my_project_default_1474926399170_41712 RUNNING 0         -      &#13;
      10.0.3.80 -</strong></span>
<span class="strong"><strong>root@ubuntu:/usr/src/my_project#</strong></span>
</pre></li><li class="listitem">Let's check the status of the Vagrant machine:<pre class="programlisting">
<span class="strong"><strong>root@ubuntu:/usr/src/my_project# vagrant status</strong></span>
<span class="strong"><strong>Current machine states:</strong></span>
<span class="strong"><strong>default                   running (lxc)</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>root@ubuntu:/usr/src/my_project#</strong></span>
</pre></li><li class="listitem">To connect to the LXC container, run the following:<pre class="programlisting">
<span class="strong"><strong>root@ubuntu:/usr/src/my_project# vagrant ssh</strong></span>
<span class="strong"><strong>Welcome to Ubuntu 12.04.5 LTS (GNU/Linux 3.13.0-91-generic x86_64)</strong></span>
<span class="strong"><strong>   * Documentation:  https://help.ubuntu.com/</strong></span>
<span class="strong"><strong>vagrant@vagrant-base-precise-amd64:~$ ps ax</strong></span>
<span class="strong"><strong>    PID TTY      STAT   TIME COMMAND</strong></span>
<span class="strong"><strong>1 ?Ss     0:00 /sbin/init</strong></span>
<span class="strong"><strong>194 ?        S      0:00 upstart-socket-bridge --daemon</strong></span>
<span class="strong"><strong>2630 ?        S      0:00 upstart-udev-bridge --daemon</strong></span>
<span class="strong"><strong>2653 ?Ss     0:00 /sbin/udevd --daemon</strong></span>
<span class="strong"><strong>2672 ?Sl     0:00 rsyslogd -c5</strong></span>
<span class="strong"><strong>2674 ?Ss     0:00 rpcbind -w</strong></span>
<span class="strong"><strong>2697 ?Ss     0:00 rpc.statd -L</strong></span>
<span class="strong"><strong>2830 ?Ss     0:00 dhclient3 -e IF_METRIC=100 -pf &#13;
      /var/run/dhclient.eth0.pid -lf &#13;
      /var/lib/dhcp/dhclient.eth0.leases -1 eth0</strong></span>
<span class="strong"><strong>2852 ?Ss     0:00 /usr/sbin/sshd -D</strong></span>
<span class="strong"><strong>2888 ?Ss     0:00 cron</strong></span>
<span class="strong"><strong>3259 ?Ss     0:00 /sbin/getty -8 38400 tty4</strong></span>
<span class="strong"><strong>3260 ?Ss     0:00 /sbin/getty -8 38400 tty2</strong></span>
<span class="strong"><strong>3261 ?Ss     0:00 /sbin/getty -8 38400 tty3</strong></span>
<span class="strong"><strong>3262 ?Ss     0:00 /sbin/getty -8 38400 console</strong></span>
<span class="strong"><strong>3263 ?Ss     0:00 /sbin/getty -8 38400 tty1</strong></span>
<span class="strong"><strong>3266 ?Ss     0:00 sshd: vagrant [priv]</strong></span>
<span class="strong"><strong>3278 ?        S      0:00 sshd: vagrant@pts/9</strong></span>
<span class="strong"><strong>   3279 pts/9    Ss     0:00 -bash</strong></span>
<span class="strong"><strong>   3305 pts/9    R+     0:00ps ax</strong></span>
<span class="strong"><strong>vagrant@vagrant-base-precise-amd64:~$ exit</strong></span>
<span class="strong"><strong>logout</strong></span>
<span class="strong"><strong>Connection to 10.0.3.181 closed.</strong></span>
<span class="strong"><strong>root@ubuntu:/usr/src/my_project#</strong></span>
</pre></li></ol></div><div class="section" title="Configuring Vagrant LXC"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec49"/>Configuring Vagrant LXC</h2></div></div></div><p>The <code class="literal">Vagrantfile</code> is very well documented, but here's a brief example on how to customize the Vagrant machine by specifying the amount of memory available to the LXC container:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Stop the running Vagrant machine:<pre class="programlisting">
<span class="strong"><strong>root@ubuntu:/usr/src/my_project# vagrant halt</strong></span>
<span class="strong"><strong>==&gt;default: Attempting graceful shutdown of VM...</strong></span>
<span class="strong"><strong>root@ubuntu:/usr/src/my_project#</strong></span>
</pre></li><li class="listitem">Edit <code class="literal">Vagrantfile</code> and set the <code class="literal">cgroup.memory.limit_in_bytes</code> cgroup limit. The new config should looks like this:<pre class="programlisting">
<span class="strong"><strong>root@ubuntu:/usr/src/my_project# vim Vagrantfile</strong></span>
<span class="strong"><strong>Vagrant.configure("2") do |config|</strong></span>
<span class="strong"><strong>config.vm.box = "fgrehm/trusty64-lxc"</strong></span>
<span class="strong"><strong>config.vm.provider :lxc do |lxc|</strong></span>
<span class="strong"><strong>lxc.customize 'cgroup.memory.limit_in_bytes', '1024M'</strong></span>
<span class="strong"><strong>end</strong></span>
<span class="strong"><strong>end</strong></span>
<span class="strong"><strong>root@ubuntu:/usr/src/my_project#</strong></span>
</pre></li><li class="listitem">Save the file and start back the Vagrant machine:<pre class="programlisting">
<span class="strong"><strong>root@ubuntu:/usr/src/my_project# vagrant up --provider=lxc</strong></span>
<span class="strong"><strong>Bringing machine 'default' up with 'lxc' provider...</strong></span>
<span class="strong"><strong>==&gt;default: Setting up mount entries for shared folders...</strong></span>
<span class="strong"><strong>default: /vagrant =&gt; /usr/src/my_project</strong></span>
<span class="strong"><strong>==&gt;default: Starting container...</strong></span>
<span class="strong"><strong>==&gt;default: Waiting for machine to boot. This may take a few &#13;
      minutes...</strong></span>
<span class="strong"><strong>default: SSH address: 10.0.3.181:22</strong></span>
<span class="strong"><strong>default: SSH username: vagrant</strong></span>
<span class="strong"><strong>default: SSH auth method: private key</strong></span>
<span class="strong"><strong>==&gt;default: Machine booted and ready!</strong></span>
<span class="strong"><strong>==&gt;default: Machine already provisioned. Run `vagrant provision` or &#13;
      use the `--provision`</strong></span>
<span class="strong"><strong>==&gt;default: flag to force provisioning. Provisioners marked to run &#13;
      always will still run.</strong></span>
<span class="strong"><strong>root@ubuntu:/usr/src/my_project#</strong></span>
</pre></li><li class="listitem">Verify that the cgroup limit was applied:<pre class="programlisting">
<span class="strong"><strong>root@ubuntu:/usr/src/my_project# cat /sys/fs/cgroup/memory/lxc/ &#13;
      my_project_default_1474926399170_41712/memory.limit_in_bytes</strong></span>
<span class="strong"><strong>1073741824</strong></span>
<span class="strong"><strong>root@ubuntu:/usr/src/my_project#</strong></span>
</pre></li><li class="listitem">Finally, let's clean up by deleting all remnants of the Vagrant machine:<pre class="programlisting">
<span class="strong"><strong>root@ubuntu:/usr/src/my_project# vagrant destroy</strong></span>
<span class="strong"><strong>default: Are you sure you want to destroy the 'default' VM? [y/N] y</strong></span>
<span class="strong"><strong>==&gt;default: Forcing shutdown of container...</strong></span>
<span class="strong"><strong>==&gt;default: Destroying VM and associated drives...</strong></span>
<span class="strong"><strong>root@ubuntu:/usr/src/my_project# lxc-ls -f</strong></span>
<span class="strong"><strong>NAME                    STATE   AUTOSTART GROUPS IPV4 IPV6</strong></span>
<span class="strong"><strong>root@ubuntu:/usr/src/my_project#</strong></span>
</pre></li></ol></div></div></div>
<div class="section" title="Putting it all together &#x2013; building a simple RESTful API to LXC with Python"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Putting it all together – building a simple RESTful API to LXC with Python</h1></div></div></div><p>With all the knowledge we have in hand by experimenting with the LXC bindings for Python earlier, we can write a simple RESTful API that will build, manage, and destroy LXC containers.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>To keep the code as simple as possible, we are going to skip all error and exception handling and any input validation from the program.</p></div></div><p>One of the simplest Python web frameworks for building APIs is Bottle. Let's install it first:</p><pre class="programlisting">
<span class="strong"><strong>root@ubuntu:~# source lxc_python/bin/activate</strong></span>
<span class="strong"><strong>(lxc_python) root@ubuntu:~# pip install bottle</strong></span>
<span class="strong"><strong>Collecting bottle</strong></span>
<span class="strong"><strong>  Downloading bottle-0.12.9.tar.gz (69kB)</strong></span>
<span class="strong"><strong>    100% |████████████████████████████████| 71kB 7.1MB/s</strong></span>
<span class="strong"><strong>Building wheels for collected packages: bottle</strong></span>
<span class="strong"><strong>  Running setup.py bdist_wheel for bottle ... done</strong></span>
<span class="strong"><strong>  Stored in directory: &#13;
/root/.cache/pip/wheels/6e/87/89/f7ddd6721f4a208d44f2dac02f281b2403a314dd735d2b0e61</strong></span>
<span class="strong"><strong>Successfully built bottle</strong></span>
<span class="strong"><strong>Installing collected packages: bottle</strong></span>
<span class="strong"><strong>Successfully installed bottle-0.12.9</strong></span>
<span class="strong"><strong>(lxc_python) root@ubuntu:~#</strong></span>
</pre><p>Make sure you have both the <code class="literal">bottle</code> and <code class="literal">lxc-python2</code> libraries installed before continuing:</p><pre class="programlisting">
<span class="strong"><strong>(lxc_python) root@ubuntu:~# pip freeze</strong></span>
<span class="strong"><strong>bottle==0.12.9</strong></span>
<span class="strong"><strong>lxc-python2==0.1</strong></span>
<span class="strong"><strong>(lxc_python) root@ubuntu:~#</strong></span>
</pre><p>Let's open the new <code class="literal">lxc_api.py</code> file and write the following code:</p><pre class="programlisting"><span class="strong"><strong>import lxc</strong></span>
<span class="strong"><strong>from bottle import run, request, get, post</strong></span>

<span class="strong"><strong>@get('/list')</strong></span>
<span class="strong"><strong>def list():</strong></span>
     <span class="strong"><strong>container_list = lxc.list_containers()</strong></span>

     <span class="strong"><strong>return "List of containers: {0}\n".format(container_list)</strong></span>
<span class="strong"><strong>run(host='localhost', port=8080, debug=True)</strong></span>
</pre><p>The <code class="literal">run</code> class provides the <code class="literal">run()</code> call, which starts a built-in server. In our example, the server will be listening on localhost, port <code class="literal">8080</code>. The <code class="literal">get()</code> decorator links the code from the function below it to an URL path. In the preceding code, the <code class="literal">/list</code> path is bound to the <code class="literal">list()</code> function. Of course, you are already familiar with the <code class="literal">list_containers()</code> method.</p><p>To test this simple API frontend, save the file and execute the program:</p><pre class="programlisting">
<span class="strong"><strong>(lxc_python) root@ubuntu:~# python lxc_api.py</strong></span>
<span class="strong"><strong>Bottle v0.12.9 server starting up (using WSGIRefServer())...</strong></span>
<span class="strong"><strong>Listening on http://localhost:8080/</strong></span>
<span class="strong"><strong>Hit Ctrl+C to quit. </strong></span>
</pre><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip24"/>Tip</h3><p>If you get the <code class="literal">socket.error: [Errno 98] Address already in use</code> error, there's another process that is bound to port <code class="literal">8080</code>. To fix this, simply change the port your Python application is listening on in the <code class="literal">run()</code> method.</p></div></div><p>In a separate terminal window, execute the following:</p><pre class="programlisting">
<span class="strong"><strong>root@ubuntu:~# curl localhost:8080/list</strong></span>
<span class="strong"><strong>List of containers: ()</strong></span>
<span class="strong"><strong>root@ubuntu:~#</strong></span>
</pre><p>It's just that simple; we created an API call to list LXC containers!</p><div class="section" title="API calls to build and configure LXC containers"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec50"/>API calls to build and configure LXC containers</h2></div></div></div><p>Let's expand the functionality a bit by adding the ability to build containers. Edit the file and add the following function:</p><pre class="programlisting">
<span class="strong"><strong>@post('/build')</strong></span>
<span class="strong"><strong>def build():</strong></span>
     <span class="strong"><strong>name = request.headers.get('X-LXC-Name')</strong></span>
     <span class="strong"><strong>template = str(request.headers.get('X-LXC-Template'))</strong></span>

     <span class="strong"><strong>container = lxc.Container(name)</strong></span>
     <span class="strong"><strong>container.create(template)</strong></span>
     <span class="strong"><strong>return "Building container {0} using the {1} template\n".format(&#13;
    name, template)</strong></span>
</pre><p>We are going to use the <code class="literal">@post</code> decorator in this case and the provided <code class="literal">headers.get()</code> method from the <code class="literal">request</code> class to get the custom headers that will contain the container and template names.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>For a complete API reference of the Bottle framework refer to <a class="ulink" href="http://bottlepy.org/docs/dev/api.html">http://bottlepy.org/docs/dev/api.html</a>.</p></div></div><p>Save the updated file and restart the program. Let's test the new call in the second terminal:</p><pre class="programlisting">
<span class="strong"><strong>root@ubuntu:~# curl -XPOST --header "X-LXC-Name: api_container" --header "X-LXC-  &#13;
Template: ubuntu" localhost:8080/build&#13;
 </strong></span>
<span class="strong"><strong>Building container api_container using the ubuntu template</strong></span>
<span class="strong"><strong>root@ubuntu:~#</strong></span>
</pre><p>We used the <code class="literal">--header</code> flags to pass the container and template names with <code class="literal">curl</code> as headers, using the <code class="literal">POST</code> verb. If you check the terminal where the application is running you can see the logs of the container being built, along with the HTTP route and the error code:</p><pre class="programlisting">
<span class="strong"><strong>Bottle v0.12.9 server starting up (using WSGIRefServer())...</strong></span>
<span class="strong"><strong>Listening on http://localhost:8080/</strong></span>
<span class="strong"><strong>Hit Ctrl-C to quit.</strong></span>
<span class="strong"><strong>Copying rootfs to /var/lib/lxc/api_container/rootfs ...</strong></span>
<span class="strong"><strong>Generating locales...</strong></span>
<span class="strong"><strong>en_US.UTF-8... up-to-date</strong></span>
<span class="strong"><strong>Generation complete.</strong></span>
<span class="strong"><strong>Creating SSH2 RSA key; this may take some time ...</strong></span>
<span class="strong"><strong>Creating SSH2 DSA key; this may take some time ...</strong></span>
<span class="strong"><strong>Creating SSH2 ECDSA key; this may take some time ...</strong></span>
<span class="strong"><strong>Creating SSH2 ED25519 key; this may take some time ...</strong></span>
<span class="strong"><strong>update-rc.d: warning: default stop runlevel arguments (0 1 6) do not match ssh  &#13;
Default-Stop values (none)</strong></span>
<span class="strong"><strong>invoke-rc.d: policy-rc.d denied execution of start.</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>127.0.0.1 - - [06/Oct/2016 21:36:10] "POST /build HTTP/1.1" 200 59</strong></span>
</pre><p>Let's use the <code class="literal">/list</code> route we defined earlier to list all containers:</p><pre class="programlisting">
<span class="strong"><strong>root@ubuntu:~# curl localhost:8080/list</strong></span>
<span class="strong"><strong>List of containers: (u'api_container',)</strong></span>
<span class="strong"><strong>root@ubuntu:~#</strong></span>
</pre><p>Great! We can now build and list containers. Let's create a new route that will start LXC. Add the following function to the <code class="literal">lxc_api.py</code> file:</p><pre class="programlisting">
<span class="strong"><strong>@post('/container/&lt;name&gt;/start')</strong></span>
<span class="strong"><strong>def container_start(name):</strong></span>
     <span class="strong"><strong>container = lxc.Container(name)</strong></span>
     <span class="strong"><strong>container.start(useinit = False, daemonize = True)</strong></span>

     <span class="strong"><strong>return "Starting container {0}\n".format(name)</strong></span>
</pre><p>We are using the <code class="literal">POST</code> decorator again and a dynamic route. The dynamic route consists of a name, in our example called <code class="literal">&lt;name&gt;</code>, which will hold whatever string value we pass to the route with the <code class="literal">curl</code> command. The method that is bound to the <code class="literal">container_start(name)</code> route also accepts a variable with the same name. Save the changes, restart the application, and execute the following:</p><pre class="programlisting">
<span class="strong"><strong>root@ubuntu:~# curl -XPOST localhost:8080/container/api_container/start</strong></span>
<span class="strong"><strong>Starting container api_container</strong></span>
<span class="strong"><strong>root@ubuntu:~#</strong></span>
</pre><p>We passed <code class="literal">api_container</code> in the URL, and the route we defined was able to match it and pass it as a variable to the <code class="literal">container_start</code> function.</p><p>Our simple API does not yet provide a route to get the status of a container, so let's ensure it's really running:</p><pre class="programlisting">
<span class="strong"><strong>root@ubuntu:~# lxc-ls -f</strong></span>
<span class="strong"><strong>NAME          STATE   AUTOSTART GROUPS IPV4       IPV6</strong></span>
<span class="strong"><strong>api_container RUNNING 0         -      10.0.3.198 -</strong></span>
<span class="strong"><strong>root@ubuntu:~#</strong></span>
</pre><p>Let's add a <code class="literal">state</code> call to our API:</p><pre class="programlisting">
<span class="strong"><strong>@get('/container/&lt;name&gt;/state')</strong></span>
<span class="strong"><strong>def container_status(name):</strong></span>
     <span class="strong"><strong>container = lxc.Container(name)</strong></span>
     <span class="strong"><strong>state = container.state</strong></span>

     <span class="strong"><strong>return "The state of container {0} is {1}\n".format(name, state)</strong></span>
</pre><p>This time we are using the <code class="literal">@get</code> decorator and calling the <code class="literal">state()</code> method on the <code class="literal">container</code> object. Let's test the new route:</p><pre class="programlisting">
<span class="strong"><strong>root@ubuntu:~# curl localhost:8080/container/api_container/state</strong></span>
<span class="strong"><strong>The state of container api_container is RUNNING</strong></span>
<span class="strong"><strong>root@ubuntu:~#</strong></span>
</pre><p>Now that we have a running container, let's add the functionality to list its IP address:</p><pre class="programlisting">
<span class="strong"><strong>@get('/container/&lt;name&gt;/ips')</strong></span>
<span class="strong"><strong>def container_status(name):</strong></span>
     <span class="strong"><strong>container = lxc.Container(name)</strong></span>
     <span class="strong"><strong>ip_list = container.get_ips()</strong></span>
     <span class="strong"><strong>return "Container {0} has the following IP's {1}\n".format(&#13;
     name, ip_list)</strong></span>
</pre><p>There is nothing new to note here, so let's see what we get back:</p><pre class="programlisting">
<span class="strong"><strong>root@ubuntu:~# curl localhost:8080/container/api_container/ips</strong></span>
<span class="strong"><strong>Container api_container has the following IP's (u'10.0.3.198',)</strong></span>
<span class="strong"><strong>root@ubuntu:~#</strong></span>
</pre><p>We saw how to freeze and unfreeze containers earlier in this chapter; let's now add that functionality to our API:</p><pre class="programlisting">
<span class="strong"><strong>@post('/container/&lt;name&gt;/freeze')</strong></span>
<span class="strong"><strong>def container_start(name):</strong></span>
     <span class="strong"><strong>container = lxc.Container(name)</strong></span>
     <span class="strong"><strong>container.freeze()</strong></span>
     <span class="strong"><strong>return "Freezing container {0}\n".format(name)</strong></span>

<span class="strong"><strong>@post('/container/&lt;name&gt;/unfreeze')</strong></span>
<span class="strong"><strong>def container_start(name):</strong></span>
     <span class="strong"><strong>container = lxc.Container(name)</strong></span>
     <span class="strong"><strong>container.unfreeze()</strong></span>
     <span class="strong"><strong>return "Unfreezing container {0}\n".format(name)</strong></span>
</pre><p>The <code class="literal">POST</code> verb makes more sense here, since we are making changes to the state of the container. Let's freeze the container and check its state:</p><pre class="programlisting">
<span class="strong"><strong>root@ubuntu:~# curl -XPOST localhost:8080/container/api_container/freeze</strong></span>
<span class="strong"><strong>Freezing container api_container</strong></span>
<span class="strong"><strong>root@ubuntu:~# curl localhost:8080/container/api_container/state</strong></span>
<span class="strong"><strong>The state of container api_container is FROZEN</strong></span>
<span class="strong"><strong>root@ubuntu:~# lxc-ls -f</strong></span>
<span class="strong"><strong>NAME          STATE  AUTOSTART GROUPS IPV4       IPV6</strong></span>
<span class="strong"><strong>api_container FROZEN 0         -      10.0.3.198 -</strong></span>
<span class="strong"><strong>root@ubuntu:~#</strong></span>
</pre><p>Finally, let's unfreeze it with the new API call we made:</p><pre class="programlisting">
<span class="strong"><strong>root@ubuntu:~# curl -XPOST localhost:8080/container/api_container/unfreeze</strong></span>
<span class="strong"><strong>Unfreezing container api_container</strong></span>
<span class="strong"><strong>root@ubuntu:~# curl localhost:8080/container/api_container/state</strong></span>
<span class="strong"><strong>The state of container api_container is RUNNING</strong></span>
<span class="strong"><strong>root@ubuntu:~# lxc-ls -f</strong></span>
<span class="strong"><strong>NAME          STATE   AUTOSTART GROUPS IPV4       IPV6</strong></span>
<span class="strong"><strong>api_container RUNNING 0         -      10.0.3.198 -</strong></span>
<span class="strong"><strong>root@ubuntu:~#</strong></span>
</pre><p>Next, as a conclusion, let's write two new functions to stop and delete the container:</p><pre class="programlisting">
<span class="strong"><strong>@post('/container/&lt;name&gt;/stop')</strong></span>
<span class="strong"><strong>def container_start(name):</strong></span>
     <span class="strong"><strong>container = lxc.Container(name)</strong></span>
     <span class="strong"><strong>container.stop()</strong></span>

     <span class="strong"><strong>return "Stopping container {0}\n".format(name)</strong></span>

<span class="strong"><strong>@post('/container/&lt;name&gt;/destroy')</strong></span>
<span class="strong"><strong>def container_start(name):</strong></span>
     <span class="strong"><strong>container = lxc.Container(name)</strong></span>
     <span class="strong"><strong>container.destroy()&#13;</strong></span>

     <span class="strong"><strong>return "Destroying container {0}\n".format(name)</strong></span>
</pre><p>All the methods we've used so far, we've tested earlier in this chapter; feel free to refer back to their description as needed.</p></div><div class="section" title="Cleaning up using the API calls"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec51"/>Cleaning up using the API calls</h2></div></div></div><p>It's time to clean up, by calling the <code class="literal">stop</code> API route:</p><pre class="programlisting">
<span class="strong"><strong>root@ubuntu:~# curl -XPOST localhost:8080/container/api_container/stop</strong></span>
<span class="strong"><strong>Stopping container api_container&#13;</strong></span>
<span class="strong"><strong>root@ubuntu:~# curl localhost:8080/container/api_container/state</strong></span>
<span class="strong"><strong>The state of container api_container is STOPPED</strong></span>
<span class="strong"><strong>root@ubuntu:~#</strong></span>
</pre><p>The console with the running application should show something similar to this after making all the preceding API calls:</p><pre class="programlisting">
<span class="strong"><strong>127.0.0.1 - - [06/Oct/2016 22:00:08] "GET /container/api_container/state HTTP/1.1" 200 48</strong></span>
<span class="strong"><strong>127.0.0.1 - - [06/Oct/2016 22:02:45] "GET /container/api_container/ips HTTP/1.1" 200 64</strong></span>
<span class="strong"><strong>127.0.0.1 - - [06/Oct/2016 22:08:14] "POST /container/api_container/freeze HTTP/1.1" 200 33</strong></span>
<span class="strong"><strong>127.0.0.1 - - [06/Oct/2016 22:08:19] "GET /container/api_container/state HTTP/1.1" 200 47</strong></span>
<span class="strong"><strong>127.0.0.1 - - [06/Oct/2016 22:08:30] "POST /container/api_container/unfreeze HTTP/1.1" 200 35</strong></span>
<span class="strong"><strong>127.0.0.1 - - [06/Oct/2016 22:08:32] "GET /container/api_container/state HTTP/1.1" 200 48</strong></span>
<span class="strong"><strong>127.0.0.1 - - [06/Oct/2016 22:18:39] "POST /container/api_container/stop HTTP/1.1" 200 33</strong></span>
<span class="strong"><strong>127.0.0.1 - - [06/Oct/2016 22:18:41] "GET /container/api_container/state HTTP/1.1" 200 48</strong></span>
</pre><p>Finally, let's destroy the container:</p><pre class="programlisting">
<span class="strong"><strong>root@ubuntu:~# curl -XPOST localhost:8080/container/api_container/destroy</strong></span>
<span class="strong"><strong>Destroying container api_container</strong></span>
<span class="strong"><strong>root@ubuntu:~# lxc-ls -f</strong></span>
<span class="strong"><strong>root@ubuntu:~#</strong></span>
</pre><p>We can easily add all the LXC Python methods we experimented with earlier, by following the same pattern – just remember to catch all exceptions and validate the input.</p><p>Here's the entire program:</p><pre class="programlisting"><span class="strong"><strong>import lxc</strong></span>
<span class="strong"><strong>from bottle import run, request, get, post</strong></span>
<span class="strong"><strong>@post('/build')</strong></span>
<span class="strong"><strong>def build():</strong></span>
<span class="strong"><strong>     name = request.headers.get('X-LXC-Name')</strong></span>
<span class="strong"><strong>     memory = request.headers.get('X-LXC-Memory')</strong></span>
<span class="strong"><strong>     template = str(request.headers.get('X-LXC-Template'))</strong></span>

<span class="strong"><strong>     container = lxc.Container(name)</strong></span>
<span class="strong"><strong>     container.create(template)</strong></span>

<span class="strong"><strong>     return "Building container {0} using the {1} template\n".format(&#13;
    name, template)</strong></span>

<span class="strong"><strong>@post('/container/&lt;name&gt;/start')</strong></span>
<span class="strong"><strong>def container_start(name):</strong></span>
<span class="strong"><strong>     container = lxc.Container(name)</strong></span>
<span class="strong"><strong>     container.start(useinit=False, daemonize=True)</strong></span>

<span class="strong"><strong>     return "Starting container {0}\n".format(name)</strong></span>

<span class="strong"><strong>@post('/container/&lt;name&gt;/stop')</strong></span>
<span class="strong"><strong>def container_start(name):</strong></span>
<span class="strong"><strong>     container = lxc.Container(name)</strong></span>
<span class="strong"><strong>     container.stop()</strong></span>

<span class="strong"><strong>     return "Stopping container {0}\n".format(name)</strong></span>

<span class="strong"><strong>@post('/container/&lt;name&gt;/destroy')</strong></span>
<span class="strong"><strong>def container_start(name):</strong></span>
<span class="strong"><strong>     container = lxc.Container(name)</strong></span>
<span class="strong"><strong>     container.destroy()</strong></span>

<span class="strong"><strong>     return "Destroying container {0}\n".format(name)</strong></span>

<span class="strong"><strong>@post('/container/&lt;name&gt;/freeze')</strong></span>
<span class="strong"><strong>def container_start(name):</strong></span>
<span class="strong"><strong>     container = lxc.Container(name)</strong></span>
<span class="strong"><strong>     container.freeze()</strong></span>

<span class="strong"><strong>     return "Freezing container {0}\n".format(name)</strong></span>

<span class="strong"><strong>@post('/container/&lt;name&gt;/unfreeze')</strong></span>
<span class="strong"><strong>def container_start(name):</strong></span>
<span class="strong"><strong>     container = lxc.Container(name)</strong></span>
<span class="strong"><strong>     container.unfreeze()</strong></span>

<span class="strong"><strong>     return "Unfreezing container {0}\n".format(name)</strong></span>

<span class="strong"><strong>@get('/container/&lt;name&gt;/state')</strong></span>
<span class="strong"><strong>def container_status(name):</strong></span>
<span class="strong"><strong>     container = lxc.Container(name)</strong></span>
<span class="strong"><strong>     state = container.state</strong></span>

<span class="strong"><strong>return "The state of container {0} is {1}\n".format(name, state)</strong></span>

<span class="strong"><strong>@get('/container/&lt;name&gt;/ips')</strong></span>
<span class="strong"><strong>def container_status(name):</strong></span>
<span class="strong"><strong>     container = lxc.Container(name)</strong></span>
<span class="strong"><strong>     ip_list = container.get_ips()</strong></span>

<span class="strong"><strong>return "Container {0} has the following IP's {1}\n".format(&#13;
    name, ip_list)</strong></span>

 <span class="strong"><strong>@get('/list')</strong></span>
<span class="strong"><strong>def list():</strong></span>
<span class="strong"><strong>     container_list = lxc.list_containers()</strong></span>

<span class="strong"><strong>     return "List of containers: {0}\n".format(container_list)</strong></span>

<span class="strong"><strong>run(host='localhost', port=8080, debug=True)</strong></span>
</pre></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Summary</h1></div></div></div><p>The bindings for Python provided by the LXC and libvirt APIs are a great way to programmatically create and manage LXC containers.</p><p>In this chapter, we explored both sets of Python bindings, by writing simple code snippets that implement most of the functions provided by the userspace tools. In fact, the best way to learn about those APIs is to look at the source code of the command-line tools, although they are implemented in C.</p><p>We had a brief introduction in how to provision LXC with Vagrant for testing your code in isolation. We ended the chapter with a working implementation of a simple RESTful API that uses some of the methods we explored earlier to provision, manage, and destroy LXC. In <a class="link" href="ch05.html" title="Chapter 5. Networking in LXC with the Linux Bridge and Open vSwitch"><span>Chapter 5</span></a>, <span class="emphasis"><em>Networking in LXC with the Linux Bridge and Open vSwitch</em></span>, we'll explore the networking aspects of LXC, using the Linux bridge, Open vSwitch in NAT, and direct routing modes, and look into examples of how to interconnect containers and the host OS.</p></div></body></html>