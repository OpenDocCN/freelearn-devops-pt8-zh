<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Introducing Lightweight Functions</h1>
                </header>
            
            <article>
                
<p>Following on from a general introduction to <strong>Google App Engine</strong> (<strong>GAE</strong>), we can now turn our attention to fully managed event processing. In this chapter, we will start working with Google Compute Engine and discover how to integrate serverless operational management tools in our<span> environment. More specifically, coverage of event processing including Cloud Functions begins here.</span></p>
<p>This chapter will begin with a quick overview of Cloud Scheduler and Cloud Tasks, which are services that provide support to Google Cloud, followed by an introduction to Cloud Functions, after which we will develop a small application to utilize these services. </p>
<p><span>Throughout this chapter, </span>we will discuss the following topics:</p>
<ul>
<li>Operational management tools</li>
<li>Cloud Tasks and Cloud Scheduler</li>
<li>An introduction to Cloud Functions</li>
<li>Developing a Cloud Functions application</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p><span>In order to complete the exercises in this chapter, you will require a Google Cloud project or a Qwiklabs account.</span></p>
<p>You <span>can find the code files for this chapter in the GitHub repository for the book in the <kbd>ch03</kbd> subdirectory at <a href="https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch03">https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch03</a></span>.</p>
<div class="packt_infobox"><span>While you are going through code snippets in the book, you will notice that, in a few instances, a few lines from the code/output have been removed and replaced with ellipses (<kbd>...</kbd>). The use of ellipses only serves to show relevant code/output. The complete code is available on GitHub at the preceding link.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Operational management tools</h1>
                </header>
            
            <article>
                
<p class="mce-root">Being capable of responding to externally generated events provides a flexible mechanism on which to build systems that can be easily scaled and augmented. Consider how you might design a solution to create a thumbnail image based on the submission of a graphical representation. First, we need some disk storage to hold the image, then we need to process the image to generate a thumbnail, and then we need some more disk storage to keep the output.</p>
<p class="mce-root">Each stage of this activity requires a state change and response. The state change is a notification tied to the service call to indicate the state of the resource; for example, an image has been deposited, a picture has changed, or processing has completed.</p>
<p class="mce-root">In the example of Cloud Functions (introduced later in this chapter), an event triggers a new item deposit in <strong>Google Cloud Storage</strong> (<strong>GCS</strong>). The function is alerted by an event trigger and can then perform a series of instructions in reaction to this event. At the outset of these instructions, the transformed image (now a thumbnail) is made available to the end user.</p>
<p class="mce-root">At this point, <span>having been through the earlier chapters based on GAE, </span>you will already have some familiarity with Cloud Tasks. It is always important to consider the objective before selecting a service. Taking this step will tell you whether the technology is appropriate for your needs.</p>
<p class="mce-root">As a result, this section will not be a detailed exploration, as these are ancillary services that enable serverless workloads on Google Cloud. Instead, we will include an overview of the critical points to provide the context and likely use cases. In this way, working through this section should help intelligent decisions to be made regarding the appropriateness of incorporating these services. In many instances, there will be grey areas, as well as circumstances in which there is no clear choice. Thankfully, these situations will be outliers, and we can, therefore, generalize to a large extent on how to address these rate type of circumstances. Our discussion begins with Cloud Tasks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cloud Tasks</h1>
                </header>
            
            <article>
                
<p>We have already reviewed the benefits of using Cloud Tasks with GAE in <a href="75f69d9a-2ac4-4f8c-9cbf-aa8928c327cb.xhtml" target="_blank">Chapter 1</a>, <em>Introducing App Engine</em> and <a href="ff73be02-51ed-4f9a-9181-5cd14fc8bd51.xhtml" target="_blank">Chapter 2</a>,<em> Developing with App Engine</em>. <span>Many of these advantages remain when working with HTTP targets, for example, decreased application latency by offloading long-lived requests to a worker, or minimizing traffic spikes in user-facing tasks.</span></p>
<p>Distributed tasks on Google Cloud have their service dedicated to managing the execution, dispatch, and delivery of jobs. The idea here is that it is preferable to be able to offload, isolate, and manage HTTP requests to minimize latency. This asynchronous workflow is especially useful when dealing with user-facing applications that require responsive interfaces. The message payload request made for the task must include POST or PUT as the HTTP method to be processed with this method.</p>
<p>Cloud Tasks provides several benefits beyond the advantage of asynchronously offloading tasks. Also, it allows the developer to configure the various properties associated with the transmission of data. This could include sophisticated policies such as the application of retries or rate limits established on any data contract created.</p>
<p>In brief, the following elements are vital characteristics of Cloud Tasks and provide a compelling reason to use this service:</p>
<ul>
<li><span>Async task offload</span></li>
<li><span>Configurable retry policy</span></li>
<li><span>Configurable rate limit</span></li>
<li><span>Deferred scheduling</span></li>
<li><span>Decouple services</span></li>
<li><span>Increase resilience against failure</span></li>
<li><span>Scalable and fully managed</span></li>
<li><span>HTTP targets</span></li>
<li><span>Guaranteed delivery</span></li>
<li><span>Supports several popular languages</span></li>
</ul>
<p>By building a queue of data elements, Cloud Tasks establishes an efficient way for workers to process information. Each queue is subject to rate limits, which determine how many tasks will be <span>executed </span>per queue. Due to the guaranteed delivery mechanism applied, there will be a retry if the response to the message published is not adequate for the application. In general, response codes follow HTTP norms, with a status code in the 2xx range indicating success.</p>
<p>Distributed task queues make applications more responsive when performing async execution. Task queues are capable of organizing and controlling requests by exploiting key product features such as scheduling, de-deduplication, retry policy, and version redirection.</p>
<p>Decoupled services (for example, Cloud Tasks and Cloud Pub/Sub) allow for better structure and application scale, especially when working with microservices. In this instance, task handlers will reside in each dedicated service to enable the microservices to scale independently. Consequently, this control of the management of resource consumption ensures better load dynamics, resulting in smoother service access, for example, rate-limiting queues.</p>
<p>Furthermore, when handling releases and incidents gracefully, requests can be paused, retried, and redirected to a new version. If you have worked with Cloud Pub/Sub, this decoupling may all sound very familiar. The main difference between the two services involves invocation. Cloud Tasks provides the publisher with the ability to control execution, that is, the endpoint. Conversely, Cloud Pub/Sub enables the subscriber to control message delivery.</p>
<div class="packt_infobox">To learn more about the differences between these two services, read the <em><span>Choosing between Cloud Tasks and Pub/Sub</span></em> documentation reference at <a href="https://cloud.google.com/tasks/docs/comp-pub-sub">https://cloud.google.com/tasks/docs/comp-pub-sub</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cloud Scheduler</h1>
                </header>
            
            <article>
                
<p>Think of Cloud Scheduler as cron jobs for the cloud. If you are not familiar with cron jobs, they represent an easy way to schedule activities on a machine based on a schedule. Acting as a single pane of glass, Cloud Scheduler enables users to manage all their automation needs from a single place. Creating a Cloud Scheduler job only requires a few elements to be up and running. </p>
<p>If you are in a situation where you wish to automate some cloud infrastructure operations, then this is a perfect way to achieve that outcome. As a fully managed service, there is a simple interface through which you can set up and configure your automation needs as follows:</p>
<ol>
<li>Establish the frequency with which to run and trigger a task. </li>
<li>Determine how Cloud Scheduler is to be invoked (that is, Pub/Sub, App Engine HTTP, or HTTP).</li>
</ol>
<ol start="3">
<li>Deploy the service and the task will be invoked automatically when the scheduled time occurs.</li>
<li>Consult the Cloud Scheduler console page to see t<span>he results of each invocation</span> or access it via Stackdriver Logging.</li>
</ol>
<p>Cloud Scheduler provides a simple and effective way to run regular jobs on schedule. If you have ever needed to run things such as backups or download updates, you will already know how useful and powerful this application is. Being an enterprise-grade product, Cloud Scheduler provides what is essentially a cloud-based crontab. The beauty of this product is that it enables users to trigger jobs across existing Google Cloud target services. Having these integration targets available provides a highly reliable mechanism to ensure that tasks run on a schedule can support existing usage patterns.</p>
<p>In addition to this, Cloud Scheduler also provides some key elements that are covered in the following list:</p>
<ul>
<li>Re<span>liable delivery guaranteed that is, delivery of at least one of the job targets (this does come with its own complications, where ordering data may be a concern, similar to using a messaging solutions such as Cloud Pub/Sub).</span></li>
<li>A wide range of service support targets such as App Engine, Cloud Pub/Sub, and HTTP endpoints.</li>
<li>The retry and backoff mechanism determines a suitable retry policy for job requirements.</li>
<li>Integration with Stackdriver Logging captures information relating to the performance and execution of your task</li>
<li>Supports the Unix cron formation, so your existing knowledge is transferable.</li>
</ul>
<p>So now we know all of that, we can create a quick Cloud Scheduler demonstration on how to use it. In the following example, Cloud Scheduler will use Cloud Pub/Sub to illustrate how it can interact with a defined endpoint.   </p>
<p>The first task is to create a Pub/Sub topic. A Pub/Sub topic will collate the messages ready for distribution based on allocated subscribers as follows:</p>
<ol>
<li>From the Google Cloud Console menu, select the <span class="packt_screen">Pub/Sub</span> option.</li>
<li>From the <span class="packt_screen">Pub/Sub</span> screen, select the <span class="packt_screen">Create Topic</span> menu option.</li>
<li>On the <span class="packt_screen">Create a topic</span> screen, enter the <span class="packt_screen">Topic ID</span> as <kbd>cron-topic</kbd>.</li>
</ol>
<ol start="4">
<li>Leave the <span class="packt_screen">Encryption</span> settings at the following default option: <span class="packt_screen">Google-managed key</span>; then select the <span class="packt_screen">CREATE TOPIC</span> button:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-819 image-border" src="assets/5fe7b49d-9e9c-4062-b630-a10a077d7dea.png" style=""/></div>
<p>Once we have a topic defined, we now need to establish a subscription to it. For any available messages, we will be able to use either the pull or push mechanism to access the data payload associated with the topic:</p>
<ol>
<li>Now we need to create a subscription for the topic, so select the <span class="packt_screen">Subscriptions</span> option from the left-hand menu.</li>
<li>At the top of the screen, select the <span class="packt_screen">CREATE SUBSCRIPTION</span> option.</li>
<li>Enter the <span class="packt_screen">Subscription ID</span> as <kbd>cron-sub</kbd>.</li>
<li>Enter the <span class="packt_screen">Topic name</span> as <kbd>projects/&lt;project-id&gt;/topics/cron-topic</kbd>, replacing <kbd>&lt;project-id&gt;</kbd> with the Google Cloud project ID on your system.</li>
<li>Then select the <span class="packt_screen">CREATE</span> button at the bottom of the screen.</li>
</ol>
<p>Finally, we need to define the Cloud Scheduler that will use the Pub/Sub created earlier as an endpoint. Each time the Cloud Scheduler task invokes, it will send a payload to Pub/Sub:</p>
<ol>
<li>Select the option for <span class="packt_screen">Cloud Scheduler</span> (located under <span class="packt_screen">Tools</span>) and choose the <span class="packt_screen">CREATE JOB</span> option.</li>
</ol>
<ol start="2">
<li>The result should look similar to the following screen:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-820 image-border" src="assets/3c8d6c37-3feb-4c6b-b0f1-9f3eff03786d.png" style=""/></div>
<ol start="3">
<li>Complete the fields as per the following table:</li>
</ol>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Field</strong></p>
</td>
<td>
<p><strong>Content</strong></p>
</td>
</tr>
<tr>
<td>
<p><span class="packt_screen">Name</span></p>
</td>
<td>
<p><kbd>cron-task</kbd></p>
</td>
</tr>
<tr>
<td>
<p><span class="packt_screen">Description</span></p>
</td>
<td>
<p><kbd>Demonstration of Cloud Scheduler on Google Cloud</kbd></p>
</td>
</tr>
<tr>
<td>
<p><span class="packt_screen">Frequency</span></p>
</td>
<td>
<p><kbd>* * * * *</kbd></p>
</td>
</tr>
<tr>
<td>
<p><span class="packt_screen">Time zone</span></p>
</td>
<td>
<p><span><span class="packt_screen">United Kingdom (GMT)</span></span></p>
</td>
</tr>
<tr>
<td>
<p><span class="packt_screen">Target</span></p>
</td>
<td>
<p><span class="packt_screen">Pub/Sub</span></p>
</td>
</tr>
<tr>
<td>
<p><span class="packt_screen">Topic</span></p>
</td>
<td>
<p><span class="packt_screen">cron-topic</span></p>
</td>
</tr>
<tr>
<td>
<p><span class="packt_screen">Payload</span></p>
</td>
<td>
<p><kbd>Yeah Cloud Scheduler Rocks</kbd></p>
</td>
</tr>
</tbody>
</table>
<ol start="4"/>
<ol start="4">
<li>Once you've finished filling in the preceding fields, select the <span class="packt_screen">CREATE</span> button to add your Cloud Scheduler task to the list of active jobs.</li>
</ol>
<p>The example code will run every minute, but for the sake of brevity, press the <span class="packt_screen">RUN NOW</span> button. From the <span class="packt_screen">Cloud Scheduler Jobs</span> page, you will see the result category logged as successful, and it also indicates the last time the job was run. If you now look at the Cloud Pub/Sub queue and click on the <span class="packt_screen">cron-topic</span>, under the <span class="packt_screen">View Messages</span> option, you can pull the payload information added in Cloud Scheduler. Alternatively, you can use the Cloud Shell to access Pub/Sub subscriptions using the <kbd>gcloud</kbd> command as follows:</p>
<pre><strong>gcloud pubsub subscriptions pull cron-sub --limit 10</strong></pre>
<p>Congratulations! As you can see, Cloud Scheduler enables straightforward integration with Pub/Sub, App Engine, and HTTP. </p>
<p><span><span>Now that we have discussed the means to initiate both tasks and scheduled activities, we can begin to consider more extensive system requirements for processing information with functions.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing Cloud Functions</h1>
                </header>
            
            <article>
                
<p class="mce-root">The Cloud Functions platform provides an effective way to run single-purpose code in the cloud. Remember that standalone services remove the need to manage a server or its associated runtime. The occurrence of an event notification then triggers single-purpose functions. The lightweight Cloud Functions platform then provides the basis for event-driven serverless compute.</p>
<p class="mce-root">Building single-purpose functions that are independently <span>called </span>provides a highly available architecture for building your services. Compounding these functions presents an excellent way to extend cloud services. These single-purpose functions deliver lightweight components that, in turn, can be a more natural way to maintain your application. The simplicity of deployment and maintenance devoid of server provisioning and patch/update cycles can be an effective way to design your solution.</p>
<p class="mce-root">The ability to connect to cloud services and interact with different interfaces such as webhooks, APIs, and <strong>Internet of Things</strong> (<strong>IoT</strong>) devices is desirable. Google has made the interface to Cloud Functions extremely simple to use; you can build single-purpose functions that are limited only by your imagination.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Later in the book, we will discuss how to develop code <span>using the Functions Framework to create lightweight functions. The Functions Framework is an open source project that enables seamless compatibility across several environments (for example, Google Cloud Functions, Cloud Run, and Knative). For now, be aware that, when building functions, this approach provides an element of compatibility that enables you to switch between technology stacks seamlessly.</span></p>
<p><span>The wide variety of scenarios in which a serverless compute platform deploys makes this an attractive offering. Often deployed as the glue between services and APIs, Cloud Functions establishes an extensible layer for anyone wishing to use Google Cloud in the following areas:</span></p>
<ul>
<li><span>Real-time file processing</span></li>
<li><span>Event-driven extract, transform, and load pipelines</span></li>
<li><span>Serverless IoT backends</span></li>
<li><span>Third-party integration via APIs</span></li>
</ul>
<p><span>Typical use cases might include the following:</span></p>
<ul>
<li><strong>The IoT</strong>: Serverless engagement with devices to process information via an event stream. Cloud Functions provide a simplistic interface that can provide a powerful tool with which to gather and disperse batch or real-time information using services such as Cloud Pub/Sub.</li>
<li><strong>APIs</strong>: HTTP triggers can design aggregated logic to respond to application calls. This lightweight API is perfect to abstract more complex processing in the event chain, such as storage or queue requirements. Building an API of this type can be achieved with an event-driven interface and over HTTP.</li>
</ul>
<p>To illustrate how to create a simple Cloud Functions application, in the next section, we will walk through the main steps of this process.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing a Cloud Functions-based application</h1>
                </header>
            
            <article>
                
<p><span>To help build our understanding of the services previously discussed, we will develop a small application to utilize these services. Our Cloud Function will present a simple web page, in which some web-based information displays the output. To illustrate the power of each of the functions previously discussed, each of the <em>Requirement</em> milestones in the following table will alter and improve the overall design incrementally.</span></p>
<p><span>Our application will be developed with Google Cloud Functions and will display some information on the screen. Incidentally, if you need to host something like a static website, this can quickly be done by using a GCS bucket. Storage buckets are very versatile. For more information on how to implement them, check the documentation at </span><a href="https://cloud.google.com/storage/docs/static-website" target="_blank"><span>https://cloud.google.com/storage/docs/static-website</span></a><span>.</span></p>
<p><span>The application we will develop over the next couple of sections will be an RSS reader. Our high-level requirement is to present information from a particular site as an HTML web page. Our high-level requirements are as follows:</span></p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Ref</strong></p>
</td>
<td>
<p><strong>Requirement</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p>1</p>
</td>
<td>
<p>Develop a Cloud Function.</p>
</td>
<td>
<p>Deploy a single function application.</p>
</td>
</tr>
<tr>
<td>
<p>2</p>
</td>
<td>
<p>Read content from an RSS site.</p>
</td>
<td>
<p>For the example, we use a BBC RSS feed.</p>
</td>
</tr>
<tr>
<td>
<p>3</p>
</td>
<td>
<p>Render data as HTML.</p>
</td>
<td>
<p>Present the information to be consumed as HTML.</p>
</td>
</tr>
<tr>
<td>
<p>4</p>
</td>
<td>
<p>Refresh the data.</p>
</td>
<td>
<p>Enable data to be refreshed on an automated schedule.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Now that we have all our requirements in place, we can progress to building our first iteration of the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">App version 1 – introducing Cloud Functions</h1>
                </header>
            
            <article>
                
<p>In this example, we will step through the process for using Cloud Functions as the basis for the application. This process consists of the following steps:</p>
<ol>
<li><strong>Creating a function</strong>: Start out with a simple Cloud Function.</li>
<li><strong>Adding Functions Framework</strong>: Understand how to add other libraries when migrating code to Cloud Shell.</li>
<li><strong>Deploying the resultant code</strong>: Learn how to deploy code from the command line.</li>
</ol>
<p class="mce-root">Starting with Cloud Functions is made more accessible by the fact that it provides template code in several languages. The inclusion of this template code is beneficial when starting and enables developers to quickly try out the service without having to spend any time setting up an environment.</p>
<p class="mce-root">When working through the high-level requirements, retrieving an RSS feed from an external site seems like a critical activity. This task also seems like something that should have an existing pattern with which to achieve the desired outcome.</p>
<p class="mce-root">As a first development step, it is always worth doing a quick scan of the internet for inspiration. For the identified task, there are quite a few existing packages capable of accessing an RSS feed. Coming up with an initial design can help us to think through what we want to design:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-822 image-border" src="assets/e5d49473-c813-44ba-b012-d1c966db899b.png" style=""/></div>
<p>In the preceding diagram, <span>we can see that Cloud Functions is used to access the backend RSS data source. Also, users can access an HTTP endpoint to retrieve RSS information consumed from the backend.</span></p>
<p><span>The following example will use the Cloud Functions option in Google Cloud. </span><span>To speed up the development cycle, we will use available components to build our application and minimize the amount of code we need to write. To handle the RSS feed, we will use a pre-existing package to handle all the processing. The package also needs to be capable of accessing elements within the </span><span>RSS</span><span> feed. In this example, I am going to use Node.js; however, feel free to use an alternative language such as Python or Go.</span></p>
<p>At this point, we will use Cloud Console to write and deploy code to Cloud Functions:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-823 image-border" src="assets/a0daa268-496d-459b-96bb-a48552b30d1e.png" style=""/></div>
<p>We begin by using the standard boilerplate code provided by Cloud Functions to create an application. Using this template will enable the creation of Cloud Functions together with different properties:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-824 image-border" src="assets/d94397ed-82c6-43ff-90d8-53ee61bf5c71.png" style=""/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Having selected the <span class="packt_screen">Cloud Functions</span> option from Google Cloud Console and then opened a new Cloud Function, select Node as the runtime language to have the application code pre-populate with the example boilerplate code, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1134 image-border" src="assets/8430801e-6389-4d71-8ee9-0a546bec2df3.png" style=""/></div>
<p><span>To print some arbitrary text to the console log with Cloud Functions, we can do the following: </span></p>
<ol>
<li>
<p>Edit the <kbd>index.js</kbd> file presented in the Cloud Functions template. <span>We will start our application by amending the blueprint code provided by Google and add some code to perform the following task:</span></p>
</li>
</ol>
<pre style="padding-left: 60px">/**<br/>* Responds to any HTTP request.<br/>*<br/>* @param {!express:Request} req HTTP request context.<br/>* @param {!express:Response} res HTTP response context.<br/>*/<br/>exports.helloRSS = (req, res) =&gt; {<br/>  console.log('helloRSS - display some info');<br/>  res.status(200).send('helloRSS');<br/>};</pre>
<p style="padding-left: 60px">In the preceding code, we introduce the <kbd>console.log</kbd> statement, which writes information to the logging infrastructure. In the case of Google Cloud, this will be Stackdriver Logging.</p>
<ol start="2">
<li>To deploy the preceding code, we need to click the <span class="packt_screen">Create</span> button displayed at the bottom of the screen.</li>
</ol>
<p style="padding-left: 60px">Deploying this code results in a<span> </span><kbd>helloRSS</kbd><span> message being returned as the HTTP response. In addition, the information will also be available under Stackdriver as this acts as a centralized repository for all captured logging.</span></p>
<ol start="3">
<li>To retrieve information from Stackdriver, use a filter on <kbd>resource.type = cloud_function</kbd> to access specific data relating to program execution.</li>
</ol>
<div class="packt_tip"><br/>
<a href="ff73be02-51ed-4f9a-9181-5cd14fc8bd51.xhtml" target="_blank">Chapter 2</a>, <em>Developing with App Engine</em>, has a section outlining the process of filtering in Stackdriver. Check that out if you need a reminder on how to perform this task.</div>
<p>We now have a very basic function. To add to this in the next section, we will incorporate some external packages to render a view.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">App version 2 – migrating to Cloud Shell</h1>
                </header>
            
            <article>
                
<p>As our code becomes more complex, we should take the opportunity to move our development to somewhere more convenient. By convenient, I am, of course, referring to the command line. Now that we have seen how to use Cloud Functions from the console, our next step is to use Cloud Shell on Google Cloud:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-826 image-border" src="assets/71f8f36d-9981-4694-8e2b-189bfc0e8029.png" style=""/></div>
<div class="packt_tip">When we use Cloud Shell, it will provide lots of helpful tips. For example, in the preceding screenshot, Cloud Shell is indicating that it doesn't know which Google Cloud project it should be associated with. To remedy this, use the <kbd>gcloud config set [PROJECT_ID]</kbd> <span>command.</span><br/>
<br/>
If you don't know the correct <kbd>PROJECT_ID</kbd> to include, you can find this information on the home screen of the Google Cloud Console under the <span class="packt_screen">Project Info</span> heading.</div>
<p><span>If you ever get stuck on any of the application code in this book, you can also use the code repository version link at the beginning of each chapter. </span>Now that we have Cloud Shell open, follow these <span>steps to recreate the application from scratch:</span></p>
<ol>
<li>First, make a new directory for your Node code to hold your code. Let's call it <kbd>ch03</kbd>.</li>
</ol>
<p style="padding-left: 60px">In the Cloud Console, two code files, <kbd>index.js</kbd> and <kbd>package.json</kbd>, are deployed as part of our Cloud Function. The content of each can be observed in the Cloud Functions console. Using your favorite editor, we are going to recreate this application.</p>
<div class="packt_tip packt_infobox" style="padding-left: 60px"><br/>
In later chapters, we will look more closely at other options for local development but, for now, we will focus on how to migrate our code to Cloud Shell.</div>
<ol start="2">
<li>In the new directory, copy the existing function code for <kbd>index.js</kbd> from the Cloud Functions console window and place this into a new <kbd>index.js</kbd> file located within the <kbd>ch03</kbd> <span>subdirectory </span>in Cloud Shell.</li>
</ol>
<ol start="3">
<li>Do the same for the <kbd>package.json</kbd> file and you now should have two source files (<kbd>index.js</kbd> and <kbd>package.json</kbd>) in your <kbd>ch03</kbd> development directory.</li>
<li>In addition, we will also need to install any packages required. Let's add the <kbd>functions-framework</kbd> package:</li>
</ol>
<pre style="padding-left: 60px"><strong><span>npm install </span>@google-cloud/functions-framework</strong></pre>
<p style="padding-left: 60px">If you take a sneaky peek at the directory, suddenly we see more than the two source files we created. Don't worry about that for now. The critical thing to mention is the inclusion of <kbd>functions-framework</kbd> in the <kbd>package.json</kbd> configuration file. We will cover what this is in more detail in the next chapter on Cloud Functions.</p>
<p style="padding-left: 60px">Now we have our code nicely packaged in Cloud Shell, we can do fancy things such as saving it to a repository to help with version control. But we will continue to test that the files are working as expected, which means deploying our code.</p>
<ol start="5">
<li>Let's stay in the Cloud Shell, using the following command to deploy our code:</li>
</ol>
<pre style="padding-left: 60px"><strong><span>gcloud functions deploy tempest --entry-point helloRSS --runtime nodejs8 --trigger-http</span></strong></pre>
<p><span>You will be asked if you want to allow unauthenticated invocations; answer Yes. </span><span>Excellent, congratulations! You have deployed a Cloud Function named <kbd>tempest</kbd> from the command line! At the moment it doesn't do much, but take a bow anyway. </span><span>Next, we are going to expand the application to do something a bit more useful.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">App version 3 – adding a view</h1>
                </header>
            
            <article>
                
<p>In our application, we want to extend the code to read an RSS feed. To build upon the existing code, we should incorporate a few additions to move closer to our application requirements<span>:</span></p>
<ul>
<li><span>Display some static content.</span></li>
<li>Utilize an HTTP response to display as HTML page.</li>
</ul>
<p>To achieve this, we will perform the following steps:</p>
<ol>
<li>Introduce an NPM peer package to perform the necessary RSS interaction. A peer package is a Node dependency declared in the <kbd>package.json</kbd> file. Performing a quick search of <span>NPM packages</span><span> shows <kbd>rss-parser</kbd> as the right choice for our requirements.</span></li>
</ol>
<div class="packt_tip">An advantage of using a package is that it will include all the relevant information about configuration. Node establishes an automatic update of the <kbd>package.json</kbd> file when an install completes. By adding the RSS component, we are quickly able to meet the requirement to read RSS feeds with a minimal amount of code.<br/>
<br/>
A good practice to adopt is to check the available source code/library. We should never implicitly trust packages and therefore must remain vigilant when incorporating third-party code into our projects. Always heed vulnerabilities and warnings displayed that relate to security.</div>
<p style="padding-left: 60px"><span>Looking at the </span><span><kbd>rss-parser</kbd> page</span><span> on the NPM website (<a href="https://www.npmjs.com/package/rss-parser">https://www.npmjs.com/package/rss-parser</a>), under <span class="packt_screen">V<span class="packt_screen">e</span></span><span class="packt_screen">rsions</span>, we can see that the most current version (at the time of writing) is version 3.7.2. </span></p>
<ol start="2">
<li>From the command line, we can install this package by issuing the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong><span>npm install rss-parser</span></strong></pre>
<ol start="3">
<li>Now by viewing the <kbd>package.json</kbd> file, we can see it has been updated to include the relevant package and version.</li>
</ol>
<pre style="padding-left: 60px">{<br/>  "name": "sample-http",<br/>  "version": "0.0.1",<br/>  "dependencies": {<br/>    "@google-cloud/functions-framework": "^1.3.2",<br/>    "rss-parser": "^3.7.3"<br/>  }<br/>}</pre>
<ol start="4">
<li>Now that the <kbd>package.json</kbd> file has been updated to incorporate <kbd>rss-parser</kbd>, in the JavaScript file, <kbd>index.js</kbd>, we will declare a new asynchronous function to do all the heavy lifting and retrieve the RSS code to output the results.</li>
</ol>
<p style="padding-left: 60px">We are using an asynchronous function as network calls may take a while to process; we don't want to incur an unnecessary delay in the UI processing of the request/response life cycle.</p>
<ol start="5">
<li>In this new function, we first want to introduce the <kbd><span>rss-parser</span></kbd> <span>package </span>(<a href="https://www.npmjs.com/package/rss-parser">https://www.npmjs.com/package/rss-parser</a>) to consume the RSS data source by declaring a new object. We also add a new background asynchronous function to handle the parsing of the relevant RSS feed.</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>
<div class="packt_infobox">We don't pass back this data to the original function, <kbd>helloRSS</kbd>. Instead, we process all network-related activity in the <kbd>asyncBBCFeed</kbd> function. </div>
<ol start="6">
<li>Add the following code to <kbd>index.js</kbd> as shown as follows:</li>
</ol>
<pre style="padding-left: 60px">let Parser = require('rss-parser');<br/>let parser = new Parser();<br/>// New background function - Async<br/>async function asyncBBCFeed(req, res) {<br/>    let feed = await parser.parseURL('http://feeds.bbci.co.uk/news/rss.xml');<br/>    console.log (feed.title);<br/>    var testString = '';<br/>    // Title<br/>    testString = '&lt;h1&gt;RSS Lab&lt;/h1&gt;&lt;/p&gt;'<br/>  <br/>    // Loop through the content<br/>    feed.items.forEach(item =&gt; {<br/>      console.log(item.title + ':' + item.link);<br/>     // Create a link per title<br/>     testString = testString + '&lt;a href="' + item.link + '"&gt;'+item.title + '&lt;/a&gt;' + '&lt;/br&gt;';<br/>    });<br/>    // Display the feed returned<br/>    res.status(200).send(testString);<br/>}</pre>
<ol start="7">
<li>Now update the <kbd>helloRSS</kbd> function to look like the following code:</li>
</ol>
<pre style="padding-left: 60px">/**<br/>* Responds to any HTTP request.*<br/>* @param {!express:Request} req HTTP request context.<br/>* @param {!express:Response} res HTTP response context.<br/>*/<br/>exports.helloRSS = (req, res) =&gt; {<br/> var testMessage = '';<br/> console.log('helloRSS - display some info');<br/> asyncBBCFeed(req, res);<br/>};</pre>
<ol start="8">
<li>Back in Cloud Shell, deploy the updated code:</li>
</ol>
<pre style="padding-left: 60px"><strong><span>gcloud functions deploy tempest --entry-point helloRSS --runtime nodejs8 --trigger-http</span></strong></pre>
<p>Once the code is deployed, look at the Cloud Functions interface in the Cloud Console. Here we can see the application has been incremented to version 2. Go ahead and trigger the function to see the result of the asynchronous call we added. Awesome! Some lovely headlines are retrieved from the RSS feed, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-890 image-border" src="assets/812654c2-4f9f-472b-841f-052946ffa7d9.png" style=""/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Working with external data sources will be an everyday use case, so it is essential to understand how to do this and also to think about crucial aspects of the associated design. Iterating to the second version of our application, we want to output HTML to our site. Again, this remains an everyday use case and, rather than developing additional code, we used an existing Node component to handle the processing for us. Introducing an asynchronous task will minimize the associated latency for network interactions.</p>
<p>Looking at the code, the HTML remains tightly coupled with the system code, so that needs addressing. Before embarking on that particular challenge, it's time to move our code from the Cloud Console to the command line. In the next section, we start to work with Cloud Shell exclusively.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">App version 4 – decoupling HTML output</h1>
                </header>
            
            <article>
                
<p><span>As we now know from working with Node, it means we have access to a wealth of packages to do cool stuff. For our application, let's utilize a </span><span>package named <kbd>pug</kbd></span><span> to render our HTML in a more manageable way. Decoupling the given text from the RSS data presents us with an opportunity to display the information in a less convoluted way and without having to recode significant elements of the Cloud </span><span>Function:<br/></span></p>
<ol>
<li>In Cloud Shell, in line with the previous example, we need to add a new peer dependency to the <kbd>package.json</kbd> file:</li>
</ol>
<pre style="padding-left: 60px"><strong><span>npm install pug</span></strong></pre>
<ol start="2">
<li>Pug will enable HTML previously embedded within the JavaScript to be segregated into a separate file:</li>
</ol>
<pre style="padding-left: 60px">{<br/>    "name": "sample-http",<br/>    "version": "0.0.1",<br/>    "dependencies": {<br/>        "@google-cloud/functions-framework": "^1.1.1",<br/>        "rss-parser": "^3.7.2",<br/>        "pug": "^2.0.4"<br/>    }<br/>}</pre>
<ol start="3">
<li>In the <kbd>index.js</kbd> file, we need to add a reference to the <kbd>pug</kbd> object within our application:</li>
</ol>
<pre style="padding-left: 60px"><span>let pug = require('pug');</span></pre>
<ol start="4">
<li>Next, we initiate a programmatic view (that is, how the page will look) when rendered against our HTML output using the <kbd>index.pug</kbd> file. In the <kbd>asyncBBCFeed</kbd> function add the following:</li>
</ol>
<pre style="padding-left: 60px"><span>const pugInputFile = pug.compileFile('index.pug');</span></pre>
<ol start="5">
<li>We also need to update the response object to indicate:</li>
</ol>
<ul>
<li style="list-style-type: none">
<ul>
<li>Successful processing</li>
<li>The view to be rendered, that is, <kbd>index.pug</kbd></li>
<li>Interpolation of values, in our case, the <kbd>feed.items</kbd> returned from the async call:</li>
</ul>
</li>
</ul>
<pre style="padding-left: 120px">res.status(200).send(pugInputFile({<br/>    items: feed.items<br/>}));</pre>
<ol start="6">
<li>Finally, let's get rid of some of the boilerplate code that is no longer required to process the feed items.</li>
</ol>
<p style="padding-left: 60px">After updating the changes outlined in the preceding step, our <kbd>index.js</kbd> should look as follows:</p>
<pre style="padding-left: 60px">let Parser = require('rss-parser');<br/>let parser = new Parser();<br/>let pug = require(‘pug');<br/><br/>// New background function - Async<br/>async function asyncBBCFeed(req, res) {<br/>    let feed = await parser.parseURL('http://feeds.bbci.co.uk/news/rss.xml');<br/>    // Use an external pug file<br/>    const pugInputFile = pug.compileFile('index.pug');<br/>    // console.log(feed.items)<br/>    // Display the feed returned<br/>    res.status(200).send(pugInputFile({<br/>        items: feed.items<br/>    }));<br/>}<br/>/**<br/>* Responds to any HTTP request.<br/>*<br/>* @param {!express:Request} req HTTP request context.<br/>* @param {!express:Response} res HTTP response context.<br/>*/<br/>exports.helloRSS = (req, res) =&gt; {<br/>    asyncBBCFeed(req, res);<br/>};</pre>
<ol start="7">
<li>To render a view, we now need to create a new file named <kbd>index.pug</kbd> within the <kbd>view</kbd> directory and add the following to it:</li>
</ol>
<pre style="padding-left: 60px">html<br/>  head<br/>    title Template - This is a Pug generated output<br/>  body<br/>    header<br/>      p RSS Lab<br/>    section<br/>    each item in items<br/>      a(href='' + item.link) #{item.title} &lt;br&gt;</pre>
<ol start="8">
<li>Back in Cloud Shell, deploy the updated code:</li>
</ol>
<pre style="padding-left: 60px"><strong><span>gcloud functions deploy tempest --entry-point helloRSS --runtime nodejs8 --trigger-http</span></strong></pre>
<p><span>Testing the deployed code should result in the same output as shown in the <em>App version 3 - adding a view</em> section previously. </span></p>
<p><span>However, take note that our application complexity has significantly decreased. Also, we haven't even needed to write much code. Once you have updated the application with the preceding code updates, take this opportunity to try another form of deployment:</span></p>
<ol>
<li><span>From the Cloud Shell, compress the contents of the development directory into a ZIP file.</span></li>
<li><span>Let's make a Cloud Storage bucket in your project (bucket names need to be globally unique, so pick one that works for you and replace <kbd>[BUCKET_ID]</kbd> with your unique identifier).</span></li>
<li><span>Upload the file to your bucket.</span></li>
<li><span>From the Cloud Function interface, choose the <kbd>Create</kbd> function and select the ZIP file from Cloud Storage.</span></li>
<li><span>Select the ZIP file from the bucket location and don't forget to change the </span><strong><span>function to execute</span></strong><span> setting—we are using a function named <kbd>helloRSS</kbd>.</span></li>
</ol>
<ol start="6">
<li>Finally, select the <span class="packt_screen">Create</span> option and <span class="packt_screen">Create a new function</span> option for the code taken from the storage bucket.</li>
</ol>
<div class="packt_tip"><br/>
If you are anything like me, the joy of deploying code manually will be short-lived. In this case, using Cloud Build will be of interest to you.</div>
<p><span>Working with event processing provides a simple and effective mechanism to set up an action to be taken in response to a stimulus. In the initial revision of our application, we introduced Cloud Functions. Working with the template code, we were able to adapt the system to consume an RSS feed and output the content to application logs.</span></p>
<p><span>In the example code, I used the BBC RSS feeds site as the source material because it has plenty of options and is a suitably stable site on which to base a demo. However, feel free to replace this site with one of your choosing as long as it adheres to the same standard specification; this should not impact the code presented.</span></p>
<p><span>Great job: working on Google Cloud provides a lot of options. In the next section, I will set you an optional challenge to build on all the things you have learned</span> so far.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">App version 5 – extending the RSS reader</h1>
                </header>
            
            <article>
                
<p>In this final revision of the application, I am going to set you a challenge! Our application can already retrieve RSS feed data and display it as HTML. However, it would be nice to have the ability to show even more information and <span>perhaps </span>include another feed or two.</p>
<p>By extending the requirements, we now have the following task list:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Ref</strong></p>
</td>
<td>
<p><strong>Requirement</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p>1</p>
</td>
<td>
<p>Develop a Cloud Function.</p>
</td>
<td>
<p>Deploy a single function application.</p>
</td>
</tr>
<tr>
<td>
<p>2</p>
</td>
<td>
<p>Read content from an RSS site.</p>
</td>
<td>
<p>For example, the BBC RSS feed.</p>
</td>
</tr>
<tr>
<td>
<p>3</p>
</td>
<td>
<p>Render data as HTML.</p>
</td>
<td>
<p>Present the information to be consumed as HTML.</p>
</td>
</tr>
<tr>
<td>
<p>4</p>
</td>
<td>
<p>Refresh data.</p>
</td>
<td>
<p>Enable data to be refreshed on an automated schedule.</p>
</td>
</tr>
<tr>
<td>
<p>5</p>
</td>
<td>
<p>Read content from an RSS site.</p>
</td>
<td>
<p>Find another RSS site and add it to the application.</p>
</td>
</tr>
<tr>
<td>
<p>6</p>
</td>
<td>
<p>Improve the HTML layout.</p>
</td>
<td>
<p>Add some images to the output and add some more data from an RSS feed.</p>
</td>
</tr>
</tbody>
</table>
<p><span> </span></p>
<p><span>The majority of the code should already be familiar to you but don't worry if it is not. The point of the challenge app is to test your understanding and build your confidence so you can take on increasingly complex code.</span></p>
<div class="packt_tip"><br/>
Remember, if you find it challenging to perform this exercise, a solution can be found in the book repository in the <kbd>ch03/solution</kbd> subdirectory.</div>
<p>In this example, do note that building an application within a single function can be viewed as an anti-pattern for serverless functions. An alternative approached might be to create a reader function for data access, and a presentation function for data rendering. This could lead to the state being migrated to other services such as Firestore (or even just saved to GCS). Also, the addition of a Cloud Scheduled job might be used to refresh the data. The refreshed data might then be stored in the backend, such as on Firestore. We could then use a t<span>rigger on writ</span><span>e</span><span> </span><span>for an event-driven function to render the updated HTML, possibly even writing the data to GCS or some other cache. With this approach serving thousands of frontend requests without the slow-down associated with getting the RSS feed, we've decoupled our workload into small and easy-to-understand code.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Throughout this chapter, you will have realized that building solutions on Google Cloud does not require a vast amount of knowledge to get to a <strong>minimum viable product</strong> (<strong>MVP</strong>). Investing time to be able to iterate over numerous revisions quickly is worthwhile and can lead to significant improvements in the overall design.</p>
<p>Through this chapter, you should now have an appreciation of the nature of the services available. You will find it much easier to think about combining different products, almost like building blocks. In this regard, it is imperative, at the outset, to have a clear view of how the end solution should look. Taking the opportunity to build lightweight functions, as opposed to a monolith, can generally simplify the overall design; however, be sure that this is what your solution requires. As you will now be aware, there are many situations in which serverless event processing can be beneficial.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>That concludes our initial overview of the three event processing services for serverless workloads. The versatility of the functions discussed fulfills a wide variety of use cases. When looking to design an application using these services, it is worth considering the desired use. Design iteration is a good thing and should bring about better efficiencies in your application. As we move on to more complex systems, having a working knowledge of the appropriate use cases and associated design patterns will make building systems feel more natural. In the next chapter, we will be turning our attention specifically to Cloud Functions. There is lots more to cover in terms of usage, and we <span>also</span><span> </span><span>need to discuss trigger events that make them so useful.</span></p>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions </h1>
                </header>
            
            <article>
                
<ol>
<li>Does Cloud Tasks support rate limiting? (True or False)</li>
<li>Describe deferred scheduling for Cloud Tasks.</li>
<li>Does Cloud Scheduler support a r<span>etry and backoff mechanism? (True or False)</span></li>
<li>Does Cloud Scheduler operate in a similar way to cron? <span>(True or False)</span></li>
<li>What trigger do we use to deploy an HTTP endpoint?</li>
<li>Where does Cloud Functions send its logs?</li>
<li>What command enables Cloud Functions to be deployed from the command line?</li>
<li>What is the entry point for Cloud Functions and why is it important?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li><strong>Choosing between Cloud Tasks and Pub/Sub</strong>: <a href="https://cloud.google.com/tasks/docs/comp-pub-sub">https://cloud.google.com/tasks/docs/comp-pub-sub</a></li>
<li><strong>Static website examples and tips</strong>: <a href="https://cloud.google.com/storage/docs/static-website">https://cloud.google.com/storage/docs/static-website</a></li>
<li><strong>The NPM pug package</strong>: <a href="https://www.npmjs.com/package/pug">https://www.npmjs.com/package/pug</a></li>
<li><strong>Distributed computing</strong>: <a href="https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing">https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing</a></li>
</ul>


            </article>

            
        </section>
    </body></html>