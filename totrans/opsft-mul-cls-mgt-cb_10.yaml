- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenShift GitOps – Argo CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we learned how to create and run a pipeline using
    Tekton to build and deploy an application. While Tekton is great for building
    and performing other actions that are usually related to **continuous integration**
    (**CI**), **GitOps** is becoming the norm for **continuous deployment** (**CD**)
    regarding Kubernetes-native applications. In this chapter, we will dive into GitOps
    and talk about one of the best tools for CD: **Argo CD**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is GitOps?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Argo CD?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application delivery model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing OpenShift GitOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Argo CD against multiple clusters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Argo CD definitions and challenges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Argo CD main objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying an application using GitOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying to multiple clusters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s dive in!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The source code used in this chapter is available at [https://github.com/PacktPublishing/OpenShift-Multi-Cluster-Management-Handbook/tree/main/chapter10](https://github.com/PacktPublishing/OpenShift-Multi-Cluster-Management-Handbook/tree/main/chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: What is GitOps?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The term GitOps was first described by *Lexis Richardson*, CEO of *Weaveworks*,
    in 2017\. At that time, he presented the four principles of GitOps, which are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The entire system is described declaratively**: This means that any configuration
    of your application and infrastructure needs to be treated as code, but not as
    a set of instructions, as you would with scripts or automation code. Instead,
    you must use a set of facts that describes the desired state of your system. These
    declaration files are versioned in Git, which is your single source of truth.
    The great benefit of this principle is that you can easily deploy or roll back
    your applications and, more importantly, restore your environment quickly if a
    disaster occurs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The canonical desired system state is versioned in Git**: Git is your source
    of truth. It needs to be the single place that triggers all the changes in your
    systems. Ideally, nothing should be done directly on the systems, but through
    configuration changes on Git that will be applied automatically using a tool such
    as Argo CD.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Approved changes are automatically applied to the system**: Since you have
    the desired state of your system stored in Git, any changes can be automatically
    applied to the system as they are pushed to the repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Software agents ensure correctness and alert you about divergence**: It is
    crucial to have tools in place that will ensure that your system is in the desired
    state, as described in Git. If any drift is detected, the tool needs to be able
    to self-heal the application and get it back to its desired state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GitOps became the norm for Kubernetes and cloud-native applications due to
    the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Standard process and tools**: Git workflows allow teams to work collaboratively
    and in a reproducible manner, avoiding issues regarding human-repetitive tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Robust and secure process**: By working with **pull requests** (**PRs**)
    in Git, all the changes need to be reviewed and approved. You can also trace all
    changes in Git and revert them if needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auditable changes**: All changes are tracked and easily auditable in Git
    history.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency**: You can deploy the same application in multiple different
    clusters consistently:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.1 – GitOps workflow ](img/B18015_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – GitOps workflow
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a better understanding of what GitOps is, let’s start learning
    how to put GitOps workflows into practice.
  prefs: []
  type: TYPE_NORMAL
- en: What is Argo CD?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In theory, it is possible to adopt GitOps without the need to use any specific
    tool. You could implement scripts and automation to deploy and manage your applications
    using declarative files from Git that describe your systems. However, that would
    be costly and time-consuming. The good news is that there are some great open
    source options for Kubernetes that are stable and work well. At the time of writing,
    the main tools for Kubernetes are **Argo CD** and **Flux CD**; both are great
    tools but in this book, we will explore Argo CD, which comes at *no additional
    cost with a Red Hat OpenShift subscription*.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, Argo CD is a tool that is capable of *reading* a set of *Kubernetes
    manifests, Helm charts, or Jsonnet files* stored in a Git repository and *applying*
    them to a Kubernetes namespace. Argo CD is not only able to apply manifests, though
    – it can also automate self-healing, object pruning, and other great capabilities,
    as we will explore in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Application delivery model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, you may be wondering how OpenShift Pipelines (**Tekton**) and
    GitOps (**Argo CD**) are related. Tekton and Argo CD are complementary tools that
    are perfect together. While Tekton is a perfect fit for *CI* pipelines that run
    unit tests and build and generate container images, Argo CD is more appropriate
    for *continuous delivery* practice. The following diagram summarizes what a CI/CD
    pipeline with Tekton and Argo CD looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Application delivery model using Tekton and Argo CD ](img/B18015_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Application delivery model using Tekton and Argo CD
  prefs: []
  type: TYPE_NORMAL
- en: 'CD with GitOps means that the actual state of the application should be monitored
    and that any changes need to be reverted to the application’s desired state, as
    described in the Git repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Continuous delivery with GitOps ](img/B18015_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Continuous delivery with GitOps
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will use our example from the previous chapter and use Argo
    CD to deploy the application and practice this application delivery model.
  prefs: []
  type: TYPE_NORMAL
- en: Installing OpenShift GitOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The installation process is simple and is similar to what we followed in the
    previous chapter regarding OpenShift Pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To install OpenShift GitOps, you will need an OpenShift cluster with cluster-admin
    permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Access the **OpenShift web console** using the administrator’s perspective.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to **Operators** | **OperatorHub**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.4 – OperatorHub ](img/B18015_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – OperatorHub
  prefs: []
  type: TYPE_NORMAL
- en: 'Search for `OpenShift GitOps` using the *Filter by keyword* box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Red Hat OpenShift GitOps on OperatorHub ](img/B18015_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Red Hat OpenShift GitOps on OperatorHub
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Red Hat OpenShift GitOps** tile and then the **Install** button
    to go to the **Install** screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Installing OpenShift GitOps ](img/B18015_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Installing OpenShift GitOps
  prefs: []
  type: TYPE_NORMAL
- en: Now, select `openshift-operators` namespace and permits the operator to install
    OpenShift GitOps instances in any target namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Automatic** or **Manual** for the upgrade’s **Approval Strategy**.
    If you go for **Automatic**, upgrades will be performed automatically by the **Operator
    Lifecycle Manager** (**OLM**) as soon as they are released by Red Hat, while for
    **Manual**, you need to approve it before it can be applied.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select an **Update channel**. The **stable** channel is recommended as it contains
    the latest stable and *supported* version of the operator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the **Install** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Installing the operator ](img/B18015_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Installing the operator
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait up to 5 minutes until you see the following message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Operator installed ](img/B18015_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Operator installed
  prefs: []
  type: TYPE_NORMAL
- en: OpenShift GitOps (Argo CD) also has a CLI, which helps execute common tasks,
    such as updating the admin’s password, registering external clusters, and much
    more. Let’s learn how to install the `argocd` CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the argocd CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `argocd` CLI makes it easier to work with Argo CD. Through it, you can manage
    Argo CD projects, applications, cluster credentials, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the `argocd` CLI, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the latest Argo CD binary file from [https://github.com/argoproj/argo-cd/releases/latest](https://github.com/argoproj/argo-cd/releases/latest).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are using Linux, download the CLI and add it to your path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If everything went well, you will see the following output by running the `argocd
    version` command. Ignore the error message you see in the last line; it is an
    expected message as we haven’t logged in to any OpenShift cluster yet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let’s learn how to configure Argo CD to deploy applications against multiple
    clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Argo CD against multiple clusters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are planning to use Argo CD to deploy applications to *external clusters*,
    you need to add the new cluster’s credentials using the `argocd` CLI. You can
    skip this step if you want to deploy applications in the same cluster where Argo
    CD is installed (the `kubernetes.default.svc` file already exists and should be
    used in this case).
  prefs: []
  type: TYPE_NORMAL
- en: 'To register new clusters, perform the following steps using the `argocd` CLI
    you installed previously:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Log into the new cluster we want to register:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, log into the cluster where Argo CD is installed using `oc login`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, you should have both clusters in your `kubeconfig` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set a different context for the new cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the Argo CD public URL from the `openshift-gitops` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the administrator password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Log in using `argocd`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the new cluster to Argo CD:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, you are ready to deploy applications either into your local or remote
    cluster using Argo CD! But before we dive into application deployment, let’s check
    out some of the important aspects related to Argo CD.
  prefs: []
  type: TYPE_NORMAL
- en: Argo CD definitions and challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we walk through the application deployment process, we need to discuss
    some important challenges related to GitOps, decisions, and standards.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub repository structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first important question that always comes up with GitOps is about the GitHub
    repository’s structure. Should I only use one repository for source code and the
    Kubernetes manifests? How should I deal with different configuration files for
    different environments, such as development, QA, and production?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, there are no right or wrong answers to these questions, as each option
    has its pros and cons. You need to find out which approach works best for you.
    My advice here is: try it! There is nothing better than practical experience,
    so use each model and find out which one fits best for your applications and teams.
    In the following sections, we’ll look at some of the most popular repository structures
    out there for GitOps-oriented applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Mono-repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this structure, you will have one repository for all your Kubernetes manifests
    and infrastructure-related files. Although there is not a single standard for
    this structure, you will probably have a repository similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at this code in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**#[1]**: This folder contains the CI/CD pipelines, Argo CD, and other related
    configuration files that are common for any environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**#[2]**: This folder contains the manifests that are specific to each environment,
    such as development, QA, and production'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**#[3]**: These are the manifest files that are specific to the development
    environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**#[4]**: Here, you have the Kubernetes manifests to deploy the applications
    that are tracked and released in this repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RoleBinding` permissions, `Namespace`, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**#[6]**: These are the manifest files that are specific to the QA environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The main benefit of this approach is its **simplicity**: in this approach,
    you only need to manage one repository for one or more applications, which makes
    it easier to manage branches, tags, **PRs**, and anything related to the application''s
    manifests repository. However, the major con of this strategy is that all the
    contributors can read and make changes to the production manifests. That said,
    it might be *hard to detect unintentional changes to production*, especially with
    large PRs.'
  prefs: []
  type: TYPE_NORMAL
- en: This leads us to the next approach, in which you have a different repository
    per environment.
  prefs: []
  type: TYPE_NORMAL
- en: Repository per environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With this strategy, you will have multiple repositories, one for each environment.
    In other words, you will have one repository for *development* manifests, another
    one for *QA*, and so on. In this strategy, you will likely use PRs to promote
    changes between each environment and have a granular review process, which leads
    to a less error-prone process. In this strategy, you can also manage Git permissions
    according to each environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – One repository per environment ](img/B18015_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – One repository per environment
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be using a mono-repository strategy and use Git push
    requests and PRs with multiple branches to mitigate the risk of unintentional
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will discuss another important aspect related to GitOps on Kubernetes:
    templating YAML files and avoiding duplication.'
  prefs: []
  type: TYPE_NORMAL
- en: Templating Kubernetes manifests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Whatever repository structure you decide to go for, one thing is certain: you
    will need to have separate files and folders for each environment you manage.
    So, how can you avoid duplicating YAML manifest files everywhere and turning your
    GitOps process into a nightmare?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, the most popular options to do this are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Helm**: Rely on Helm Charts and Helm Templates to package and deliver Kubernetes
    applications. Through Helm Templates, you can combine values with templates and
    generate valid Kubernetes manifest files as a result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kustomize**: With Kustomize, you can reuse existing manifest files using
    a patch strategy. It uses a hierarchical structure so that you can flexibly reuse
    shared configurations and create layers of configurations with only environment-specific
    parameters that will be overloaded with base parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While Helm is a great package tool, we are going to focus on Kustomize in this
    chapter due to the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Kustomize runs natively on Kubernetes and the OpenShift CLI (`kubectl`/`oc`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is declarative, which is an important factor for GitOps, as we mentioned
    previously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use a remote base in a repository as the starter set of the manifest
    and have the overlays stored in different repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take a closer look at Kustomize.
  prefs: []
  type: TYPE_NORMAL
- en: Kustomize
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Kustomize is composed of hierarchical layers of manifest files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Base`: This is a directory that contains the resources that are always reused
    as the base manifest files. These describe the application and objects declaratively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Overlays`: This is a directory that only contains the configurations that
    are specific for each overlay. For instance, it is common to have an overlay for
    the development environment, another for QA, and so on. The configurations that
    reside in the `overlay` directories replace the values that are in the `base`
    directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can have multiple layers of bases and overlays – as many as you want. However,
    to maintain the legibility and maintainability of your application manifest files,
    it is not recommended to use several layers of manifest files. The following diagram
    shows an example of a base and two overlays that might be used with Kustomize:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – Kustomize layers ](img/B18015_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – Kustomize layers
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a typical folder structure you’ll see when you’re using Kustomize:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We will practice using Kustomize a bit more in this chapter when we deploy our
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Managing secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Last, but not least, the real challenge with Kubernetes is managing sensitive
    data using secrets. While secrets are somewhat safe, depending on how the permissions
    are set among users, they are not encrypted. This is a real problem when we think
    about storing those secrets in a GitHub repository. So, how can we handle secrets
    securely?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to handle secrets:'
  prefs: []
  type: TYPE_NORMAL
- en: Use an external vault to store the secrets securely outside Git and the cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypt the secret before saving it in Git using a sealed secret tool such as
    Bitnami Sealed Secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Secrets are presented in Base64 encoding. The following command, for instance,
    decrypts a secret named `db-root-password` that contains a password field:'
  prefs: []
  type: TYPE_NORMAL
- en: '`oc get secret db-root-password –o jsonpath="{.data.password}" | base64 -d`'
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Bitnami Sealed Secrets allows you to encrypt your secret into a `SealedSecret`
    object and store it securely, even in a public GitHub repository, since it is
    encrypted using a public/private certificate. To learn more, check out the link
    in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have discussed the main points that you need to think about regarding
    GitOps. They are important topics we decided to bring to you before our practical
    example but don’t get too worried about that yet – you will find out what works
    best for you and your team by practicing and learning from it. In the next section,
    we will introduce some of the main objects you will work with in Argo CD.
  prefs: []
  type: TYPE_NORMAL
- en: Argo CD main objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will look at some of the main Argo CD objects you need
    to know about. Argo CD is quite simple and most of what you will do can be summarized
    in two objects: **AppProject** and **Application**.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will not mention all the different objects Argo CD has since
    that is not the main focus of this book. Check out the *Further reading* section
    to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: AppProject
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Projects allow you to group applications and structure them according to any
    group logic you need. Using projects, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Limit the Git *source repositories* that can be used to deploy applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restrict the *clusters and namespaces destination* that the applications can
    be deployed to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limit the type of objects that can be deployed (for example, Deployments, Secrets,
    DaemonSets, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set roles to limit the permissions that are allowed by groups and/or JWTs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Argo CD is installed, it comes with a `default` project. If you don’t specify
    a project in your Argo CD application, the `default` option will be used. Creating
    additional projects is optional as you could use Argo CD’s `default` project instead.
    However, it is recommended to create additional projects to help you organize
    your Argo CD applications.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There is no relationship between Argo CD’s default project and OpenShift’s default
    namespace. Although they have the same name, they are unrelated.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical `AppProject` specification looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at this code in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[1]**: The name of the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[2]**: The Git source repositories that are allowed. In this case, any source
    repository is allowed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[3]**: The destination clusters and namespaces that are allowed. In this
    case, any combination of clusters and namespaces is allowed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[4]**: The objects that can be deployed (for example, Deployments, Secrets,
    DaemonSets, and so on). In this case, there is no limitation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properly adjust the code pointed out to achieve manifest file.
  prefs: []
  type: TYPE_NORMAL
- en: Applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Applications represent application instances that have been deployed and managed
    by Argo CD. The specification of an application is composed of `source` and `destination`.
    `source` is where the Kubernetes manifests (Git repository) that specify the desired
    state of the application reside, while `destination` specifies the cluster and
    namespace where the application will be deployed. Besides that, you can also specify
    the synchronization policies you want Argo CD to apply.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of an `Application` specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at this code in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Application` name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`openshift-gitops`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AppProject` object. Do not get it confused with the OpenShift project; they
    are unrelated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[4]**: Git source repository information about where the Kubernetes manifests
    reside.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[5]**: The cluster and namespace where the application will be deployed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[6]**: The synchronization policies that Argo CD will use. We will learn
    more about these policies in the next section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Argo CD’s namespace (`openshift-gitops`) has special privileges within the cluster
    to perform all the necessary activities. Due to that, you must protect access
    to this namespace to avoid unwanted deployments or changes.
  prefs: []
  type: TYPE_NORMAL
- en: Syncing policies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can configure Argo CD to automatically synchronize your application when
    there is any drift between the desired state specified in the manifests in Git
    and the actual application state. You have the following options with Argo CD:'
  prefs: []
  type: TYPE_NORMAL
- en: '`true`, Argo CD will automatically sync when it detects any differences between
    the manifests in Git and the actual state. By default, this flag is `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prune` flag to `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syncing the order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For standard Kubernetes manifests, Argo CD already knows the correct order
    that needs to be applied to avoid precedence issues. For instance, consider an
    application that contains three manifests for namespace creation, deployment,
    and role bindings. In such a case, Argo CD will always apply the objects in the
    following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Namespace
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Role bindings
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That said, this is the kind of thing you don’t need to be worried about as Argo
    CD is smart enough to apply them in the correct order.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are some other specific cases where you may need to specify objects’
    precedence. Let’s say that you want to deploy an application composed of one StatefulSet
    to deploy a database and a deployment for an application that uses the database.
    In this case, you can use **resource hooks** to specify the correct order to apply
    the objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following types of resource hooks can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PreSync`: Objects marked with `PreSync` are executed before any other manifests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sync`: This runs after `PreSync` is complete. You can also use `sync-wave`
    to set the sync precedence of the objects in the `Sync` phase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PostSync`: Runs after all the `Sync` objects have been applied and are in
    a `Healthy` state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SyncFail`: The manifests with this annotation will only be executed when a
    sync operation fails.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example of a resource hook specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There are different types of annotations that you can include in your manifests
    to perform more complex tasks. Check out the *Further reading* section to learn
    more.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have covered the most important concepts and theories behind GitOps
    and Argo CD. Now, without further ado, let’s look at our example and practice
    what we have discussed so far!
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an application using GitOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this practical exercise, we will build and deploy our sample application
    in three different namespaces to simulate an application life cycle composed of
    development, QA, and production environments. The following diagram shows the
    delivery model we will use in this exercise to practice Argo CD deployments. Use
    it as much as you want as a starting point to build a comprehensive and complex
    ALM workflow that’s suitable for your needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Application delivery model using Tekton, Argo CD, and Git
    ](img/B18015_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – Application delivery model using Tekton, Argo CD, and Git
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, we are going to use the content we have prepared in this book’s
    GitHub repository. To do this, you must *fork this repository to your GitHub account*:
    [https://github.com/PacktPublishing/OpenShift-Multi-Cluster-Management-Handbook](https://github.com/PacktPublishing/OpenShift-Multi-Cluster-Management-Handbook).
    Once you have forked it, follow the instructions in this section to put this workflow
    into practice.'
  prefs: []
  type: TYPE_NORMAL
- en: Building a new image version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will build a new container image version, 1.0, and push
    it to the OpenShift internal registry, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Building a new image version ](img/B18015_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 – Building a new image version
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the repository in your machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following script and follow the instructions to change the references
    from the original repository (`PacktPublishing`) to your forked repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new branch for development:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `./sample-go-app/clouds-api/clouds.go` file with your preferred text
    editor and change line 147 by adding `version=1.0` to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Commit and push change to the `dev` branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following command to deploy the required prerequisites and the pipeline
    that builds image version 1.0, which we will deploy in the development namespace
    shortly. Make sure that you are already logged into the OpenShift cluster (by
    using the `oc login` command):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, run the pipeline and check the logs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, you have built the `clouds-api:v1.0` container image and pushed it
    to OpenShift’s internal registry. Now, let’s deploy this image using **Kustomize**
    and **Argo CD**.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying in development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to use Kustomize to overwrite the image tag of
    the deployment YAML file so that it uses `v1.0`, which we built in the previous
    section. We will also create a new namespace for the development branch named
    `clouds-api-dev`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the steps we will perform:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13 – Deploying in development ](img/B18015_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 – Deploying in development
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the image version of our development `kustomization.yaml` file. To do
    so, change line 18 from `changeme` to `v1.0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, you may use the `sed` command to replace this line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, push this change to the `dev` branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s create a new Argo CD project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new Argo CD application that will deploy the application in the development
    namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get Argo CD’s URL and admin passwords using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Access the Argo CD UI using the URL and admin user provided previously. You
    should see a new application there named `clouds-app-dev`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.14 – The Argo CD application to deploy in development ](img/B18015_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14 – The Argo CD application to deploy in development
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **clouds-app-dev** to learn more about the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.15 – The Argo CD application ](img/B18015_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.15 – The Argo CD application
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `curl` command to check that version 1.0 of the application is running
    and has been successfully deployed by Argo CD:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, our sample application is running in the development namespace.
    Now, let’s learn how to promote this application to the next stage: QA.'
  prefs: []
  type: TYPE_NORMAL
- en: Promoting to QA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have application version 1.0 running in development. Now, let’s use Kustomize
    and Argo CD once more to deploy it in a new namespace that’s dedicated to QA,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.16 – Promoting to QA ](img/B18015_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.16 – Promoting to QA
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new branch for QA:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an overlay for QA by copying the `dev` overlay:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the references to `dev` with `qa`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Push the changes to Git:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Deploy the manifest file to promote the environment using Argo CD:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Access the Argo CD UI again. At this point, you should have two applications
    on Argo CD:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.17 – Argo CD applications ](img/B18015_10_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.17 – Argo CD applications
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s access the application that is running in the QA namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the same response that you saw previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: With that, we have promoted our application to QA! Now, let’s learn how to move
    it to the last stage, which is the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Promoting to production
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For production, we are going to use a different approach – we are going to
    use PRs instead of simple Git pushes. We will use a temporary branch named `pre-prod`
    to commit the overlay manifests that will be used for production, as shown in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.18 – Promoting to production ](img/B18015_10_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.18 – Promoting to production
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to promote version 1.0 of our application to production:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new branch to prepare for production:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an overlay for production, similar to what you did with QA:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Push the changes to the `pre-prod` branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a PR on GitHub and merge it with the main branch. Access the **Pull
    requests** tab of your GitHub repository and click the **New pull request** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.19 – Creating a PR ](img/B18015_10_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.19 – Creating a PR
  prefs: []
  type: TYPE_NORMAL
- en: 'Since you are working in the forked repository, GitHub suggests that you create
    a PR for the source repository (in this case, from `PacktPublishing`). We want
    to create a PR that goes from our `pre-prod` branch to the `main` branch, both
    in our forked repository. So, change the base repository to our forked repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.20 – Creating a PR ](img/B18015_10_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.20 – Creating a PR
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, select `pre-prod` in the **compare** field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.21 – Creating a PR ](img/B18015_10_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.21 – Creating a PR
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, fill out the form and click **Create pull request**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.22 – Creating a PR ](img/B18015_10_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.22 – Creating a PR
  prefs: []
  type: TYPE_NORMAL
- en: 'In a real-life scenario, this PR would be reviewed, approved by peers, and
    then merged. We are still practicing at the moment, so let’s go ahead and click
    the **Merge pull request** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.23 – Approving the PR ](img/B18015_10_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.23 – Approving the PR
  prefs: []
  type: TYPE_NORMAL
- en: 'The overlay manifests for version 1.0 of the production environment are already
    in the `main` branch of our Git repository. This means we can deploy it using
    Argo CD:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, you should have three applications on Argo CD:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.24 – Argo CD applications ](img/B18015_10_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.24 – Argo CD applications
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s access the application to see version 1.0 of our application running
    in production:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the same response that you saw previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Congratulations! We have deployed our application using Argo CD into three
    different namespaces, each one representing a different environment: development,
    QA, and production. Since this book is intended to be about *multi-cluster*, we
    must learn how to do the same process but deploy into multiple clusters, instead
    of only one. In the next section, you will see that the process is the same, except
    you must change one parameter in Argo CD’s `Application` object.'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to multiple clusters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We learned how to register external clusters in the *Configuring Argo CD against
    multiple clusters* section. As soon as you have multiple external clusters registered
    to Argo CD, deploying an application to one of them is simple – you only need
    to refer to the external cluster you registered in the `destination` field of
    Argo CD’s `Application`. An example of this can be seen in the following manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: You can create as many `Application` objects as you need, deploying only to
    the local cluster or including multiple external clusters. As you have seen, the
    deployment process itself is similar, regardless of whether you are deploying
    to a local or external cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: When you work with multiple clusters, you need to pay special attention to the
    **container image registry**. The OpenShift internal registry, as its name suggests,
    should only be used internally in a single cluster; it is not suitable for multiple
    clusters. In such a case, an enterprise container image registry is recommended.
    There are multiple options on the market, such as Nexus, Quay, Harbor, and many
    others. In this book, we will cover Quay in [*Chapter 13*](B18015_13.xhtml#_idTextAnchor275),
    *OpenShift Plus – a Multi-Cluster Enterprise-Ready Solution*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about various concepts related to **GitOps**. You
    also learned about **Argo CD** and how to install it on OpenShift and use it.
    You also built and deployed a sample application to three different namespaces
    to simulate the *development*, *QA*, and *production* environments. Finally, you
    learned that deploying to the local or external cluster is a similar process –
    you only need to change the destination server field.
  prefs: []
  type: TYPE_NORMAL
- en: Argo CD allows you to establish an efficient and robust application delivery
    model using GitOps, in which you ensure *consistency*, *auditable changes*, and
    a *secure process*, no matter where you are deploying your applications. And the
    best part is that there is no additional cost to use it since it is included in
    Red Hat OpenShift’s subscription. That said, if you are deploying containerized
    applications on OpenShift, I strongly recommend that you try OpenShift GitOps
    and use the concepts we explored in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore a great tool that will help you deploy
    and manage several OpenShift clusters from a single unified interface – **Red
    Hat Advanced Cluster Management**. This tool allows you to monitor, manage, define,
    and enforce policies and deploy applications to several clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on and take a deep dive into Red Hat Advanced Cluster Management!
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To find out more about the topics that were covered in this chapter, take a
    look at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A History of GitOps:* [https://www.weave.works/blog/the-history-of-gitops](https://www.weave.works/blog/the-history-of-gitops
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Argo CD official documentation:* [https://argo-cd.readthedocs.io/](https://argo-cd.readthedocs.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Great tutorial about* **Kustomize**: [https://blog.stack-labs.com/code/kustomize-101/](https://blog.stack-labs.com/code/kustomize-101/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Bitnami’s Sealed Secrets overview:* [https://github.com/bitnami-labs/sealed-secret](https://github.com/bitnami-labs/sealed-secrets).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
