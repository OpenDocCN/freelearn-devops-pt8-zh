<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Extending Puppet</h1>
                </header>
            
            <article>
                
<p>The Puppet ecosystem, which is over 10 years old now, was originally written in Ruby.</p>
<p>There has been a lot of progress made toward moving the main code base to the Clojure language (especially the main Puppet Server and PuppetDB components); however, there are still several parts of the ecosystem that can still be accessed at the Ruby level for the purposes of extending Puppet to suit more advanced use cases, namely the following:</p>
<ul>
<li>Custom facts</li>
<li>Custom functions</li>
<li>Types and providers</li>
</ul>
<p>Let'<span>s consider each of these in turn, and see how we can extend Puppet on both the client and server side using firstly some rudimentary and then later some more advanced understanding of Ruby code.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Custom facts</h1>
                </header>
            
            <article>
                
<p>Custom facts are a client-side technology for extracting arbitrary information from the node during the execution of the agent run, and they may be utilized in Puppet manifests or templates, along with any other distributed facts. Facts are executed on the Puppet agent.</p>
<p>The best way to create and distribute a new custom fact is to place it in a module, in the <kbd>facter</kbd> subdirectory of the <kbd>lib</kbd> directory, and it will then be distributed to the agent machine via <kbd>pluginsync</kbd>.</p>
<div class="packt_infobox">
<p>This documentation page at <a href="https://puppet.com/docs/puppet/5.3/plugins_in_modules.html#adding-plug-ins-to-a-module">https://puppet.com/docs/puppet/5.3/plugins_in_modules.html#adding-plug-ins-to-a-module</a> shows you exactly where in a module to place your code, and the section at <a href="https://puppet.com/docs/puppet/5.3/plugins_in_modules.html#installing-plug-ins">https://puppet.com/docs/puppet/5.3/plugins_in_modules.html#installing-plug-ins</a>, in the same documentation, shows the technical details for <kbd>pluginsync</kbd>.</p>
</div>
<p>The following diagram illustrates the <kbd>pluginsync</kbd> process that precedes a normal catalog request. Usually, a <kbd>GET</kbd> method is called on the Puppet server using the FQDN, which then initiates the <kbd>pluginsync</kbd> process, and the appropriate facts, types, and providers are distributed back to the agent:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/d31e01c4-ec1c-4801-a206-e03360fb7f18.png" style="width:40.92em;height:39.67em;"/></div>
<p class="mce-root"/>
<div class="packt_infobox">
<p>You can review the exact details for all the HTTPS communication between the Puppet agent and Puppet Server at <a href="https://puppet.com/docs/puppet/5.3/subsystem_agent_master_comm.html">https://puppet.com/docs/puppet/5.3/subsystem_agent_master_comm.html</a><span>.</span></p>
</div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Most of the time, I have found that a fact is generally just an execution of an arbitrary command-line expression, and that is a good way to think generally about facts: they effectively consist of a Ruby wrapper, usually around a command-line expression that makes itself available to the Puppet ecosystem via Facter.</p>
<p>The following code would be a good snippet to use as a template for further development:</p>
<pre># &lt;modulepath&gt;/lib/facter/mycustomfact.rb<br/>Facter.add(:mycustomfact) do<br/>   confine :kernel =&gt; "Linux"<br/>   ...<br/>   myvar = Facter::Core::Execution.exec("foo")<br/>  ...<br/> end</pre>
<p>Do make sure that you <kbd>confine</kbd> your fact appropriately. There's nothing worse than when you introduce a new operating system to your infrastructure only to find that you are now executing failing facts because they don't use a certain command syntax. Or, what if we suddenly introduce a handful of Windows nodes, only to find that Windows doesn't, of course, understand most Linux commands?</p>
<p>Bear this in mind during your authoring of custom facts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Debugging facts</h1>
                </header>
            
            <article>
                
<p>You can debug Facter by using a <kbd>facter.debug</kbd> statement anywhere in your custom fact's Ruby code, as shown in the following:</p>
<pre>Facter::Type.newtype(:mycustomfact) do<br/>   ...<br/>   Facter.debug "foo is the value: #{foo}"<br/>   ...<br/> end</pre>
<p>During debugging, running Facter by itself won't pick up your new custom fact since it would usually require the <kbd>pluginsync</kbd> process to distribute it. You must set the <kbd>FACTERLIB</kbd> environment variable to shortcut this process when you are developing and debugging the new code on your development node. Let's say you have the <kbd>some_facts</kbd> and <kbd>some_other_facts</kbd> subdirectories in your personal working directory, where you are editing the Ruby code for a new fact you are developing. You would set the code up as follows:</p>
<pre><strong>$ ls ~/some_facts</strong><br/><strong> mycustomfact.rb</strong><br/><strong>$ ls ~/some_other_facts</strong><br/><strong> myothercustomfact.rb</strong><br/><strong>$ export FACTERLIB="~/some_facts: ~/some_other_facts"</strong><br/><strong>$ facter mycustomfact myothercustomfact –debug</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Custom functions</h1>
                </header>
            
            <article>
                
<p>This is where custom facts allow us to run arbitrary code on the client side. Custom functions are a <em>server-side</em> technology that assist you in the compilation of a catalog. Functions are executed on the Puppet server. Puppet already includes several functions that are built-in, and additional ones are contained in Puppet Forge modules, particularly the <kbd>stdlib</kbd> module (see <a href="https://forge.puppet.com/puppetlabs/stdlib">https://forge.puppet.com/puppetlabs/stdlib</a>).</p>
<p>There are, in fact, three possible ways to create custom functions, although you are unlikely to use the first two, so I will just leave you with some links to the Puppet documentation for those options:</p>
<ul>
<li>You could write the function in Puppet DSL (see <a href="https://puppet.com/docs/puppet/5.3/lang_write_functions_in_puppet.html">https://puppet.com/docs/puppet/5.3/lang_write_functions_in_puppet.html</a>), although you'll be unable to take advantage of the more powerful Ruby API.</li>
<li>You could write the function in the legacy Ruby functions API (see <a href="https://puppet.com/docs/puppet/5.3/functions_legacy.html">https://puppet.com/docs/puppet/5.3/functions_legacy.html</a>), although this is to be avoided unless you must specifically support Puppet 3.</li>
<li>You could write the function in the modern Ruby function API. This is what we'll concentrate on for the remainder of this section.</li>
</ul>
<p>The best way to create and distribute a new custom function is to place it in a module, in the <kbd>puppet/functions/&lt;modulename&gt;</kbd> subdirectory of the <kbd>lib</kbd> directory, and it will then be distributed via <kbd>pluginsync</kbd>, as shown in the following code:</p>
<pre>#&lt;modulepath&gt;/lib/puppet/functions/mymodule/myfunction.rb<br/>Puppet::Functions.create_function(:'mymodule::myfunction') do<br/>  dispatch :up do<br/>    param 'String', :a_string<br/>  end<br/>  def up(a_string)<br/>    a_string.upcase<br/>  end<br/>end</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Types and providers</h1>
                </header>
            
            <article>
                
<p>Puppet already has a very rich lexicon of built-in resource types (see <a href="https://puppet.com/docs/puppet/5.3/type.html">https://puppet.com/docs/puppet/5.3/type.html</a>), and these have also been extended with additional modules. Windows-specific resource types would be a very good example of where Puppet has had its resource types successfully extended (see <a href="https://puppet.com/docs/puppet/5.3/resources_windows_optional.html">https://puppet.com/docs/puppet/5.3/resources_windows_optional.html</a>).</p>
<p>The following are some indications that you may want to consider writing a type and provider as an alternative to regular modules and manifests in Puppet DSL:</p>
<ul>
<li>You have several <kbd>exec</kbd> statements in your Puppet DSL with convoluted <kbd>onlyif</kbd> and <kbd>unless</kbd> conditional properties</li>
<li>Puppet doesn't handle situation very well where:
<ul>
<li>Your Puppet DSL is not a powerful-enough API, and you need access to pure Ruby to manipulate data</li>
<li>Your Puppet DSL code has significant and quite convoluted conditional logic</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Types</h1>
                </header>
            
            <article>
                
<p>Go through the following steps to create your type:</p>
<ol>
<li>Create and distribute the type</li>
<li>Add the<span> </span><kbd>namevar</kbd> special attribute</li>
<li>Add additional type<span> </span>properties</li>
<li>Add the optional<span> </span><kbd>ensure</kbd> property</li>
<li>Add type<span> </span>parameters</li>
<li>Set the property and parameter<span> </span>defaults</li>
<li>Check the input value with a validate block</li>
<li>Check the input value against a<span> </span><kbd>newvalues</kbd> array</li>
<li>Check datatype compatibility with<span> </span><kbd>munge</kbd></li>
<li>Use<span> </span><kbd>AutoRequire</kbd> for implicit relationships</li>
<li>Use<span> </span><kbd>Arrays</kbd><kbd> </kbd>to list the values of an attribute</li>
<li>Use the<span> </span><kbd>desc</kbd> method to add inline documentation</li>
</ol>
<p class="mce-root"/>
<div class="packt_infobox">
<p>Check out the official documentation page on Puppet types at <a href="https://puppet.com/docs/puppet/5.3/custom_types.html">https://puppet.com/docs/puppet/5.3/custom_types.html</a>. Gary Larizza's blog also offers an alternative set of useful examples of types at <a href="http://garylarizza.com/blog/2013/11/25/fun-with-providers/">http://garylarizza.com/blog/2013/11/25/fun-with-providers/</a>.</p>
</div>
<p>Let's now go through each of these steps to create your new type in more detail in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating and distributing the type</h1>
                </header>
            
            <article>
                
<p>The best way to create and distribute a new custom type is to place it into a module, in the <kbd>puppet/type</kbd> subdirectory of the <kbd>lib</kbd> directory, and it will then be distributed to the agent machine via <kbd>pluginsync</kbd>, as we already saw with custom facts in the previous section.</p>
<p>The filename should match the name of the type under development, as shown in the following code:</p>
<pre> &lt;modulepath&gt;/lib/puppet/type/mynewtype.rb<br/> <br/> Puppet::Type.newtype(:mynewtype) do<br/> ...<br/> end</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the namevar special attribute</h1>
                </header>
            
            <article>
                
<p>After we make use of the special attribute of the type, that is its <kbd>namevar</kbd>, we can then actually use a declaration of our resource using the Puppet DSL. The <kbd>namevar</kbd> should identify the resource uniquely within the underlying operating system, and must be something that can be prespecified, as shown in the following code:</p>
<pre>Puppet::Type.newtype(:mynewtype) do<br/> <br/>   mynewparam(:name, :namevar =&gt; true) do<br/>   end<br/> <br/> end</pre>
<p>Now, we can declare our resource in the Puppet DSL. In this case, the <kbd>namevar</kbd> defaults to the resource title, as shown in the following code:</p>
<pre>mynewtype { ‘foo': }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The resource title is used to make a reference to the resource uniquely inside the Puppet catalog. Hence, the <kbd>namevar</kbd> indicates the underlying system's name for that resource, as shown in the following code:</p>
<pre>mynewtype { 'foo':<br/>   name =&gt; 'bar',<br/> }</pre>
<p>Then, run the following command:</p>
<pre><strong>$ puppet apply -e "mynewtype { 'foo': }"</strong><br/><strong>notice: Finished catalog run in 0.09 seconds</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding additional type properties</h1>
                </header>
            
            <article>
                
<p>Type properties are attributes that reflect the current state of that resource on the underlying operating system.</p>
<p>During the Puppet run, these values are actively enforced, so they should be both <em>discoverable</em> and <em>updatable</em>. If the attribute can't be updated, it could be implemented as a read-only property. In the following code, we are extending our example type's interface to define a version property:</p>
<pre>Puppet::Type.newtype(:mynewtype) do<br/>   ...<br/>   mynewproperty(:version) do<br/>   end<br/>   ...<br/> end</pre>
<p>Now we start to use that property in the Puppet DSL, as shown in the following code:</p>
<pre>mynewtype{ 'foo':<br/>   version =&gt; '2.2',<br/> }</pre>
<p>But it won't allow the catalog to compile yet, since there's no implementation for that property in any corresponding provider, as shown in the following command:</p>
<pre><strong>$ puppet apply -e "mynewtype { 'foo': version =&gt; '2.2' }"</strong><br/><strong>err: /Stage[main]// Mynewtype[foo]: Could not evaluate: undefined method 'version' for nil:NilClass</strong><br/><strong>notice: Finished catalog run in 0.04 seconds</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the optional ensure property</h1>
                </header>
            
            <article>
                
<p>Although optional, most native Puppet resource types do have an <kbd>ensure</kbd> property, although there are exceptions—for example, <kbd>. exec</kbd> and <kbd>notify</kbd>. You simply give the resource type the <kbd>ensure</kbd> property by immediately calling <kbd>ensurable</kbd>:</p>
<pre> Puppet::Type.newtype(:mynewtype) do<br/>   ensurable<br/>   ...<br/> end</pre>
<p>The corresponding providers for this type would then implement the <kbd>ensure</kbd> property through the use of <kbd>create</kbd>, <kbd>exists?</kbd>, and <kbd>destroy</kbd> methods.</p>
<p>In Puppet DSL, the <kbd>ensure</kbd> property should be the first attribute in the resource (according to the Puppet style guidelines), and it supports the <kbd>present</kbd> and <kbd>absent</kbd> keywords (<kbd>present</kbd> being the default, so it may be omitted for the sake of brevity), as shown in the following code:</p>
<pre>mynewtype { 'foo':<br/>   ensure =&gt; absent,<br/> }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding type parameters</h1>
                </header>
            
            <article>
                
<p><kbd>Type</kbd> parameters differ from properties in that they don't directly relate to actual discoverable and updatable resources on the underlying system. Rather, they do one of the two following things:</p>
<ul>
<li>Allow you to specify additional informational context for interacting with properties and resources on the underlying system</li>
<li>Provide a layer of abstraction allowing you to override the expected behavior on the underlying system</li>
</ul>
<p>Let's add a <kbd>source</kbd> parameter to our new type using the <kbd>newparam</kbd> method:</p>
<pre>Puppet::Type.newtype(:mynewtype) do<br/>   ...<br/>   newparam(:source) do<br/>   end<br/>   ...<br/> end</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting property and parameter defaults</h1>
                </header>
            
            <article>
                
<p>Let's say we wanted to add an additional <kbd>override</kbd> parameter, which we wanted to configure with a default value of <kbd>false</kbd>. Here's the Ruby code to express that:</p>
<pre>Puppet::Type.newtype(:mynewtype) do<br/>   ...<br/>   newparam(:override) do<br/>     defaultto :false<br/>   end<br/>   ...<br/> end</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Checking the input value with a validate block</h1>
                </header>
            
            <article>
                
<p>We can validate the provided value of a new property called <kbd>version</kbd> with a <kbd>validate</kbd> block and, for example, a <kbd>regex</kbd> expression, as shown in the following code:</p>
<pre>Puppet::Type.newtype(:mynewtype) do<br/>   ...<br/>   newproperty(:version) do<br/>     validate do |value|<br/>       fail("Invalid version specified") unless value =~<br/>         /^(\d+\.)?(\d+\.)?(\*|\d+)$/<br/>     end<br/>   end<br/>   ...<br/> end</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Checking the input value against a newvalues array</h1>
                </header>
            
            <article>
                
<p>We can also validate the provided value of the property with an array of values using the <kbd>newvalues</kbd> method, as shown in the following code:</p>
<pre>Puppet::Type.newtype(:mynewtype) do<br/>   ...<br/>   newparam(:override) do<br/>     defaultto :true<br/>     newvalues(:true, :false)<br/>   end<br/>   ...<br/> end</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Checking datatype compatibility with munge</h1>
                </header>
            
            <article>
                
<p>To decide whether an underlying provider property should be updated, a simple equality comparison is made between the provided value and the value retrieved using the provider.</p>
<p>The <kbd>munge</kbd> method can ensure that the data supplied by the user has a consistent datatype with that expected to be returned from the provider. For example, we could call the <kbd>munge</kbd> method to make sure that the user-supplied datatype of <kbd>integer</kbd> or <kbd>numeric string</kbd> is compatible with the <kbd>integer</kbd> required by the provider, as shown in the following code:</p>
<pre>Puppet::Type.newtype(:mynewtype) do<br/>   ...<br/>   newparam(:identifier) do<br/>     munge do |value|<br/>       Integer(value)<br/>     end<br/>   end<br/>   ...<br/> end</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using autorequire for implicit relationships</h1>
                </header>
            
            <article>
                
<p>To make it easier for users of your type, you can use <kbd>autorequire</kbd>  to avoid tediously specifying a lot of explicit relationships in longhand between resources. The <kbd>autorequire</kbd> method establishes implicit ordering between resources in the catalog. A typical example of this would be filing resources depending on their parent directories.</p>
<p>For example, in our type, if the <kbd>source</kbd> parameter is a file path, then we should ensure the corresponding <kbd>file</kbd> resource is managed first, as shown in the following code:</p>
<pre>Puppet::Type.newtype(:mynewtype) do<br/>   ...<br/>   autorequire(:file) do<br/>     self[:source]<br/>   end<br/>   ...<br/> end</pre>
<p>Manually specified dependencies in the Puppet DSL have a higher precedence for the compiler than the implicit dependencies that are put in place by virtue of the <kbd>autorequire</kbd> method.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using arrays to assign a list of values to an attribute</h1>
                </header>
            
            <article>
                
<p>When the expected value of an attribute is an array, the <kbd>array_matching</kbd> option should be included in the call to <kbd>newproperty</kbd> with a value of <kbd>all</kbd>. All values of the array are then used for that attribute, as shown in the following code:</p>
<pre>Puppet::Type.newtype(:mynewtype) do<br/>   ...<br/>   newproperty(:myarray, :array_matching =&gt; :all) do<br/>   end<br/>   ...<br/> end</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the desc method to add inline documentation</h1>
                </header>
            
            <article>
                
<p>Users of your new type can use the <kbd>puppet describe</kbd> and <kbd>puppet doc</kbd> commands to fetch the inline documentation you've configured. For a full description of all the types currently configured in your environment, including custom resources, run the following command:</p>
<pre><strong>$ puppet describe –list</strong></pre>
<p>Let's finish our type example now by adding some inline documentation using the <kbd>desc</kbd> method:</p>
<pre>Puppet::Type.newtype(:mynewtype) do<br/> <br/>   ensurable<br/> <br/>   newparam(:override) do<br/>     desc 'whether or not to override'<br/>     defaultto :true<br/>     newvalues(:true, :false)<br/>   end<br/> <br/>   newproperty(:version) do<br/>     desc 'the version to use for mynewtype'<br/>     validate do |value|<br/>       fail("Invalid version") unless value =~<br/>         /^(\d+\.)?(\d+\.)?(\*|\d+)$/<br/>     end<br/>   end<br/> <br/>   newparam(:identifier) do<br/>     desc 'the identifier for mynewtype'<br/>     munge do |value|<br/>       Integer(value)<br/>     end<br/>   end<br/> <br/> end</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Providers</h1>
                </header>
            
            <article>
                
<p>Providers are the implementation of the resources on a system. Types express the interface used in describing the resources, whereas providers provide the implementation about how the resources interact with the underlying system.</p>
<p class="mce-root">The separation between the interface and its implementation allows multiple providers to be developed for a type.</p>
<p class="mce-root">The <kbd>package</kbd> type provided as part of a Puppet installation, for example, has many separate providers that interact with systems, including <kbd>rpm</kbd>, <kbd>apt</kbd>, <kbd>yum</kbd>, <kbd>zipper</kbd>, <kbd>chocolatey</kbd>, and so on. All that's needed for a new provider to be developed is for it to adhere to the interface defined in its type.</p>
<div class="packt_infobox">
<p>You can check out the official documentation pages on Puppet providers at <a href="https://puppet.com/docs/puppet/5.3/custom_types.html#providers">https://puppet.com/docs/puppet/5.3/custom_types.html#providers</a> and <a href="https://puppet.com/docs/puppet/5.3/provider_development.html">https://puppet.com/docs/puppet/5.3/provider_development.html</a>. Gary Larizza's blog also offers an alternative set of useful examples on providers at <a href="http://garylarizza.com/blog/2013/11/26/fun-with-providers-part-2/">http://garylarizza.com/blog/2013/11/26/fun-with-providers-part-2/</a><span>.</span></p>
</div>
<p>Go through the following steps to create a new provider for your type:</p>
<ol>
<li>Create and distribute your provider</li>
<li>Indicate the suitability of the provider to the type in the following ways:
<ul>
<li>Using the <kbd>confine</kbd> method</li>
<li>Using the <kbd>defaultfor</kbd> method</li>
<li>Using the <kbd>commands</kbd> method</li>
</ul>
</li>
<li>Implement the <kbd>ensure</kbd> property
<ul>
<li>Using the <kbd>exists?</kbd> method</li>
<li>Using the <kbd>create</kbd> and <kbd>destroy</kbd> methods</li>
</ul>
</li>
<li>Use the <kbd>GET</kbd> and <kbd>SET</kbd> methods to manage type properties</li>
<li>Implement the <kbd>self.instances</kbd> method</li>
</ol>
<p class="mce-root"/>
<p>Let's now go into more detail for each of these steps for creating your new provider in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating and distributing the provider</h1>
                </header>
            
            <article>
                
<p>The best way to create and distribute a new provider for your type is to place it into the same module, in the <kbd>puppet/provider/&lt;typename&gt;</kbd> subdirectory of the <kbd>lib</kbd> directory, and it will then be distributed to the agent machine via <kbd>pluginsync</kbd>. Note that the filename should match the name of the provider, as shown in the following code:</p>
<pre># &lt;modulepath&gt;/lib/puppet/provider/mynewtype/myprovider.rb<br/> <br/> Puppet::Type.type(:mynewtype).provide(:myprovider) do<br/>   ...<br/> end</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Indicating the suitability of the provider to the type</h1>
                </header>
            
            <article>
                
<p>The <kbd>confine</kbd> and <kbd>commands</kbd> <span>methods</span><span> </span><span>are used to ascertain which providers are valid for the type, and the </span><kbd>defaultfor</kbd> <span>method</span> <span>is used to indicate the default provider where there are multiple providers. Let's take a look at each of these methods.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the confine method</h1>
                </header>
            
            <article>
                
<p>The <kbd>confine</kbd> method can be used with a fact, as shown in the following code:</p>
<pre>Puppet::Type.type(:mynewtype).provide(:myprovider) do<br/>   ...<br/>   confine :osfamily =&gt; :redhat<br/>   ...<br/> end</pre>
<p>The <kbd>confine</kbd> method could also use <kbd>exisits</kbd> to base its conditions on whether a certain file is present on the system under management. The following example demonstrates how the provider is restricted to only those systems where Puppet's <kbd>.config</kbd> file exists:</p>
<pre>Puppet::Type.type(:mynewtype).provide(:myprovider) do<br/>   ...<br/>   confine :exisits =&gt; Puppet[:config]<br/>   ...<br/> end</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Another possibility is to base the conditions of the <kbd>confine</kbd> method on certain Puppet features (they are all listed in the source code directory at <a href="https://github.com/puppetlabs/puppet/tree/master/lib/puppet/feature">https://github.com/puppetlabs/puppet/tree/master/lib/puppet/feature</a>), as shown in the following code:</p>
<pre>Puppet::Type.type(:mynewtype).provide(:myprovider) do<br/>   ...<br/>   confine :feature =&gt; :selinux<br/>   ...<br/> end</pre>
<p>Finally, <kbd>confine</kbd> can accept a Boolean expression to restrict your provider, as shown in the following code:</p>
<pre>Puppet::Type.type(:mynewtype).provide(:myprovider) do<br/>   ...<br/>   confine :exisits =&gt;  Puppet[:config]<br/>   ...<br/>   confine :true =&gt; begin<br/>     if File.exists?(Puppet[:config])<br/>       File.readlines(Puppet[:config]).find {|line| line =~ /^\s*\[agent\]/ }<br/>     end<br/>   end<br/>   ...<br/> end</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the defaultfor method</h1>
                </header>
            
            <article>
                
<p>The <kbd>confine</kbd> method is fine, but its usage may still result in multiple valid providers for a particular resource type. In this circumstance, the type should specify its preferred provider using the <kbd>defaultfor</kbd> method.</p>
<p>The <kbd>defaultfor</kbd> method uses a fact name and value as its arguments, which are then used to determine the default provider for certain types of underlying system.</p>
<p>For example, on Red Hat systems, both <kbd>yum</kbd> and <kbd>rpm</kbd> would be valid as providers to the package resource type, but the <kbd>defaultfor</kbd> method would be used to indicate that for Red Hat systems, <kbd>yum</kbd> is in fact the default provider, as shown in the following code:</p>
<pre>Puppet::Type.type(:mynewtype).provide(:yum) do<br/>   ...<br/>   confine :osfamily =&gt;  :redhat<br/>   defaultfor: osfamily =&gt; :redhat<br/>   ...<br/> end</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the commands method</h1>
                </header>
            
            <article>
                
<p>Confining providers may also be based on the availability of certain commands from the system path using the <kbd>commands</kbd> method.</p>
<p>More importantly, by using the special methods generated by <kbd>commands</kbd>, we can also inform Puppet of the correct commands for interacting with the underlying system. This is preferable over Ruby's own methods for command execution, such as <kbd>%x{cmd}</kbd> or <kbd>cmd</kbd> for the following reasons:</p>
<ul>
<li>Puppet displays commands invoked this way when the <kbd>--debug</kbd> flag is set</li>
<li>They are documented as a requirement for the provider</li>
<li>Exceptions are handled consistently by raising a <kbd>Puppet::ExecutionFalure</kbd></li>
</ul>
<p>This is shown in the following code:</p>
<pre>Puppet::Type.type(:mynewtype).provide(:yum) do<br/>   ...<br/>   commands :yum =&gt; 'yum', :rpm =&gt; 'rpm'<br/>   ...<br/> end</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the ensure property</h1>
                </header>
            
            <article>
                
<p>In order to implement the <kbd>ensure</kbd> property, the providers need to be able to ascertain whether the resource exists, create the resource where it doesn't exist, and destroy resources that exist. This is implemented by virtue of the <kbd>exists?</kbd>, <kbd>create</kbd>, and <kbd>destroy</kbd> methods, which we will look at in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the exists? method</h1>
                </header>
            
            <article>
                
<p>The <kbd>exists?</kbd> method retrieves the <kbd>ensure</kbd> state of the resource. A Boolean is returned, as shown in the following code:</p>
<pre>Puppet::Type.type(:mynewtype).provide(:yum) do<br/>   ...<br/>   confine :osfamily =&gt;  :redhat<br/>   defaultfor: osfamily =&gt; :redhat<br/>   ...<br/>   def exists?<br/>     begin<br/>       rpm('-q', resource[:name])<br/>     rescue Puppet::ExecutionFailure =&gt; e</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<pre>       false<br/>     end<br/>   end<br/>   ...<br/> end<br/> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the create and destroy methods</h1>
                </header>
            
            <article>
                
<p>The existence state of a resource is modified with reference to the declaration of the resource with the <kbd>ensure</kbd> property by the user in the Puppet DSL by using the <kbd>create</kbd> and <kbd>destroy</kbd> methods.</p>
<p>The <kbd>create</kbd> method is called when both of the following criteria have been met:</p>
<ul>
<li>The <kbd>ensure</kbd> property has been set to <kbd>present</kbd> in the resource declaration</li>
<li>The <kbd>false</kbd> value is returned by the <kbd>exists?</kbd> method (to indicate that the resource doesn't already exist)</li>
</ul>
<p>The <kbd>destroy</kbd> method is called when both of the following criteria have been met:</p>
<ul>
<li>The <kbd>ensure</kbd> property has been set as <kbd>absent</kbd> in the resource declaration</li>
<li>The <kbd>true</kbd> value is returned by the <kbd>exists?</kbd> method (to indicate that the resource already exists)</li>
</ul>
<p>The following code shows how you can use these methods:</p>
<pre>Puppet::Type.type(:mynewtype).provide(:yum) do<br/>   ...<br/>   def create<br/>     package=resource[:version] ?<br/>       “#{resource[:name]}-#{resource[:version]}]” : resource[:name]<br/>     yum(‘install', ‘-y, package')<br/>   end<br/>   ...<br/>   def destroy<br/>     yum(‘erase', ‘-y', resource[:name])<br/>   end<br/>   ...<br/> end</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the GET and SET methods to manage type properties</h1>
                </header>
            
            <article>
                
<p>Each property defined in the type should implement a <kbd>GET</kbd> and <kbd>SET</kbd> method in the provider.</p>
<p>Puppet will then invoke these methods during a Puppet run to manage the property as follows:</p>
<ol>
<li>The <kbd>GET</kbd> method is called initially to retrieve the current value</li>
<li>This is subsequently compared against the value declared by the user in the Puppet DSL</li>
<li>If the values are different, then the <kbd>SET</kbd> method is invoked to update that value if necessary.</li>
</ol>
<p>This is shown in the following code:</p>
<pre>Puppet::Type.type(:mynewtype).provide(:yum) do<br/>   ...<br/>   def version<br/>     version = rpm('-q', resource[:name])<br/>     if version =~ /^#{Regexp.escape(resource[:name])}-(.*)/<br/>       $1<br/>     end<br/>   end<br/> <br/>   def version=(value)<br/>     yum('install', "#{resource[:name]}-#{resource[:version]}")<br/>   end<br/>   ...<br/> end</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the self.instances method</h1>
                </header>
            
            <article>
                
<p>Puppet provides an additional mode of operation, that being the discovery of resources using the <kbd>puppet resource</kbd> command. The <kbd>self.instances</kbd> method should implement the return of any instances of a particular resource type that the provider is able to find on the underlying system.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The following example illustrates the use of the <kbd>rpm -qa</kbd> command to query for all packages installed on the underlying Red Hat system:</p>
<pre>Puppet::Type.type(:mynewtype).provide(:yum) do<br/>   ...<br/>   def self.instances<br/>     pkgs = rpm('-qa','--qf','%{NAME} %{VERSION}-%{RELEASE}\n')<br/>     pkgs.split("\n").collect do |entry|<br/>       name, version = entry.split(' ', 2)<br/>       new( :name =&gt; name,<br/>         :ensure =&gt; :present,<br/>         :version =&gt; version<br/>       )<br/>     end<br/>   end<br/>   ...<br/> end</pre>
<p>Each resource returned by <kbd>self.instances</kbd> stores the attributes in the <kbd>@property_hash</kbd> <span>instance variable</span><span>. All the other methods in the provider have access to the property hash, so we could implement the</span> <kbd>exists?</kbd> <span>and</span> <kbd>version</kbd> <span>methods in our provider in a much simpler way, as shown in the following code:</span></p>
<pre>Puppet::Type.type(:mynewtype).provide(:yum) do<br/>   ...<br/>   def exists?<br/>     @property_hash[:ensure] == :present<br/>   end<br/> <br/>   def version<br/>     @property_hash[:version]<br/>   end<br/>   ...<br/> end</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we looked at extending Puppet with client-side facts, server-side custom functions, and custom types and providers. You can see that with some Ruby know-how, you can easily extend the Puppet ecosystem to cover some of your own unique requirements.</p>
<p>In the next chapter, we'll be taking a look at Hiera 5, which we'll use to create a separation between code and business data.</p>


            </article>

            
        </section>
    </body></html>