<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">Security and Identity</h1>
            </header>

            <article>
                
<p>In this chapter, we will cover:</p>
<ul>
<li>Federating with your AWS account</li>
<li>Creating SSL certificates</li>
<li>Active Directory as a service</li>
<li>Creating users</li>
<li>Creating instance roles</li>
<li>Cross-account user roles</li>
<li>Storing secrets</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Introduction</h1>
            </header>

            <article>
                
<p>Security is one of the most critical areas of using the cloud. It's important to get it right because good security practices reinforce themselves, leading to a virtuous cycle of capabilities and control.</p>
<p>There are many tools and AWS services to ensure that your cloud-based infrastructure is as secure—if not more secure—than your own resources.</p>
<p>AWS IAM is the backbone of security in AWS. It provides incredibly granular levels of permissions to allow (and deny) specific users access to your resources.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Federating with your AWS account</h1>
            </header>

            <article>
                
<p>This recipe will show you how to federate identities from your Active Directory and use AD groups and IAM roles to provide different levels of access to multiple AWS accounts.</p>
<p>At a high level, we're going to have an AWS account that is designated as an Auth Account. Users will log in to this account and be assigned a role. This role will have next to no privileges because we don't want them doing anything in the <strong>Auth Account</strong>. However, they will be able to use role switching to access another AWS account; we'll call this the <strong>App Account</strong>.</p>
<p>This is a reasonably common pattern whereby users will have access to a number of AWS accounts and use role switching to jump between them—all using credentials that are verified against an AD backend and a level of access that is derived from AD groups.</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_001.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Federation</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Getting ready</h1>
            </header>

            <article>
                
<p>You'll need the following before we can proceed:</p>
<ul>
<li>An instance of Simple AD. Refer to the <em>Active Directory as a service</em> recipe.</li>
<li>The name of an access URL, which your users will use to log in (that is, <a href="https://bluthcorp.awsapps.com"><span class="URLPACKT">https://bluthcorp.awsapps.com</span></a>).</li>
<li>Two AWS accounts. One of these will be your <em>Auth</em> <em>Account</em>, the other will be your <em>App</em> <em>Account</em>.</li>
<li>A Windows server in your VPC, joined to your Simple AD domain, with Remote Server Admin Tools installed so we can manage groups and users.</li>
</ul>
<div class="packt_tip">If you launch the Windows server using the launch wizard, it will give you the option of joining the domain at boot time. Note that the server will need to be running with an instance role that will have the following two AWS Managed Policies: <span class="packt_screen">AmazonEC2RoleForSSM</span> and <span class="packt_screen">AmazonSSMReadOnlyAccess</span>.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<p>This recipe is split up in to five parts:</p>
<ul>
<li>Active Directory configuration</li>
<li>Auth Account policy configuration</li>
<li>Auth Account role configuration</li>
<li>Simple AD Directory configuration</li>
<li>App Account role configuration</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Active Directory configuration</h1>
            </header>

            <article>
                
<p>Our first task will be to create the necessary groups in Active Directory:</p>
<ol>
<li>Go ahead and create a group called <kbd>AWSPowerUser</kbd>, as shown in the following screenshot:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_002.png"/></div>
<ol start="2">
<li>Do the same for the <kbd>AWSReadOnly</kbd> group:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_003.png"/></div>
<ol start="3">
<li>We're now going to create a couple of users. The first one is <kbd>Lucille</kbd>, as shown in the following screenshot:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_004.png"/></div>
<ol start="4">
<li>The next user will be <kbd>Buster</kbd>. Let's add him now:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_005.png"/></div>
<ol start="5">
<li><kbd>Lucille</kbd> is going to be our power user, so we'll add her to the <kbd>AWSPowerUser</kbd> group:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_006.png"/></div>
<ol start="6">
<li>We don't really trust <kbd>Buster</kbd> at all. True to his name, he's prone to breaking things. Let's add him to the <kbd>AWSReadOnly</kbd> group:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_007.png"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Auth Account policy configuration</h1>
            </header>

            <article>
                
<p>We now we need to create a policy in our Auth Account. Remember that this is the account that the users <kbd>Lucille</kbd> and <kbd>Buster</kbd> will initially log in to when visiting the AWS console. We actually want to give them extremely limited access to this account. In fact, the only thing we're going to let them do is attempt to switch to a role in the application account.</p>
<ol>
<li>Visit the IAM console in the Auth Account and create a new policy:</li>
</ol>
<div class="packt_infobox">AWS refers to this type of policy as a <em>Customer Managed Policy</em>.</div>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_008.png"/></div>
<ol start="2">
<li>Call this policy <kbd>AllowAssumeRole</kbd>. Give it a description to help you remember what it's for. Then apply the following policy document. You are going to want to make sure the account number of the App Account is added to your policy:</li>
</ol>
<pre>
      { <br/>        "Version": "2012-10-17", <br/>        "Statement": [ <br/>            { <br/>              "Sid": "Stmt1487396837000", <br/>              "Effect": "Allow", <br/>              "Action": [ <br/>                  "sts:AssumeRole" <br/>              ], <br/>              "Resource": [ <br/>                  "arn:aws:iam::&lt;app-acct-number&gt;:role/*" <br/>              ] <br/>            } <br/>        ] <br/>      }
</pre>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_009.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Auth Account policy config</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Auth Account role configuration</h1>
            </header>

            <article>
                
<p>Now we're going to create two roles. These roles will correspond to the groups we defined in Active Directory:</p>
<ul>
<li><kbd>AWSPowerUser</kbd>: <kbd>CanAssumePowerUser</kbd></li>
<li><kbd>AWSReadOnly</kbd>: <kbd>CanAssumeReadOnly</kbd></li>
</ul>
<ol>
<li>Start by creating the <kbd>CanAssumePowerUser</kbd> role first:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_010.png"/></div>
<ol start="2">
<li>We want this role to be an <span class="packt_screen">AWS Directory Service</span> role, so be sure to select it before proceeding:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_011.png"/></div>
<ol start="3">
<li>Attach the <kbd>AllowAssumeRole</kbd> policy we have already created to this role:</li>
</ol>
<div class="packt_tip">Hint: You can filter the roles using the search box to make finding them easier.</div>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_012.png"/></div>
<ol start="4">
<li>Click <span class="packt_screen">Create Role</span> to confirm:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_013.png"/></div>
<ol start="5">
<li>Now go ahead and do exactly the same for the <kbd>CanAssumeReadOnly</kbd> role. Again, attach the <kbd>AllowAssumeRole</kbd> policy we created earlier:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_014.png"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Simple AD configuration</h1>
            </header>

            <article>
                
<p>We now need to go through the process of enabling user accounts in the directory to log in to the AWS management console.</p>
<ol>
<li>Point your browser to the <span class="packt_screen">AWS Directory Service Console</span> and edit the configuration of your Simple AD directory. Enter the access URL you've chosen:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_015.png"/></div>
<ol start="2">
<li>We now want to enable the <span class="packt_screen">AWS Management Console</span> for this service. Click on it to proceed to the next step:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_016.png"/></div>
<ol start="3">
<li>We've already created roles and assigned a policy to them. So select <span class="packt_screen">Use Existing Role</span>, as shown in the following screenshot:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_017.png"/></div>
<ol start="4">
<li>Start with the <kbd>CanAssumePowerUser</kbd> role. We need to map it to the <kbd>AWSPowerUser</kbd> group we created in AD (the one <kbd>Lucille</kbd> resides in):</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_018.png"/></div>
<ol start="5">
<li>Search for <kbd>AWSPowerUser</kbd> and then proceed to the next step:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_019.png"/></div>
<ol start="6">
<li>You now need to repeat these steps for the <kbd>CanAssumeReadOnly</kbd> role. Map it to the <kbd>AWSReadOnly</kbd> role we created in AD:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_020.png"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">App Account role configuration</h1>
            </header>

            <article>
                
<p>It's now time to configure our application account. In it, we need to create some new roles and then set up a trust relationship between those new roles and the roles we created in our Auth Account:</p>
<ol>
<li>Start by going to the IAM console in the Auth Account and creating a new role. This role will be <kbd>PowerUserRole</kbd>:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_021.png"/></div>
<ol start="2">
<li>This role will be of the <span class="packt_screen">Role for Cross-Account Access</span> kind. Make sure to select this type:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_022.png"/></div>
<ol start="3">
<li>You'll be prompted to enter an AWS <span class="packt_screen">Account ID</span>. This is the account ID of the Auth Account:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_023.png"/></div>
<ol start="4">
<li>For this role, we are going to use the AWS Managed Policy for <kbd>PowerUserAccess</kbd>, so go ahead and attach this policy now:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_024.png"/></div>
<ol start="5">
<li>Click <span class="packt_screen">Create Role</span> on the confirmation page and we're ready for the next step:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_025.png"/></div>
<ol start="6">
<li>AWS will automatically create a trust relationship on our behalf. Unfortunately, it's not quite right, so we need to edit it:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_026.png"/></div>
<ol start="7">
<li>We want anyone who has the <kbd>CanAssumePowerUser</kbd> role in our Auth Account to be able to assume <kbd>PowerUserRole</kbd> in our App Account. So we need to make a small change to the trust relationship like so (remember to replace the account IDs with your own):</li>
</ol>
<pre>
      { <br/>        "Version": "2012-10-17", <br/>        "Statement": [ <br/>            { <br/>              "Effect": "Allow", <br/>              "Principal": { <br/>                 "AWS": "arn:aws:iam::&lt;auth-account-number&gt;:<br/>                    role/CanAssumePowerUser" <br/>              }, <br/>              "Action": "sts:AssumeRole" <br/>            } <br/>        ] <br/>      }
</pre>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_027.png"/></div>
<ol start="8">
<li>Repeat these steps by creating a role called <kbd>ReadOnlyRole</kbd> and attach the AWS Managed <kbd>ReadOnlyAccess</kbd> policy to it:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_028.png"/></div>
<ol start="9">
<li>Again, we want to update the trust policy. Here we're going to allow both <kbd>CanAssumePowerUser</kbd> and <kbd>CanAssumeReadOnly</kbd> to switch to the <kbd>ReadOnlyRole</kbd>. This will be useful for administrators who would want to avoid accidents while clicking around the console:</li>
</ol>
<pre>
      { <br/>        "Version": "2012-10-17", <br/>        "Statement": [ <br/>            { <br/>              "Effect": "Allow", <br/>              "Principal": { <br/>                  "AWS": "arn:aws:iam::&lt;auth-account-number&gt;:<br/>                     role/CanAssumeReadOnly" <br/>              }, <br/>              "Action": "sts:AssumeRole" <br/>            }, <br/>            { <br/>              "Effect": "Allow", <br/>              "Principal": { <br/>                  "AWS": "arn:aws:iam::&lt;auth-account-number&gt;:<br/>                    role/CanAssumePowerUser" <br/>              }, <br/>              "Action": "sts:AssumeRole" <br/>            } <br/>        ] <br/>      }
</pre>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_029.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">App Account role config</div>
<p>That was our final step. It's now time to test it out.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<ol>
<li>Visit the access URL you assigned to your Simple AD directory (for example, <a href="https://bluthcorp.awsapps.com/console"><span class="URLPACKT">https://bluthcorp.awsapps.com/console</span></a>). Log in with the credentials of the user <kbd>Lucille</kbd> so we can test out our <kbd>PowerUserRole</kbd>:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_030.png"/></div>
<ol start="2">
<li>If you click around the AWS console, you'll notice you don't really have access to do anything at all. This is because you're currently bound by a policy that only allows you to assume a role (in the application account). So, let's try doing that. Click on your account name in the top-right corner and choose <span class="packt_screen">Switch Role</span>:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_031.png"/></div>
<ol start="3">
<li>On the next page, you want to enter the account ID of the application account and the role you wish to assume: <kbd>PowerUserRole</kbd>. Clicking <span class="packt_screen">Switch Role</span> here will log you in to the application account under <kbd>PowerUserRole</kbd>:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_032.png"/></div>
<ol start="4">
<li>You should now have an active session under <kbd>PowerUserRole</kbd> in the application account. You'll recall that we assigned a <kbd>PowerUserAccess</kbd> policy to this role. So you should be free to do almost anything in this account using the profile of the user, <kbd>Lucille</kbd> (notable exceptions being IAM and organizations management). If you click on your name again, you'll see details about which role was assigned to you when you logged in and which role is currently active:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_033.png"/></div>
<ol start="5">
<li>Try switching to the <kbd>ReadOnlyRole</kbd>. Verify that you aren't able to create any resources, perhaps by trying to create a new EC2 key pair or by creating an empty security group:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_034.png"/></div>
<ol start="6">
<li>Log out and go back to the access URL for Simple AD. Sign in with the credentials of the user, <kbd>Buster</kbd>. Again, you'll see you don't have access to do much in the Auth Account:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_035.png"/></div>
<ol start="7">
<li>You should be able to switch to the <kbd>ReadOnlyRole</kbd> in the application account. Try it now to make sure it works. You can use the <span class="packt_screen">Role History</span> shortcut to avoid typing in the account number and role name again:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_036.png"/></div>
<ol start="8">
<li>Finally, try switching <kbd>Buster</kbd> to <kbd>PowerUserRole</kbd> in the application account. <kbd>Buster</kbd> definitely shouldn't have access to it and you should see an error page that looks like this:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_037.png"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">There's more...</h1>
            </header>

            <article>
                
<ul>
<li>Exactly the same setup can be achieved with your existing Active Directory installation, even if it resides outside AWS in your data center. You will need to swap out Simple AD for AD Connector:</li>
</ul>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_038.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Federation with AD Connector</div>
<ul>
<li>You can also use ADFS and SAML 2.0 to enable federation to AWS from your existing AD installation. This would negate the need for users to log in to the console using a <kbd>*.awsapps.com</kbd> domain and would also negate the need for an Auth account.</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<ul>
<li>The <em>Active Directory as a service</em> recipe</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating SSL certificates</h1>
            </header>

            <article>
                
<p>SSL-based communications are now becoming the de facto standard—insecure methods are no longer <em>good enough</em>.</p>
<p>AWS provides the <strong>AWS Certificate Manager</strong> (<strong>ACM</strong>) service to provision AWS-backed SSL certificates that you can use with your AWS resources, such as <strong>Elastic Load Balancers</strong> (<strong>ELBs</strong>) and CloudFront.</p>
<div class="packt_infobox">ACM is free to use! There's nothing to pay for the certificates themselves. You pay for the underlying resources you use with them as normal.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Run the CLI command, including the domain name you want the certificate for (you can use <kbd>*</kbd> as a wildcard):</li>
</ol>
<pre>
<strong>        aws acm request-certificate --domain-name &lt;your-domain&gt;</strong>
</pre>
<ol start="2">
<li>You can now see the request in the ACM console, but note the request is pending:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_039.png"/></div>
<ol start="3">
<li>Check your domain administration e-mail(s). You will receive a confirmation of the request that will look like the following message:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_040.png"/></div>
<ol start="4">
<li>Once you approve the request, you will be given a confirmation message:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_041.png"/></div>
<ol start="5">
<li>You can now see that the certificate is ready to use in the AWS ACM console:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_042.png"/></div>
<ol start="6">
<li>Use the <span class="packt_screen">Identifier</span> value to apply the certificate to your resources:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_043.png"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>Using the CLI tool is the quickest and easiest way to create a certificate request. Create the certificate in the region you plan to use it in; that is where your ELB(s) are located.</p>
<div class="packt_infobox">If you plan to use your certificate with CloudFront, you must create it in the <kbd>us-east-1 region</kbd>.</div>
<p>After the request has been created, AWS will confirm the request is valid by sending approval e-mails to various standard e-mail addresses, based on conventions and the WHOIS information for your domain. Approval e-mails will be sent to the following:</p>
<ul>
<li>The domain registrant</li>
<li>The technical contact</li>
<li>The administrative contact</li>
<li>And the following addresses:
<ul>
<li><kbd>administrator@&lt;your-domain&gt;</kbd></li>
<li><kbd>hostmaster@&lt;your-domain&gt;</kbd></li>
<li><kbd>postmaster@&lt;your-domain&gt;</kbd></li>
<li><kbd>webmaster@&lt;your-domain&gt;</kbd></li>
<li><kbd>admin@&lt;your-domain&gt;</kbd></li>
</ul>
</li>
</ul>
<p>You must accept at least one of the approvals before you can use your certificate.</p>
<p>Once approved, you can use the <span class="packt_screen">Identifier</span> value in the configuration of your other resources, such as EC2 ELB(s) and CloudFront distributions.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">There's more...</h1>
            </header>

            <article>
                
<p>While ACM makes getting SSL certificates for your application trivial, there are a few limitations to be aware of.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">EC2 instances</h1>
            </header>

            <article>
                
<p>You'll notice in the documentation that only ELBs and CloudFront are supported by ACM certificates. You cannot put an ACM certificate directly on an EC2 instance.</p>
<p>While this is a limitation, in practice it's not a big issue. Generally, you wouldn't want to expose your instances to the Internet directly—they should be behind an ELB/ALB for security, performance, and management reasons. If you are serving static assets, CloudFront is going to be much more secure, and performs better at a lower cost.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Importing certificates</h1>
            </header>

            <article>
                
<p>You can import your own certificates in to ACM, so that they can be used with your ELB(s) and CloudFront. This might be done because you have already purchased a certificate from a third-party provider, or require a particular signing authority.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">CloudFormation</h1>
            </header>

            <article>
                
<p>You can also request certificates as part of the CloudFormation stack. This is great for ensuring each of your resources has a specific certificate, unique to each deployment.</p>
<p>Here is a sample snippet of CloudFormation YAML to create a certificate, similar to the preceding example in this recipe:</p>
<pre>
Resources: <br/>  MyCertificate: <br/>    Type: "AWS::CertificateManager::Certificate" <br/>    Properties: <br/>      DomainName: &lt;your-domain&gt;
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Active Directory as a service</h1>
            </header>

            <article>
                
<p>This recipe will show you how to deploy an AWS <strong>Simple Active Directory</strong> (<strong>Simple AD</strong>) service.</p>
<p>Simple AD is powered by Samba 4 and is a Microsoft Active Directory compatible managed service. It will work with many applications that require Active Directory support and provides a large range of the commonly used Active Directory features, including the following:</p>
<ul>
<li>User accounts</li>
<li>Single sign-on (Kerberos)</li>
<li>Group memberships</li>
<li>Domain joining</li>
</ul>
<p>It also integrates with other services provided by AWS, such as the following:</p>
<ul>
<li>AWS Management Console</li>
<li>WorkMail</li>
<li>WorkDocs</li>
<li>WorkSpaces and WorkSpaces Application Manager</li>
</ul>
<p>AWS manages backup and restoration of the directory for you in the form of daily snapshots and the ability to perform point-in-time recovery.</p>
<p>Features that aren't supported include the following:</p>
<ul>
<li>Trust relationships with other AD domains</li>
<li>DNS dynamic updates</li>
<li>Schema extensions</li>
<li>MFA</li>
<li>LDAPS</li>
<li>PowerShell AD cmdlets</li>
<li>Transfer of FSMO roles</li>
</ul>
<p>The ideal scenario for Simple AD usage is when you don't require advanced AD features and you're supporting less than 5,000 users. If either of these isn't true, you will want to look at AWS' fully fledged Microsoft Active Directory service. Brace yourself for some added complexity and much higher cost if you choose this path, however.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Getting ready</h1>
            </header>

            <article>
                
<p>Before going ahead, we'll need the following pieces of info:</p>
<ul>
<li>The FQDN for your directory (for example, <a href="http://megacorp.com/"><span class="URLPACKT">http://megacorp.com/</span></a>).</li>
<li>A password for administering your directory. This password corresponds to the <kbd>Administrator</kbd> user that will be created on your behalf. Note that the password needs to be between 8-64 characters and will also need to contain one character from three of the following four groups:
<ul>
<li>Lowercase letters</li>
<li>Uppercase letters</li>
<li>Numbers</li>
<li>Non-alphanumeric characters</li>
</ul>
</li>
<li>The ID of the VPC we're deploying to.</li>
<li>The IDs of two subnets in this VPC. These subnets need to be in different Availability Zones.</li>
<li>The size of the directory you'd like to deploy. You can choose between <em>Small</em> and <em>Large</em>.</li>
</ul>
<p>A domain controller is going to be deployed in each of the two subnets you've chosen. They'll be communicating between each other on a fairly large number of ports. Ideally, these subnets would exist in the same <em>tier</em> in your VPC and by extension would not have any NACLs which would stop the controllers from talking with each other.</p>
<div class="packt_infobox">If, for some reason, you're restricting traffic using NACLs within your VPC tiers, you will want to refer to the AWS docs for a list of which ports to allow.<br/>
For more details, visit <a href="http://docs.aws.amazon.com/directoryservice/latest/admin-guide/prereq_simple.html"><span class="URLPACKT">http://docs.aws.amazon.com/directoryservice/latest/admin-guide/prereq_simple.html</span></a>.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Create a new CloudFormation template file. We'll start by populating it with <kbd>Parameters</kbd> that correspond to all the requirements we mentioned before:</li>
</ol>
<pre>
      AWSTemplateFormatVersion: '2010-09-09' <br/>      Parameters: <br/>        FullyQualifiedName: <br/>          Description: The fully qualified name for the directory<br/>            (e.g. megacorp.com) <br/>          Type: String <br/>          AllowedPattern: '^([a-zA-Z0-9]+[\\.-])+([a-zA-Z0-9])+$' <br/>        Password: <br/>          Description: The password for the directory Administrator <br/>          Type: String <br/>          NoEcho: true <br/>        VpcId: <br/>          Description: The ID of the VPC to deploy to <br/>          Type: AWS::EC2::VPC::Id <br/>        SubnetIds: <br/>          Description: Subnets where the directory will be deployed to<br/>            (pick at least 2) <br/>          Type: List&lt;AWS::EC2::Subnet::Id&gt; <br/>        DirectorySize: <br/>          Description: The size of the directory to deploy <br/>          Type: String <br/>          AllowedValues:  <br/>            - Small <br/>            - Large
</pre>
<ol start="2">
<li>Next, we define our <kbd>Resources</kbd>. Even though two Simple AD domain controllers are being deployed, we only need to create one resource here:</li>
</ol>
<pre>
      Resources: <br/>        ExampleDirectory: <br/>          Type: AWS::DirectoryService::SimpleAD <br/>          Properties:  <br/>            Name: !Ref FullyQualifiedName <br/>            Password: !Ref Password <br/>            Size: !Ref DirectorySize <br/>            VpcSettings:  <br/>              SubnetIds:  <br/>                - !Select [ 0, Ref: SubnetIds ] <br/>                - !Select [ 1, Ref: SubnetIds ] <br/>              VpcId: !Ref VpcId
</pre>
<ol start="3">
<li>You can now go ahead and run this template in the CloudFormation web console, or via the CLI like this:</li>
</ol>
<pre>
<strong>      aws cloudformation create-stack \ </strong><br/><strong>        --stack-name example-directory \ </strong><br/><strong>        --template-body file://08-active-directory-as-a-service.yaml \ </strong><br/><strong>        --parameters \ </strong><br/><strong>        ParameterKey=FullyQualifiedName,ParameterValue=&lt;fqdn&gt; \ </strong><br/><strong>        ParameterKey=Password,ParameterValue=&lt;password&gt; \ </strong><br/><strong>        ParameterKey=VpcId,ParameterValue=&lt;vpd-id&gt; \ </strong><br/><strong>        "ParameterKey=SubnetIds,ParameterValue='&lt;subnet-1&gt;,&lt;subnet-2&gt;'" \ </strong><br/><strong>        ParameterKey=DirectorySize,ParameterValue=&lt;Small/Large&gt;</strong>
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>It will take several minutes to create the directory. Once the <span class="packt_screen">Status</span> becomes <span class="packt_screen">Active</span>, you may proceed with further setup and integration tasks. Your directory listing page will eventually show a directory listing that looks similar to this:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_044.png"/></div>
<p>Clicking on the directory ID will reveal more detailed information about your directory, like so:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_045.png"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">There's more...</h1>
            </header>

            <article>
                
<ul>
<li>The password for the <kbd>Administrator</kbd> account can't be retrieved or reset. Be sure to keep this password somewhere safe.</li>
<li>You may notice an additional security group appear in your EC2 console. This group is necessary for the directory controllers (although you won't see these appear as EC2 instances in your console).</li>
<li>The directory will contain an account with the prefix <kbd>AWSAdminD-</kbd>. This account is necessary for AWS to perform maintenance tasks such as backup and FSMO role transfers. Removing this account or changing its password is almost certainly a bad idea.</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<ul>
<li>The <em>Building a secure network</em> recipe in <a href="de50c1bf-fc87-4674-9719-c55280a6b60d.xhtml"><span class="ChapterrefPACKT">Chapter 7</span></a>, <em>Networking</em>.</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating users</h1>
            </header>

            <article>
                
<p>Before we introduce this recipe, we need to talk briefly about <strong>Identity and Access Management</strong> (<strong>IAM</strong>). It's free and is enabled on every account. It allows you to create groups and users and allows you to control exactly what they can and can't do using policy assignment.</p>
<p>By default, groups and users will have no permissions until you assign them either an <em>AWS Managed Policy</em> or a <em>Customer Managed Policy</em> (one which you manage). You'll want to use AWS Managed Policies as much as possible to avoid having to create and maintain your own.</p>
<div class="packt_infobox">There's a third kind of policy called an <strong>Inline Policy</strong>. Use this sparingly. In fact, the only time we typically see it is in CloudFormation templates.</div>
<p>You pretty much never want to assign a policy directly to a user. If you go down this path, you'll create a lot of work for yourself in the future. Instead, you want to apply policies to groups and then assign users to those groups. Fortunately, it's a pretty easy process and we're about to walk you through it.</p>
<p>The IAM dashboard provides a URL that your IAM users can use to log in to the web console (if you've assigned them a password and given them access to do so). You can also customize this <em>IAM sign-in link</em> if necessary. Don't forget to give this URL to any IAM users you create so they know where to go to sign in.</p>
<p>It will look something like this until you customize it:</p>
<p><kbd>https://&lt;account-id&gt;.signin.aws.amazon.com/console</kbd></p>
<p>Now, jump right in. There's no excuse for not using IAM. Start today!</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Getting ready</h1>
            </header>

            <article>
                
<p>All you need to proceed is the CLI tools installed with a profile which can call the AWS IAM API. If you don't have this, you can follow along with the recipe steps using the AWS web console instead as the process is the same.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Create a new group by running this CLI command:</li>
</ol>
<pre>
<strong>      aws iam create-group --group-name &lt;group-name&gt;</strong>
</pre>
<ol start="2">
<li>The output looks like this:</li>
</ol>
<pre>
      { <br/>          "Group": { <br/>            "Path": "/", <br/>            "GroupId": "AGPAIHM2XJ2ELQTNYBFQQ", <br/>            "Arn": "arn:aws:iam::067180688831:group/PowerUsers", <br/>            "GroupName": "PowerUsers" <br/>          } <br/>      }
</pre>
<ol start="3">
<li>The group doesn't have permissions to do anything yet, so you'll need to attach a policy to it. You can do it with this command (which unfortunately doesn't provide any feedback if it successfully runs):</li>
</ol>
<pre>
<strong>      aws iam attach-group-policy \</strong><br/><strong>        --group-name &lt;group-name&gt; \</strong><br/><strong>        --policy-arn &lt;policy-arn&gt;</strong>
</pre>
<ol start="4">
<li>You can find the <strong>Amazon Resource Name</strong> (<strong>ARN</strong>) for the policy you'd like to attach in the AWS IAM web console. You can also run the following CLI command to get a list of policies:</li>
</ol>
<pre>
<strong>      aws iam list-policies</strong>
</pre>
<ol start="5">
<li>In this example, we're dealing with <kbd>PowerUsers</kbd> so we want to attach the following ARN, which maps to the AWS Managed Policy for power users:</li>
</ol>
<pre>
<strong>      arn:aws:iam::aws:policy/PowerUserAccess</strong>
</pre>
<ol start="6">
<li>Now we can go ahead and create a new user by running this CLI command:</li>
</ol>
<pre>
<strong>      aws iam create-user --user-name &lt;new-username&gt;</strong>
</pre>
<ol start="7">
<li>You'll get a response that looks like this:</li>
</ol>
<pre>
      { <br/>        "User": { <br/>            "UserName": "lucille.bluth", <br/>            "Path": "/", <br/>            "CreateDate": "2017-02-19T06:16:50.558Z", <br/>            "UserId": "AIDAIU5P6ESCGYTVGACFE", <br/>            "Arn": "arn:aws:iam::07180688831:user/lucille.bluth" <br/>        } <br/>      }
</pre>
<ol start="8">
<li>If you wish to give this user access to the web console, you'll need to create a login profile for them. You can do it like so:</li>
</ol>
<pre>
<strong>      aws iam create-login-profile --user-name &lt;username&gt; \</strong><br/><strong>        --password &lt;password&gt; \</strong><br/><strong>        --password-reset-required</strong>
</pre>
<ol start="9">
<li>Forcing a password reset here is probably good practice. The API should respond to you like so:</li>
</ol>
<pre>
      { <br/>         "LoginProfile": { <br/>              "UserName": "lucille.bluth", <br/>              "CreateDate": "2017-02-19T06:29:06.244Z", <br/>              "PasswordResetRequired": true <br/>         } <br/>      }
</pre>
<ol start="10">
<li>To give the API access to the user, they'll need a set of API keys. Generate them with this command:</li>
</ol>
<pre>
<strong>      aws iam create-access-key --user-name &lt;username&gt;</strong>
</pre>
<ol start="11">
<li>The output will look something like this:</li>
</ol>
<pre>
      { <br/>          "AccessKey": { <br/>            "UserName": "lucille.bluth", <br/>            "Status": "Active", <br/>            "CreateDate": "2017-02-19T06:59:45.273Z", <br/>            "SecretAccessKey": "abcdefghijklmnopqrstuvwxyz", <br/>            "AccessKeyId": "AAAAAAAAAAAAAAAAAAAA" <br/>          } <br/>      }
</pre>
<ol start="12">
<li>Access keys can only be retrieved once. There is no way to fetch them again after they've been generated and shown to you. If you lose your access keys, you'll have to regenerate a new set of keys.</li>
<li>This user still doesn't have any permissions to do anything; this is because they don't yet belong to a group. Let's add them to the group we created in step 1:</li>
</ol>
<pre>
<strong>      aws iam add-user-to-group \</strong><br/><strong>        --group-name &lt;group-name&gt; \</strong><br/><strong>        --user-name &lt;username&gt;</strong>
</pre>
<div class="packt_infobox">Note that unfortunately this command doesn't return any output either. You can verify whether or not this worked by running this command:</div>
<pre>
<strong>      aws iam list-groups-for-user --user-name &lt;username&gt;</strong>
</pre>
<ol start="14">
<li>You should see something like this:</li>
</ol>
<pre>
      { <br/>          "Groups": [ <br/>              { <br/>                 "Path": "/", <br/>                 "CreateDate": "2017-02-19T07:24:46Z", <br/>                 "GroupId": "AGPAIHM2XJ2ELQTNYBFQQ", <br/>                 "Arn": "arn:aws:iam::067180688831:group/PowerUsers", <br/>                 "GroupName": "PowerUsers" <br/>              } <br/>          ] <br/>      }
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">There's more...</h1>
            </header>

            <article>
                
<p>This pretty much covers the basics of how to create IAM groups and users and assign policies to them. Here are some of the IAM tips and gotchas we've run into over the years:</p>
<ul>
<li>Users can exist in more than one group. Use this to your advantage.</li>
<li>Groups, however, cannot exist within other groups.</li>
<li>Users can have more than one set of API keys. This is necessary when they need to perform key rotation.</li>
<li>You can (and should) define a strong password policy for your IAM users.</li>
<li>The <kbd>PowerUserAccess</kbd> policy is good but does not allow IAM access. At first this might not seem to be a problem; however, if you are bound by this policy you will encounter issues when running CloudFormation stacks that create IAM roles for EC2 instances, for example.</li>
<li>IAM is a global service, meaning that users and groups are global, not region-specific. By default, a user can use AWS services in any region.</li>
<li>EC2 key pairs are region-specific and not specific to an IAM user. In other words, IAM users don't have SSH keys associated with them.</li>
<li>Your IAM username and password (and access keys) won't provide you with SSH or RDP access to running instances. Credentials for these services are managed separately.</li>
<li>You can assign up to 10 policies to a group or user.</li>
<li>You should also consider enabling MFA on IAM user accounts for added security. This is used primarily for accessing the web console but you can also configure your policies so that MFA will be required for API calls too. You can choose between hardware and software tokens. A good rule of thumb is to use software tokens for IAM users and hardware tokens for root logins. MFA via SMS is due to arrive soon and is currently in public preview.</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<ul>
<li>The <em>Federating with your AWS account</em> recipe</li>
<li>The <em>Cross-account user roles</em> recipe</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating instance roles</h1>
            </header>

            <article>
                
<p>This recipe is reasonably short but it contains a really important concept to anyone who is new to the AWS platform. Understanding and utilizing IAM roles for EC2 will significantly reduce your exposure to lost credentials and probably help you sleep a little better at night too. In a nutshell, instance roles help you get AWS credentials off your servers and out of your code base(s).</p>
<p>Roles contain one or more policies. We're going to create a role that has some AWS Managed Policies as well as an Inline Policy. As the name would suggest, an AWS Managed Policy is a policy that is created and fully controlled by AWS. The Inline Policy is going to be created by us and will be embedded in our role definition.</p>
<p>The AWS Managed Policies we'll use will allow read-only access to the S3 and EC2 APIs. The Inline Policy we'll create will allow write access to CloudWatch logs. We'll talk through why you would or wouldn't choose a Managed Policy later in this recipe.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Create a new CloudFormation template file and add the first <kbd>Resource</kbd>. This is going to be our role that contains references to the managed policies, and also our Inline Policy:</li>
</ol>
<pre>
      AWSTemplateFormatVersion: '2010-09-09' <br/>      Resources: <br/>        ExampleRole: <br/>          Type: AWS::IAM::Role <br/>          Properties: <br/>            AssumeRolePolicyDocument: <br/>              Version: "2012-10-17" <br/>              Statement: <br/>                - <br/>                  Effect: Allow <br/>                  Principal: <br/>                    Service: <br/>                      - ec2.amazonaws.com <br/>                  Action: <br/>                    - sts:AssumeRole <br/>            ManagedPolicyArns: <br/>              - arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess <br/>              - arn:aws:iam::aws:policy/AmazonEC2ReadOnlyAccess <br/>            Path: / <br/>            Policies: <br/>              - <br/>                PolicyName: WriteToCloudWatchLogs <br/>                PolicyDocument: <br/>                  Version: "2012-10-17" <br/>                  Statement: <br/>                    - <br/>                      Effect: Allow <br/>                      Action: <br/>                        - logs:CreateLogGroup <br/>                        - logs:CreateLogStream <br/>                        - logs:PutLogEvents <br/>                        - logs:DescribeLogStreams <br/>                      Resource: "*"
</pre>
<ol start="2">
<li>We now need to create an <kbd>InstanceProfile</kbd> resource. A profile encapsulates a single IAM role and, roughly speaking, that's all it's used for. A profile can contain only a single IAM role, so it's not clear why AWS has built this extra layer of abstraction; presumably they have plans to give profiles of other properties aside from roles:</li>
</ol>
<pre>
      ExampleInstanceProfile: <br/>        Type: AWS::IAM::InstanceProfile <br/>        Properties: <br/>          Roles: <br/>            - !Ref ExampleRole <br/>          Path: /
</pre>
<ol start="3">
<li>For convenience, we'll add some <kbd>Outputs</kbd> that will provide the profile name and ARN to us after the stack is created:</li>
</ol>
<pre>
      Outputs: <br/>        ExampleInstanceProfile: <br/>          Value: !Ref ExampleInstanceProfile <br/>        ExampleInstanceProfileArn: <br/>          Value: !GetAtt ExampleInstanceProfile.Arn
</pre>
<ol start="4">
<li>You can now create your instance role CloudFormation web console or via the CLI like this:</li>
</ol>
<pre>
<strong>      aws cloudformation create-stack \</strong><br/><strong>        --stack-name example-instance-profile \</strong><br/><strong>        --template-body file://08-creating-instance-roles.yaml \</strong><br/><strong>        --capabilities CAPABILITY_IAM</strong>
</pre>
<p>This role can now be assigned to your EC2 instances. The <em>Feeding log files in to CloudWatch logs</em> recipe in <a href="http://Management%20Tools"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Management Tools</em>, shows how you can define a role and assign it to an EC2 instance at launch using CloudFormation.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>How on earth does this solve the problem of hardcoded AWS API keys? Well, something really interesting happens when you assign a role to an EC2 instance. The metadata for that instance will return a set of short-lived API keys. You can retrieve these keys by sending an HTTP request to the metadata URL (this is a service EC2 instances can use to fetch information about themselves):</p>
<p><kbd>http://169.254.169.254/latest/meta-data/iam/security-credentials/&lt;role name&gt;</kbd></p>
<p>The output of a curl request to this URL will look something like this:</p>
<pre>
      { <br/>        "Code" : "Success", <br/>        "LastUpdated" : "2017-02-17T11:14:23Z", <br/>        "Type" : "AWS-HMAC", <br/><strong>        </strong>"AccessKeyId" : "AAAAAAAAAAAAAAAAAAAA", <br/>        "SecretAccessKey" : "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz", <br/>        "Token" : "token", <br/>        "Expiration" : "2017-02-17T12:14:23Z" <br/>      }
</pre>
<p>If you take the <kbd>AccessKeyId</kbd> and <kbd>SecretAccessKey</kbd> returned in the response, you can use them to query the AWS API. The policies applied to the instance based on the role assigned to it will determine exactly what API actions the instance is able to perform using these keys.</p>
<p>The really fun part is that you don't have to worry too much about handling these keys at all (although it's really useful to know how all this works under the hood). For example, the AWS CLI tools will automatically fetch these keys for you prior to running any CLI commands. The same goes for the AWS SDKs.</p>
<p>Take a scenario where your developers are building an application that needs to fetch files from S3. As long as they are using the AWS SDK to do this and the application is running on an EC2 instance that has been assigned a role containing a policy that allows files to be fetched from S3, then no credentials are required by the application whatsoever! The SDK will take care of the queries to the metadata service for you.</p>
<p>The AWS SDKs are available for almost every widely used language, so there's no excuse for keeping hardcoded AWS credentials in config files or source code.</p>
<p>You will see your instances roles listed in the IAM console under the <kbd>Roles</kbd> section:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_046.png"/></div>
<p>Clicking on the role will reveal further details, such as the policies that have been assigned to it:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_047.png"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">There's more...</h1>
            </header>

            <article>
                
<ul>
<li>IAM is a global service. This means that the roles and policies you create will be available in every region.</li>
<li>You'll find all the available AWS Managed Policies in the AWS web console. There's quite a few of them so don't be afraid to use the search bar.</li>
<li>There's a third kind of policy called a Customer Managed Policy. These are policies which are managed by you and will appear in the AWS console amongst the AWS Managed Policies.</li>
<li>As of February 2017, it is possible to attach an IAM role to an existing/running EC2 instance. This previously wasn't the case and the role could only be assigned at the time the instance launched.</li>
<li>AWS automatically and periodically rotates the credentials returned by the metadata service.</li>
<li>It's not always appropriate to use an AWS Managed Policy. For example, if a server needs to write to CloudWatch logs, it may be tempting to assign it the AWS Managed Policy that provides full access. If you do this, however, you'll also be giving the server access to delete log groups and streams. This is almost certainly undesirable. You'll want to inspect the policies before you apply them and defer to an Inline or Customer Managed Policy where appropriate. The principle of least privilege applies here.</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<ul>
<li>The <em>Feeding log files in to CloudWatch logs</em> recipe in <a href="2ac3ef94-1ec2-4473-84ef-76cad8517270.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Management Tools</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Cross-account user roles</h1>
            </header>

            <article>
                
<p>Using multiple accounts to provision your resources (for example, development and production environments) provides a form of <em>blast radius</em> protection—even in a worst-case scenario, any issues or damages are limited to the account they occur in, not your entire AWS presence.</p>
<p>Creating and assuming roles across accounts is the best way to manage access to multiple accounts. Specific roles provide a clear and explicit declaration of permissions that can be easily reviewed, and revoked if needed.</p>
<p>This recipe provides a way to scale your access across many accounts, without compromising your security.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Getting ready</h1>
            </header>

            <article>
                
<p>This recipe assumes you already have two AWS accounts created and ready to go.</p>
<p>In one account (the <strong>source</strong> account, referred to as <em>Account A</em>) you will need an IAM user.</p>
<div class="packt_infobox">While you will need to use your account's root credentials to set up the first role in an account, <em>do not</em> use them on a day-to-day basis. The root account has permissions to do anything in your account, and should only be used when necessary.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Start a new template with a version and description:</li>
</ol>
<pre>
      AWSTemplateFormatVersion: "2010-09-09" <br/>      Description: This template creates a role that can be assumed <br/>       from another account.
</pre>
<ol start="2">
<li>The template will take one parameter—the source account that can assume the role:</li>
</ol>
<pre>
      Parameters: <br/>        SourceAccountNumber: <br/>          Type: String <br/>          Description: The AWS account number to grant access to assume<br/>            the role. <br/>          AllowedPattern: "[0-9]+" <br/>          MaxLength: "12" <br/>          MinLength: "12"
</pre>
<ol start="3">
<li>The role itself will consist of the trust role and a sample policy:</li>
</ol>
<div class="packt_infobox">This role has full access to the target account.</div>
<pre>
        Resources: <br/>          CrossAccountRole: <br/>            Type: "AWS::IAM::Role" <br/>            Properties: <br/>              Path: "/" <br/>              AssumeRolePolicyDocument: <br/>                Version: "2012-10-17" <br/>                Statement: <br/>                  - Sid: "" <br/>                    Action: "sts:AssumeRole" <br/>                    Effect: Allow <br/>                    Principal: <br/>                      AWS: <br/>                        !Sub "arn:aws:iam::${SourceAccountNumber}:root" <br/>              Policies: <br/>                - PolicyName: DoEverything <br/>                  PolicyDocument: <br/>                    Version: "2012-10-17" <br/>                    Statement: <br/>                      - Action: <br/>                          - "*" <br/>                        Effect: Allow <br/>                        Resource: "*" <br/>                        Sid: DoEverything
</pre>
<ol start="4">
<li>Finally, we create an output that will make it easy to retrieve the target role ARN:</li>
</ol>
<pre>
      Outputs: <br/>        RoleARN: <br/>          Description: The Role ARN that can be assumed by the<br/>            other account. <br/>          Value: !GetAtt CrossAccountRole.Arn
</pre>
<ol start="5">
<li>Save the template with a known name, for example <kbd>08-target-account-role.yaml</kbd>.</li>
<li>Deploy the role to the target account (that is, <strong>Account B</strong>) by using the CLI tool:</li>
</ol>
<pre>
<strong>      aws cloudformation create-stack \<br/>        --stack-name CrossAccountRole \</strong><br/><strong>        --template-body file://src/08-target-account-role.yaml \</strong><br/><strong>        --parameters \<br/>        ParameterKey=SourceAccountNumber, \<br/>        ParameterValue=&lt;your-source-a</strong><strong>ccount-number&gt; \</strong><br/><strong>        --capabilities CAPABILITY_IAM</strong>
</pre>
<ol start="7">
<li>Get (just) the target role ARN from the outputs of your CloudFormation stack:</li>
</ol>
<pre>
<strong>      aws cloudformation describe-stacks \</strong><br/><strong>        --stack-name CrossAccountRole \</strong><br/><strong>        --query 'Stacks[0].Outputs[0].OutputValue' \</strong><br/><strong>        --output text</strong>
</pre>
<ol start="8">
<li>In your source account (that is, <strong>Account A</strong>) confirm that you can assume the target role by manually invoking the CLI tool:</li>
</ol>
<pre>
<strong>      aws sts assume-role \</strong><br/><strong>        --role-arn &lt;your-target-role-arn&gt; \</strong><br/><strong>        --role-session-name CrossAccountRole</strong>
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>While cross-account roles are extremely useful for administering multiple AWS accounts, they're not the most intuitive thing to configure. Here's a diagram that illustrates the resources and their interactions:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_048.png"/></div>
<p>The first few steps of this recipe are simply creating the <strong>Target IAM Role</strong> in a clear and repeatable way using CloudFormation.</p>
<p>You must explicitly call out the AWS account number that will be allowed to assume this role. If you want to allow multiple accounts to assume the role, simply add more statements to the <kbd>AssumeRolePolicyDocument</kbd> property of the role.</p>
<p>The sample policy created in this template gives full access to the target account (because the <kbd>Action</kbd> and <kbd>Resource</kbd> are both set to <kbd>*</kbd>). You should adjust this as appropriate for your needs.</p>
<p>Defining an output value that returns the IAM role's ARN will make it easier to get the generated ID later in the recipe.</p>
<p>We then launch the template in the target account. As this template creates IAM resources, you must supply the <kbd>--capabilities CAPABILITY_IAM</kbd> argument. If you don't have any existing IAM users that can launch it, use the AWS web console (after logging in with your root credentials). This means you don't need to bother creating IAM users in the target account.</p>
<p>Once you have deployed the template, you will no longer need to log in to the account manually—you can just assume the newly created role from the trusted (source) account. Using an IAM role in the target account means that your day-to-day access does not require multiple passwords, which takes work to manage and store securely. You only need to have one password—the password of your source IAM user.</p>
<p>After the stack has finished creating (which shouldn't take long, as it's only creating one resource), you can quickly extract the target role's ARN with a <kbd>describe-stacks</kbd> call, combined with a specifically-crafted <kbd>--query</kbd> argument. The JMESPath query <kbd>Stacks[0].Outputs[0].OutputValue</kbd> gets the <kbd>OutputValue</kbd> property of the first output in the first stack returned, which we know will be the target role ARN because there is only one output in the template.</p>
<p>Finally, the sample <kbd>assume-role</kbd> command will return the credentials for the target role (that is, <kbd>ACCESS_KEY_ID</kbd> and <kbd>SECRET_ACCESS_KEY</kbd>). You can then use this in an API call, via the CLI tool or one of the SDKs. Keep in mind that these tokens will be short-lived.</p>
<p>See the next section for a more convenient way to use the credentials with the CLI tool by creating profiles.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">There's more...</h1>
            </header>

            <article>
                
<p>Just as there are multiple ways to use roles, there are multiple ways to utilize cross-account roles.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">AWS CLI profiles</h1>
            </header>

            <article>
                
<p>One of the easiest ways to use a cross-account role is configuring it as a profile for the AWS CLI tool to use. This means you can quickly and easily switch accounts just by changing the profile you use when executing your commands.</p>
<p>To do this, you must define the target role in the CLI configuration file. With this configuration, it is assumed that your <kbd>default</kbd> profile is in the source account (that is, Account A).</p>
<p>Add the following snippet to the <kbd>~/.aws/config</kbd> file on Linux and Mac computers, and <kbd>C:\Users\[USERNAME]\.aws\config</kbd> file on Windows:</p>
<pre>
[profile accountb] <br/>role_arn = &lt;your-target-account-role-arn&gt; <br/>source_profile = default
</pre>
<p>To use switch roles, all you need to do is pass the <kbd>--profile</kbd> argument along with your command:</p>
<pre>
<strong>      aws --profile accountb ...</strong>
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<ul>
<li>The <em>Creating users</em> recipe.</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Storing secrets</h1>
            </header>

            <article>
                
<p>A common mistake new administrators make when getting started with Infrastructure-as-Code is committing secrets (passwords, access keys, and so on) in their repositories. While this makes their infrastructure repeatable, it also makes it much more likely their credentials will be compromised. Once something is in version control, it's hard and annoying to remove it (that's the point of version control!). Even if you do remove it, it's almost impossible to know if it has already been viewed/copied by someone unintended.</p>
<p>In this recipe, we will introduce and use the open source tool, <strong>Unicreds</strong>.</p>
<div class="packt_infobox">Unicreds is a Golang port of the Python tool, Credstash: <a href="https://github.com/fugue/credstash"><span class="URLPACKT">https://github.com/fugue/credstash</span></a>.<br/>
While the functionality is very similar, Unicreds has the benefit of being cross-platform and dependency-free!</div>
<p>Since this pattern is completely backed by AWS services, it removes the need to manage (and worry about) password vaults, shared passwords, and committing sensitive information to SCM.</p>
<p>You might even use Unicreds to store non-secret information, because it provides a convenient way to store and share settings without the need to run or maintain any servers!</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Getting ready</h1>
            </header>

            <article>
                
<p>You must have Unicreds present on your target system.</p>
<p>As it is written in Golang, it is easily distributed as a standalone binary application—no installer or dependencies are required.</p>
<div class="packt_infobox">Releases for all platforms are available at <a href="https://github.com/Versent/unicreds/releases"><span class="URLPACKT">https://github.com/Versent/unicreds/releases</span></a>.</div>
<p>These commands assume your default profile has the permission to create KMS keys and DynamoDB tables. You can override the profile used by passing the <kbd>--profile</kbd> argument with all of the commands in the recipe. You must also have your AWS region setting configured.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Create a KMS key, and take note of the Key ID returned:</li>
</ol>
<pre>
<strong>        aws kms create-key --query 'KeyMetadata.KeyId' --output text</strong>
</pre>
<ol start="2">
<li>Create an alias for the key:</li>
</ol>
<div class="packt_infobox">Unicreds uses the <kbd>alias/credstash</kbd> alias to make it compatible with Credstash.</div>
<pre>
<strong>        aws kms create-alias --alias-name 'alias/credstash' \<br/>        --target-key-id "&lt;your-key-id&gt;"</strong>
</pre>
<ol start="3">
<li>Set up the resources required by Unicreds:</li>
</ol>
<pre>
<strong>        unicreds setup</strong>
</pre>
<ol start="4">
<li>Store a secret using the <kbd>put</kbd> command:</li>
</ol>
<pre>
<strong>        unicreds put foo bar</strong>
</pre>
<ol start="5">
<li>Get the secret using the <kbd>get</kbd> command:</li>
</ol>
<pre>
<strong>        unicreds get foo</strong>
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>Here is a high-level diagram that illustrates the components involved in theses Unicreds commands:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_08_049.png"/></div>
<p>We start this recipe by creating the key that will be used to encrypt the secrets in KMS. Note that we never get to see this key—it only exists in KMS. All you can do is request that KMS encrypts or decrypts data with it for you.</p>
<p>It is possible to import your own key in to KMS (so that you could decrypt the secrets outside of AWS if you needed to), but this is not required for Unicreds to work. The <kbd>create-key</kbd> command returns the GUID for the key, which will be used in the following steps.</p>
<p>Aliases make it much easier to deal with KMS keys. You can use them in most commands in place of the full key ARN. More importantly, it makes it obvious which key you are dealing with so that you can quickly, easily, and confidently assign access permissions.</p>
<p>The default alias for the key used with Unicreds is <kbd>alias/credstash</kbd>. While this might seem a bit confusing at first, it means that Unicreds is backward-compatible with Credstash. You can choose your own alias; you will simply need to override it when you give your other commands (such as <kbd>setup</kbd>, <kbd>put</kbd>, and so on).</p>
<p>The <kbd>setup</kbd> command creates the required resources in your AWS account. This effectively means creating a DynamoDB table to store the secrets in.</p>
<p>Once everything is set up, you can start storing secrets using Unicreds. In this example, the secret is stored with the (highly original) key <kbd>foo</kbd> and the value <kbd>bar</kbd>.</p>
<p>At this stage, you can go to DynamoDB in the AWS console and see the stored value in the <kbd>credential-store</kbd> table. You can also change the name of the DDB table used when you run the <kbd>credstash setup</kbd> command, if you want to.</p>
<p>Once there's a secret stored, you can retrieve it with the <kbd>get</kbd> command. It's important to remember that there's no need to do this from the same machine you stored it from. As long as the AWS user/role has sufficient permission to use the KMS service and access the DDB table, they will be able to retrieve the secret.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">There's more...</h1>
            </header>

            <article>
                
<p>Unicreds leverages the built-in functionality of AWS, so you get an enterprise-grade solution without the overhead of needing to run your own servers. Here are some other useful things you can do to make your secrets even more secure.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Key aliases</h1>
            </header>

            <article>
                
<p>Creating multiple KMS keys—and referring to them with unique aliases—is a great way to limit the access to put/get secrets to specific applications or teams.</p>
<p>Instead of using the default <kbd>alias/credstash</kbd> alias, you could give a team their own alias and be confident that they aren't going to see or write to anyone else's secrets.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Secret reader role</h1>
            </header>

            <article>
                
<p>Due to the fine-grained nature of IAM permissions, you can easily segment the type of different access roles get to your AWS resources.</p>
<p>With the following IAM policy, you can ensure that the user/role can only read secret values (using a specific key and table), but they can never set or change them:</p>
<pre>
{ <br/>  "Version": "2012-10-17", <br/>  "Statement": [ <br/>    { <br/>      "Action": [ <br/>        "kms:Decrypt" <br/>      ], <br/>      "Effect": "Allow", <br/>      "Resource": "arn:aws:kms:us-east-1:&lt;your-account-id&gt;:<br/>         key/&lt;your-key-id&gt;" <br/>    }, <br/>    { <br/>      "Action": [ <br/>        "dynamodb:GetItem", <br/>        "dynamodb:Query", <br/>        "dynamodb:Scan" <br/>      ], <br/>      "Effect": "Allow", <br/>      "Resource": "arn:aws:dynamodb:us-east-1:&lt;your-account-id&gt;:<br/>         table/credential-store" <br/>    } <br/>  ] <br/>}
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Secret writer role</h1>
            </header>

            <article>
                
<p>The flip side to the secret reader role is the secret writer.</p>
<p>Add this snippet to the relevant IAM policy section of a role to give it the ability to set secret values, but not retrieve them:</p>
<pre>
{ <br/>  "Version": "2012-10-17", <br/>  "Statement": [ <br/>    { <br/>      "Action": [ <br/>         "kms:GenerateDataKey" <br/>      ], <br/>      "Effect": "Allow", <br/>      "Resource": "arn:aws:kms:us-east-1:&lt;your-account-id&gt;:<br/>         key/&lt;your-key-id&gt;" <br/>    }, <br/>    { <br/>      "Action": [ <br/>        "dynamodb:PutItem" <br/>      ], <br/>      "Effect": "Allow", <br/>      "Resource": "arn:aws:dynamodb:us-east-1:&lt;your-account-id&gt;:<br/>         table/credential-store" <br/>    } <br/>  ] <br/>}
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">The put-file command</h1>
            </header>

            <article>
                
<p>You can put entire files in to storage with Unicreds. Just use the <kbd>put-file</kbd> command:</p>
<pre>
<strong>unicreds put-file foo bar.txt</strong>
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Versioning</h1>
            </header>

            <article>
                
<p>While storing your secrets securely is a great start, it is still good practice to change/rotate your passwords, keys, and other secrets regularly.</p>
<p>Unicreds has built-in support for versioning, which means you can update your secrets while still keeping records of previous versions.</p>
<p>When you put to the same secret name multiple times, Unicreds will automatically create new versions for the values. You can get a specific version of secret by providing a version argument with a <kbd>get</kbd> or <kbd>put</kbd> command:</p>
<pre>
<strong>unicreds get foo 1</strong>
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<ul>
<li>The <em>Creating users</em> recipe</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>