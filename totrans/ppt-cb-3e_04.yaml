- en: Chapter 4. Working with Files and Packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"A writer has the duty to be good, not lousy; true, not false; lively,
    not dull; accurate, not full of error."* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*E.B. White* |'
  prefs: []
  type: TYPE_TB
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Making quick edits to config files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing INI style files with puppetlabs-inifile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Augeas to reliably edit config files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building config files using snippets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ERB templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using array iteration in templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using EPP templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using GnuPG to encrypt secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing packages from a third-party repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing package versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll see how to make small edits to files, how to make larger
    changes in a structured way using the **Augeas** tool, how to construct files
    from concatenated snippets, and how to generate files from templates. We'll also
    learn how to install packages from additional repositories, and how to manage
    those repositories. In addition, we'll see how to store and decrypt secret data
    with Puppet.
  prefs: []
  type: TYPE_NORMAL
- en: Making quick edits to config files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you need to have Puppet change a particular setting in a config file, it's
    common to simply deploy the whole file with Puppet. This isn't always possible,
    though; especially if it's a file that several different parts of your Puppet
    manifest may need to modify.
  prefs: []
  type: TYPE_NORMAL
- en: What would be useful is a simple recipe to add a line to a config file if it's
    not already present, for example, adding a module name to `/etc/modules` to tell
    the kernel to load that module at boot. There are several ways to do this, the
    simplest is to use the `file_line` type provided by the `puppetlabs-stdlib` module.
    In this example, we install the `stdlib` module and use this type to append a
    line to a text file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install the `puppetlabs-stdlib` module using puppet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This installs the module from the forge into my user's puppet directory; to
    install into the system directory, run the command as root or use `sudo`. For
    the purpose of this example, we'll continue working as our own user.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the `file_line` resource type, we can ensure that a line exists or is
    absent in a config file. Using `file_line` we can quickly make edits to files
    without controlling the entire file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a manifest named `oneline.pp` that will use `file_line` on a file in
    `/tmp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run `puppet apply` on the `oneline.pp` manifest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now verify that `/tmp/cookbook` contains the line we defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We installed the `puppetlabs-stdlib` module into the default module path for
    Puppet, so when we ran `puppet apply`, Puppet knew where to find the `file_line`
    type definition. Puppet then created the `/tmp/cookbook` file if it didn't exist.
    The line `Hello World!` was not found in the file, so Puppet added the line to
    the file.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can define more instances of `file_line` and add more lines to the file;
    we can have multiple resources modifying a single file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `oneline.pp` file and add another `file_line` resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now apply the manifest again and verify whether the new line is appended to
    the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `file_line` type also supports pattern matching and line removal as we''ll
    show you in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify the contents of `/tmp/cookbook` before your Puppet run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the updated manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the line has been removed and the goodbye line has been replaced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Editing files with `file_line` works well if the file is unstructured. Structured
    files may have similar lines in different sections that have different meanings.
    In the next section, we'll show you how to deal with one particular type of structured
    file, a file using **INI syntax**.
  prefs: []
  type: TYPE_NORMAL
- en: Editing INI style files with puppetlabs-inifile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: INI files are used throughout many systems, Puppet uses INI syntax for the `puppet.conf`
    file. The `puppetlabs-inifile` module creates two types, `ini_setting` and `ini_subsetting`,
    which can be used to edit INI style files.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install the module from the forge as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we will create a `/tmp/server.conf` file and ensure that the
    `server_true` setting is set in that file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `initest.pp` manifest with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Apply the manifest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify the contents of the `/tmp/server.conf` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `inifile` module defines two types, `ini_setting` and `ini_subsetting`.
    Our manifest defines an `ini_setting` resource that creates a server = true setting
    within the main section of the `ini` file. In our case, the file didn't exist,
    so Puppet created the file, then created the `main` section, and finally added
    the setting to the `main` section.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using `ini_subsetting`, you can have several resources added to a setting.
    For instance, our `server.conf` file has a server''s line, we could have each
    node append its own hostname to a server''s line. Add the following to the end
    of the `initest.pp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now temporarily change your hostname and rerun Puppet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with INI syntax files, using the `inifile` module is an excellent
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: If your configuration files are not in INI syntax, another tool, Augeas, can
    be used. In the following section, we will use `augeas` to modify files.
  prefs: []
  type: TYPE_NORMAL
- en: Using Augeas to reliably edit config files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes it seems like every application has its own subtly different config
    file format, and writing regular expressions to parse and modify all of them can
    be a tiresome business.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, Augeas is here to help. Augeas is a system that aims to simplify
    working with different config file formats by presenting them all as a simple
    tree of values. Puppet's Augeas support allows you to create `augeas` resources
    that can make the required config changes intelligently and automatically.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create an example `augeas` resource:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify your `base` module as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run Puppet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether the setting has been correctly applied:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We declare an `augeas` resource named `enable-ip-forwarding`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We specify that we want to make changes in the file `/etc/sysctl.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we specify the lens to use on this file. Augeas uses files called lenses
    to translate a configuration file into an object representation. Augeas ships
    with several lenses, they are located in `/usr/share/augeas/lenses` by default.
    When specifying the lens in an `augeas` resource, the name of the lens is capitalized
    and has the `.lns` suffix. In this case, we will specify the `Sysctl` lens as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `changes` parameter specifies the changes we want to make. Its value is
    an array, because we can supply several changes at once. In this example, there
    is only change, so the value is an array of one element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, Augeas changes take the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the setting will be translated into a line like this in `/etc/sysctl.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I've chosen `/etc/sysctl.conf` as the example because it can contain a wide
    variety of kernel settings and you may want to change these settings for all sorts
    of different purposes and in different Puppet classes. You might want to enable
    IP forwarding, as in the example, for a router class but you might also want to
    tune the value of `net.core.somaxconn` for a load-balancer class.
  prefs: []
  type: TYPE_NORMAL
- en: This means that simply puppetizing the `/etc/sysctl.conf` file and distributing
    it as a text file won't work because you might have several different and conflicting
    versions depending on the setting you want to modify. Augeas is the right solution
    here because you can define `augeas` resources in different places, which modify
    the same file and they won't conflict.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about using Puppet and Augeas, see the page on the Puppet
    Labs website [http://projects.puppetlabs.com/projects/1/wiki/Puppet_Augeas](http://projects.puppetlabs.com/projects/1/wiki/Puppet_Augeas).
  prefs: []
  type: TYPE_NORMAL
- en: Another project that uses Augeas is **Augeasproviders**. Augeasproviders uses
    Augeas to define several types. One of these types is `sysctl`, using this type
    you can make sysctl changes without knowing how to write the changes in Augeas.
    More information is available on the forge at [https://forge.puppetlabs.com/domcleal/augeasproviders](https://forge.puppetlabs.com/domcleal/augeasproviders).
  prefs: []
  type: TYPE_NORMAL
- en: Learning how to use Augeas can be a little confusing at first. Augeas provides
    a command line tool, `augtool`, which can be used to get acquainted with making
    changes in Augeas.
  prefs: []
  type: TYPE_NORMAL
- en: Building config files using snippets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes you can't deploy a whole config file in one piece, yet making line
    by line edits isn't enough. Often, you need to build a config file from various
    bits of configuration managed by different classes. You may run into a situation
    where local information needs to be imported into the file as well. In this example,
    we'll build a config file using a local file as well as snippets defined in our
    manifests.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although it's possible to create our own system to build files from pieces,
    we'll use the puppetlabs supported `concat` module. We will start by installing
    the `concat` module, in a previous example we installed the module to our local
    machine. In this example, we'll modify the Puppet server configuration and download
    the module to the Puppet server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your Git repository create an `environment.conf` file with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the public directory and download the module into that directory as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add the new modules to our Git repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then push to our Git server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have the `concat` module available on our server, we can create
    a `concat` container resource in our `base` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `concat::fragment` module for the header of the new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `concat::fragment` that includes a local file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `concat::fragment` module that will go at the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'On the node, create `/etc/hosts.allow.local` with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Run Puppet to have the file created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify the contents of the new file as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `concat` resource defines a container that will hold all the subsequent
    `concat::fragment` resources. Each `concat::fragment` resource references the
    `concat` resource as the target. Each `concat::fragment` also includes an `order`
    attribute. The `order` attribute is used to specify the order in which the fragments
    are added to the final file. Our `/etc/hosts.allow` file is built with the header
    line, the contents of the local file, and finally the `in.tftpd` line we defined.
  prefs: []
  type: TYPE_NORMAL
- en: Using ERB templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While you can deploy config files easily with Puppet as simple text files, templates
    are much more powerful. A template file can do calculations, execute Ruby code,
    or reference the values of variables from your Puppet manifests. Anywhere you
    might deploy a text file using Puppet, you can use a template instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the simplest case, a template can just be a static text file. More usefully,
    you can insert variables into it using the ERB (embedded Ruby) syntax. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If the template is used in a context where the variable `$name` contains `Zaphod
    Beeblebrox`, the template will evaluate to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This simple technique is very useful to generate lots of files that only differ
    in the values of one or two variables, for example, virtual hosts, and for inserting
    values into a script such as database names and passwords.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we''ll use an ERB template to insert a password into a backup
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the file `modules/admin/templates/backup-mysql.sh.erb` with the following
    contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify your `site.pp` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run Puppet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether Puppet has correctly inserted the password into the template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wherever a variable is referenced in the template, for example `<%= @mysql_password
    %>`, Puppet will replace it with the corresponding value, `secret`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the example, we only used one variable in the template, but you can have
    as many as you like. These can also be facts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Or Ruby expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Or any Ruby code you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using GnuPG to encrypt secrets* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.puppetlabs.com/guides/templating.html](https://docs.puppetlabs.com/guides/templating.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using array iteration in templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example, we saw that you can use Ruby to interpolate different
    values in templates depending on the result of an expression. But you're not limited
    to getting one value at a time. You can put lots of them in a Puppet array and
    then have the template generate some content for each element of the array using
    a loop.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to build an example of iterating over arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify your `site.pp` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the file `modules/base/templates/addresslist.erb` with the following
    contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run Puppet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check the contents of the generated file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the first line of the template, we reference the array `ipaddresses`, and
    call its `each` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In Ruby, this creates a loop that will execute once for each element of the
    array. Each time round the loop, the variable `ip` will be set to the value of
    the current element.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, the `ipaddresses` array contains three elements, so the following
    line will be executed three times, once for each element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in three output lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The final line ends the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the first and last lines end with `-%>` instead of just `%>` as we
    saw before. The effect of the `-` is to suppress the new line that would otherwise
    be generated on each pass through the loop, giving us unwanted blank lines in
    the file.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Templates can also iterate over hashes, or arrays of hashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using ERB templates* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using EPP templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EPP templates are a new feature in Puppet 3.5 and newer versions. EPP templates
    use a syntax similar to ERB templates but are not compiled through Ruby. Two new
    functions are defined to call EPP templates, `epp`, and `inline_epp`. These functions
    are the EPP equivalents of the ERB functions `template` and `inline_template`,
    respectively. The main difference with EPP templates is that variables are referenced
    using the Puppet notation, `$variable` instead of `@variable`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create an EPP template in `~/puppet/epp-test.epp` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an `epp.pp` manifest, which uses the `epp` and `inline_epp` functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Apply the manifest making sure to use the future parser (the future parser
    is required for the `epp` and `inline_epp` functions to be defined):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify that the template worked as intended:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the future parser, the `epp` and `inline_epp` functions are defined. The
    main difference between EPP templates and ERB templates is that variables are
    referenced in the same way they are within Puppet manifests.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both `epp` and `inline_epp` allow for variables to be overridden within the
    function call. A second parameter to the function call can be used to specify
    values for variables used within the scope of the function call. For example,
    we can override the value of `$message` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when we run Puppet and verify the output we see that the value of `$message`
    has been overridden:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Using GnuPG to encrypt secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We often need Puppet to have access to secret information, such as passwords
    or crypto keys, for it to configure systems properly. But how do you avoid putting
    such secrets directly into your Puppet code, where they're visible to anyone who
    has read access to your repository?
  prefs: []
  type: TYPE_NORMAL
- en: It's a common requirement for third-party developers and contractors to be able
    to make changes via Puppet, but they definitely shouldn't see any confidential
    information. Similarly, if you're using a distributed Puppet setup like that described
    in [Chapter 2](ch02.html "Chapter 2. Puppet Infrastructure"), *Puppet Infrastructure*,
    every machine has a copy of the whole repo, including secrets for other machines
    that it doesn't need and shouldn't have. How can we prevent this?
  prefs: []
  type: TYPE_NORMAL
- en: One answer is to encrypt the secrets using the **GnuPG** tool, so that any secret
    information in the Puppet repo is undecipherable (for all practical purposes)
    without the appropriate key. Then we distribute the key securely to the people
    or machines that need it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First you''ll need an encryption key, so follow these steps to generate one.
    If you already have a GnuPG key that you''d like to use, go on to the next section.
    To complete this section, you will need to install the gpg command:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `puppet` resource to install gpg:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You may need to use gnupg2 as the package name, depending on your target OS.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the following command. Answer the prompts as shown, except to substitute
    your name and e-mail address for mine. When prompted for a passphrase, just hit
    *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Hit enter twice here to have an empty passphrase
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You may see a message like this if your system is not configured with a source
    of randomness:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this case, install and start a random number generator daemon such as `haveged`
    or `rng-tools`. Copy the gpg key you just created into the `puppet` user''s account
    on your Puppet master:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With your encryption key installed on the `puppet` user's keyring (the key generation
    process described in the previous section will do this for you), you're ready
    to set up Puppet to decrypt secrets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the file `modules/admin/lib/puppet/parser/functions/secret.rb` with
    the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the file `secret_message` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Encrypt this file with the following command (use the e-mail address you supplied
    when creating the GnuPG key):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Move the resulting encrypted file into your Puppet repo:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove the original (plaintext) file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify your `site.pp` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run Puppet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we''ve created a custom function to allow Puppet to decrypt the secret
    files using GnuPG:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code creates a function named `secret` that takes a file path
    as an argument and returns the decrypted text. It doesn''t manage encryption keys
    so you need to ensure that the `puppet` user has the necessary key installed.
    You can check this with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Having set up the `secret` function and the required key, we now encrypt a
    message to this key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This creates an encrypted file that can only be read by someone with access
    to the secret key (or Puppet running on a machine that has the secret key).
  prefs: []
  type: TYPE_NORMAL
- en: 'We then call the `secret` function to decrypt this file and get the contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You should use the `secret` function, or something like it, to protect any
    confidential data in your Puppet repo: passwords, AWS credentials, license keys,
    even other secret keys such as SSL host keys.'
  prefs: []
  type: TYPE_NORMAL
- en: You may decide to use a single key, which you push to machines as they're built,
    perhaps as part of a bootstrap process like that described in the *Bootstrapping
    Puppet with Bash* recipe in [Chapter 2](ch02.html "Chapter 2. Puppet Infrastructure"),
    *Puppet Infrastructure*. For even greater security, you might like to create a
    new key for each machine, or group of machines, and encrypt a given secret only
    for the machines that need it.
  prefs: []
  type: TYPE_NORMAL
- en: For example, your web servers might need a certain secret that you don't want
    to be accessible on any other machine. You could create a key for web servers,
    and encrypt the data only for this key.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use encrypted data with Hiera, there is a GnuPG backend for Hiera
    available at [http://www.craigdunn.org/2011/10/secret-variables-in-puppet-with-hiera-and-gpg/](http://www.craigdunn.org/2011/10/secret-variables-in-puppet-with-hiera-and-gpg/).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Configuring Hiera* recipe in [Chapter 2](ch02.html "Chapter 2. Puppet Infrastructure"),
    *Puppet Infrastructure*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Storing secret data with hiera-gpg* recipe in [Chapter 2](ch02.html "Chapter 2. Puppet
    Infrastructure"), *Puppet Infrastructure*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing packages from a third-party repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most often you will want to install packages from the main distribution repo,
    so a simple package resource will do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, you need a package that is only found in a third-party repository
    (an Ubuntu PPA, for example), or it might be that you need a more recent version
    of a package than that provided by the distribution, which is available from a
    third party.
  prefs: []
  type: TYPE_NORMAL
- en: On a manually-administered machine, you would normally do this by adding the
    repo source configuration to `/etc/apt/sources.list.d` (and, if necessary, a gpg
    key for the repo) before installing the package. We can automate this process
    easily with Puppet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we''ll use the popular Percona APT repo (Percona is a MySQL
    consulting firm who maintain and release their own specialized version of MySQL,
    more information is available at [http://www.percona.com/software/repositories](http://www.percona.com/software/repositories)):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the file `modules/admin/manifests/percona_repo.pp` with the following
    contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify your `site.pp` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run Puppet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to install any Percona package, we first need to have the repository
    configuration installed on the machine. This is why the `percona-server-server-5.5`
    package (Percona''s version of the standard MySQL server) requires the `admin::percona_repo`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'So, what does the `admin::percona_repo` class do? It:'
  prefs: []
  type: TYPE_NORMAL
- en: Installs the Percona APT key with which the packages are signed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configures the Percona repo URL as a file in `/etc/apt/sources.list.d`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runs `apt-get update` to retrieve the repo metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adds an APT pin configuration in `/etc/apt/preferences.d`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First of all, we install the APT key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The `unless` parameter checks the output of `apt-key list` to make sure that
    the Percona key is not already installed, in which case we need not do anything.
    Assuming it isn''t, the `command` runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This command retrieves the key from the GnuPG keyserver, exports it in the ASCII
    format, and pipes this into the `apt-key add` command, which adds it to the system
    keyring. You can use a similar pattern for most third-party repos that require
    an APT signing key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having installed the key, we add the repo configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run `apt-get update` to update the system''s APT cache with the metadata
    from the new repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we configure the APT pin priority for the repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that packages installed from the Percona repo will never be superseded
    by packages from somewhere else (the main Ubuntu distro, for example). Otherwise,
    you could end up with broken dependencies and be unable to install the Percona
    packages automatically.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The APT package framework is specific to the Debian and Ubuntu systems. There
    is a forge module for managing apt repos, [https://forge.puppetlabs.com/puppetlabs/apt](https://forge.puppetlabs.com/puppetlabs/apt).
    If you''re on a Red Hat or CentOS-based system, you can use the `yumrepo` resources
    to manage RPM repositories directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.puppetlabs.com/references/latest/type.html#yumrepo](http://docs.puppetlabs.com/references/latest/type.html#yumrepo)'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing package versions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Package version numbers are odd things. They look like decimal numbers, but
    they''re not: a version number is often in the form of `2.6.4`, for example. If
    you need to compare one version number with another, you can''t do a straightforward
    string comparison: `2.6.4` would be interpreted as greater than `2.6.12`. And
    a numeric comparison won''t work because they''re not valid numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Puppet''s `versioncmp` function comes to the rescue. If you pass two things
    that look like version numbers, it will compare them and return a value indicating
    which is greater:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'returns:'
  prefs: []
  type: TYPE_NORMAL
- en: 0 if A and B are equal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Greater than 1 if A is higher than B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less than 0 if A is less than B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s an example using the `versioncmp` function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify your `site.pp` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run Puppet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now change the value of `$app_version`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run Puppet again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've specified that the minimum acceptable version (`$min_version`) is `1.2.10`.
    So, in the first example, we want to compare it with `$app_version` of `1.2.2`.
    A simple alphabetic comparison of these two strings (in Ruby, for example) would
    give the wrong result, but `versioncmp` correctly determines that `1.2.2` is less
    than `1.2.10` and alerts us that we need to upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, `$app_version` is now `1.2.14`, which `versioncmp` correctly
    recognizes as greater than `$min_version` and so we get the message **Version
    OK**.
  prefs: []
  type: TYPE_NORMAL
