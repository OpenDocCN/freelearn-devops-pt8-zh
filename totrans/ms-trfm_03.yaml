- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Harnessing HashiCorp Utility Providers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用 HashiCorp 实用程序提供程序
- en: As we discussed in the first chapter, when we learned about Terraform’s architecture,
    Terraform was designed to be extensible. In the previous chapter, we spent a lot
    of time looking at the **HashiCorp Configuration Language** (**HCL**), which provides
    many tools that we can use to help us define our **infrastructure as code** (**IaC**).
    However, these language devices are not always sufficient. That is why HashiCorp
    has built a set of utility providers that provide a kind of base class library,
    or a set of reusable features that are helpful to specific scenarios, no matter
    what cloud platforms you are using to build your IaC solutions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第一章中讨论的，当我们了解 Terraform 的架构时，Terraform 被设计为可扩展的。在上一章中，我们花了很多时间研究 **HashiCorp
    配置语言** (**HCL**)，它提供了许多工具，可以帮助我们定义 **基础设施即代码** (**IaC**)。然而，这些语言工具并不总是足够的。这就是为什么
    HashiCorp 构建了一套实用的提供程序，它提供了一种基础类库或一套可重用的功能，适用于特定场景，无论你使用什么云平台来构建你的 IaC 解决方案。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Working with reality
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理现实
- en: Adaptation and integration
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配与集成
- en: Filesystem
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统
- en: Operating system and networking
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统和网络
- en: Working with reality
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理现实
- en: When building our architecture with IaC, the product is not the code but living
    and breathing environments. While the code lives in the abstract realms of our
    minds, these environments operate within the real world, and just like how our
    best-laid plans get smashed by reality—so do our environments.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用 IaC 构建架构时，产物不是代码，而是活生生的环境。虽然代码存在于我们大脑的抽象领域中，但这些环境在现实世界中运作，就像我们的最佳计划会被现实击碎一样——我们的环境也会如此。
- en: Therefore, we need some tools to prepare our environments to meet and come to
    grips with reality. The `random` and `time` providers allow us to avoid conflicts
    between our resources and our environments—whether it’s the name of something
    or when something expires. These are all critical elements of our solution design
    that can make or break our architecture when it encounters the real world.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要一些工具来准备我们的环境，以面对现实并与之应对。`random` 和 `time` 提供程序使我们能够避免资源和环境之间的冲突——无论是某个事物的名称，还是某个事物的过期时间。这些都是我们解决方案设计中的关键元素，当架构遇到现实世界时，它们可能决定成败。
- en: Randomizing
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机化
- en: The `random` provider offers several ways to add randomness to your Terraform
    solution. Each `random` resource type may generate different types of random values
    and have other attributes to control the output. Still, all of them—with only
    a couple of exceptions—generate the random value through a single output called
    `result`. They also all have at least one attribute called `keepers`, which triggers
    Terraform to recreate the resource. This attribute can be helpful to set when
    you have transient resources that get replaced often, and you need to ensure there
    are no name conflicts when destroying and recreating the resource.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`random` 提供程序提供了多种方法来为你的 Terraform 解决方案添加随机性。每种 `random` 资源类型可能会生成不同类型的随机值，并具有其他属性来控制输出。然而，除了少数几个例外，它们都通过一个叫做
    `result` 的输出生成随机值。它们还至少有一个名为 `keepers` 的属性，用于触发 Terraform 重新创建资源。当你有频繁替换的临时资源时，这个属性特别有用，它可以帮助你确保在销毁并重新创建资源时没有名称冲突。'
- en: Random strings
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随机字符串
- en: Generating random strings can be a great way to guarantee uniqueness across
    deployments, especially in situations where you are dynamically generating short-lived
    environments. Depending on the case, there are two ways to generate strings—one
    for non-sensitive data, such as resource names, and another for sensitive data,
    such as access keys and passwords.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 生成随机字符串是保证部署唯一性的好方法，特别是在动态生成短生命周期环境的情况下。根据不同的场景，有两种生成字符串的方式——一种用于非敏感数据，如资源名称，另一种用于敏感数据，如访问密钥和密码。
- en: 'Generating non-sensitive dynamic names can be done using `random_string`. At
    the same time, `random_password` can create sensitive values you should protect
    from leakage by marking them as sensitive if you output them and by securing your
    state, since Terraform will store the resulting value in state:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 生成非敏感动态名称可以通过 `random_string` 来完成。同时，`random_password` 可以生成敏感值，你应该通过将其标记为敏感来防止泄漏，如果你输出它们，还需要通过保护你的状态来确保安全，因为
    Terraform 会将结果值存储在状态中：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code generates a random string that can generate unique resource
    names within projects. Using short random strings to embed within the names of
    your resources is a great strategy when working with resources with minimal name
    length constraints, as it can be challenging to create a coherent naming convention
    across all your resources when one or two of the resources require abnormally
    small name lengths. This situation is common when resources need to have globally
    unique names, such as S3 buckets or Azure Storage accounts:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成一个随机字符串，可以在项目中生成唯一的资源名称。当您的资源名称长度要求较小时，使用短的随机字符串嵌入到资源名称中是一个很好的策略，因为当一个或两个资源需要异常小的名称长度时，创建一致的命名约定会变得很有挑战性。这种情况通常出现在资源需要具有全球唯一名称时，比如S3存储桶或Azure存储帐户：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When you couple a random name suffix with part of your naming convention, you
    can still have a relatively rational resource name:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将随机名称后缀与命名约定的部分结合时，仍然可以获得一个相对合理的资源名称：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Unique identifiers
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 唯一标识符
- en: 'You can also generate a `random_uuid`. This can be helpful when your resource
    supports very long names, as these non-case-sensitive, alphanumeric values take
    the following format: `00000000-0000-0000-0000-000000000000`. You might need this
    to generate a unique correlation identifier to link resources within your deployments
    using a common tag.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以生成`random_uuid`。这对于您的资源支持非常长的名字时很有帮助，因为这些不区分大小写的字母数字值采用以下格式：`00000000-0000-0000-0000-000000000000`。您可能需要这个来生成唯一的关联标识符，以便在部署中使用公共标签将资源链接起来。
- en: Just for fun
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 纯粹为了娱乐
- en: 'There is also a fun little resource called `random_pet`, with a nod to the
    age-old jest of *pets versus cattle*, where you can generate pet names. This resource
    is probably not useful for production but can be helpful in development or lab
    environments where you can be more creative with resource names. The `random_pet`
    resource’s `id` output will generate names with an adjective-noun format. Here
    are some sample values I came up with using the sample included in this chapter
    of the book:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个有趣的小资源叫做`random_pet`，它向古老的*宠物与牲畜*笑话致敬，您可以用它生成宠物名字。这个资源可能对生产环境没有太大用处，但在开发或实验室环境中，当您可以更加自由地为资源命名时，它是很有帮助的。`random_pet`资源的`id`输出将生成形容词-名词格式的名字。以下是我通过书中这一章的示例生成的一些示例值：
- en: '`notable-coyote`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notable-coyote`'
- en: '`quiet-parakeet`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quiet-parakeet`'
- en: '`pure-woodcock`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pure-woodcock`'
- en: '`healthy-monkey`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`healthy-monkey`'
- en: '`mint-foal`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mint-foal`'
- en: '`pet-serval`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pet-serval`'
- en: '`ideal-lab`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ideal-lab`'
- en: '`special-urchin`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`special-urchin`'
- en: You can see that almost all of them don’t make much sense, but some can be funny.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到几乎所有的名字都没有什么意义，但有些可能很有趣。
- en: Random numbers
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随机数
- en: Generating random numbers can also help generate random names or generate a
    random index from an array. `random_integer` offers a simple solution that allows
    you to pick a number between specified `min` and `max` values.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 生成随机数还可以帮助生成随机名称或从数组中生成随机索引。`random_integer`提供了一个简单的解决方案，允许您从指定的`min`和`max`值之间选择一个数字。
- en: 'Consider the following array of AWS availability zones:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下AWS可用区数组：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we wanted to pick a random availability zone from this `list`, we could
    use `random_integer` to generate a random index from it:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想从这个`list`中选择一个随机的可用区，我们可以使用`random_integer`来生成一个随机索引：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code would allow us to generate a random integer between `0` and
    the length of the `list` minus `1`, which would be `4 - 1 = 3`. Therefore, we
    would randomly generate either `0`, `1`, `2`, or `3`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码将允许我们在`0`和`list`长度减去`1`之间生成一个随机整数，即`4 - 1 = 3`。因此，我们将随机生成`0`、`1`、`2`或`3`。
- en: 'We can access the random availability zone using the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下代码访问随机的可用区：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we could use the availability zone name to configure our AWS resources:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用可用区名称来配置我们的AWS资源：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Beyond simple integers
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 超越简单的整数
- en: 'When simple integers aren’t enough, you can use `random_id` to generate more
    sophisticated outputs. The only input is the `byte_length` to control how large
    the random number generated can be. This resource differs from other `random`
    providers’ resources as it does not have a `result` output, but has several others
    that present the random number in various formats, including decimal, hexadecimal,
    and Base64:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当简单的整数不足以满足需求时，您可以使用`random_id`来生成更复杂的输出。唯一的输入是`byte_length`，它控制生成的随机数的大小。这个资源与其他`random`提供者的资源不同，因为它没有`result`输出，而是有几个其他输出，以不同格式呈现随机数，包括十进制、十六进制和Base64：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code generates a random number with a length of 8 bytes. Examples
    of the output values of the different formats are listed as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成了一个长度为 8 字节的随机数。不同格式的输出值示例如下：
- en: '`IpVgeF7uUY0`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IpVgeF7uUY0`'
- en: '`2492004038924456333`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2492004038924456333`'
- en: '`229560785eee518d`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`229560785eee518d`'
- en: '`IpVgeF7uUY0=`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IpVgeF7uUY0=`'
- en: '`=` `IpVgeF7uUY0`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`=` `IpVgeF7uUY0`'
- en: Again, depending on your naming conventions, this can be useful for creating
    names or tags that uniquely identify your resources.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，根据你的命名规范，这对创建独特标识资源的名称或标签非常有用。
- en: Shuffle
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混洗
- en: Using the previous example, when selecting availability zones from a list, we
    would have to generate various `random_integer` resources if we wanted to select
    multiple items from that list at random. Attempting to do so with `random_integer`
    is already pretty cumbersome, but it becomes more challenging if we have requirements
    to ensure that the second instance of `random_integer` isn’t the same as the first
    one.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，当从列表中选择可用区时，如果我们想从列表中随机选择多个项，我们需要生成多个 `random_integer` 资源。使用 `random_integer`
    来做到这一点已经相当繁琐，如果我们有要求确保第二个 `random_integer` 的结果不与第一个相同，问题会更加复杂。
- en: Luckily, an alternative approach to using `random_integer` to select the index
    of an array is to use a built-in resource for the specific task of choosing a
    random subset of items from a `list`. You can achieve this approach using the
    `random_shuffle` resource, passing in the `list` and the number of items you want
    using the `result_count` attribute. The output `result` will be a `list` of strings
    that you can use. This approach dramatically simplifies our solution if we want
    our AWS **Elastic Load Balancer** (**ELB**) to span multiple availability zones.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，选择数组索引的替代方法是使用内建资源来从 `list` 中选择随机子集。你可以使用 `random_shuffle` 资源来实现此方法，通过
    `list` 和你想要的项数（通过 `result_count` 属性传递）来实现。输出的 `result` 将是一个你可以使用的字符串 `list`。如果我们希望
    AWS **Elastic Load Balancer** (**ELB**) 跨多个可用区展开，这种方法会极大简化我们的解决方案。
- en: 'Consider the following array of AWS availability zones:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下 AWS 可用区的数组：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We would use `random_shuffle` to generate two availability zones for our ELB:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `random_shuffle` 来为我们的 ELB 生成两个可用区：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we set the `availability_zones` attribute using the `result` of `random_shuffle`
    because its output is the correct type of `list(string)`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `random_shuffle` 的 `result` 来设置 `availability_zones` 属性，因为它的输出是正确类型的
    `list(string)`：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This resource is useful, but you need to watch out when using it as it can cause
    your solution to become non-deterministic—meaning that Terraform won’t be able
    to figure out how to create a plan until the `random_shuffle` resource has been
    created. This could require you to use targeted `terraform apply` operations to
    avoid first-time-apply failures.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个资源非常有用，但使用时需要小心，因为它可能导致你的解决方案变得非确定性——意味着 Terraform 需要等到 `random_shuffle` 资源创建完成后，才能确定如何创建计划。这可能需要你使用有针对性的
    `terraform apply` 操作，以避免第一次应用失败。
- en: Working with time
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与时间相关的工作
- en: In Terraform, the `time` provider offers several capabilities that make it easier
    to handle various scenarios where resource life cycle management is dictated by
    time.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Terraform 中，`time` 提供商提供了几项功能，使得在资源生命周期管理由时间决定的各种场景下更容易处理。
- en: While most cloud providers offer much better solutions for resource scheduling,
    there are still cases where time plays a crucial role in the provisioning of resources.
    This situation often involves certificates, where you need to set a fixed or rolling
    window for the certificate to expire. In this situation, you can use either a
    specific date/time in the future or one that is relative to the current date/time.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数云提供商为资源调度提供了更好的解决方案，但在一些情况下，时间仍然在资源配置中起着至关重要的作用。这种情况通常涉及证书，你需要为证书设置固定的或滚动的过期时间窗口。在这种情况下，你可以使用未来的特定日期/时间，或者相对于当前日期/时间的日期/时间。
- en: Current date/time
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当前日期/时间
- en: 'Sometimes, you want to capture the current date and time, which you may like
    to use for the effective date of a secret’s value. There are two methods to obtaining
    the current date in Terraform—a function and the `time_static` resource:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能想捕捉当前的日期和时间，这些信息可能用于一个秘密值的生效日期。Terraform 提供了两种获取当前日期的方法——一个是函数，另一个是 `time_static`
    资源：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code demonstrates using the `timestamp()` function. The following
    code shows how to use the `time_static` resource from the `time` provider:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码演示了如何使用 `timestamp()` 函数。以下代码展示了如何使用 `time` 提供商中的 `time_static` 资源：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Both approaches will generate the current date/time on the first time you run
    `apply`. The difference is that the `timestamp()` function will always generate
    a current date/time stamp on every subsequent `apply`. This makes it more ideal
    for scenarios such as tagging a resource with its last modified date, which could
    be useful to determine the last time the resource was touched by Terraform. Another
    common scenario is triggering resource updates that you want to happen every time,
    but try to avoid this because this creates perpetual churn in your solution.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都会在你第一次运行 `apply` 时生成当前的日期/时间。不同之处在于，`timestamp()` 函数每次运行 `apply` 时都会生成当前的日期/时间戳。这使得它在一些场景中更加理想，比如给资源打上最后修改日期的标签，这有助于确定资源最后一次被
    Terraform 修改的时间。另一个常见的场景是触发资源更新，你希望每次都触发更新，但要避免这种做法，因为这会导致解决方案中的持续变化。
- en: At the same time, the `time_static` resource will maintain, in State, the original
    date/time stamp at the first Terraform `apply`. This can be useful for life cycle
    management of the resources to determine when the deployment was originally created
    or for setting policies for backups, scaling, or decommissioning based on age.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，`time_static` 资源将在 State 中维护第一次 Terraform `apply` 时的原始日期/时间戳。这对于资源的生命周期管理很有用，可以帮助确定部署最初创建的时间，或根据年龄设置备份、扩展或退役策略。
- en: Fixed date/time
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 固定日期/时间
- en: 'A string representation of the date/time can be used to create a specific time
    in the future using an absolute date/time:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用日期/时间的字符串表示形式来创建一个未来的特定时间，方法是使用绝对的日期/时间：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding code will set the expiration date to May 4, 2024\. The format
    of the string representation of date/time is `YYYY-MM-DDTHH:MM:SSZ`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码会将过期日期设置为 2024 年 5 月 4 日。日期/时间的字符串表示格式为 `YYYY-MM-DDTHH:MM:SSZ`。
- en: 'Another option is using the `time_static` resource and setting the `rfc3339`
    attribute, which is rarely used due to its limited value over simply setting a
    local:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用 `time_static` 资源并设置 `rfc3339` 属性，但由于其相较于简单设置本地时间的有限值，通常很少使用：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Time offset
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间偏移
- en: 'A specific time in the future using a period relative to the current date can
    be created using `time_offset`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用相对于当前日期的周期来创建未来的特定时间，方法是使用 `time_offset`：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code will set the expiration date to exactly one year in the future.
    There are different attributes to adjust the offset date/time stamp by years,
    months, days, hours, minutes, and seconds. You can set the `base_rfc3339` attribute
    to change the date/time to which the offset is relative. This can be a great way
    to dynamically set certain expiration dates. However, you need to ensure that
    you routinely run Terraform to keep the target date in the future.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码会将过期日期设置为恰好一年后的未来日期。有不同的属性可以调整偏移日期/时间戳，单位包括年份、月份、天数、小时、分钟和秒。你可以设置 `base_rfc3339`
    属性来改变偏移的日期/时间的基准。这是动态设置某些过期日期的好方法。但你需要确保定期运行 Terraform 来保持目标日期在未来。
- en: Rotation
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 旋转
- en: You may need to recreate resources on a regular cadence in several situations.
    This secret could need to be updated every 90 days or XXX days. In these situations,
    the `time_rotating` resource provides an advantage over its static siblings, both
    `time_static` and `time_offset`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能需要定期重建资源。这个密钥可能需要每90天或XXX天更新一次。在这些情况下，`time_rotating` 资源相较于其静态同类资源
    `time_static` 和 `time_offset` 提供了优势。
- en: 'Time offset seems like the solution for rotation as it is relative to the current
    date, but just like `time_static`, it is just another way of calculating a static
    date/time stamp that Terraform will store in State. The `time_rotating` resource’s
    superpower is that when the `rotation_days` period expires relative to the original
    date, you will see that the resource triggers a replacement:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 时间偏移看起来是旋转的解决方案，因为它是相对于当前日期的，但就像 `time_static` 一样，它只不过是另一种计算 Terraform 将存储在
    State 中的静态日期/时间戳的方法。`time_rotating` 资源的超级能力是，当 `rotation_days` 期限相对于原始日期到期时，你会看到该资源触发替换：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This also requires you to regularly run Terraform to keep the values in the
    future. If you utilize resources like this, make sure you coordinate with your
    change management procedures, as they can sneak up on you when you execute a `terraform
    plan` only to discover you’ve passed the magic date.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这也要求你定期运行 Terraform 以保持未来的值。如果你使用了这样的资源，确保与变更管理流程进行协调，因为当你执行 `terraform plan`
    时，它们可能会在不经意间出现在你面前，而你可能会发现自己已经错过了那个关键日期。
- en: In this section, we learned how to randomize the names of our resources using
    the `random` provider, and even generate secrets that we can use to fully automate
    an environment with resources that need you to set passwords before Terraform
    can provision them. We also learned how we could use the `time` provider, when
    to use it versus the `timestamp()` function we looked at in [*Chapter 2*](B21183_02.xhtml#_idTextAnchor096),
    and other advanced scenarios of creating time periods and windows of rotation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用 `random` 提供者随机化资源的名称，甚至生成我们可以在 Terraform 在为其提供密码之前可以使用的密钥的部分自动化环境。我们还学习了在[*第
    2 章*](B21183_02.xhtml#_idTextAnchor096)中查看的 `timestamp()` 函数和其他创建时间段和旋转窗口的高级场景中何时使用
    `time` 提供者。
- en: Next, we’ll look at some utility providers that help us overcome some limitations
    of Terraform whenever we encounter a situation in which Terraform doesn’t already
    have a built-in solution or an existing provider that tackles the problem.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看一些实用程序提供者，这些提供者帮助我们克服 Terraform 遇到不具备内置解决方案或已有提供者解决该问题的情况时的一些限制。
- en: Adaptation and integration
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适应和集成
- en: As we’ve discussed, Terraform and its providers are open source projects, so
    there may be limits to what it can do or what is available. As a result, we often
    need to find ways of overcoming these limitations—even temporarily. In this section,
    we’ll look at several providers that help Terraform reach outside and take advantage
    of external programs and systems that can enhance Terraform and help it overcome
    situations lacking a built-in solution.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论过的，Terraform 及其提供者是开源项目，因此它可能存在其无法执行或无法获取的限制。因此，我们经常需要找到克服这些限制的方法，即使是暂时性的。在本节中，我们将查看几个提供者，这些提供者帮助
    Terraform 扩展外部并利用可以增强 Terraform 并帮助其克服缺乏内置解决方案的情况的程序和系统。
- en: Accessing external resources
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问外部资源
- en: 'Like many utility providers, the `external` provider is tiny. It only has one
    data source of the same name as the provider: `external`. As the name implies,
    this data source allows you to integrate with third-party components. It enables
    you to execute a local program, pass its input, and process the output. This capability
    can be advantageous when you want to obtain dynamic configuration from an external
    source, perform complex transformations on inputs you receive from other providers,
    and integrate with third-party tools that you want to integrate with Terraform.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 像许多实用程序提供者一样，`external` 提供者很小。它只有一个与提供者同名的数据源：`external`。顾名思义，此数据源允许您与第三方组件集成。它使您能够执行本地程序，传递其输入并处理输出。当您希望从外部源获取动态配置，对来自其他提供者的输入执行复杂转换，并集成您希望与
    Terraform 集成的第三方工具时，此功能可能非常有利。
- en: This provider is very particular about the runtime requirements of the program
    that you specified. First, the program must run successfully by exiting with an
    exit code of zero. If the program returns a non-zero code, the provider will sound
    the alarm and scramble an error message to Terraform. Second, the provider expects
    both the input and the output to be in JSON format.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此提供者非常关注您指定的程序的运行时要求。首先，程序必须成功运行并以零退出码退出。如果程序返回非零代码，提供者将向 Terraform 发出警报并散播错误消息。其次，提供者期望输入和输出都以
    JSON 格式提供。
- en: Using the `external` provider works perfectly when your third-party program
    fulfills all these requirements. It is a happy coincidence indeed! If you are
    integrating with such a program, that’s great. However, this provider is the right
    choice when you author custom scripts or programs that explicitly meet these contractual
    obligations.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的第三方程序满足所有这些要求时，使用 `external` 提供者非常完美。这确实是一个幸运的巧合！如果您正在集成这样的程序，那太棒了。但是，当您编写明确满足这些合同义务的自定义脚本或程序时，此提供者是正确的选择。
- en: 'To be as cross-platform as possible, the ideal programming language to write
    these custom scripts would be Python or Go. With these programming languages,
    you can create a lightweight script, designed and built, that is fit for the purpose
    of talking to the external system of your choice and providing Terraform-friendly
    outputs and error handling:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尽可能跨平台，编写这些自定义脚本的理想编程语言是 Python 或 Go。使用这些编程语言，您可以创建一个轻量级脚本，专门设计和构建，适合与您选择的外部系统进行通信，并提供
    Terraform 友好的输出和错误处理：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, we are executing the Python program on the local machine–this
    could be our laptop or the build agent of our **continuous integration/continuous
    delivery** (**CI/CD**) pipeline.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们正在本地机器上执行 Python 程序——这可能是我们的笔记本电脑，或者是我们**持续集成/持续交付**（**CI/CD**）管道的构建代理。
- en: When you want to make something from nothing
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当你想从无到有地创建某样东西时
- en: Terraform and its providers are open source projects. That means that we are
    at the mercy of friendly internet strangers who are keeping pace with the changes
    made to the platforms and technologies that we hope to automate. While Terraform
    has fantastic coverage across a wide set of public cloud platforms and technologies,
    sometimes, it needs a little help. There might be a small feature that lacks support
    that you can’t configure natively through the resources available in the provider.
    Sometimes, those small tweaks play a critical role in configuration, and we need
    to draw dependencies on them from other resources that can be provisioned natively
    through the Terraform provider. That’s where the `null_resource` comes into play.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 及其提供者是开源项目。这意味着我们依赖于那些积极跟进平台和技术变化的友好互联网陌生人，他们在帮助我们实现自动化时提供支持。尽管 Terraform
    对于广泛的公共云平台和技术有着出色的支持，但有时它还是需要一些帮助。可能有一些小特性没有得到支持，而你无法通过提供者中的资源原生配置。那些小小的调整有时在配置中发挥着关键作用，我们需要从其他可以通过
    Terraform 提供者原生配置的资源中引入它们的依赖。这就是 `null_resource` 的作用所在。
- en: Null resource
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空资源
- en: The `null_resource` allows us to leverage meta-arguments such as `provisioner`
    to perform local and remote script executions. This allows you to execute critical
    command-line scripts that must be completed before Terraform can continue its
    plan. As a result, the `null_resource` has no attributes such as other Terraform
    resources. Its only attribute is a `list(string)` called `triggers`. When any
    strings within this array change, the `null_resource` is replaced. This is an
    important life cycle control that you need to consider when configuring the `provisioner`
    blocks you attach.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`null_resource` 允许我们利用元参数如 `provisioner` 来执行本地和远程脚本执行。这使你能够执行一些关键的命令行脚本，这些脚本必须在
    Terraform 继续其计划之前完成。因此，`null_resource` 没有像其他 Terraform 资源那样的属性。它唯一的属性是一个名为 `triggers`
    的 `list(string)` 类型。当该数组中的任何字符串发生变化时，`null_resource` 就会被替换。这是一个重要的生命周期控制因素，在配置你附加的
    `provisioner` 块时，你需要考虑这一点。'
- en: Time sleep
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间睡眠
- en: 'There is another technique of doing nothing. There can be situations where
    the action you try to trigger is non-deterministic, meaning you won’t know exactly
    when it finishes. This could be out of context or a true technical limitation
    of the resource or shim you use. The `time` provider offers a resource called
    `time_sleep`, which lets you create a sleep timer. You must declare `depends_on`
    meta-arguments to ensure that the sleep timer is invoked between the required
    resources:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种什么都不做的技巧。在某些情况下，你试图触发的操作是非确定性的，这意味着你无法准确知道它何时完成。这可能是上下文之外的，或者是你使用的资源或适配器的真正技术限制。`time`
    提供者提供了一个名为 `time_sleep` 的资源，可以让你创建一个睡眠定时器。你必须声明 `depends_on` 元参数，以确保在所需资源之间调用睡眠定时器：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Delayed `destroy` can be done using a different attribute called `destroy_duration`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟 `destroy` 可以通过一个名为 `destroy_duration` 的不同属性来完成。
- en: Making HTTP requests
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发起 HTTP 请求
- en: Sometimes, you can access data from external sources without using a local script
    or command-line utility, by directly accessing a REST API endpoint. This approach
    is advantageous when you want to fetch configuration information staged at a static
    HTTP endpoint, access information about resources managed outside of Terraform,
    integrate with a cloud provider or external services directly through a REST API,
    and integrate health checks into your Terraform process.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可以不使用本地脚本或命令行工具，通过直接访问 REST API 端点来访问外部数据。当你希望从静态 HTTP 端点获取配置信息，访问管理在 Terraform
    之外的资源的信息，或直接通过 REST API 与云提供商或外部服务集成，甚至将健康检查集成到 Terraform 流程中时，这种方法特别有利。
- en: 'The `http` provider provides a single data source called `http`, allowing you
    to make an HTTP `GET` operation. The only required input is `url`, but you can
    provide several attributes you would expect to set on an HTTP request, such as
    HTTP request headers and body content:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`http` 提供者提供了一个名为 `http` 的单一数据源，允许你进行 HTTP `GET` 操作。唯一必需的输入是 `url`，但你可以提供一些你期望在
    HTTP 请求中设置的属性，比如 HTTP 请求头和正文内容：'
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After Terraform makes the HTTP request, you can access the HTTP response status
    code, headers, and body content.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Terraform 发出 HTTP 请求后，你可以访问 HTTP 响应状态码、头信息和正文内容。
- en: In this section, we learned how to integrate with all sorts of external components—local
    programs or scripts, a remote server, and nothing at all.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何与各种外部组件集成——本地程序或脚本、远程服务器或完全不使用任何组件。
- en: Next, we’ll look at some utility providers that help us work with creating and
    accessing files. We’ve already encountered some functions that enable some of
    these scenarios, but some additional scenarios are only possible when we use utility
    providers.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看一些有助于我们创建和访问文件的实用程序提供者。我们已经遇到了一些能够启用这些场景的函数，但一些额外的场景只有在使用实用程序提供者时才可能。
- en: Filesystem
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件系统
- en: When building IaC solutions using Terraform, there are many situations where
    we need to either use existing files or create new ones. In this section, we’ll
    look at the utility providers that enable more advanced scenarios that move beyond
    the `file` and `templatefile` functions and when we should use the providers versus
    using the functions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Terraform 构建基础设施即代码（IaC）解决方案时，有许多情况需要使用现有文件或创建新文件。在本节中，我们将查看使更高级场景成为可能的实用程序提供者，这些场景超出了
    `file` 和 `templatefile` 函数的范围，以及何时应该使用提供者而不是函数。
- en: Reading and writing local files
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取和写入本地文件
- en: There are many situations when reading or writing files can be very useful to
    simplify how Terraform integrates with other tools by creating configuration files,
    scripts, or any other artifact required for your infrastructure deployment. To
    produce the desired output, you can define the content using templated files,
    input variables, or other expressions within your HCL code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况下，读取或写入文件可以大大简化 Terraform 如何与其他工具集成，例如通过创建配置文件、脚本或任何其他基础设施部署所需的工件。为了生成所需的输出，你可以在
    HCL 代码中使用模板文件、输入变量或其他表达式来定义内容。
- en: Terraform has a utility provider called `local` that provides this functionality.
    This provider has two resources and two data sources named `local_file` and `local_sensitive_file`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 有一个名为 `local` 的实用程序提供者，提供了此功能。该提供者有两个资源和两个数据源，分别名为 `local_file` 和
    `local_sensitive_file`。
- en: Why not just use the function? Functions do not participate in the dependency
    graph, so when you use the `file` or `template_file` functions, you cannot use
    them with files generated dynamically during a Terraform operation. Therefore,
    if you plan on generating and using a file within Terraform, you should always
    use the `local` provider’s resources.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不直接使用函数呢？函数不会参与依赖图，因此当你使用 `file` 或 `template_file` 函数时，不能与在 Terraform 操作过程中动态生成的文件一起使用。因此，如果你计划在
    Terraform 中生成并使用文件，应该始终使用 `local` 提供者的资源。
- en: Writing files
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 写入文件
- en: 'The `local_file` resource (and the corresponding `local_sensitive_file` resource)
    allows you to create a new file at a target location specified in the `filename`
    attribute. There are several options for sourcing the content, either by using
    dynamically generated content inside Terraform or an existing file:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`local_file` 资源（以及相应的 `local_sensitive_file` 资源）允许你在 `filename` 属性中指定的目标位置创建一个新文件。有几种选项可以用于获取内容，可以通过使用
    Terraform 内部动态生成的内容或现有文件来提供：'
- en: '`content`: This attribute allows you to pass any string as long as it is UTF-8-encoded,
    using simple strings from resource outputs, local variables, or functions to generate
    a string.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content`：此属性允许你传递任何 UTF-8 编码的字符串，可以使用资源输出、局部变量或函数中的简单字符串来生成该字符串。'
- en: '`content_base64`: This attribute allows you to pass binary data as a Base64-encoded
    string.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content_base64`：此属性允许你传递作为 Base64 编码字符串的二进制数据。'
- en: '`source`: This attribute allows you to pass a path to an existing file from
    which you want to read the contents. When using this attribute, you copy the original
    file to a new location.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`source`：此属性允许你传递一个现有文件的路径，用于读取文件内容。当使用此属性时，你将原始文件复制到新位置。'
- en: 'In the following code, we are setting the `content` attribute to a simple constant
    string and using the `${path.module}` special token to specify the current module’s
    working directory as the output location for a file with the name of `foo.bar`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们将 `content` 属性设置为一个简单的常量字符串，并使用 `${path.module}` 特殊标记指定当前模块的工作目录作为名为
    `foo.bar` 文件的输出位置：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Be careful when destroying, especially if you dynamically generate the file’s
    contents inside Terraform using a `jsonencode`, `yamlencode`, or any other method—you
    may run into issues because of the way Terraform handles dependencies on this
    resource type.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在销毁时要小心，特别是当你在Terraform中动态生成文件内容时，使用`jsonencode`、`yamlencode`或任何其他方法时——你可能会遇到问题，因为Terraform处理这种资源类型依赖关系的方式。
- en: Also, be aware when writing sensitive data to files, as it can pose a security
    risk. Likewise, filesystem access or I/O failures can create opportunities for
    additional points of failure when executing Terraform.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，当将敏感数据写入文件时要小心，因为这可能会带来安全风险。同样，文件系统访问或I/O失败可能会为执行Terraform时创造额外的故障点。
- en: Given these common pitfalls, generating file contents using Terraform can still
    be extremely effective. One such scenario is generating YAML inventories for Ansible,
    which can be an excellent way of integrating Terraform and Ansible as part of
    a broader maintenance process for long-lived environments that need configuration
    management changes at the operating system level.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这些常见的陷阱，使用Terraform生成文件内容仍然是非常有效的。一个这样的场景是为Ansible生成YAML清单，这是将Terraform和Ansible集成作为更广泛的维护过程的一部分的一个极好的方法，适用于需要操作系统级别配置管理变更的长期环境。
- en: Reading files
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取文件
- en: The `local_file` data source (and the corresponding `local_sensitive_file` data
    source) allows you to read the contents of an existing file and output its contents
    in a variety of formats that you can use as inputs to other resources and modules
    within your code base. This capability is similar to what the `file` function
    can do but provides a few advantages.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`local_file`数据源（以及相应的`local_sensitive_file`数据源）允许你读取现有文件的内容，并以各种格式输出其内容，供你在代码库中的其他资源和模块中作为输入。这一功能与`file`函数类似，但提供了一些优势。'
- en: First, it can create a standalone block referenced multiple times from multiple
    resources without repeating the filename’s path in the equivalent function call.
    Creating a central reference to the local file can make your code more maintainable
    by making the dependencies on the file more apparent to both Terraform and humans.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它可以创建一个独立的块，从多个资源中引用，而不必在等效的函数调用中重复文件名的路径。创建一个对本地文件的集中引用可以使你的代码更易于维护，因为它让Terraform和人类对文件的依赖关系更加明确。
- en: Second, by leveraging the data source, you immediately have several ways to
    output the data, including Base64-string, SHA, and MD5 options. By leveraging
    these output options, you can avoid additional nested function calls to perform
    the same encoding operations.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，通过利用数据源，你可以立即获得多种输出数据的方式，包括Base64字符串、SHA和MD5选项。通过利用这些输出选项，你可以避免进行额外的嵌套函数调用，以执行相同的编码操作。
- en: 'In the following code, we access an existing file within the module’s current
    directory with a `foo.bar` filename:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们通过`foo.bar`文件名访问模块当前目录中的现有文件：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can then access the file’s raw content by using the `content` output of the
    data source or any of the other encoding options mentioned earlier.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过使用数据源的`content`输出或之前提到的其他编码选项来访问文件的原始内容。
- en: Templating files and directories
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板文件和目录
- en: In the previous chapter, we covered templating files and surveyed HCL’s built-in
    functions, including the function called `template_file`. You should use this
    function when working with a single file, but the `template` provider offers a
    resource that you can use to apply templating across all the files within a given
    directory.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了模板文件，并调查了 HCL 内置函数，包括名为`template_file`的函数。当你处理单个文件时，应该使用这个函数，但`template`提供者提供了一个资源，你可以用它在给定目录中的所有文件上应用模板化。
- en: The resource takes input files from the `source_dir` attribute and, for each
    file, substitutes the specified input variables for the corresponding placeholders,
    writing each output file to the established `destination_dir`. Using this resource
    is a great way to update configurations that span a multitude of files. Still,
    you must stage all files with a consistent set of placeholders for the templating
    engine to replace in the same fashion as the `template_file()` function operates.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 该资源从`source_dir`属性获取输入文件，并且对于每个文件，它会将指定的输入变量替换为相应的占位符，将每个输出文件写入已建立的`destination_dir`。使用这个资源是更新跨多个文件的配置的一个好方法，但你必须确保所有文件都使用一致的占位符集，以便模板引擎以与`template_file()`函数相同的方式替换。
- en: Generating file archives
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成文件归档
- en: Sometimes, it’s necessary to package outputs from Terraform into compressed
    archives that you can use for several different purposes, such as efficiently
    transferring configuration to the next stage in the application deployment pipeline,
    bundling configuration for easy distribution to other external repositories, and
    generating documentation or other artifacts to track deployment history, environmental
    changes, or snapshots of configuration as they change over time.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: You should avoid this approach when working with secrets or sensitive data,
    as more appropriate solutions exist for those scenarios. Metadata related to the
    infrastructure generated by Terraform and needed by another tool in another format
    is the ideal scenario for this approach.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: The `archive_file` resource generates a ZIP file at the specified `output_path`
    and includes one or more files, using either existing files or dynamically generated
    files.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Including existing files
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you want to reference either existing files that are stored in your Terraform
    module directory or files generated by Terraform using the `local` provider, you
    should use `source_file` or `source_dir` to include a single file or an entire
    directory of files within the archive, respectively:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Including dynamically created files
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you want to output content that’s dynamically generated by Terraform using
    object construction in local variables or other means, you need to use one or
    more `source` blocks and specify the `content` and the `filename` of the file
    to include it within the archive:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Optionally, if you only want one dynamically generated file in the archive,
    you can use the top-level `source_content` and `source_filename` to have a single
    file:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding examples produce the same output, but the latter is slightly more
    concise for the single-file archive scenario. At the same time, the former allows
    you to add as many files to the archive as you like in the future using additional
    `source` blocks.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that each method for including files within the archive
    is mutually exclusive, so you must choose one—and only one—approach.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to leverage the `local`, `archive`, and `template`
    providers to handle more robust filesystem access scenarios where leveraging the
    existing functions may not be ideal.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll look at some utility providers that help us work with setting
    up operating system configuration, security, and network access control.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Operating system and networking
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HashiCorp created Terraform’s utility providers to solve common problems that
    span cloud platforms. As a result, some utility providers solve problems relating
    to common architectural scenarios you will encounter when setting up or connecting
    to servers.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Generating certificates and SSH keys
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Terraform, the `tls` provider offers general capabilities related to **Transport
    Layer Security** (**TLS**) and cryptography. You should use this provider with
    a certificate authority to generate signed certificates for production workloads.
    Still, several features are very helpful in development and lab environments to
    streamline productivity.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: SSH keys
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When working with virtual machines, an everyday use case is the need to generate
    `ssh-keygen`, but Terraform has a provider with resources for this very task,
    which makes it extremely easy and convenient to encapsulate the same SSH key generation
    with the infrastructure that is going to use it. It’s a perfect tool for short-lived
    lab environments to kick the tires on, but when using this approach, you’ll need
    to lock down your Terraform state:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now that Terraform has generated your resource, you can drop it into the secrets
    manager of your choice:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding example, we drop the `private_key_openssh` value into an Azure
    Key Vault secret, allowing us to use the SSH key from the Azure portal to connect
    to the machine directly or use Azure Bastion.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '`RSA` is the most popular algorithm used for SSH keys. It is tried and true,
    but you should use a key size of at least 4,096 bits. Newer algorithms such as
    `ECDSA` and `ED25519` are also supported, but you should ensure your clients support
    these algorithms before wider adoption within your organization.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: When you generate the SSH key, you don’t need to save it to the filesystem.
    You should save it to a certificate management service such as **AWS Certificate
    Manager** (**ACM**), Azure Key Vault, or Google Cloud’s Certificate Manager.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Due to the way Terraform planning works, for Terraform to know whether or not
    the SSH key resource exists and whether your certificate manager has the resource,
    it needs to maintain critical attributes in the state file. Many of those key
    attributes are highly sensitive information, including the public and private
    keys. Therefore, securing your Terraform state’s backend will be crucial to prevent
    unauthorized access. It’s not an impossible or difficult task in its own right,
    but until you’ve got a secure backend strategy in place, this approach is probably
    good to skip for production workloads.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Certificates
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When generating a certificate, you typically need to generate a `PEM` file)
    and details about the certificate subject, including human-friendly information
    such as the organization name, physical address, and network address information
    such as domain names or IP addresses.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Terraform has a resource, `tls_cert_request`, that can generate the CSR. Like
    the `tls_private_key` resource that generates an SSH key, this resource performs
    a task a human operator would perform by using a graphical or command-line interface
    to generate the CSR. The output of this resource would then need to be passed
    to a CA to generate a signed certificate.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `foo` resource to generate the certificate locally. The CSR
    provider will attempt to process it on the local machine running Terraform.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need a private key, which you can create using the `tls_private_key`
    resource we used to generate an SSH key:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we need to generate the CSR using the `tls_cert_request` resource:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, we can generate a certificate using the private key and the CSR:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Generating CloudInit configuration
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Cloud Init** is an open source, multi-platform tool for providing startup
    configuration to cloud-hosted virtual machines. It configures the new instance
    using metadata from the cloud and user data. For example, you can set the hostname,
    set up users and groups, mount and format disks, install packages, and run custom
    scripts.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Basic usage
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, you can use data sources to generate content rather than talk to
    an external system. The `cloudinit_config` is a perfect example of this. It is
    designed with a schema to help simplify generating the sometimes-verbose Cloud-Init
    configuration file passed as input to newly created virtual machines.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Cloud-Init supports several different part types. Each type infers a different
    schema and format for passing in content, sometimes using JSON, YAML, bash scripts,
    or raw text. The full scope of what Cloud-Init can do is out of the scope of this
    book, but I’d encourage you to look into the online documentation for further
    details. I’ll cover a few everyday use cases to show how you can use your existing
    Cloud-Init knowledge and apply it while using the `cloudinit` Terraform provider:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To attach the output as user data to a new **Elastic Compute Cloud** (**EC2**)
    instance on AWS, we would use the following code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Loading external content
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you have a large amount of external content you want to download to the
    instance, you can use `x-include-url` and `x-include-once-url`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Using custom scripts
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you want to execute custom scripts stored within the Terraform module
    directory, you can use several different part types to run the scripts under other
    conditions:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '`x-shellscript`: This script will run whenever the instance is booted. That
    is, it will execute every time your instance starts up, whether it is the first
    boot after creation or a subsequent reboot.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x-shellscript-per-boot`: This is the same as `x-shellscript`. It will also
    run on every boot of the instance.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x-shellscript-per-instance`: This script will run only once per instance.
    That is, the script will run on the first boot after the instance is created but
    will not run on subsequent reboots. This part is helpful for initialization tasks
    that only need to be done once for each instance, such as setting up software
    or users that persist across reboots.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x-shellscript-per-once`: This script will run only once across all instances.
    If you create multiple instances with the same script, this script will only run
    on the first instance that boots. This part is helpful for tasks that only need
    to be done once in a set of instances, such as setting up a database or a leader
    node in a cluster.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following script, which is stored in a bash script file called
    `foo.sh` in the Terraform module’s root folder:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can embed this in a `cloudinit_config` data source to generate the user
    data we pass to a newly created virtual machine:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Cloud config files
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Cloud-Init supports a custom schema for performing various everyday tasks.
    Several different part types are supported, enabling you to include cloud config
    data in multiple formats in your Cloud-Init packages:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '`cloud-config`: This is the most commonly used content type for standard cloud-init
    YAML configuration files. You can use the `cloud-config` content type for general-purpose
    instance configuration tasks, such as setting up users and groups, managing packages,
    running commands, and writing files.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cloud-config-archive`: This content type provides multiple cloud-config parts
    in a single file. A `cloud-config-archive` file is a YAML file that contains a
    list of cloud-config parts, where each part is a map containing a filename, a
    content type, and the content itself. You should use this when applying multiple
    cloud-config files in a specific order. Their order in the list influences when
    they are applied.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cloud-config-jsonp`: This content type allows you to write **JSON with Padding**
    (**JSONP**) responses. JSONP is commonly used to bypass web browser cross-domain
    policies. You might use this content type if you’re writing a web app that needs
    to interact with a server on a different domain and uses JSONP to circumvent the
    same-origin policy.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The full capabilities of cloud config are beyond the scope of this book, but
    I encourage you to explore them in more detail through online documentation. The
    following configuration demonstrates how we can use `cloud init` to generate a
    user, a group, assign the user to the group, and set up permissions and settings
    for the machine:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can embed this in a `cloudinit_config` data source to generate the user
    data we pass to a newly created virtual machine:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Configuring DNS records
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Managing **Domain Name System** (**DNS**) using automation is critical to specific
    release strategies such as blue-green deployment. Terraform provides an extensible
    framework that can easily handle such essential configurations.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: While most cloud providers offer their own DNS services, from Amazon’s Route
    53 to Azure’s Private DNS zones, there is usually a first-party solution for managing
    DNS on the cloud of your choice. Several third-party providers for public DNS
    registrars have DNS service offerings such as Cloudflare, Akamai, GoDaddy, and
    DynDNS.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: However, because Terraform offers such an extensible foundation, managing DNS
    is not limited to public cloud platforms through their respective providers. You
    can also manage your on-premises DNS servers or any custom DNS infrastructure
    built using infrastructure as a service in your chosen public or private clouds.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `DNS` provider with any DNS server that supports either the
    secret key (`RFC 2845`) or GSS-TSIG (`RFC 3645`) authentication method.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked in depth at the utility providers that HashiCorp
    has built to help us augment our IaC solutions. We learned how to integrate with
    external systems, work with assets stored on the filesystem, and randomize and
    fill in whitespace within Terraform. These Terraform providers are incredibly
    versatile, and as you explore them more, you will find them more and more valuable.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: As you would when using other providers, always reference the provider in your
    `required_providers` block with an explicit version number. Do not implicitly
    take the latest. Other than that, resources from these providers can be embedded
    in any Terraform module. Take special care when designing reusable modules to
    ensure you have minimal provider requirements on upstream client modules, as this
    can add additional complexity to users who hope to reuse your module when it requires
    a dozen different providers to be declared!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will establish some architectural concepts we can apply
    to our IaC, no matter the cloud platform we target. After all, our IaC is only
    as good as the architecture that it defines. Therefore, we must have a sound understanding
    of the typical elements of cloud service anatomy and the mechanics of different
    computational paradigms such as virtual machines and containers. So, next, we’ll
    look at virtual machine architecture through a multi-cloud lens.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Concepts of Cloud Architecture and Automation'
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Without a solid foundation in cloud architecture and software development processes,
    the journey into Infrastructure as Code would be a futile one. Luckily, many of
    these concepts transcend cloud platforms, and once you understand the key concepts,
    you’ll be ready to apply that knowledge within the cloud of your choice—be it
    AWS, Azure, or GCP.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B21183_04.xhtml#_idTextAnchor239), *Foundations of Cloud Architecture
    – Virtual Machines and Infrastructure-as-a-Service*'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B21183_05.xhtml#_idTextAnchor278), *Beyond VMs – Core Concepts
    of Containers and Kubernetes*'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B21183_06.xhtml#_idTextAnchor330), *Connecting It All Together
    – GitFlow, GitOps, and* *CI/CD*'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
