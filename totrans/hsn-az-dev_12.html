<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Big Data Pipeline - Azure Event Hub</h1>
                </header>
            
            <article>
                
<p>Azure Event Hub is one of the best solutions for introducing an entry point with <span>almost</span> limitless throughput. It's designed for big data workloads and is able to process millions of messages per second. It offers a very simple configuration, and thanks to the available SDK, you can easily adjust it to almost any solution developed in the cloud. It also integrates natively with other Azure components, making creating a whole platform hosted in the cloud a breeze.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Working efficiently with Azure Event Hub</li>
<li>Different concepts such as publishers, partitions, throughput units, or consumer groups</li>
<li>Azure Event Hub security concepts</li>
<li>Azure Event Hub<em> </em>capture feature</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To perform the exercises in this chapter, you will need the following:</p>
<ul>
<li>Microsoft Azure subscription</li>
<li>Visual Studio 2017</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Azure Event Hub service and concepts</h1>
                </header>
            
            <article>
                
<p>Nowadays, we gather more and more data, which has to be aggregated, processed, and stored somewhere. This implies using services that can handle increasing loads, scale to growing demands, and offer the smallest latency available. All these requirements are often mentioned when building so-called big data pipelines—parts of a system designed to process as much data as possible, so it is later accessible by tools such as Hadoop, Spark, ML, AI, and so on. If you are looking for a service in Azure that can handle millions of messages per second, Azure Event Hub<em> </em>is the right choice. In this chapter, you will learn the basics of this Azure component and get familiar with messaging solutions in Azure. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Azure Event Hub concepts</h1>
                </header>
            
            <article>
                
<p>In general, Azure Event Hub<em> </em>is a simple service that is built on top of two concepts:</p>
<ul>
<li>Event publishers</li>
<li>Event processor hosts</li>
</ul>
<p>Of course, these are not the only topics we will cover here. However, before we proceed, I would like to focus a little bit on the distinction between a publisher<strong> </strong>and a processor:</p>
<ul>
<li><strong>Publisher</strong>:<strong> </strong>This is an entity that sends data to an instance of Azure Event Hub. It can use one of the two available protocols (HTTP or AMQP) and is unaware of the current Event Hub capabilities.</li>
<li><strong>Processor</strong>: An entity that reads events from Azure Event Hub<em> </em>as they become available. It uses AMQP for communication and relies on additional concepts such as consumer groups<strong> </strong>and partitions.</li>
</ul>
<p>The following shows how Azure Event Hub<em> </em>works:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/020778c9-5eea-4c0a-8286-0e047871a8a7.png" style="width:42.50em;height:12.50em;" width="635" height="186"/></p>
<p>As you can see, there are an additional two concepts mentioned here:</p>
<ul>
<li><strong>Partition</strong>: Each partition is an independent event log that stores data separately. In general, it is Event Hub's responsibility to ensure that each event sharing the same partition key is stored within the same partition in order. Of course, you can set this value by yourself—in such a scenario you have to make sure you are not overloading one specific partition.</li>
<li><strong>Consumer group</strong>: If you would like to allow separate processors to consume events separately, you have to use different consumer groups to do so. </li>
</ul>
<p>As you can see, Azure Event Hub<em> </em>does not use things such as instance topics for distributing data—instead it acts as a single event pipeline that you can read anytime with high throughput. To define this value, Event Hub uses a concept named <strong>throughput units</strong> (<strong>TU</strong>). 1 TU<strong> </strong>is defined as follows:</p>
<ul>
<li>Up to 1 MB/s or 1,000 events for ingress</li>
<li>Up to 2 MB/s or 4,096 events for egress</li>
</ul>
<div class="packt_tip">Note that Azure Event Hub<em> </em>shares TUs for all consumer groups you are using. If you have 1 TU and 5 consumer groups, the maximum egress will be divided among all consumers (so when all 5 read events at the same time, a maximum of 400 events per second will be available).</div>
<p>If you happen to exceed the available limit, Event Hub will start throttling your requests, finally returning <kbd>ServerBusyException</kbd>. This is, however, true only for incoming events—for egress you just cannot read more than the current TU value allows.</p>
<div class="packt_infobox">By default, you cannot have more than 20 TUs per Event Hub namespace. However, this is just a soft limit—you can extend it by contacting Azure support.</div>
<p>Now, let's focus a little bit on partitions. Each hub in Event Hub can have a maximum number of 32 partitions. You may wonder what this implies—in fact, this gives some additional options:</p>
<ul>
<li>Because each partition can have a corresponding consumer, by default, you can process messages in parallel using 32 consumers.</li>
<li>Because you cannot change the number of partitions after the hub's creation, you have to carefully design it at the very beginning.</li>
<li>Using the maximum number of partitions by default is not always the best option—it should reflect the number of readers you are planning to support. If you choose too many, they will start to race to acquire a lease on a partition.</li>
</ul>
<p>The following shows globally how data could be stored among different partitions within a hub:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="Images/1406bcad-2d1c-4a99-9673-8da1f54b1241.png" style="width:35.08em;height:17.50em;" width="525" height="261"/></p>
<p>As mentioned earlier, each partition can grow independently—what is more, each one has an individual offset<strong> </strong>value. What is an offset<strong> </strong>value? You could think about it as a pointer to some specific point within a log—if it stores events numbered from 1 to 10,000 and you have read 1,000, an offset<strong> </strong>value will be 1,001. In such a case, it means that a reader should start reading data from the 1,001<sup>st</sup> event.</p>
<div class="packt_infobox">In fact, offset and consumer groups are connected with each other conceptually—each consumer group has an individual offset value; that is why,by introducing it, you can read all available logs once more.</div>
<p>However, remember that to set an offset, a consumer has to perform a checkpoint. If it fails to do so, the next time it connects, it will read all the data once more. This is very important if you want to avoid processing duplicates—either you have to implement a very durable process for processing events, so you can be sure that a checkpoint will be performed even if something fails, or you need to have a mechanism for detecting duplicates.</p>
<div class="packt_tip">If you have to do so, you can easily read previous events by providing the offset<strong> </strong>value you are interested in when starting a processor.</div>
<p class="mce-root"/>
<p>The last thing to consider for now is Azure Event Hub's<em> </em>retention policy for stored events. By default (or in other words, by using the Basic<strong> </strong>tier), events can be stored only for 24 hours to be consumed; after that period, they are lost. Of course, it is possible to extend it by using the Standard tier; you will have an option to do so up to a maximum of 7 days from event retention. In general, you should avoid using this service as some kind of a standard queue or cache—its main purpose is to provide functionality for aggregating thousands of messages per second and pushing them further.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Azure Event Hub durability</h1>
                </header>
            
            <article>
                
<p>In many scenarios, Azure Event Hub<em> </em>is one of the main entry points to the system, making it a critical component that should be replicated and highly available. In this particular service, the geo-disaster recovery feature is available when selecting the standard<strong> </strong>tier and requires you to set up and configure the appropriate environment. To do so, you need to understand the following topics:</p>
<ul>
<li><strong>Alias</strong>: Instead of providing multiple connection strings, you can use an alias to make a connection with a single stable one.</li>
<li><strong>Failover</strong>: This is the process of initiating a switch between namespaces.</li>
<li><strong>Primary/secondary namespace</strong>: When using the Azure Event Hub<em> </em>geo-disaster recovery feature, you have to define which namespace is the primary and which is the secondary one. The important thing here is that you can send events to both namespaces, but the second one remains passive—that means events from an active<em> </em>namespace are not transferred.</li>
</ul>
<p>Now, to implement the feature in Event Hub, you can to do two things:</p>
<ul>
<li>Monitor your primary namespace to detect any anomalies</li>
<li>Initiate failover</li>
</ul>
<p>Of course, if a disaster occurs, you will have to create a new pairing after finishing a failover.</p>
<div class="packt_tip">You have to know the difference between outage, when there are temporary problems within a data center, and a disaster, which often means permanent damage and possible loss of data. The geo-disaster recovery feature is designed for disasters; in the case of an outage, you should implement another way of dealing with it, such as caching data locally.</div>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with Azure Event Hub</h1>
                </header>
            
            <article>
                
<p>Now that  you are familiar with some basic concepts, we can proceed and start working with a real instance of Azure Event Hub. In this section, you will learn both how to create and access Event Hub in the Azure portal and work with it using its SDK. In fact, using this service is possible both from the portal (as many Azure components seamlessly integrate with it and no additional configuration is required) and by providing custom implementations of consumers that read and process data further.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating an Azure Event Hub in the Azure portal</h1>
                </header>
            
            <article>
                
<p>To create an Azure Event Hub, we will start, as in most cases, by clicking on the <span class="packt_screen">+ Create a resource</span><strong> </strong>button. Enter <kbd>Event Hub</kbd><em> </em>and select the service from the search results. Here, you can see an example of a configuration of my Event Hub instance:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/408532ce-f5f1-44f9-b893-6cac51801016.png" style="width:20.42em;height:34.42em;" width="370" height="623"/></p>
<p>Let's globally now focus on what we actually have here:</p>
<ul>
<li><span class="packt_screen">Name</span>: This is the unique name of your Event Hub instance. Note, it has to be unique among all others supported by Azure.</li>
<li><span class="packt_screen">Pricing tier</span>: You can choose between Basic and Standard tiers. In fact, there is also one additional tier – Dedicated, which is, however, available only if you ask for it directly. The difference between Basic and Standard is quite huge in terms of capabilities and throughput; we will cover it in a second.</li>
<li><span class="packt_screen">Enable Kafka</span>: This is a new feature, which allows you to use Azure Event Hub<em> </em>as if it was an <strong>Apache Kafka</strong> instance. Thanks to that, you are able to switch to this Azure service without the need to reconfigure applications communicating with your Kafka instances.</li>
<li><span class="packt_screen">Make this namespace zone redundant</span>: If you wish, you can leverage availability zones for Event Hub and make the whole namespace zone redundant. This improves the availability of your instance of a service with no additional cost (you still have to pay for an additional instance, though). Currently, this feature is enabled for three locations – Central US, East US 2, and France Central.</li>
<li><span class="packt_screen">Subscription</span>: A subscription where an instance will be created.</li>
<li><span class="packt_screen">Resource group</span>: In which RG, an instance of Event Hub, will be created.</li>
<li><span class="packt_screen">Location</span>: In which region Azure Event Hub<em> </em>will be created.</li>
<li><span class="packt_screen">Throughput Units</span>: This setting defines the throughput of the whole namespace. In Azure, each instance of Event Hub shares available TUs between all other hubs in a namespace. You can change the value later, depending on your needs.</li>
<li><span class="packt_screen">Enable Auto-Inflate</span>: Instead of manually scaling the throughput of your namespace, you can enable Auto-Inflate. This feature scales up your namespace automatically  as the load grows. Note, however, that it will not scale it down automatically. By enabling it, you can also define  the maximum value of TUs, so you will not be charged more than you are supposed to.</li>
</ul>
<div class="packt_infobox">Remember that you are charged for each TU—that means that if you selected  the Basic<strong> </strong>tier and require 10 TUs, you will pay 9.41 EUR * 10 = 94.1 EUR per month!</div>
<p>When you click on the <span class="packt_screen">Create</span><strong> </strong>button, Azure will take care of creating an instance of Azure Event Hub<em> </em>for you.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with Azure Event Hub in the portal</h1>
                </header>
            
            <article>
                
<p>The following screenshot shows a brand-new instance of Azure Event Hub:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/b2ec64a0-7943-4741-beaf-c4a2216673a0.png" width="971" height="751"/></p>
<p>As you can see, it contains some basic info such as metrics, metadata, and access to connection strings. Of course, this is a view of a namespace—we have not created any Event Hub yet. Before we do so, I would like to focus a little on what we have available now. On the left, you can find the <span class="packt_screen">SETTINGS</span><strong> </strong>section, which contains additional features:</p>
<ul>
<li><span class="packt_screen">Shared access policies</span>: In Azure Event Hub,<em> </em>access policies have two levels—they are assigned either for a namespace or for a hub. With them, you are able to share an access key with a combination of three permissions—Manage<strong>,</strong> Listen, and Send.</li>
<li><span class="packt_screen">Scale</span>: If you feel that you need more throughput, you can go to this blade and scale a namespace up (or down if you need fewer TUs). From that screen, you can also change the tier – for example, select Standard<strong> </strong>to be able to use Auto-Inflate.</li>
<li><span class="packt_screen">Geo-recovery</span>: If you have a requirement to make your Event Hub highly available and you selected Standard<strong> </strong>tier, from this blade you will able to initiate pairing with another region.</li>
</ul>
<p>Now let's create a hub:</p>
<ol>
<li>Click on the <span class="packt_screen">Event Hubs</span><strong> </strong>blade:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/0f4bf125-2d3e-4d43-b076-90d66a9048d3.png" style="width:38.33em;height:22.17em;" width="515" height="298"/></p>
<ol start="2">
<li>Click on the <span class="packt_screen">+ Event Hub</span><strong> </strong>button to see a form that enables you to configure a new instance of a hub:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/ebcc7a02-b91e-4ad4-8850-4f2a592fa6f5.png" width="636" height="377"/></p>
<p style="padding-left: 60px;">Note that some fields are currently grayed out. This is because I used the Basic<strong> </strong>tier for this example; both <span class="packt_screen">Message Retention</span> (which enables you to extend the period an event is available to a maximum of seven days) and <span class="packt_screen">Capture<strong> </strong></span>(which will be described later) are features of the Standard<strong> </strong>tier.</p>
<ol start="3">
<li>Click on the <span class="packt_screen">Create</span><strong> </strong>button to initiate the creation of a hub.</li>
</ol>
<p style="padding-left: 60px;">Once a hub is created, you are able to click on it and access it, as shown:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/74bf99fa-ea1f-4be0-ac72-8f7e6901a73e.png" width="1170" height="831"/></p>
<p>Note that this view is a bit different from the view of a namespace; while it also contains some metadata and metrics, available additional features are limited. </p>
<div class="packt_infobox">Note that for the Basic<strong> </strong>tier, consumer groups<strong> </strong>are also unavailable. With that tier, only the default group—named <kbd>$Default</kbd>—can be used.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Developing applications with Azure Event Hub</h1>
                </header>
            
            <article>
                
<p>We created and configured our instance of Azure Event Hub<em> </em>in the Azure portal; now it is time to work with a concept I mentioned at the very beginning—Event Processor Host. In this section, you will learn:</p>
<ul>
<li>How to send events to Azure Event Hub</li>
<li>How to receive events by implementing your own Event Processor Host</li>
</ul>
<p>Before we start writing some code, however, you have to understand what really underlies such a concept. As opposed to competing consumers, where each consumer uses the same messaging channel, Azure Event Hub<em> </em>uses the idea of an Event Processor Host, which is an intelligent agent able to distribute events between different, partitioned consumers. You may wonder how this idea works when implemented; to get an understanding, here you can see a diagram of the first scenario:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/7358c913-7106-468a-8eb0-551446eebd73.png" style="width:27.00em;height:12.58em;" width="439" height="205"/></p>
<p>In this diagram, you can see that there is a single <strong>producer</strong> and four different <strong>consumers</strong>. Each consumer implements <kbd><span>IEventProcessor</span></kbd><span>—</span><span>an interface that is provided by the SDK and makes receiving events possible. Each <strong>consumer</strong> covers one <strong>partition</strong> and acquires a lease on it. Now let's check another scenario:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/ec3b8ad8-0a6d-408f-8dc7-5958735f33ac.png" style="width:25.25em;height:11.92em;" width="441" height="208"/></p>
<p>The only change here is the number of <strong>partitions</strong>—now the Event Hub has eight. Event Processor Host<strong> </strong>makes sure that the load will be distributed equally, each <strong>consumer</strong> will consume two <strong>partitions</strong>. To make things even more complicated, there is a third scenario to consider:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/8e7e7e64-56d5-4391-9cba-081f6bf19e9f.png" style="width:27.50em;height:13.00em;" width="442" height="209"/></p>
<p>This time, we have more <strong>consumers</strong> than <strong>partitions</strong> available. In that case, you will notice a situation where one <strong>consumer</strong> does not work as there is no <strong>partition</strong> it can process. There is also one more caveat in that scenario; because lease duration (the time during which a partition is attached to a specific <strong>consumer</strong>) is not infinite, at some point currently an idle <strong>consumer</strong> can expropriate others and take control over a partition. Now, when the concept of Event Processor Host<strong> </strong>is described, we can check how to write some code that can interact with Azure Event Hub. The following code is for an event producer:</p>
<pre>using System;<br/>using System.Text;<br/>using Microsoft.ServiceBus.Messaging;<br/><br/>namespace HandsOnAzure.Sender<br/>{<br/>    internal class Program<br/>    {<br/>        private const string ConnectionString = "&lt;connection-string&gt;";<br/><br/>        private static void Main()<br/>        {<br/>            var eventHubClient = EventHubClient.CreateFromConnectionString(ConnectionString);<br/><br/>            try<br/>            {<br/>                var message = Guid.NewGuid().ToString();<br/>                Console.WriteLine("{0} &gt; Sending message: {1}", DateTime.Now, message);<br/>                eventHubClient.Send(new EventData(Encoding.UTF8.GetBytes(message)));<br/>            }<br/>            catch (Exception exception)<br/>            {<br/>                Console.ForegroundColor = ConsoleColor.Red;<br/>                Console.WriteLine("{0} &gt; Exception: {1}", DateTime.Now, exception.Message);<br/>                Console.ResetColor();<br/>            }<br/><br/>            Console.ReadLine();<br/>        }<br/>    }<br/>}</pre>
<p>To use this code example, you will need a connection string. To get it, I accessed my hub instance, went to the <span class="packt_screen">Shared access policies</span><strong> </strong>blade, and created a new policy with only the <span class="packt_screen">Send</span><strong> </strong>permission:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/7a0b3a67-6501-40f6-8f0b-92eb0953bc49.png" style="width:22.33em;height:31.50em;" width="302" height="426"/></p>
<p>Now, when I execute my application, I will see that it sends events successfully:</p>
<pre>23.08.2018 11:20:50 &gt; Sending message: 1a09038b-1aeb-4729-ace0-104f26c7d376</pre>
<p>We have a producer, now we need a consumer! I created an access policy once more, this time only for <span class="packt_screen">Listen</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/f49ddcb8-e621-42f8-bece-d9a0e8ef17fe.png" style="width:22.00em;height:31.75em;" width="306" height="440"/></p>
<p>To create a consumer you will need the <kbd>Microsoft.Azure.ServiceBus.EventProcessorHost</kbd><strong> </strong>NuGet package. Once you install it, you will be able to implement <kbd><span>IEventProcessor</span></kbd> just like this:</p>
<pre>public class MyFirstEventProcessor : IEventProcessor<br/>{<br/>  private Stopwatch _checkpointStopWatch;<br/><br/>  public Task OpenAsync(PartitionContext context)<br/>  {<br/>    Console.WriteLine("SimpleEventProcessor initialized. Partition: '{0}', Offset: '{1}'", context.Lease.PartitionId, context.Lease.Offset);<br/>    _checkpointStopWatch = new Stopwatch();<br/>    _checkpointStopWatch.Start();<br/>    return Task.FromResult&lt;object&gt;(null);<br/>  }<br/><br/>  public async Task ProcessEventsAsync(PartitionContext context, IEnumerable&lt;EventData&gt; messages)<br/>  {<br/>    foreach (var eventData in messages)<br/>    {<br/>      var data = Encoding.UTF8.GetString(eventData.GetBytes());<br/>      Console.WriteLine($"Message received. Partition: '{context.Lease.PartitionId}', Data: '{data}'");<br/>    }<br/><br/>    if (_checkpointStopWatch.Elapsed &gt; TimeSpan.FromMinutes(5))<br/>    {<br/>      await context.CheckpointAsync();<br/>      _checkpointStopWatch.Restart();<br/>    }<br/>  }<br/><br/>  public async Task CloseAsync(PartitionContext context, CloseReason reason)<br/>  {<br/>    Console.WriteLine("Processor Shutting Down. Partition '{0}', Reason: '{1}'.", context.Lease.PartitionId, reason);<br/><br/>    if (reason == CloseReason.Shutdown)<br/>    {<br/>      await context.CheckpointAsync();<br/>    }<br/>  }<br/>}</pre>
<p>As you can see, it has three methods: <kbd>OpenAsync</kbd>, <kbd>ProcessEventsAsync</kbd>,<strong> </strong>and <kbd>CloseAsync</kbd>. To be able to actually use such a processor, you have to initiate the whole event processing host:</p>
<pre>using System;<br/>using Microsoft.ServiceBus.Messaging;<br/><br/>namespace HandsOnAzure.Receiver<br/>{<br/>    internal class Program<br/>    {<br/>        private const string EventHubConnectionString = "&lt;connection-string&gt;";<br/>        private const string EventHubName = "&lt;event-hub-name&gt;";<br/>        private const string StorageAccountName = "&lt;storage-account-name&gt;";<br/>        private const string StorageAccountKey = "&lt;storage-account-key&gt;";<br/><br/>        private static void Main()<br/>        {<br/>            var storageConnectionString =<br/>                $"DefaultEndpointsProtocol=https;AccountName={StorageAccountName};AccountKey={StorageAccountKey}";<br/><br/>            var eventProcessorHostName = Guid.NewGuid().ToString();<br/>            var eventProcessorHost = new EventProcessorHost(eventProcessorHostName, EventHubName, EventHubConsumerGroup.DefaultGroupName, EventHubConnectionString, storageConnectionString);<br/>            Console.WriteLine("Registering EventProcessor...");<br/><br/>            var options = new EventProcessorOptions();<br/>            options.ExceptionReceived += (sender, e) =&gt; { Console.WriteLine(e.Exception); };<br/>            eventProcessorHost.RegisterEventProcessorAsync&lt;MyFirstEventProcessor&gt;(options).Wait();<br/><br/>            Console.WriteLine("Receiving. Press enter key to stop worker.");<br/>            Console.ReadLine();<br/>            eventProcessorHost.UnregisterEventProcessorAsync().Wait();<br/>        }<br/>    }<br/>}</pre>
<p>Now when you run your application, you should be able to see incoming events.</p>
<div class="packt_infobox">Note that Event Processor Host<strong> </strong>requires you to create a Storage Account instance. It uses it to internally manage leases and offsets.</div>
<p>Here, you can see the log coming from my processor:</p>
<pre>Registering EventProcessor...<br/>Receiving. Press enter key to stop worker.<br/>MyFirstEventProcessor initialized. Partition: '4', Offset: ''<br/>MyFirstEventProcessor initialized. Partition: '9', Offset: ''<br/>MyFirstEventProcessor initialized. Partition: '11', Offset: ''<br/>MyFirstEventProcessor initialized. Partition: '8', Offset: ''<br/>Message received. Partition: '9', Data: '5e0b2a73-ca9d-418d-8d47-43c7b7feb17e'<br/>Message received. Partition: '4', Data: '1a09038b-1aeb-4729-ace0-104f26c7d376'<br/>Message received. Partition: '4', Data: '859cce28-76e1-4a68-8637-a2349d898e8b'<br/>MyFirstEventProcessor initialized. Partition: '15', Offset: ''<br/>Message received. Partition: '15', Data: '36f13819-46d6-42c9-8afe-6776264e7aab'<br/>MyFirstEventProcessor initialized. Partition: '1', Offset: ''<br/>MyFirstEventProcessor initialized. Partition: '5', Offset: ''<br/>MyFirstEventProcessor initialized. Partition: '0', Offset: ''<br/>MyFirstEventProcessor initialized. Partition: '7', Offset: ''<br/>MyFirstEventProcessor initialized. Partition: '12', Offset: ''<br/>MyFirstEventProcessor initialized. Partition: '3', Offset: ''<br/>MyFirstEventProcessor initialized. Partition: '14', Offset: ''<br/>MyFirstEventProcessor initialized. Partition: '10', Offset: ''<br/>MyFirstEventProcessor initialized. Partition: '2', Offset: ''<br/>MyFirstEventProcessor initialized. Partition: '6', Offset: ''<br/>MyFirstEventProcessor initialized. Partition: '13', Offset: ''</pre>
<p>Note how a single receiver handles all 16 partitions I used for this particular hub. Now you can check what happens if I introduce another consumer:</p>
<pre class="mce-root">Microsoft.ServiceBus.Messaging.ReceiverDisconnectedException: New receiver with higher epoch of '4' is created hence current receiver with epoch '3' is getting disconnected. If you are recreating the receiver, make sure a higher epoch is used. TrackingId:628871df00003ffd002d0cc25b7fd487_C1655342710_B13, SystemTracker:handsonazure:eventhub:handsonazurehub~2047|$default, Timestamp:8/24/2018 9:49:09 AM<br/>   at Microsoft.ServiceBus.Common.AsyncResult.End[TAsyncResult](IAsyncResult result)<br/>   at Microsoft.ServiceBus.Messaging.MessageReceiver.RetryReceiveEventDataAsyncResult.TryReceiveEnd(IAsyncResult r, IEnumerable`1&amp; messages)<br/>   at Microsoft.ServiceBus.Messaging.MessageReceiver.EndTryReceiveEventData(IAsyncResult result, IEnumerable`1&amp; messages)<br/>   at Microsoft.ServiceBus.Messaging.EventHubReceiver.&lt;ReceiveAsync&gt;b__61_1(IAsyncResult result)<br/>   at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean requiresSynchronization)<br/>--- End of stack trace from previous location where exception was thrown ---<br/>   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)<br/>   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)<br/>   at Microsoft.ServiceBus.Common.TaskHelpers.EndAsyncResult(IAsyncResult asyncResult)<br/>   at Microsoft.ServiceBus.Messaging.IteratorAsyncResult`1.&lt;&gt;c.&lt;CallTask&gt;b__24_1(TIteratorAsyncResult thisPtr, IAsyncResult r)<br/>   at Microsoft.ServiceBus.Messaging.IteratorAsyncResult`1.StepCallback(IAsyncResult result)<br/>Processor Shutting Down. Partition '0', Reason: 'LeaseLost'.</pre>
<p>As you can see, <kbd>Partition 0</kbd> has been taken by another receiver, which will start processing events from it:</p>
<pre>Registering EventProcessor...<br/>Receiving. Press enter key to stop worker.<br/>MyFirstEventProcessor initialized. Partition: '0', Offset: ''<br/>Message received. Partition: '0', Data: '3c3bb090-2e0c-4d06-ad44-1d0ad4a106a7'<br/>Message received. Partition: '0', Data: '54fed07a-a51e-4f36-8f26-f2ded2da9faa'<br/>Message received. Partition: '0', Data: '69b8b291-8407-466a-a2c1-0b33a2ef03ad'<br/>Message received. Partition: '0', Data: 'ec45d759-01bb-41db-ab51-de469ee5da55'<br/>Message received. Partition: '0', Data: 'fcf41b0e-cd6b-465a-ac20-100ba13fd6af'<br/>Message received. Partition: '0', Data: '2f05104a-c4a2-4a8f-8689-957f2dca6c71'<br/>Message received. Partition: '0', Data: '63d77b4c-584f-4db3-86d0-9f73179ccb9f'<br/>Message received. Partition: '0', Data: '03c70d22-4efa-4bd6-9c5c-f666c2922931'<br/>Message received. Partition: '0', Data: '96f4c8be-831c-415c-8aa7-0a5125458f16'<br/>Message received. Partition: '0', Data: 'af2e8a21-d9ce-4256-a8eb-73483387912c'<br/>Message received. Partition: '0', Data: '73d9f92b-686b-44d1-b01a-50c0c63426ee'<br/>Message received. Partition: '0', Data: 'bf53ea8f-dd34-405f-a6a6-0e947ce2473b'</pre>
<p>It will gradually take control of half of the available partitions until the load is balanced. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Azure Event Hub security</h1>
                </header>
            
            <article>
                
<p>We have covered some topics regarding working with and developing applications using Azure Event Hub – now it is time to learn something more about the security features of this service. In the previous part of this chapter, you used shared access policies, which are the easiest options when you want to restrict access to a hub to some predefined operations (such as listening to events, sending them, or managing Event Hub). Now I will show you something more about the security model and restricting access to the whole namespace by IP filtering.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Event publishers</h1>
                </header>
            
            <article>
                
<p>When creating an Event Hub namespace instance, you had to choose a tier – you could choose between Basic<strong> </strong>and Standard<strong> </strong>tier. Besides features such as consumer groups or message retention, Standard<strong> </strong>tier offers one more thing—the ability to create event publishers. An event publisher<strong> </strong>acts as a virtual endpoint for sending messages to a hub. In fact, it enhances security by combining an SAS token with the identity of a sender. To generate a token, you have to use the following method:</p>
<pre>public static string SharedAccessSignatureTokenProvider.GetSharedAccessSignature(string keyName, string sharedAccessKey, string resource, TimeSpan tokenTimeToLive)</pre>
<p>To execute it correctly, you will need:</p>
<ul>
<li><strong>Key name</strong>: the name of an SAS policy</li>
<li><strong>Shared access key</strong>: the key generated for a policy</li>
<li><strong>Resource</strong>: the URL to a namespace in the following format: <kbd>sb:<span>//&lt;NAMESPACE&gt;.servicebus.windows.net/&lt;EVENT_HUB_NAME&gt;/publishers/&lt;PUBLISHER_NAME&gt;</span></kbd></li>
<li><strong>Token lifetime</strong>: how long a token will be valid</li>
</ul>
<div class="packt_tip">Remember that <kbd>PUBLISHER_NAME</kbd> should be unique for each client.</div>
<p>When you generate a token, it will be in the following format:</p>
<pre>SharedAccessSignature sr=%2f%2fZvZExXejq40LO5vmRIikSpWLn9YlKMZ5cwC2Nk83%2bnE%3d.servicebus.windows.net%2fhandsonazurehub%2fpublishers%2fhandsonazurepublisher&amp;sig=UraqQnVck9O64h3pd8dcX9KdZZa2rb%2bxfR%2blyod2Ep2Q%3d&amp;se=1535279857&amp;skn=handsonazuresend</pre>
<p>To be able to actually use it, you will have to use <kbd>EventHubSender</kbd><strong> </strong>instead of <kbd>EventHubClient</kbd>:</p>
<pre>private static EventHubSender CreateSender()<br/>{<br/>  var publisher = "handsonazurepublisher";<br/>  var token = SharedAccessSignatureTokenProvider.GetSharedAccessSignature(KeyName, SASKey,<br/>    $"sb://{Namespace}.servicebus.windows.net/{HubName}/publishers/{publisher}", TimeSpan.FromHours(24));<br/>  var connectionString =<br/>    ServiceBusConnectionStringBuilder.CreateUsingSharedAccessSignature(<br/>      new Uri($"sb://{Namespace}.servicebus.windows.net"), HubName, publisher, token);<br/>  var eventHubSender = EventHubSender.CreateFromConnectionString(connectionString);<br/>  return eventHubSender;<br/>}</pre>
<p>This is because when using event publishers you can only send events—they cannot be used for other Event Hub operations. </p>
<div class="packt_tip">Note that clients, in general, should not be aware of additional features that such generated SAS tokens supply. The most important thing is that they should not be generated by them; instead, you should introduce a service in which they can ask for a full connection string and use it.</div>
<p>Now, when you have control over who or what can access Azure Event Hub, there is one more thing you can do—revoke publisher, so it cannot access a hub anymore. To do so, you will need the following methods:</p>
<pre>var nsm = NamespaceManager.CreateFromConnectionString(manageString);<br/>nsm.RevokePublisher(eventHubName, publisherId);</pre>
<p>Once you revoke a publisher, when it tries to send an event, it will receive <kbd><span>PublisherRevokedException</span></kbd><span>.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">IP filters</h1>
                </header>
            
            <article>
                
<p>It is possible to restrict access to Azure Event Hub by introducing IP filters; this feature (as shown next) allows you to secure the whole namespace by knowing which IP addresses should be rejected. By default, the IP filter is empty, that means that Event Hub accepts any connection (so this is equivalent to setting it as approve <span><kbd>0.0.0.0/0</kbd> IP address</span><span>):</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/18b13256-40f1-4c9f-b8b8-37c5c8e295f2.png" width="922" height="475"/></p>
<p>You can easily create a rule by clicking on <span class="packt_screen">+ Add IP Filter Rule</span><strong>:</strong></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/bef7ea13-87d1-40e3-a7b2-b51279992be2.png" style="width:32.42em;height:24.50em;" width="421" height="316"/></p>
<p class="mce-root"><span>When I restrict access to my computer's IP, I will get the following message when I try to send an event:</span></p>
<pre>25.08.2018 13:11:39 &gt; Sending message: 0a7dd971-6600-458c-816d-fbbbee0d81cb<br/>25.08.2018 13:11:40 &gt; Exception: Ip has been prevented to connect to the endpoint. TrackingId:9421f06c-3a1c-4e4e-8a25-fb76f1cacee6, SystemTracker:AmqpGatewayProvider, Timestamp:8/25/2018 11:11:36 AM</pre>
<p>You can choose to either restrict access from some specific IP addresses or allow a particular subset. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Azure Event Hub Capture feature</h1>
                </header>
            
            <article>
                
<p>There is one feature of Azure Event Hub that requires an individual section itself to describe it in depth. It is capture, a functionality which allows you to automatically store events using a predefined storage solution (such as Azure Storage<em> </em>or Azure Data Lake) and process it further. Unfortunately, this particular feature is often misused as its use cases are not so obvious; additionally, the way it works might sometimes be unclear. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How Azure Event Hub Capture works</h1>
                </header>
            
            <article>
                
<p>In common use cases for Event Hub, you need a <strong>producer</strong> and a <strong>consumer</strong> to fetch data and process it. Let's consider the following scenario:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/2b9ba131-0184-4ac7-a17e-72c044383b8a.png" style="width:28.17em;height:12.83em;" width="427" height="195"/></p>
<p>In this scenario, we have two consumers:</p>
<ul>
<li><strong>Consumer 1 </strong>for some generic processing</li>
<li><strong>Consumer 2 </strong>for archiving events</li>
</ul>
<p>We also introduced <strong>storage </strong>for storing a log of events. As you can see, the downside of that solution is the fact that you need to maintain both consumers—two code bases and two instances. With Event Hub Capture, the scenario we are considering now will change a little bit:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/0c77fb58-5762-4e54-8616-b16b9ae0e3b1.png" style="width:28.58em;height:14.67em;" width="438" height="225"/></p>
<p>Now we no longer require additional consumers as it will be Event Hub Capture's responsibility to store data. You may wonder how storing data works in that scenario; in general, it is based on a time window which, when it ends, triggers a capture of data.</p>
<p>It can be easily described using an example. Suppose you set your time window to 10 minutes; after that interval, all data which is stored within Azure Event Hub<em> </em>will be captured and stored inside a selected database using <strong>Apache Avro</strong> format.</p>
<div class="packt_tip">An important thing is Capture pricing; it costs <span>€ 0.085/hour per each throughput unit. It means that if you have<em> </em>Azure Event Hub<em> </em>with 1 TU and Capture enabled, you will pay 80 EUR instead of 18 EUR. With 2 TUs, it will be 160 EUR instead of 37 EUR.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Enabling Event Hub Capture</h1>
                </header>
            
            <article>
                
<p>Event Hub Capture is a feature of an individual Event Hub, not the whole namespace. To enable it, you need to go to your hub and search for the <span class="packt_screen">Capture</span><strong> </strong>blade.</p>
<p>Now, when you enable Capture, you will see a full configuration of the feature, which  we will try to understand now:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/399ae79d-86b8-4f6f-b110-49bd745ec7b0.png" style="width:51.50em;height:34.00em;" width="977" height="645"/></p>
<p>As you can see, it contains the following settings:</p>
<ul>
<li><strong>Time window</strong>: It defines after how many minutes a capture is triggered.</li>
<li><strong>Size window</strong>: Alternatively, it is possible to trigger a capture after a window reaches the size limit. Whether it triggers because of time or size depends on which one reaches the limit first.</li>
<li><strong>Capture Provider</strong>: You can choose between Azure Storage<em> </em>and Azure Data Lake Store. The choice is yours as it does not imply any additional features or limits.</li>
<li><strong>Azure Storage Container/Data Lake Store</strong>: Depending on your choice, you will have to choose a different kind of a container.</li>
<li><strong>Capture file name format</strong>: This Event Hub feature has a predefined set of formats for how your files will be stored. Unfortunately, it is impossible to make it fully customizable as it must contain the <kbd>{Namespace}</kbd>, <kbd>{EventHub}</kbd>, <kbd>{PartitionId}</kbd>, <kbd>{Year}</kbd>, <kbd>{Month}</kbd>, <kbd>{Day}</kbd>, <kbd>{Hour}</kbd>, <kbd>{Minute}</kbd> and <kbd>{Second}</kbd> fields.</li>
</ul>
<p>Once you are satisfied with your choice, you can save the form. After some time, your producers send data; you will see that data from each partition is captured:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/51b60ba0-5c07-4830-b41d-5aba485cf9d4.png" style="width:36.92em;height:29.92em;" width="674" height="546"/> </p>
<p>What is more, they contain files with data in the following format:</p>
<pre><span>Objavro.codecnullavro.schema{"type":"record","name":"EventData","namespace ":"Microsoft.ServiceBus.Messaging","fields":[{"name":"SequenceNumber","type ":"long"},{"name":"Offset","type":"string"},{"name":"EnqueuedTimeUtc","type ":"string"},{"name":"SystemProperties","type":{"type":"map","values":["long ","double","string","bytes"]}},{"name":"Properties","type":{"type":"map","v alues":["long","double","string","bytes","null"]}},{"name":"Body","type":[" null","bytes"]}]}</span></pre>
<p>This data can be easily converted to JSON:</p>
<pre>{<br/>  "definitions" : {<br/>    "record:Microsoft.ServiceBus.Messaging.EventData" : {<br/>      "type" : "object",<br/>      "required" : [ "SequenceNumber", "Offset", "EnqueuedTimeUtc", "SystemProperties", "Properties", "Body" ],<br/>      "additionalProperties" : false,<br/>      "properties" : {<br/>        "SequenceNumber" : {<br/>          "type" : "integer",<br/>          "minimum" : -9223372036854775808,<br/>          "maximum" : 9223372036854775807<br/>        },<br/>        "Offset" : {<br/>          "type" : "string"<br/>        },<br/>        "EnqueuedTimeUtc" : {<br/>          "type" : "string"<br/>        },<br/>        "SystemProperties" : {<br/>          "type" : "object",<br/>          "additionalProperties" : {<br/>            "oneOf" : [ {<br/>              "type" : "integer",<br/>              "minimum" : -9223372036854775808,<br/>              "maximum" : 9223372036854775807<br/>            }, {<br/>              "type" : "number"<br/>            }, {<br/>              "type" : "string"<br/>            }, {<br/>              "type" : "string",<br/>              "pattern" : "^[\u0000-y]*$"<br/>            } ]<br/>          }<br/>        },<br/>        "Properties" : {<br/>          "type" : "object",<br/>          "additionalProperties" : {<br/>            "oneOf" : [ {<br/>              "type" : "integer",<br/>              "minimum" : -9223372036854775808,<br/>              "maximum" : 9223372036854775807<br/>            }, {<br/>              "type" : "number"<br/>            }, {<br/>              "type" : "string"<br/>            }, {<br/>              "type" : "string",<br/>              "pattern" : "^[\u0000-y]*$"<br/>            }, {<br/>              "type" : "null"<br/>            } ]<br/>          }<br/>        },<br/>        "Body" : {<br/>          "oneOf" : [ {<br/>            "type" : "null"<br/>          }, {<br/>            "type" : "string",<br/>            "pattern" : "^[\u0000-y]*$"<br/>          } ]<br/>        }<br/>      }<br/>    }<br/>  },<br/>  "$ref" : "#/definitions/record:Microsoft.ServiceBus.Messaging.EventData"<br/>}</pre>
<p>You will find more about Avro in the <em>Further reading</em><strong> </strong>section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you have learned many things about Azure Event Hub—how it works, what partitions are for, and how to leverage more advanced features such as consumer groups or the Event Hub Capture feature. I strongly encourage you to give it a try and play a little bit with this Azure service as it is a powerful tool for processing thousands of events per second. It is also pretty simple to use and does not require much time to get started.</p>
<p>In the next chapter, you will learn about another service for processing many events, and additionally analyze and transform them in near real time—Azure Stream Analytics.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What are consumer groups for?</li>
<li>How many events can be processed in one second using 1 TU?</li>
<li>How many partitions should you use for each Event Hub?</li>
<li>Are TUs assigned to a namespace or a particular Event Hub?</li>
<li>What are the three different permissions you can assign to an access policy?</li>
<li>Can an event publisher listen to incoming events using its token?</li>
<li>What happens if you have more consumers than partitions?</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>The full documentation on Event Hub disaster recovery of can be found here: <a href="https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-geo-dr">https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-geo-dr</a>.</p>
<p>Apache Avro Documentation can be found here: <a href="https://avro.apache.org/">https://avro.apache.org/</a>.</p>


            </article>

            
        </section>
    </div>



  </body></html>