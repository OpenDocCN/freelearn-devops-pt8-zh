<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Application Orchestration</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>Application orchestration provides a few key features for the Puppet language. Application orchestration extends the concept of exported resources to a more targeted application, allowing the sharing of configuration items between nodes. Additionally, this feature provides a way to order Puppet runs to ensure that dependency nodes have finished building or converging prior to the nodes that require them. Application orchestration allows us to entangle multiple nodes together in an ordered run. Most importantly, configuration updates are not randomly applied on check-in, but are applied in a particular, ordered pattern.</span></p>
<div class="packt_infobox"><span>Application Orchestration only works in Puppet Enterprise. Puppet open source users can use the language constructs, but ordered runs are provided by Puppet Enterprise.</span></div>
<p class="p">Application orchestration has three new language constructs we'll need to use to create ordered runs that share information automatically with each other:</p>
<ul>
<li><strong>Application definitions</strong>: An end-to-end description of a collection of components describing an entire application stack</li>
<li><strong>Application components</strong>: An individual component of an entire application stack</li>
<li><strong>Service resources</strong>: Resources designed to share information across application components</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application definition</h1>
                </header>
            
            <article>
                
<p>Application definitions look a lot like a defined resource, but are also similar to a traditional Puppet profile. They describe a collection of components that make an entire system, but unlike profiles, are not tied down to a single node. These application definitions describe a configured state of one or more nodes, broken down by application components. </p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Application definitions will resemble defined types, with a few key differences:</p>
<ul>
<li>They are titled <kbd>application</kbd> instead of <kbd>define</kbd>.</li>
<li>Each resource must be name spaced within the module:</li>
</ul>
<pre style="padding-left: 60px"># Application used instead of 'class' or 'define'<br/>application 'example' (<br/>  $var,<br/>) {<br/><br/># app1 exports its database configuration items<br/>  example::app1 {<br/>    config =&gt; $var,<br/>    export =&gt; Database['app1'],<br/>  }<br/><br/># app2 both imports the previous database and exports its own type: Application<br/>  example::app2 {<br/>    config  =&gt; $var,<br/>    consume =&gt; Database['app1'],<br/>    export  =&gt; Application['app1'],<br/>  }</pre>
<p>What is important to note is that each resource in this application can be tied to an entirely different node with our site definition. We can also use our site definitions to pass in those shared configuration items, represented by <kbd>$var</kbd> in the preceding code:</p>
<pre>#/etc/puppetlabs/code/environments/production/manifests/site.pp<br/>site {<br/>  example {'app1':<br/>    var =&gt; 'config',<br/>    nodes =&gt; {<br/>      Node['database'] =&gt; [ Example::App1['app']],<br/>      Node['app']      =&gt; [ Example::App2['app']],<br/>    }<br/>  }<br/>}</pre>
<div class="packt_tip">Inside of the node's hash, notice that the <kbd>Node</kbd> object and <kbd>Example::App&lt;X&gt;</kbd> objects are capitalized.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application components</h1>
                </header>
            
            <article>
                
<p>Application components provide the individual pieces of the multi-node application. They are most often defined types (for reusability), but can also consist of classes or even native resources, such as files, in very simple cases. Application components are created by the <kbd>export</kbd>, <kbd>consume</kbd>, or <kbd>require</kbd> metaparameters that are used in an application declaration. </p>
<p>Application components are written as general classes or defined types. They follow the same autoload format as all other Puppet code. The manifest for <kbd>example::app2</kbd> would still be located at <kbd>manifests/example/app2.pp</kbd>. <span>Application components can explicitly list the values they export and consume in their individual manifests by placing an additional statement at the bottom of the manifests:</span></p>
<pre>class example::app2 (<br/># $db_host is provided by the consume of the Database<br/>  $db_host,<br/>) {<br/># Any resources, defined types or class calls in a regular manifest would be placed here.<br/>}<br/># Note that the consume is outside of the class declaration<br/>Example::App2 consumes Database {<br/>  db_host =&gt; $host,<br/>}<br/># Note that the produces is outside of both the class declaration, and above consume<br/>Example::App2 produces Http {<br/>  host =&gt; $::fqdn,<br/>  port =&gt; '80',<br/>}</pre>
<p>In the preceding sample, <kbd>$db_host</kbd> is a value that could be passed to any resource in the manifest. Rather than passing it via Hiera or Puppet DSL, we instead consume that value from the <kbd>host</kbd> parameter provided by another application. We also export the node's own FQDN and hostname, so that follow-on applications can use those values to point at the web service created by <kbd>example::app2</kbd>. <kbd>Database</kbd> and <kbd>Http</kbd> are both service resources, describing information that's shared between applications.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Service resources</h1>
                </header>
            
            <article>
                
<p>Service resources are environment-wide information pools filled and viewed by application components. Service resources work like exported resources, providing information about other nodes from PuppetDB. The uniqueness of service resources is found in their building of  dependencies between nodes. Service resources are declared as Puppet types, written in Ruby. Providers are optional, and allow for exported resource availability tests.</p>
<p>Service resource types provide a framework of information that can be stored and transported via application orchestration's <kbd>consume</kbd> and <kbd>export</kbd> metaparameters. The type is required for a service resource, and declares the structure of the information using Ruby code. They are always stored in modules at <kbd>lib/puppet/type/&lt;resource&gt;.rb</kbd>, and will be sent to all nodes in an environment when deployed, but will not be actioned upon by nodes not using the resource. The following sample type could encompass the database resource exported by <kbd>app1</kbd> and consumed by <kbd>app2</kbd>:</p>
<pre><span>#lib/puppet/type/database.rb<br/><br/># Notice the :is_capability =&gt; true. This property creates this type as an<br/># environment-wide service, to be produced and consumed.<br/>Puppet::Type.newtype </span><span class="hljs-symbol">:database</span><span>, </span><span class="hljs-symbol">:is_capability</span><span> =&gt; </span><span class="hljs-literal">true</span><span> </span><span class="hljs-keyword">do<br/>  newparam :host<br/>end</span></pre>
<p><span>This simple example provides us with a way to export information about a database, specifically the <kbd>host</kbd> parameter. This can be filled with the <kbd>export</kbd> parameter, and read with the <kbd>consume</kbd> parameter.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modeling applications</h1>
                </header>
            
            <article>
                
<p>For the rest of this chapter, we'll be focusing on building a simple and a more complex example of an orchestrated application. Our first phase will be to create a single database and a single webserver.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application and database</h1>
                </header>
            
            <article>
                
<p>In our first example, we'll export information from a database on one node, and retrieve it on a WordPress instance. This simple example will allow us to deploy nodes in pairs, and ensure that the database is built before the web application that relies on it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dependencies</h1>
                </header>
            
            <article>
                
<p>Before we begin writing our code, we'll want to check the Forge for relevant supported or open source modules. WordPress requires an SQL server and a web host, which we'll provide via Apache HTTPD. Before we begin, we'll want to install the following modules from the Forge:</p>
<ul>
<li><kbd>puppetlabs-mysql</kbd></li>
<li><kbd>puppetlabs-apache</kbd></li>
<li><kbd>hunner-wordpress</kbd></li>
</ul>
<pre><strong>[root@pe-puppet-master myapp]# puppet module install puppetlabs-mysql</strong><br/><strong>Notice: Preparing to install into /etc/puppetlabs/code/environments/production/modules ...</strong><br/><strong>Notice: Downloading from https://forgeapi.puppet.com ...</strong><br/><strong>Notice: Installing -- do not interrupt ...</strong><br/><strong>/etc/puppetlabs/code/environments/production/modules</strong><br/><strong>└─┬ puppetlabs-mysql (v5.4.0)</strong><br/><strong>  ├── puppet-staging (v3.2.0)</strong><br/><strong>  ├── puppetlabs-stdlib (v4.25.1)</strong><br/><strong>  └── puppetlabs-translate (v1.1.0)</strong><br/><strong>[root@pe-puppet-master myapp]# puppet module install puppetlabs-apache</strong><br/><strong>Notice: Preparing to install into /etc/puppetlabs/code/environments/production/modules ...</strong><br/><strong>Notice: Downloading from https://forgeapi.puppet.com ...</strong><br/><strong>Notice: Installing -- do not interrupt ...</strong><br/><strong>/etc/puppetlabs/code/environments/production/modules</strong><br/><strong>└─┬ puppetlabs-apache (v3.1.0)</strong><br/><strong>  ├── puppetlabs-concat (v4.2.1)</strong><br/><strong>  └── puppetlabs-stdlib (v4.25.1)</strong><br/><strong>[root@pe-puppet-master myapp]# puppet module install hunner-wordpress</strong><br/><strong>Notice: Preparing to install into /etc/puppetlabs/code/environments/production/modules ...</strong><br/><strong>Notice: Downloading from https://forgeapi.puppet.com ...</strong><br/><strong>Notice: Installing -- do not interrupt ...</strong><br/><strong>/etc/puppetlabs/code/environments/production/modules</strong><br/><strong>└─┬ hunner-wordpress (v1.0.0)</strong><br/><strong>  ├── puppetlabs-concat (v4.2.1)</strong><br/><strong>  ├── puppetlabs-mysql (v5.4.0)</strong><br/><strong>  └── puppetlabs-stdlib (v4.25.1)</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Build</h1>
                </header>
            
            <article>
                
<p>We'll write our code from the top down. It helps to think about the end state of the code as we're learning it, and learn the pieces that enable it along the way.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Node declaration</h1>
                </header>
            
            <article>
                
<p>Our first piece will be the node declaration. This will go in our <kbd>site.pp</kbd>, and each application will go under a specific site call. In the following sample, notice the following:</p>
<ul>
<li>All apps are declared in the top-level <kbd>site{}</kbd> declaration.</li>
<li><kbd>myapp {'myapp': }</kbd> is just one possible app that can go in <kbd>site.pp</kbd>. We could have another beneath it called <kbd>myapp.{'myapp2': }</kbd> is inside of the site, and has a second standalone instance of this application.</li>
<li><kbd>Node['&lt;nodename&gt;']</kbd> and <kbd>Myapp::&lt;app&gt;</kbd> are capitalized.</li>
<li>I can still use the <kbd>site.pp</kbd> for other things, as indicated by the classification of the Puppet Master, as follows:</li>
</ul>
<pre style="padding-left: 60px">site {<br/>  myapp { 'myapp':<br/>      nodes =&gt; {<br/>        Node['mysql'] =&gt; [ Myapp::Db['myapp']],<br/>        Node['appserver'] =&gt; [ Myapp::Web['myapp']],<br/>        Node['haproxy'] =&gt; [ Myapp::Lb['myapp']],<br/>    }<br/>  }<br/>}<br/><br/>node 'puppetmaster' {<br/>  include role::puppetmaster<br/>}<br/><br/># To keep the sample simple, firewalls have been disabled on all machines.<br/>service {'firewalld': ensure =&gt; stopped }<br/>service {'iptables':  ensure =&gt; stopped }</pre>
<p>This particular configuration will ensure that the <kbd>mysql</kbd> node gets the database, <kbd>appserver</kbd> will get WordPress, and HAProxy will get the load balancer configuration.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application declaration</h1>
                </header>
            
            <article>
                
<p>In the previous example, we called a resource called <kbd>myapp</kbd> just under the <kbd>site{}</kbd> declaration. This manifest, located in the <kbd>myapp</kbd> module at <kbd>manifests/init.pp</kbd>, declares the application, describes some overridable parameters, and orchestrates applications using the <kbd>export</kbd> and <kbd>consume</kbd> metaparameters. Notice the following:</p>
<ul>
<li>On the first line, the application <kbd>myapp</kbd> is used in place of a class or define.</li>
<li><kbd>myapp::db</kbd> exports to the SQL resource.</li>
<li><kbd>myapp::web</kbd> consumes the SQL resource.</li>
<li><kbd>myapp::db</kbd> will run before <kbd>myapp::web</kbd>, because <kbd>myapp::web</kbd> has a dependency via consume.</li>
<li>We use the <kbd>$name</kbd> variable so that each component receives <kbd>myapp</kbd> as a name, taken from <kbd>myapp {'myapp':}</kbd>:</li>
</ul>
<pre style="padding-left: 60px">application myapp (<br/>  $dbuser = 'wordpress',<br/>  $dbpass = 'w0rdpr3ss!',<br/>  $webpath = '/var/www/wordpress',<br/>  $vhost = 'appserver',<br/>) {<br/>  myapp::db { $name:<br/>    dbuser =&gt; $dbuser,<br/>    dbpass =&gt; $dbpass,<br/>    export =&gt; Sql[$name],<br/>  }<br/>  myapp::web { $name:<br/>    webpath =&gt; $webpath,<br/>    consume =&gt; Sql[$name],<br/>    vhost =&gt; $vhost,<br/>  }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DB service resource</h1>
                </header>
            
            <article>
                
<p>We'll build our own custom DB type for this simple use case. It will allow us to pass values from our database to our WordPress application. This simple example ensures that the type is named <kbd>db</kbd>, marks it as a service resource, and provides five available parameters to the database service resource. This file is placed in <kbd>lib/puppet/type/db.rb</kbd>:</p>
<pre># lib/puppet/type/db.rb<br/># Adding :is_capability to the custom type marks the resources as service resources<br/>Puppet::Type.newtype :db, :is_capability =&gt; true do<br/>  newparam :name, :is_namevar =&gt; true<br/>  newparam :user<br/>  newparam :password<br/>  newparam :port<br/>  newparam :host<br/>end</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application components</h1>
                </header>
            
            <article>
                
<p>Our <kbd>myapp</kbd> defined type will make use of the <kbd>db</kbd> resource we created in the previous section, passing four values to PuppetDB, directly from <kbd>myapp::db</kbd>. We'll use this manifest to build a MySQL server, and provide information to our WordPress instance on another node. Notice the following in the example:</p>
<ul>
<li>A regular defined type, with standard Puppet DSL. We build a server and a database to support the app.</li>
<li><kbd>$host</kbd> is not used in the manifest, but is passed along to the produced <kbd>Db</kbd> resource.</li>
<li><kbd>Myapp::Db produces Db</kbd> is placed directly after the define, in the same manifest:</li>
</ul>
<pre style="padding-left: 60px">define myapp::db (<br/>  $dbuser,<br/>  $dbpass,<br/>  $host = $::fqdn,<br/>){<br/><br/>  class {'::mysql::server':<br/>    root_password =&gt; 'Sup3rp@ssword!',<br/>    override_options =&gt; {<br/>      'mysqld' =&gt; {<br/>        'bind-address' =&gt; '0.0.0.0'<br/>      }<br/>    }<br/>  }<br/><br/>  mysql::db { $name:<br/>    user =&gt; $dbuser,<br/>    password =&gt; $dbpass,<br/>    host =&gt; '%',<br/>    grant =&gt; ['ALL PRIVILEGES'],<br/>  }<br/>}<br/>Myapp::Db produces Db {<br/>  dbuser =&gt; $dbuser,<br/>  dbpass =&gt; $dbpass,<br/>  dbhost =&gt; $host,<br/>  dbname =&gt; $name,<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p><kbd>Myapp::Web</kbd> is a defined type meant to consume the <kbd>Db</kbd> produced by <kbd>Myapp::Db</kbd>. It installs the required packages, installs Apache, builds a vhost, and deploys WordPress to the <kbd>docroot</kbd> of the vhost. Notice the following:</p>
<ul>
<li><kbd>$vhost</kbd> and <kbd>$webpath</kbd> were provided by application <kbd>myapp</kbd>.</li>
<li><kbd>$dbuser</kbd>, <kbd>$dbpass</kbd>, <kbd>$dbhost</kbd>, and <kbd>$dbname</kbd> are provided by the consumes <kbd>Db {}</kbd>.</li>
<li>Because our manifest uses the values <kbd>dbpass</kbd>, <kbd>dbhost</kbd>, <kbd>dbuser</kbd> and <kbd>dbname</kbd>, our mappings don't need to be declared. The following example will directly declare variables:</li>
</ul>
<pre style="padding-left: 60px">define myapp::web (<br/>  $webpath,<br/>  $vhost,<br/>  $dbuser,<br/>  $dbpass,<br/>  $dbhost,<br/>  $dbname,<br/>  ) {<br/><br/>    package {['php',<br/>              'mysql',<br/>              'php-mysql',<br/>              'php-gd'<br/>             ]:<br/>      ensure =&gt; installed,<br/>    }<br/><br/>    class {'apache':<br/>      default_vhost =&gt; false<br/>    }<br/><br/>    include ::apache::mod::php<br/><br/>    apache::vhost { $vhost:<br/>      port =&gt; '80',<br/>      docroot =&gt; $webpath,<br/>      require =&gt; File[$webpath],<br/>    }<br/><br/>    file { $webpath:<br/>      ensure =&gt; directory,<br/>      owner =&gt; 'apache',<br/>      group =&gt; 'apache',<br/>      require =&gt; Package['httpd'],<br/>    }<br/><br/>    class { '::wordpress':<br/>      db_user =&gt; $dbuser,<br/>      db_password =&gt; $dbpass,<br/>      db_host =&gt; $dbhost,<br/>      db_name =&gt; $dbname,<br/>      create_db =&gt; false,<br/>      create_db_user =&gt; false,<br/>      install_dir =&gt; $webpath,<br/>      wp_owner =&gt; 'apache',<br/>      wp_group =&gt; 'apache',<br/>    }<br/>  }<br/>Myapp::Web consumes Db { }</pre>
<p>We can use the preceding collection of code to order and deploy our multitier application. Our current module should resemble the following:</p>
<pre>myapp<br/>├── lib<br/>│   └── puppet<br/>│       └── type<br/>│           ├── sql.rb<br/>├── manifests<br/>    ├── db.pp<br/>    ├── init.pp<br/>    └── web.pp</pre>
<p>We can then use the <kbd>puppet app</kbd> and <kbd>puppet job</kbd> commands to deploy our application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploy</h1>
                </header>
            
            <article>
                
<p>To view applications listed in our <kbd>site.pp</kbd>, we can use the command <kbd>puppet app show</kbd>. This command reads our main manifest, and lists all applications and their components. In the following example, from the preceding code, we're deploying <kbd>Myapp::Db</kbd> to <kbd>mysql</kbd> and <kbd>Myapp::Web</kbd> to <kbd>appserver</kbd>:</p>
<div class="packt_tip"><span>You may receive a message when running this lab: <em>Application management is disabled. To enable it, set `app-management: true` in the orchestrator service config</em>. To fix this, you can log into the Puppet Enterprise console, enter the Puppet Master configuration and change the value of <kbd>puppet_enterprise::profile::master::app-management</kbd> to <kbd>true</kbd>.</span></div>
<p class="mce-root"/>
<p class="mce-root"/>
<pre><strong>[root@pe-puppet-master manifests]# puppet app show</strong><br/><strong>Myapp[myapp]</strong><br/><strong>    Myapp::Db[myapp] =&gt; mysql</strong><br/><strong>      + produces Sql[myapp]</strong><br/><strong>    Myapp::Web[myapp] =&gt; appserver</strong><br/><strong>        consumes Sql[myapp]</strong></pre>
<p>To simulate a deployment, we can use the <kbd>puppet job plan</kbd> command. We give it both an <kbd>application</kbd> and <kbd>environment</kbd> flag to let application orchestrator know which version of <kbd>site.pp</kbd> to use. This command primarily shows ordering, and you can see in the following results that <kbd>mysql</kbd> will be configured before <kbd>appserver</kbd>:</p>
<pre><strong>[root@pe-puppet-master manifests]# puppet job plan --application Myapp --environment production</strong><br/><br/><strong>+-------------------+------------+</strong><br/><strong>| Environment | production |</strong><br/><strong>| Target | Myapp |</strong><br/><strong>| Concurrency Limit | None |</strong><br/><strong>| Nodes | 2 |</strong><br/><strong>+-------------------+------------+</strong><br/><br/><strong>Application instances: 1</strong><br/><strong>  - Myapp[myapp]</strong><br/><br/><strong>Node run order (nodes in level 0 run before their dependent nodes in level 1, etc.):</strong><br/><strong>0 -----------------------------------------------------------------------</strong><br/><strong>mysql</strong><br/><strong>    Myapp[myapp] - Myapp::Db[myapp]</strong><br/><br/><strong>1 -----------------------------------------------------------------------</strong><br/><strong>appserver</strong><br/><strong>    Myapp[myapp] - Myapp::Web[myapp]</strong><br/><br/><strong>Use `puppet job run --application 'Myapp' --environment production` to create and run a job like this.</strong><br/><strong>Node catalogs may have changed since this plan was generated.</strong></pre>
<p>By switching from <kbd>puppet job plan</kbd> to <kbd>puppet job show</kbd>, we actually deploy our code in an ordered fashion. The run first takes place on the <kbd>mysql</kbd> server, which produces information that will be consumed by the <kbd>appserver</kbd> node. This run ensures that the necessary components are fully deployed before attempting to deploy applications that depend on them:</p>
<pre><strong>Use `puppet job run --application 'Myapp' --environment production` to create and run a job like this.</strong><br/><strong>Node catalogs may have changed since this plan was generated.</strong><br/><strong>[root@pe-puppet-master manifests]# puppet job run --application 'Myapp' --environment production</strong><br/><strong>Starting deployment ...</strong><br/><br/><strong>+-------------------+------------+</strong><br/><strong>| Job ID | 8 |</strong><br/><strong>| Environment | production |</strong><br/><strong>| Target | Myapp |</strong><br/><strong>| Concurrency Limit | None |</strong><br/><strong>| Nodes | 2 |</strong><br/><strong>+-------------------+------------+</strong><br/><br/><strong>Application instances: 1</strong><br/><strong>  - Myapp[myapp]</strong><br/><br/><strong>Node run order (nodes in level 0 run before their dependent nodes in level 1, etc.):</strong><br/><strong>0 -----------------------------------------------------------------------</strong><br/><strong>mysql</strong><br/><strong>    Myapp[myapp] - Myapp::Db[myapp]</strong><br/><br/><strong>1 -----------------------------------------------------------------------</strong><br/><strong>appserver</strong><br/><strong>    Myapp[myapp] - Myapp::Web[myapp]</strong><br/><br/><strong>New job created: 8</strong><br/><strong>Started puppet run on mysql ...</strong><br/><strong>Finished puppet run on mysql - Success!</strong><br/><strong>    Resource events: 0 failed 4 changed 32 unchanged 0 skipped 0 noop</strong><br/><strong>    Report: https://pe-puppet-master/#/run/jobs/8/nodes/mysql/report</strong><br/><strong>Started puppet run on appserver ...</strong><br/><strong>Finished puppet run on appserver - Success!</strong><br/><strong>    Resource events: 0 failed 3 changed 130 unchanged 0 skipped 0 noop</strong><br/><strong>    Report: https://pe-puppet-master/#/run/jobs/8/nodes/appserver/report</strong><br/><br/><strong>Success! 2/2 runs succeeded.</strong></pre>
<p>We've now deployed a very simple ordered application. Our database will be fully up and running before the configuration of our <kbd>wordpress</kbd> server. In the next example, we'll allow for multiple <kbd>wordpress</kbd> servers and multiple load balancers to provide scaling to our application.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a load balancer and providing horizontal scaling</h1>
                </header>
            
            <article>
                
<p>In many cases, we want our applications to scale horizontally. Building more nodes allows us to serve more customers. This will be a complete rewrite of the previous application, also incorporating <kbd>puppetlabs/app_modeling</kbd> from the Forge. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dependencies</h1>
                </header>
            
            <article>
                
<p>To provide new capabilities, we'll need to grab the <kbd>puppetlabs-haproxy</kbd> module and the <kbd>puppetlabs/app_modeling</kbd> module from the Forge. If you're using a <kbd>Puppetfile</kbd>, simply add them to the <kbd>Puppetfile</kbd>. In the following example, I am manually installing these dependencies on an existing master:</p>
<pre><strong>[root@pe-puppet-master myapp]# puppet module install puppetlabs-haproxy</strong><br/><strong>Notice: Preparing to install into /etc/puppetlabs/code/environments/production/modules ...</strong><br/><strong>Notice: Downloading from https://forgeapi.puppet.com ...</strong><br/><strong>Notice: Installing -- do not interrupt ...</strong><br/><strong>/etc/puppetlabs/code/environments/production/modules</strong><br/><strong>└─┬ puppetlabs-haproxy (v2.1.0)</strong><br/><strong>  ├── puppetlabs-concat (v4.2.1)</strong><br/><strong>  └── puppetlabs-stdlib (v4.25.1)</strong><br/><strong>[root@pe-puppet-master myapp]# puppet module install puppetlabs/app_modeling</strong><br/><strong>Notice: Preparing to install into /etc/puppetlabs/code/environments/production/modules ...</strong><br/><strong>Notice: Downloading from https://forgeapi.puppet.com ...</strong><br/><strong>Notice: Installing -- do not interrupt ...</strong><br/><strong>/etc/puppetlabs/code/environments/production/modules</strong><br/><strong>└─┬ puppetlabs-app_modeling (v0.2.0)</strong><br/><strong> └── puppetlabs-stdlib (v4.25.1)</strong></pre>
<p>We now have the capability to build <kbd>haproxy</kbd> nodes and new app orchestration features via <kbd>app_modeling</kbd>.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Build</h1>
                </header>
            
            <article>
                
<p>We'll begin at the <kbd>site.pp</kbd> again, and model our application from the endpoint. I have added two additional service lines that ensure that firewalls are disabled for the purpose of this lesson. We could consider using <kbd>puppetlabs/firewall</kbd> to manage our firewall as well, and even produce and consume FQDNs for our firewall. In the following sample, you will notice a few things:</p>
<ul>
<li>We're passing a <kbd>dbpass</kbd> variable to the application. This could be stored in Hiera and encrypted with EYAML.</li>
<li>We have two <kbd>wordpress</kbd> nodes and two <kbd>haproxy</kbd> nodes that each have their own unique name in the <kbd>appserver</kbd>:</li>
</ul>
<pre># For the purposes of this demo, the next two lines can be used to ensure firewalls<br/># are off for all CentOS nodes.<br/><br/>service {'iptables': ensure =&gt; stopped }<br/>service {'firewalld': ensure =&gt; stopped }<br/><br/>site {<br/>  myapp { 'myapp':<br/>    dbpass =&gt; 'rarypass',<br/>    nodes =&gt; {<br/>      Node['mysql']       =&gt; [ Myapp::Db['myapp']],<br/>      Node['wordpress']   =&gt; [ Myapp::Web['myapp-1']],<br/>      Node['wordpress-2'] =&gt; [ Myapp::Web['myapp-2']],<br/>      Node['haproxy']     =&gt; [ Myapp::Lb['myapp-1']],<br/>      Node['haproxy-2']   =&gt; [ Myapp::Lb['myapp-2']],<br/>    }<br/>  }<br/>}</pre>
<p>After our application is declared, we can model our <kbd>init.pp</kbd> to declare the entire application. There is a lot going on in this application, so note the following:</p>
<ul>
<li>Five variables are made available, and the <kbd>db</kbd> variables are used in both the <kbd>DB</kbd> and the <kbd>App</kbd>.</li>
<li><kbd>Myapp::Db</kbd> produces a database.</li>
<li><kbd>Myapp::Web</kbd> consumes a database and produces an HTTP service resource.</li>
<li>We use the <kbd>collect_component_titles</kbd> function from <kbd>puppetlabs/app_modeling</kbd> to provide an array that we can iterate over. We're collecting the nodes via <kbd>$nodes</kbd> that are attached to <kbd>Myapp::Web</kbd> and <kbd>Myapp::Lb</kbd>. These values are named <kbd>allwebs</kbd> and <kbd>alllbs</kbd>.</li>
<li>We use a map function from <kbd>puppetlabs/stdlib</kbd> against <kbd>$allwebs</kbd>. In this map function, we turn each node name into the value <kbd>Http["web-${wordpress_name}"]</kbd>, where <kbd>$wordpress_name</kbd> is the name of each node attached to the <kbd>Myapp::Web</kbd> application. We use this value as our export on each <kbd>MyApp::Web</kbd> declaration.</li>
<li>We provide the value of <kbd>$http (Http["web-${wordpress_name}"])</kbd> back to the array of <kbd>$https</kbd>, so that we can use these values on the load balancer.</li>
<li>Our load balancer uses an each statement in place of a map statement, because we don't need to transform any of this data:</li>
</ul>
<pre style="padding-left: 60px">application myapp (<br/>  $dbuser = 'wordpress',<br/>  $dbpass = 'w0rdpr3ss!',<br/>  $dbname = 'wordpress',<br/>  $webpath = '/var/www/wordpress',<br/>  $webport = '80'<br/>) {<br/><br/>  myapp::db { $name:<br/>    dbuser =&gt; $dbuser,<br/>    dbpass =&gt; $dbpass,<br/>    dbname =&gt; $dbname,<br/>    export =&gt; Database["db-${name}"],<br/>  }<br/><br/># This section can be confusing, but here is essentially what's going on<br/># $allwebs is an array full of every node assigned to Myapp::Web in our application<br/># $https takes that $allwebs array of every node, creates a service resource,<br/># adds myapp::web to each node providing values for that service resource, and then<br/># returns all transformed service resource names back to the array.<br/><br/># We're transforming each node listed in our site.pp into an array of Http[&lt;nodename&gt;]<br/># resource calls. And on each node we'll apply our defined type inside of the<br/># same map.<br/><br/>  $allwebs = collect_component_titles($nodes, Myapp::Web)<br/><br/>  $https = $allwebs.map |$wordpress_name| {<br/><br/>    $http = Http["web-${wordpress_name}"]<br/><br/>    myapp::web { "$wordpress_name":<br/>      dbuser =&gt; $dbuser,<br/>      dbpass =&gt; $dbpass,<br/>      dbname =&gt; $dbname,<br/>      webport =&gt; $webport,<br/>      webpath =&gt; $webpath,<br/>      consume =&gt; Database["db-${name}"],<br/>      export =&gt; $http,<br/>    }<br/><br/>    $http<br/><br/>  }<br/><br/># We'll use an each statement here instead of a map, because we don't need<br/># any Load balancer values returned. They're the end of the chain. Our each<br/># statement covers each node, and $https from before is used to add nodes<br/># to the load balancer<br/><br/>  $alllbs = collect_component_titles($nodes, Myapp::Lb)<br/><br/>  $alllbs.each |$load_balancer| {<br/><br/>    myapp::lb { "${load_balancer}":<br/>      balancermembers =&gt; $https,<br/>      require =&gt; $https,<br/>      port =&gt; '80',<br/>      balance_mode =&gt; 'roundrobin',<br/>    }<br/><br/>  }<br/><br/>}</pre>
<p>Our <kbd>myapp::db</kbd> produces a MySQL server, and a single database meant to serve our application. We use the values of <kbd>dbuser</kbd>, <kbd>dbpass</kbd>, and <kbd>dbname</kbd> from our application at <kbd>init.pp</kbd>. Pay special attention to the produces line, using the <kbd>app_modeling</kbd> service resource for databases at the bottom of the manifest:</p>
<ul>
<li>Produces a host from the FQDN of the machine to be consumed by the web application.</li>
<li>Produces a port which is not used by our web manifest, but provides an availability test to our application orchestration nodes. The application orchestration for the web will not trigger until the node can reach a database at the FQDN on port <kbd>3306</kbd>. Without this declaration, it will default to <kbd>5432</kbd>, which is the default port of a postgres server:</li>
</ul>
<pre style="padding-left: 60px">define myapp::db (<br/>  $dbuser,<br/>  $dbpass,<br/>  $dbname,<br/>){<br/><br/>  class {'::mysql::server':<br/>    root_password =&gt; 'Sup3rp@ssword!',<br/>    override_options =&gt; {<br/>      'mysqld' =&gt; {<br/>        'bind-address' =&gt; '0.0.0.0'<br/>      }<br/>    }<br/>  }<br/><br/>  mysql::db { $dbname:<br/>    user =&gt; $dbuser,<br/>    password =&gt; $dbpass,<br/>    host =&gt; '%',<br/>    grant =&gt; ['ALL'],<br/>  }<br/>}<br/># This produces line is producing 2 values: host and port. We'll use host directly<br/># on Myapp::Web, but the port designator is used to pass the Resource Type test for<br/># Database using puppetlabs/app_modeling. Without the port, the test will fail to find<br/># the upstream Database and won't finish the agent run.<br/>Myapp::Db produces Database {<br/>  host =&gt; $::fqdn,<br/>  port =&gt; '3306',<br/><br/>}</pre>
<p>Our <kbd>Myapp::Web</kbd> call will make use of five variables from our initial application, but receive its database host from the consumed resources. Pay attention to the following:</p>
<ul>
<li>The value for <kbd>$dbhost</kbd> is filled by consuming the database. At the bottom, we explicitly map the value of <kbd>$dbhost</kbd> to the consumed <kbd>$host</kbd> value in the <kbd>Myapp::Web</kbd> consumes <kbd>Myapp::Db</kbd>.</li>
<li>We pass <kbd>$dbhost</kbd>, provided by the consume to class <kbd>wordpress</kbd>, providing an automatic connection to a remote DB.</li>
<li><kbd>Myapp::Web</kbd> produces an HTTP resource that provides host, port, IP, and status codes. We'll use the host, port, and IP for our load balancer, but the <kbd>status_codes</kbd> is another availability test to ensure that the website served by the <kbd>haproxy</kbd> is up with a status code of <kbd>302</kbd> or <kbd>200</kbd>:</li>
</ul>
<pre style="padding-left: 60px">define myapp::web (<br/>  $webpath,<br/>  $webport,<br/>  $dbuser,<br/>  $dbpass,<br/>  $dbhost,<br/>  $dbname,<br/>  ) {<br/><br/>    package {['php','mysql','php-mysql','php-gd']:<br/>      ensure =&gt; installed,<br/>    }<br/><br/>    class {'apache':<br/>      default_vhost =&gt; false<br/>    }<br/><br/>    include ::apache::mod::php<br/><br/>    apache::vhost { $::fqdn:<br/>      port =&gt; $webport,<br/>      docroot =&gt; $webpath,<br/>      require =&gt; [File[$webpath]],<br/>    }<br/><br/>    file { $webpath:<br/>      ensure =&gt; directory,<br/>      owner =&gt; 'apache',<br/>      group =&gt; 'apache',<br/>      require =&gt; Package['httpd'],<br/>    }<br/><br/>    class { '::wordpress':<br/>      db_user =&gt; $dbuser,<br/>      db_password =&gt; $dbpass,<br/>      db_host =&gt; $dbhost,<br/>      db_name =&gt; $dbname,<br/>      create_db =&gt; false,<br/>      create_db_user =&gt; false,<br/>      install_dir =&gt; $webpath,<br/>      wp_owner =&gt; 'apache',<br/>      wp_group =&gt; 'apache',<br/>    }<br/>  }<br/>Myapp::Web consumes Database {<br/>  dbhost =&gt; $host,<br/>}<br/>Myapp::Web produces Http {<br/>  host =&gt; $::clientcert,<br/>  port =&gt; $webport,<br/>  ip =&gt; $::networking['interfaces']['enp0s8']['ip'],<br/>  # Like the port parameter in the Database provider, we'll need to send the status_codes<br/>  # flag to the Http provider to ensure we don't only accept a 302 status code.<br/>  # A new wordpress application sends status code 200, so we'll let it through as well.<br/>  status_codes =&gt; ['302','200'],<br/>}</pre>
<p><kbd>Myapp::Lb</kbd> doesn't actually consume or export any resources. We build a <kbd>haproxy::listen</kbd> service, and then for every <kbd>balancermember</kbd>, we import the aforementioned values. In our application declaration, we ran each statement against every member of the <kbd>$https</kbd> array, and the following code transforms that data into a relevant load balancer. We take the host, port, and IP produced from every <kbd>myapp::web</kbd>, and add it as a member to our <kbd>haproxy::listen</kbd>:</p>
<pre>define myapp::lb (<br/>  $balancermembers,<br/>  String $ipaddress = '0.0.0.0',<br/>  String $balance_mode = 'roundrobin',<br/>  String $port = '80',<br/>) {<br/><br/>  include haproxy<br/><br/>  haproxy::listen {"wordpress-${name}":<br/>    collect_exported =&gt; false,<br/>    ipaddress =&gt; $::networking['interfaces']['enp0s8']['ip'],<br/>    mode =&gt; 'http',<br/>    options =&gt; {<br/>      'balance' =&gt; $balance_mode,<br/>    },<br/>    ports =&gt; $port,<br/>  }<br/><br/>  $balancermembers.each |$member| {<br/>    haproxy::balancermember { $member['host']:<br/>      listening_service =&gt; "wordpress-${name}",<br/>      server_names =&gt; $member['host'],<br/>      ipaddresses =&gt; $member['ip'],<br/>      ports =&gt; $member['port'],<br/>    }<br/>  }<br/><br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploy</h1>
                </header>
            
            <article>
                
<p>Deploying our new applications uses the same commands as before. We'll use <kbd>puppet app show</kbd> to provide a list of nodes with ordering. You'll see that our single DB produces a database; each webapp uses that database and produces an HTTP service resource, which is finally consumed by each load balancer:</p>
<pre><strong>[root@pe-puppet-master manifests]# puppet app show</strong><br/><strong>Myapp[myapp]</strong><br/><strong>    Myapp::Db[myapp] =&gt; mysql</strong><br/><strong>      + produces Database[db-myapp]</strong><br/><strong>    Myapp::Web[myapp-1] =&gt; appserver</strong><br/><strong>      + produces Http[web-myapp-1]</strong><br/><strong>        consumes Database[db-myapp]</strong><br/><strong>    Myapp::Web[myapp-2] =&gt; appserver2</strong><br/><strong>      + produces Http[web-myapp-2]</strong><br/><strong>        consumes Database[db-myapp]</strong><br/><strong>    Myapp::Lb[myapp-1] =&gt; haproxy</strong><br/><strong>        consumes Http[web-myapp-1]</strong><br/><strong>        consumes Http[web-myapp-2]</strong><br/><strong>    Myapp::Lb[myapp-2] =&gt; haproxy2</strong><br/><strong>        consumes Http[web-myapp-1]</strong><br/><strong>        consumes Http[web-myapp-2]</strong></pre>
<p>Before we launch our application, we can run a <kbd>puppet job plan</kbd> to get an idea of what ordering will look like during our run:</p>
<pre><strong>[root@pe-puppet-master manifests]# puppet job plan --application Myapp --environment production</strong><br/><br/><strong>+-------------------+------------+</strong><br/><strong>| Environment | production |</strong><br/><strong>| Target | Myapp |</strong><br/><strong>| Concurrency Limit | None |</strong><br/><strong>| Nodes | 5 |</strong><br/><strong>+-------------------+------------+</strong><br/><br/><strong>Application instances: 1</strong><br/><strong>  - Myapp[myapp]</strong><br/><br/><strong>Node run order (nodes in level 0 run before their dependent nodes in level 1, etc.):</strong><br/><strong>0 -----------------------------------------------------------------------</strong><br/><strong>mysql</strong><br/><strong>    Myapp[myapp] - Myapp::Db[myapp]</strong><br/><br/><strong>1 -----------------------------------------------------------------------</strong><br/><strong>wordpress</strong><br/><strong>    Myapp[myapp] - Myapp::Web[myapp-1]</strong><br/><strong>wordpress2</strong><br/><strong>    Myapp[myapp] - Myapp::Web[myapp-2]</strong><br/><br/><strong>2 -----------------------------------------------------------------------</strong><br/><strong>haproxy</strong><br/><strong>    Myapp[myapp] - Myapp::Lb[myapp-1]</strong><br/><strong>haproxy2</strong><br/><strong>    Myapp[myapp] - Myapp::Lb[myapp-2]</strong><br/><br/><strong>Use `puppet job run --application 'Myapp' --environment production` to create and run a job like this</strong></pre>
<p>Finally, we run our application and see MySQL configured first, then our <kbd>wordpress</kbd> instances, followed by the load balancers. Thanks to the service resources provided by <kbd>puppetlabs/app_modeling</kbd>, we also know that our database is actively seen before the <kbd>wordpress</kbd> servers, and that our <kbd>wordpress</kbd> servers are producing 302 status codes prior to the load balancers being configured:</p>
<pre><strong>[root@pe-puppet-master production]# puppet job run --application Myapp --environment production --verbose</strong><br/><strong>Starting deployment ...</strong><br/><br/><strong>+-------------------+------------+</strong><br/><strong>| Job ID | 42 |</strong><br/><strong>| Environment | production |</strong><br/><strong>| Target | Myapp |</strong><br/><strong>| Concurrency Limit | None |</strong><br/><strong>| Nodes | 5 |</strong><br/><strong>+-------------------+------------+</strong><br/><br/><strong>Application instances: 1</strong><br/><strong> - Myapp[myapp]</strong><br/><br/><strong>Node run order (nodes in level 0 run before their dependent nodes in level 1, etc.):</strong><br/><strong>0 -----------------------------------------------------------------------</strong><br/><strong>mysql</strong><br/><strong> Myapp[myapp] - Myapp::Db[myapp]</strong><br/><br/><strong>1 -----------------------------------------------------------------------</strong><br/><strong>wordpress</strong><br/><strong> Myapp[myapp] - Myapp::Web[myapp-1]</strong><br/><strong>wordpress-2</strong><br/><strong> Myapp[myapp] - Myapp::Web[myapp-2]</strong><br/><br/><strong>2 -----------------------------------------------------------------------</strong><br/><strong>haproxy</strong><br/><strong> Myapp[myapp] - Myapp::Lb[myapp-1]</strong><br/><strong>haproxy-2</strong><br/><strong>    Myapp[myapp] - Myapp::Lb[myapp-2]</strong><br/><br/><strong>New job created: 42</strong><br/><strong>Started puppet run on mysql ...</strong><br/><strong>Finished puppet run on mysql - Success!</strong><br/><strong>    Resource events: 0 failed 9 changed 27 unchanged 0 skipped 0 noop</strong><br/><strong>    Report: https://pe-puppet-master/#/run/jobs/42/nodes/mysql/report</strong><br/><strong>Started puppet run on wordpress-2 ...</strong><br/><strong>Started puppet run on wordpress ...</strong><br/><strong>Finished puppet run on wordpress-2 - Success!</strong><br/><strong>    Resource events: 0 failed 81 changed 66 unchanged 0 skipped 0 noop</strong><br/><strong>    Report: https://pe-puppet-master/#/run/jobs/42/nodes/wordpress-2/report</strong><br/><strong>Finished puppet run on wordpress - Success!</strong><br/><strong>    Resource events: 0 failed 81 changed 66 unchanged 0 skipped 0 noop</strong><br/><strong>    Report: https://pe-puppet-master/#/run/jobs/42/nodes/wordpress/report</strong><br/><strong>Started puppet run on haproxy-2 ...</strong><br/><strong>Started puppet run on haproxy ...</strong><br/><strong>Finished puppet run on haproxy - Success!</strong><br/><strong>    Resource events: 0 failed 4 changed 30 unchanged 0 skipped 0 noop</strong><br/><strong>    Report: https://pe-puppet-master/#/run/jobs/42/nodes/haproxy/report</strong><br/><strong>Finished puppet run on haproxy-2 - Success!</strong><br/><strong>    Resource events: 0 failed 4 changed 30 unchanged 0 skipped 0 noop</strong><br/><strong>    Report: https://pe-puppet-master/#/run/jobs/42/nodes/haproxy-2/report</strong><br/><br/><strong>Success! 5/5 runs succeeded.</strong><br/><strong>Duration: 58 sec</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned how to order our applications using application orchestration. This builds upon the fundamental knowledge we learned when writing Puppet code, and even when using exported resources. As we build more applications and objects to configure, we'll need to make sure that our Puppet Master is available to service all these nodes.</p>
<p>In the next chapter, we'll discuss scaling Puppet Enterprise both horizontally and vertically.</p>


            </article>

            
        </section>
    </body></html>