- en: Chapter 8. Maintaining Systems Using Chef and Puppet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining consistent systems using scheduled convergence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Chef encrypted data bags and Hiera-eyaml with Puppet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Chef Vault encryption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing and manipulating system information with Ohai
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating application deployment (a WordPress example)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a TDD workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning for the worse – train to rebuild working systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've previously seen how to automate systems with code and how to properly
    test this code. Now we're ready for prime time; there's a whole set of features,
    constraints, and objectives to be properly set. We'll want to isolate environments
    such as dev, staging, and production. We'll need our infrastructure code to stay
    consistent without our intervention. Security and confidentiality will start becoming
    an issue, and maybe those passwords and secret keys should not be stored in clear
    text at all. After a few months, our automated infrastructure will grow into a
    large number of managed nodes, and it will become critical to have coherent behaviour
    according to systems profiles—we'll need to gather and process system information.
    We'll eventually end up deploying web applications directly from Chef. To keep
    a high level of quality while our code base gets more and more complex, we'll
    switch to the **Test-Driven Development** (**TDD**) approach for our workflow.
    And finally, we'll make sure we're always ready to redeploy any part of the infrastructure
    at any time (think of a disaster).
  prefs: []
  type: TYPE_NORMAL
- en: All recipes are based on Chef. However, when possible, we'll try to show how
    things work similarly with Puppet, Chef's direct alternative.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining consistent systems using scheduled convergence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once initially deployed and configured, it's hardly imaginable to let our systems
    be manually updated afterwards by logging in to each host and launching the `chef-client`
    command. Systems maintained with Chef have the opportunity to be converged at
    a predetermined time, either through a `chef-client` daemon or a cron job. We'll
    go through both these options.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Chef DK installation on the workstation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working Vagrant installation on the workstation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Chef code (optionally) from either [Chapter 6](ch06.html "Chapter 6. Fundamentals
    of Managing Servers with Chef and Puppet"), *Fundamentals of Managing Servers
    with Chef and Puppet*, [Chapter 7](ch07.html "Chapter 7. Testing and Writing Better
    Infrastructure Code with Chef and Puppet"), *Testing and Writing Better Infrastructure
    Code with Chef and Puppet*, or any custom Chef code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We recommend that you create a cookbook, different from other cookbooks, dedicated
    to configuring the underlying host. Let''s call this cookbook `common`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To configure the Chef client, there''s an official cookbook aptly named `chef-client`.
    Let''s declare a `cookbook` requirement to it, specifically to `Berksfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To the `common/metadata.rb` file, add the dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Using the Chef client as a daemon
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The documentation tells us that including the default recipe will automatically
    detect the host platform and configure `chef-client` accordingly to run as a daemon.
    Here are the steps to enable `chef-client`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following to `recipes/default.rb`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install the dependencies using Berkshelf:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now upload the `common` cookbook with all its dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `common` cookbook to the host `run-list`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On the target host, launch the Chef client one last time to make it deploy
    itself as a service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The logs seem pretty optimistic, but let''s double-check the daemon is really
    running on the host:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `chef-client` service is indeed enabled and running!
  prefs: []
  type: TYPE_NORMAL
- en: Tweaking the convergence interval time
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Interesting enough, we see that the interval is introduced every 1,800 seconds
    (30 minutes). What if we want a different convergence interval, say, every 900
    seconds (15 minutes)? Let''s transform the `default.rb` recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Bump the version in `metadata.rb`, upload the new version, wait for the new
    `chef-client` execution, or launch it yourself to save some time. The `systemd`
    unit is now updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Our system is now configured to converge every 15 minutes with a controlled
    variation of 300 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We highly suggest that you include this `common` cookbook in every new host
    deployment process so they could all be automatically configured to converge at
    a predetermined interval.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Chef client as a cron
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Under certain circumstances, we might not want to run the Chef client as a
    daemon (such as memory or security requirements). So luckily, we can simply fall
    back to a simple method that is based on a cron. Let''s transform the default
    `recipe.rb` recipe to match this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Upload this cookbook version using Berkshelf and execute `chef-client` on the
    target host. See root''s `crontab` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: By default, it's executing `chef-client` every four hours with, in this case,
    a `69` seconds delay to avoid every node from hammering the Chef server at the
    same time.
  prefs: []
  type: TYPE_NORMAL
- en: Tweaking the Chef cron job
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If converging every four hours is not enough for you and you would like to
    converge every 15 minutes, like we did with the daemon in the `default.rb` recipe,
    here''s what you need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Upload the cookbook and run `chef-client` (or wait for the next scheduled run).
    The interval is now set to run every 15 minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With Puppet, the agent can also run as a service or a cron.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command is used to enable the service mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this mode, the Puppet agent will apply the configuration every 30 minutes
    by default. This delay can be changed in `/etc/puppetlabs/puppet.conf`. Here is
    an example to reduce this delay to five minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the Puppet agent as a cron, we need to declare a Puppet cron resource
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The generated `crontab` file is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the Puppet agent will run every hour. The `splay` option is
    used to introduce a random delay before the run itself, and this delay cannot
    exceed 60 minutes (the value of the `splaylimit` option). This is particularly
    useful when a lot of nodes are connected to the same Puppet server in order to
    spread the Puppet agent's requests in time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, if there are many nodes in your infrastructure, you should create
    a module containing these Puppet resources and include it for each node. Based
    on our previous Vagrant-based LAMP setup, let''s create a local module with a
    single file, namely `module/baseconfig/manifests/init.pp`, with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can define the requested mode from the main manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If there is any future change between `service` versus `cron`, our `baseconfig`
    module will remove the configuration for the previous mode.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `chef-client` cookbook source at [https://github.com/chef-coo](https://github.com/chef-coo)[kbooks/chef-client](http://kbooks/chef-client)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Puppet cron resource at [https://docs.puppet.com/puppet/4.8/types/cron.html](https://docs.puppet.com/puppet/4.8/types/cron.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A classic organization has a minimum of two environments in which the infrastructure
    is run: development and production. Very often, a lot of environments are seen,
    such as staging, testing, alpha or beta. It''s entirely up to the organization
    to model the infrastructure according to its needs, and the complexity can grow
    very quickly. The good news is that Chef helps a lot in mapping this model to
    the infrastructure. There''s a set of information that will be different in two
    distinct environments, such as cookbook versions or attributes, and Chef makes
    it as easy as possible to manage these environments. By default, nodes without
    an environment set will run in a `_default` environment.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll see how to create different environments, how to set
    nodes (both existing and new) in a dedicated environment, how to set cookbook
    constraints, and finally how to override the attributes in each environment.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Chef DK installation on the workstation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working Vagrant installation on the workstation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Chef code (optionally) from [Chapter 6](ch06.html "Chapter 6. Fundamentals
    of Managing Servers with Chef and Puppet"), *Fundamentals of Managing Servers
    with Chef and Puppet*, [Chapter 7](ch07.html "Chapter 7. Testing and Writing Better
    Infrastructure Code with Chef and Puppet"), *Testing and Writing Better Infrastructure
    Code with Chef and Puppet*, or any custom Chef code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Chef environments live in a folder named `environments` at the root of `chef-repo`.
    If the folder doesn''t exist, create it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Creating a production environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create a production environment, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a `production` environment in a `production.rb` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is the simplest environment possible; it does nothing. Upload it to the
    Chef server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'List the available remote environments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We see we have two environments available: `production` and `_default`.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting an environment to a node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To set an already existing node to this new `production` environment, execute
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Bootstrapping a node with an environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we''re bootstrapping a node with the `knife bootstrap` command, we can start
    in the required environment right from the beginning (using an user named `vagrant`
    like the previous examples):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Fixing cookbook versions for an environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s say our production systems are running a perfectly stable `mysite` cookbook
    in version 0.3.1, but we want to try a new feature in the development infrastructure
    in the 0.4.0 version of the same cookbook. As every cookbook version can live
    together, each environment can call its own version. The `production.rb` file
    would contain the following for the `production` environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `development.rb` file would contain the following for the development environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'A Chef environment file may contain many cookbook constraints, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Overriding attributes for an environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each environment can override any value, and, in Chef, it''s the highest level
    of override. Nothing else can override a value set for an environment. So, if
    we simply want to override the value of the `sitename` attribute to `production.rb`,
    it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the environment from a recipe
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The node's environment is available from any recipe through the `node.chef_environment`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'So if our wish is to create a file that would display the environment inside
    which the node is running, we would need to create a template like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With Puppet, environments are located in distinct directories on the Puppet
    server. You probably noticed this in [Chapter 6](ch06.html "Chapter 6. Fundamentals
    of Managing Servers with Chef and Puppet"), *Fundamentals of Managing Servers
    with Chef and Puppet*; we created the code in the `/etc/puppetlabs/code/environments/production`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: This is because the default Puppet environment is `production`. Other environments,
    for example `test`, should be created under `/etc/puppetlabs/code/environments/`.
  prefs: []
  type: TYPE_NORMAL
- en: Manual environment creation in the Puppet server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s start with samples from [Chapter 6](ch06.html "Chapter 6. Fundamentals
    of Managing Servers with Chef and Puppet"), *Fundamentals of Managing Servers
    with Chef and Puppet*, and try creating a new environment, namely `test`. On the
    Puppet server, we just need to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Node environment selection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On the node side, the environment to use can be controlled using `--environment`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To use this environment as the default one, without using `--environment`,
    we can configure it in `/etc/puppetlabs/puppet/puppet.conf` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Getting the environment from manifests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As for Chef, we can get the name of the running environment from any manifest.
    This is done by using the `$environment` variable, which is set by the Puppet
    server.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, let''s modify our `index.php` file (`manifests/site.pp`),
    both in `production` and `test`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now switch between `test` and `production` and see the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The dynamic way – r10k
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We edited the environments and code directly in the Puppet master, which is
    not recommended. Fortunately, r10k (which we already used in [Chapter 6](ch06.html
    "Chapter 6. Fundamentals of Managing Servers with Chef and Puppet"), *Fundamentals
    of Managing Servers with Chef and Puppet*, to install modules) can be used to
    create environments from a Git repository. Each branch from the Git repository
    will be checked out into a distinct directory and will be available as an environment.
    This feature is dynamic: each new branch added to the Git repository will be deployed
    by r10k.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's try it from our workstation. Until now, the job of the shared folder of
    our Vagrant setup was to map the relative directory `puppetcode` to `/etc/puppetlabs/code/environments/production`
    in the `puppet.pomes.pro` box. We are about to use multiple environments, so we
    need to change the mapping to `/etc/puppetlabs/code/`.
  prefs: []
  type: TYPE_NORMAL
- en: We need a Git repository with two branches, `production` and `test`, with all
    of the previous code. An example is available at [https://github.com/ppomes/r10k_sample.git](https://github.com/ppomes/r10k_sample.git).
  prefs: []
  type: TYPE_NORMAL
- en: 'The r10k tool needs a global configuration file, which must be created at the
    same level as our Vagrantfile, with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s use r10k:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Both branches from the Git repository have been deployed, and we can now fire
    up Vagrant and play with our boxes and branches.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The r10k tool also takes care of the `Puppetfile` file in each branch, as we
    already saw in [Chapter 6](ch06.html "Chapter 6. Fundamentals of Managing Servers
    with Chef and Puppet"), *Fundamentals of Managing Servers with Chef and Puppet*,
    and deploys external modules, if any.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Chef environment documentation at [https://docs.chef.io/environments.html](http://://docs.chef.io/environments.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Puppet's r10k at [https://github.com/puppetlabs/r10k](https://github.com/puppetlabs/r10k)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Chef encrypted data bags and Hiera-eyaml with Puppet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some information in data bags can be safely stored in the Chef server in plain
    text, but under some circumstances, sensitive information might be safer if encrypted.
    Companies might not like production API keys, private keys, or similar sensitive
    content to be stored in plain text on the Chef server or on third-party services,
    such as GitHub. We'll see how to encrypt and decrypt data in the command line
    and from inside a Chef recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Chef DK installation on the workstation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working Vagrant installation on the workstation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Chef code (optionally) from [Chapter 6](ch06.html "Chapter 6. Fundamentals
    of Managing Servers with Chef and Puppet"), *Fundamentals of Managing Servers
    with Chef and Puppet*, [Chapter 7](ch07.html "Chapter 7. Testing and Writing Better
    Infrastructure Code with Chef and Puppet"), *Testing and Writing Better Infrastructure
    Code with Chef and Puppet*, or any custom Chef code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our goal is to create a configuration file containing our AWS credentials for
    the `us-east-1` region, and it''s not acceptable that you store the credentials
    in clear text on the Chef server. We''d like to use a data bag, as it can be encrypted:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a data bag folder `aws` to store the credentials for the `us-east-1`
    region:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the data bag on the Chef server while we''re at it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside this `aws` data bag folder, create a sample `us-east-1.json` file containing
    the credentials:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is the standard procedure for a normal data bag. If we upload it now as
    is, it won't be encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting data bags with a shared secret
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The solution to use an encrypted data bag is to send it encrypted from our
    workstation. The encryption is done through a shared secret, the secret being
    either a file or a string. Let''s use the string `s3cr3t` as an encryption key
    (weak). To simply send the encrypted version of the data bag, let''s use the encryption
    feature of the `knife` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If we request the data without providing a decryption key, we''ll get the encrypted
    data from the Chef server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks like we got what we wanted: data is stored encrypted on the Chef server!'
  prefs: []
  type: TYPE_NORMAL
- en: 'As it may not be a secure move to store unencrypted data bags on version control
    systems, such as Git, we can ask for a JSON-formatted encrypted version, such
    as the following, and redirect the output to a JSON file for storage purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This might be the content you'd like to store on Git!
  prefs: []
  type: TYPE_NORMAL
- en: Accessing an encrypted data bag in the CLI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To access unencrypted data from the knife CLI, the process is as easy as encrypting
    data—pass the shared secret as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now we have access to our data but in an unencrypted form.
  prefs: []
  type: TYPE_NORMAL
- en: Using an encrypted data bag from a recipe
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that the data is safely stored on the Chef server, how do we access it
    from inside a Chef recipe? Let''s say our objective is to create a file named
    `/etc/aws/credentials` that will contain the unencrypted value from the encrypted
    version on the Chef server. The final file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To do so, create a new recipe named `aws` inside the `mysite` cookbook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't forget to bump the cookbook version and environment constraints accordingly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start by creating the `/etc/aws` folder using the `directory` resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here''s a `templates/aws.erb` ERB template file for our destination, namely
    `/etc/aws/credentials`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We see the template is expecting the `aws_region`, `aws_access_key`, and `aws_secret_key`
    variables. Let''s write the code to inject these values to the `aws.rb` recipe.
    To begin with, let''s access our encrypted data bag item `us-east-1` from the
    `aws` data bag, using the inline shared secret `s3cr3t`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: All of this information can be set as attributes if we like. If the file method
    is chosen for the shared secret, the final argument will be the path to the secret
    key file to decrypt the data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let''s create the template, writing the decrypted credentials to the `/etc/aws/credentials`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here we are! The Chef server is now safely storing encrypted data. For added
    security, it's better to not hardcode the shared key—use the key file that is
    sent separately (but this creates an added layer of complexity in the deployment
    system).
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While using Puppet, it is a good practice to store the credentials and site
    information in Hiera, as we saw in [Chapter 6](ch06.html "Chapter 6. Fundamentals
    of Managing Servers with Chef and Puppet"), *Fundamentals of Managing Servers
    with Chef and Puppet*. Using `hiera-eyaml`, it is possible to encrypt sensitive
    data. Using our previous LAMP setup with Vagrant, let's try to encrypt the root
    password for MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the Puppet server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need to install a new backend for Hiera. We have not discussed a lot about
    Hiera yet, and it''s time to do so. Hiera is used to store data out of manifests,
    and is based on a hierarchy to look up data. A default configuration is provided
    with the Puppet server installation and is located at `/etc/puppetlabs/puppet/hiera.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here, a `yaml` backend is defined, allowing us to use `yaml` files in the `hieradata`
    directory of our environments. Then, a hierarchy is defined. Puppet will first
    try to look up data in a `yaml` file with the name matching the name of the client
    certificate (that is, the FQDN node) and located under the `nodes` subdirectory.
    If no data is found, Puppet will try to look up a `common.yaml` file.
  prefs: []
  type: TYPE_NORMAL
- en: With `hiera-eyaml`, we need to declare a new backend to look up data in encrypted
    files. This backend is `eyaml`, and by default, we will look for files with the
    `.eyaml` extension. This backend relies on a key pair to read data, so we need
    to generate these keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, a Puppet module, named `puppet/hiera`, exists to handle all of
    this for us. So we just need to add it to `Puppetfile` with its dependencies (do
    not forget to run `r10k puppetfile install`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'With this module, it is now very easy to prepare the Puppet server using the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This piece of code will:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare a service resource for the Puppet server. This is needed by the `puppet/hiera`
    module (see parameter `master_service`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the `eyaml` backend in the Puppet server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the Hiera configuration in order to use this backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate the private and public keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restart the Puppet server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private and public keys will be respectively placed in `/etc/puppetlabs/puppet/keys/private_key.pkcs7.pem`
    and `/etc/puppetlabs/puppet/keys/public_key.pkcs7.pem`.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the workstation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To prepare the workstation, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create and edit encrypted data, we need `eyaml`. Let''s install it using
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s copy the keys from the Puppet server and store them in a `keys` folder
    under `$HOME`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For security reasons, it is a good idea to restrict access to the private key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need an `eyaml` configuration file, located in `~/.eyaml/config.yaml`,
    with this content (do not forget to adjust the path of your `$HOME` directory):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are now ready to encrypt sensitive data.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the MySQL root password
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From the command line, `eyaml` can encrypt values. Here is a session example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `eyaml` backend is looking for files with the `.eyaml` extension,
    we just need to create a `hieradata/nodes/web.pomes.pro.eyaml` file with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `eyaml` has a very handy feature—the `edit` mode—allowing us to create
    and edit encrypted values in plain text, based on the keys stored in the `$HOME`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will launch an editor, and we just need to enter the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: While saving, `eyaml` will write the file with the encrypted content for `root_password`.
    If needed, we can edit the file again and all the encrypted values will be automatically
    decrypted.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When editing with `eyaml edit`, all the new values should be contained in a
    `DEC::PKCS7[value]!` block. For existing values, `eyaml` will add an index called
    `num` to `DEC(<num>)::PKCS7[value]!` blocks. This index must remain unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'As our last step, we need to modify the main manifest to do a Hiera lookup
    in order to get the password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Now the root password is encrypted in Hiera, and only people having the keys
    can recover it.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `hiera-eyaml` GitHub repository with its documentation at [https://github.com/TomPoulton/hiera-eyaml](https://github.com/TomPoulton/hiera-eyaml)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `puppet-hiera` GitHub repository with its documentation at [https://github.com/voxpupuli/puppet-hiera](https://github.com/voxpupuli/puppet-hiera)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Chef Vault encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A different way of encrypting data is proposed through Chef Vault, and this
    does not require you to include the key somewhere in the code. The concept is
    elegant and simple: shared key encryption is done for each and every existing
    Chef node through their already existing client keys. This way, only the nodes
    allowed to access the data can decrypt it—each with their own private key—ensuring
    no clear-text shared keys are being sent, like with the classic encrypted data
    bag scheme.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Chef DK installation on the workstation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working Vagrant installation on the workstation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Chef code (optionally) from [Chapter 6](ch06.html "Chapter 6. Fundamentals
    of Managing Servers with Chef and Puppet"), *Fundamentals of Managing Servers
    with Chef and Puppet*, [Chapter 7](ch07.html "Chapter 7. Testing and Writing Better
    Infrastructure Code with Chef and Puppet"), *Testing and Writing Better Infrastructure
    Code with Chef and Puppet*, or any custom Chef code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll build on the previous, already existing, `mysite` cookbook; however,
    any other situation will work similarly. Instead of using the `us-east-1` item
    from the `aws` data bag, let''s create a new `eu-west-1` item, very similar to
    the other item for `us-east-1` in `data_bags/aws/eu-west-1.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'As we know, the data will be encrypted for each and every running node''s public
    key. It means we have to filter hosts based on a search. I propose, that you search
    for every node using `search(*:*)`; however, feel free to limit to whatever is
    more secure or appropriate for you, such as tags or roles, like `search(tags:aws)`
    or `search(role:mysite)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't forget the `--mode "client"` option when executing with a Chef server
    like we do!
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the encrypted vault from a cookbook
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The companion to `knife vault` is the `chef-vault` cookbook. We''ll use it
    to easily access encrypted data in our recipe. If you''re using Berkshelf to manage
    dependencies, don''t forget to add the cookbook where required (either `metadata.rb`
    or `Berksfile`). In the `aws.rb` file, include the `chef-vault` recipe and set
    `aws` to the result of the `chef_vault_item` helper search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'If the node making the request isn''t allowed to decrypt the data with its
    private key, we''ll get an error. If the node can decrypt it, like we did previously
    with traditional data bags, the data will be available for use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In the end, the `/etc/aws/credentials` file is populated with valid unencrypted
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Using Chef Vault, no shared key has ever transited in clear text, and only filtered
    and existing nodes can decrypt data that has been encrypted specifically for them.
    Much more can be done with this tool!
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Chef Vault gem at [https://github.com/chef/chef-vault](https://github.com/chef/chef-vault)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Chef Vault cookbook at [https://github.com/chef-cookbooks/chef-vault](https://github.com/chef-cookbooks/chef-vault)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing and manipulating system information with Ohai
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A vast amount of information from a given system is available to Chef through
    Ohai. This program is executed during each Chef run and stores all of the gathered
    information in the Chef database to make it available right from the cookbooks.
    The kind of information gathered by default is quite large.
  prefs: []
  type: TYPE_NORMAL
- en: It ranges from networking details—such as link speed, MTU, or addresses—to all
    the memory usage details you'd find on a utility such as `top`, all of the imaginable
    data regarding filesystems or virtualization systems, or the list of every single
    installed package and logged-in users.
  prefs: []
  type: TYPE_NORMAL
- en: On top of this, Ohai is a modular system with a lot of community plugins to
    integrate Dell DRAC information with support information related to a KVM, LXC,
    or XenServer.
  prefs: []
  type: TYPE_NORMAL
- en: It can even be used to retrieve some specific data related to **Windows Management
    Instrumentation** (**WMI**). We obviously can write our own plugins, but that's
    way beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Chef DK installation on the workstation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working Vagrant installation on the workstation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Chef code (optionally) from [Chapter 6](ch06.html "Chapter 6. Fundamentals
    of Managing Servers with Chef and Puppet"), *Fundamentals of Managing Servers
    with Chef and Puppet*, [Chapter 7](ch07.html "Chapter 7. Testing and Writing Better
    Infrastructure Code with Chef and Puppet"), *Testing and Writing Better Infrastructure
    Code with Chef and Puppet*, or any custom Chef code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a fresh and minimal installation of a CentOS 7.2 virtual machine, the `ohai`
    output is 5,292 lines long, which is full of information. To see it bit by bit,
    refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, another solution is to redirect its content to a file so it''s
    easier to process with a dedicated tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'All of this information is also graphically available on the Chef interface
    when you select a node in the **Attributes** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B05671_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Accessing Ohai information from a Chef recipe
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let''s access this information from a recipe. We''d like an `index.html`
    page with some of this information, so let''s edit the one we already have from
    the `apache` cookbook; however, you can start from scratch as well. We''d like
    this page to dynamically display something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'All the information we need is stored somewhere in ohai: `platform`, `platform_version`,
    `os`, `os_version`, `ipaddress`, or `uptime` are all valid values. Let''s use
    them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `apache/templates/index.html.erb`, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'To build something more interesting, as the platform name is available, let''s
    make our `apache` cookbook a bit more portable across Linux distributions. When
    running on Ubuntu, install the `apache2` package; else, install the `httpd` package.
    (This will have to be more precise to handle all the real cases.) In the `apache::default`
    recipe, make the following change so the `httpd` variable is set to `apache2`
    when running Ubuntu and to the default `httpd` elsewhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This is how we can start leveraging the use of the powerful `ohai` command in
    our Chef infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The counterpart for Puppet is `facter`, which is installed with the Puppet
    agent. Like `ohai`, `facter` is a command-line tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: As for Chef, the `facter` information can be accessed from a Puppet manifest.
    Such information in the Puppet world is named **facts**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting from Puppet 4.x, facts can be accessed from manifests using the `$facts`
    hash. Let''s try to create more portable lines of code for the `apache` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may find pieces of codes that are accessing facts using variables, such
    as `$osfamily` instead of `$facts['os']['family']`. This method works with previous
    versions of Puppet, but it is not obvious here that a fact is being used.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ohai plugins at [https://docs.chef.io/plugin_com](http://ttps://docs.chef.io/plugin_com)[munity.html#ohai](http://munity.html#ohai)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.puppet.com/puppet/4.8/lang_facts_and_builtin_vars.html](https://docs.puppet.com/puppet/4.8/lang_facts_and_builtin_vars.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating application deployment (a WordPress example)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chef can also be used to deploy applications from code repositories. It combines
    one of the most complete, feature rich, and complicated Chef resources available—the
    `deploy` resource—and the various powerful and popular cookbooks, such as the
    `database` cookbook. We'll show you how to deploy a simple WordPress application
    right from the GitHub repository, creating a dedicated database and user as well
    as all the required dependencies. This builds on what has already been done previously,
    but the resources and cookbook shown here are made to be reusable anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Chef DK installation on the workstation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working Vagrant installation on the workstation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Chef code (optionally) from [Chapter 6](ch06.html "Chapter 6. Fundamentals
    of Managing Servers with Chef and Puppet"), *Fundamentals of Managing Servers
    with Chef and Puppet*, [Chapter 7](ch07.html "Chapter 7. Testing and Writing Better
    Infrastructure Code with Chef and Puppet"), *Testing and Writing Better Infrastructure
    Code with Chef and Puppet*, or any custom Chef code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we''re going to deploy an application for MySite (maybe an engineering blog
    for the MySite company), let''s call this recipe `mysite::deploy`. Create the
    recipe like this from `chef-repo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Our next steps will be to include the Apache and MySQL dependencies, configure
    everything on MySQL so that WordPress can be installed, and finally deploy the
    WordPress code from GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Including dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A WordPress installation needs at least an HTTP server and a database. Start
    by including the known dependencies to the service we already have: an Apache
    virtual host and MySQL. Include them in `deploy.rb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Creating the application's database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we deploy anything, we need to create a database on our already running
    MySQL server with a dedicated WordPress user. There''s a wonderful cookbook meant
    just for this: the `database` cookbook. We''ll reuse this one very often. It gives
    access to many helpers for most use cases and most types of databases. According
    to the documentation, we''ll need to deploy a gem named `mysql2_chef_gem`, which
    fortunately comes with a dedicated cookbook as well. And finally, as we''re using
    MySQL, let''s make sure we depend on its official cookbook. Let''s include all
    of this information in our `mysite` cookbook''s `metadata.rb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'To build the `mysql2` gem using the cookbook''s new `mysql2_chef_gem` resource,
    we''ll need the MySQL development package named `mysql-community-devel`. Let''s
    add the following to our `deploy.rb` recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The database cookbook created, among others, two useful resources for us: `mysql_database`
    and `mysql_database_user`. As we can guess by their names, they respectively help
    create MySQL databases and MySQL users. Let''s create the MySQL connection information
    variable so it can be reused in our two resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a proper `production` environment, we should use encrypted data bags for
    this matter, as seen in this chapter. We're trying to keep the code simple here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can create our database named `wordpress` using the `mysql_database`
    resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, create a `wordpress_user` MySQL user with the password `changeme`. This
    will create the user and grant all the privileges to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we should have everything we need related to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an application from git or GitHub
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now on to application deployment! We know we want to deploy from `git`. Let''s
    make sure `git` is installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The `deploy_revision` resource is the most complex of all. It has a multitude
    of options, and a full chapter about it wouldn''t be enough. Let''s keep it simple
    here and refer to the complete online documentation for more complex uses. Let''s
    keep it simple here, and please refer to the very complete online documentation
    for more complex uses—because this resource is absolutely powerful and does wonders
    when properly manipulated. We know the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Our code is available at [https://github.com/WordPress/WordPress](https://github.com/WordPress/WordPress)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to try the latest revision (`HEAD`) and keep the last five revisions
    to allow rollbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our HTTP web server runs under the `apache` user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The virtual host folder is inherited from an attribute set earlier (`/var/www/#{node['sitename']}`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's no database migrations to execute with WordPress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `deploy_revision` resource is modeled after Capistrano and therefore comes
    from the Ruby on Rails world. But the concepts still apply to most languages,
    and it''s a good practice in production to create shared folders and symlinks
    for long-lasting configurations and files. It includes certificates, database
    configuration files, local assets, and so on. However, to keep the current deployment
    simple, we won''t use these right now, even though you''ll probably start looking
    into it as soon as you''ll need it. We''ll include the symlinks configuration
    and initialize them to nothing so the code is already present when the time arises.
    Here''s how all this ties together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the code is applied, the `/var/www/mysite` (or whatever name you may have
    overridden) structure will change a little:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a `current`, `releases`, and `shared` folder. The `shared` folder
    contains everything that will last through the releases, including a cached copy
    of the current code. The `releases` folder contains all the stored releases. The
    `current` folder is itself a symlink to a specific release, which is the git commit
    SHA on GitHub (`72606bed348e61b6f98318cf920684765aa08b37`). Each subsequent release
    will be identified by its SHA indicating its unique identification and symlinked
    to `current` at the end of the deployment process. The number of kept releases
    is set by the `keep_releases` integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this code is applied to our node, if we navigate to `http://<node_ip>/current/`,
    we''ll see the WordPress setup page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying an application from git or GitHub](img/B05671_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To check whether the connection to the database is working correctly, type
    in all of the information from our Chef code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying an application from git or GitHub](img/B05671_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: And, job done! The WordPress installer says, **All right, sparky! You’ve made
    it through this part of the installation. WordPress can now communicate with your
    database. If you are ready, time now to... run the installer!**.
  prefs: []
  type: TYPE_NORMAL
- en: We're now basically able to deploy any WordPress installation from scratch,
    at will, and in seconds, again and again.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Let''s insist again**:'
  prefs: []
  type: TYPE_NORMAL
- en: Once you're comfortable with this, refer to the deploy resource documentation
    to discover everything this resource has to offer. It works wonders.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With Puppet, there is no deploy resource. However, Puppet Labs is providing
    a useful module—`vcsrepo`. With this module, we will be able to deploy a WordPress
    site from git.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s reuse our Vagrant LAMP example in [Chapter 6](ch06.html "Chapter 6. Fundamentals
    of Managing Servers with Chef and Puppet"), *Fundamentals of Managing Servers
    with Chef and Puppet*. We just need to add the `vcsrepo` module to `Puppetfile`
    (do not forget to run `r10k puppetfile install`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to modify the main manifest of the box, namely `web.pomes.pro`,
    to include the WordPress deployment. First, install the `git` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a database for WordPress:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, update our virtual definition to change `DocumentRoot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, install WordPress from `git` and give rights to Apache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `deploy` resource documentation at [https://docs.chef.io/resource_](https://docs.chef.io/resource_)[deploy.html](http://deploy.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PuppetLabs `vcsrepo` module at [https://forge.puppet.com/puppetlabs/vcsrepo](https://forge.puppet.com/puppetlabs/vcsrepo)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The WordPress hardening guide at [https://codex.wordpress.org/Hardening_WordPress](https://codex.wordpress.org/Hardening_WordPress)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a TDD workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TDD is a popular technique in development teams that consists of this: you
    begin by writing tests that will fail because no code is actually written and
    then write the code that will make these tests pass. This way, we ensure that
    the code we write is already tested, that it really covers the tested area; if
    some regression was to happen someday, it would be immediately noticed. Here,
    we''ll show a whole workflow, from development to production, where we deploy
    Docker on CentOS 7 and Ubuntu 16.04 using the TDD technique. Using Git branches,
    Chef tools, Test Kitchen, linting, and ServerSpec, we''ll go through each and
    every step of a small project led by TDD principles. We''ll do this to achieve
    maximum code quality among teams, from the development phase in the beginning
    to the final production environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Chef DK installation on the workstation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working Vagrant installation on the workstation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Chef code (optionally) from [Chapter 6](ch06.html "Chapter 6. Fundamentals
    of Managing Servers with Chef and Puppet"), *Fundamentals of Managing Servers
    with Chef and Puppet*, [Chapter 7](ch07.html "Chapter 7. Testing and Writing Better
    Infrastructure Code with Chef and Puppet"), *Testing and Writing Better Infrastructure
    Code with Chef and Puppet*, or any custom Chef code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our goal is to start a new platform based on Docker. To do this, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating the `platform` cookbook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now create the empty `platform::docker` recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize a `git` repo if it''s not already done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add and commit whatever work is in the repository right now, if any:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a feature branch for we''re about to work on supporting `docker` in
    our platform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Infrastructure TDD – writing tests first
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's write our tests first so they will fail for sure, and we'll know we're
    building from there correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the ServerSpec integration folder inside the platform cookbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `.kitchen.yml` at the root of the `platform` cookbook file with the
    following content. We''ll use Vagrant and simulate a Chef server with the `chef_zero`
    provisioner. We''d like our platform to work on both Ubuntu 16.04 and CentOS 7.2,
    and we want the entry point for our cookbook as its default recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'As we''ve seen earlier in this book, create a helper script in the `serverspec`
    folder named `spec_helper.rb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start our test and see what is it we want to do according to our needs:'
  prefs: []
  type: TYPE_NORMAL
- en: We want the `docker-engine` package to be installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want the `docker` service to be enabled and started
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want a specific `docker` image to be pulled (that is, `sjourdan/terraform:0.7.10`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'let''s write these tests in `docker_spec.rb`, in the `serverspec` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'This is good enough for our needs! Let''s launch our test environment by firing
    up `kitchen`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: We've failed successfully! Docker is neither installed, enabled, nor started,
    and no `docker` image is there.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get to work.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Docker with Chef
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There''s a very nice cookbook, which is extremely well-documented, that does
    everything we need ([https://github.com/chef-cookbooks/docker](https://github.com/chef-cookbooks/docker)).
    Let''s add it to `metadata.rb` so we depend on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Add it to Berkshelf as well if you plan to use it in `Berksfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'As we''ll be writing our Docker code in the `platform::docker` recipe, let''s
    start by including it in the `default.rb` recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The `docker` cookbook provides us with a new resource named `docker_installation`
    that does just this: install `docker`. There''s a myriad of installation options
    you can toy around with. Let''s keep it simple and install the current stable
    Docker version from Docker repositories (not from our Linux distribution). Add
    the following to the `docker.rb` recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute `kitchen` again to apply our code and see whether the tests are passing
    or failing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Good! What was failing a few minutes ago is now passing. It proves our action
    has fixed the problem, and we're on the right track. However, other tests are
    still failing, though.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the Docker service and start it using the `docker_service` resource
    the cookbook is offering us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute `kitchen` again to apply our code and see what the tests say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Good! The service is now tested and enabled and it is running. Let''s add this
    little requirement to have an image pulled right from the beginning, and we''ve
    chosen the Docker image `sjourdan/terraform` in its version 0.7.10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute `kitchen` again to apply our new code and check whether the tests pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Our code seems to do exactly what our tests expected! Let''s destroy our testing
    environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Linting the code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s not forget to check how clean our code is with `cookstyle` from inside
    the `platform` cookbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: No offenses! Our code is clean. Let's move on.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting another platform
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s check whether this code would work on Ubuntu 16.04 as well. Wouldn''t
    it be awesome to have it working on both the current platforms with long-term
    support? Simply add the platform to the cookbook''s `kitchen.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Launch `kitchen` again and check whether it works with Ubuntu 16.04 as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: We're now sure that our code supports Ubuntu 16.04 as well!
  prefs: []
  type: TYPE_NORMAL
- en: Team working using Chef and git
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that our `platform` cookbook works pretty well in our `docker_support`
    git branch, let''s commit that work. Start by verifying what''s not tracked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Commit that work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Is our `git` tree clean so that we can ship it to our team? Check this using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s push it to our `git` repository (supposedly GitHub, but it might
    be anything):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Now one of our coworkers can peer review the code and eventually merge `docker_support`
    with the `master` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Our new cookbook is now ready for prime time and can be deployed to staging.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a more complex setup, it's highly recommended that you run those integration
    tests in a continuous integration system, such as Jenkins. These systems can integrate
    very well with services such as GitHub or GitLab and launch tests automatically
    after a push or pull request. This is an added value, ensuring quality in the
    process before shipping.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to staging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let''s deploy this new platform cookbook to our staging environment. Let''s
    begin by making sure we have all the required cookbook dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, upload all the required cookbooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Use already existing environments, such as `staging`, and add our new `platform`
    cookbook version constraint to `environments/staging.rb` or any similar environment
    you''re using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Update that environment using the `knife` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Check this code into `git`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the platform cookbook to the target node''s run_list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Wait for the next Chef run or run it yourself and Docker will be available on
    any node, including this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to production
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Deploying to production at this stage is totally similar to shipping to staging;
    there''s no difference. The `environments/production.rb` file should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to upload it to the Chef server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Commit the changes to `git`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the next Chef run or execute it yourself, and from now on, we''ll
    have a nice four-step workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: Storing the TDD infrastructure code locally
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Peer reviewing and merging
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deployment to staging
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deployment to production
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, each time we're interested in testing or staging a new version of the cookbook
    that has passed steps 1 and 2, we just bump the cookbook's version number constraint,
    validating the results in the staging environment without impacting production,
    and finally deploy it in production whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With Puppet, the same logic applies. In [Chapter 7](ch07.html "Chapter 7. Testing
    and Writing Better Infrastructure Code with Chef and Puppet"), *Testing and Writing
    Better Infrastructure Code with Chef and Puppet*, we introduced Beaker as an acceptance
    test tool. In a TDD workflow, we can first write acceptance tests in the `specs/acceptance`
    subdirectory of any module and then write the code itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using multiple `nodesets`, we can also ensure tests can be validated on multiple
    platforms. In [Chapter 7](ch07.html "Chapter 7. Testing and Writing Better Infrastructure
    Code with Chef and Puppet"), *Testing and Writing Better Infrastructure Code with
    Chef and Puppet*, we used only one platform (Ubuntu) in `spec/acceptance/nodesets/default.yml`.
    However, we can create as many as needed. Here is an example of a CentOS node
    that should be defined in `spec/acceptance/nodesets/centos-7-x64.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the environment variable `BEAKER_set`, it is then possible to specify
    on which platform the test needs to be run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: And using git and r10k, the same team workflow applies. We first develop in
    a `test` branch. When all the tests have passed successfully, we merge them into
    the `production` branch and use r10k to deploy the code.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Docker chef cookbook at [https://github.com/chef-cookbooks/docker](https://github.com/chef-cookbooks/docker)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning for the worse – train to rebuild working systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's one thing to get a full infrastructure finally managed by Chef—block by
    block, weeks after weeks, modification after modification—keeping the Chef run
    always smooth and working. However, it's something quite different to be able
    to rebootstrap a working system from scratch. What if the current setup that works
    perfectly well is in fact working because there's a script or a binary somewhere
    left from last year, which does the thing that makes it work? What if the application
    servers get corrupted tonight? If this happens, will we be able to rebuild it
    from scratch? If tomorrow our IaaS cloud provider crashes, in what timeframe will
    we be able to rebuild systems somewhere else (provided the backups are working;
    well, that's another story)?
  prefs: []
  type: TYPE_NORMAL
- en: Now our systems are as much as possible automated, hopefully 100 percent. It's
    important to know whether we'd be able to fully rebootstrap these systems in case
    of a disaster; if yes, how long it would take. You may be surprised when you collect
    some data and discover that many systems can be recovered in minutes. Compare
    this with the time it might take to find an outdated documentation, apply untested
    manual processes, and finally do whatever it takes to get something up and running
    under the pressure of an emergency. We'll all spend better nights and weekends
    if we know that all the system profiles are being continuously rebootstrapped
    successfully; in fact, why not use the CI system every night so every morning
    we would know whether the previous day's changes have impacted something. We,
    as a team, always know that we're ready to redeploy a system if required.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Chef DK installation on the workstation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working Vagrant installation on the workstation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Chef code (optionally) from [Chapter 6](ch06.html "Chapter 6. Fundamentals
    of Managing Servers with Chef and Puppet"), *Fundamentals of Managing Servers
    with Chef and Puppet*, [Chapter 7](ch07.html "Chapter 7. Testing and Writing Better
    Infrastructure Code with Chef and Puppet"), *Testing and Writing Better Infrastructure
    Code with Chef and Puppet*, or any custom Chef code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no single way to achieve our goal. We've already covered Test Kitchen,
    and this might be a good solution, especially if we have written extensive tests.
    Integrate this in the company's **Continuous Integration** (**CI**) system and
    this will do the job.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simpler and quicker solution can also be to just launch Vagrant boxes with
    the right Chef-provisioning profiles for each use case: `docker`, `webserver`,
    database server, or full deployment.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refer to the Vagrant chapter of this book for more information about the Vagrant
    tool!
  prefs: []
  type: TYPE_NORMAL
- en: 'Our production servers are configured by the application of some Chef code,
    and currently, it does this job pretty well. Are we able to easily rebootstrap
    a similar CentOS 7.2 server from scratch to the point that it is similarly installed
    without any Chef or system error? Let''s find this out by including `Vagrantfile`
    at the root of the infrastructure repository, using the previous project code
    for deploying Docker (but the idea is the same for any kind of Chef repo). The
    minimum we can do is boot a fresh CentOS 7.2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'We''d like to automatically install Chef on our temporary node, so let''s use
    the `vagrant-omnibus` plugin (remember, installing it is easy: `vagrant plugin
    install vagrant-omnibus`). Here''s the code to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s configure the Vagrant provisioning system to use Chef Zero in order
    to simulate a Chef server. We can also directly use a real Chef server; if we
    have one behind the firewall, it can be handy. We have to specify where is everything
    placed (cookbooks, environments, roles, and so on) with the added subtlety of
    a `nodes` folder that will be left empty in our case. Our virtual machine will
    run in the `production` environment and apply the `docker` role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re almost done! We need to tell the Vagrant Berkshelf plugin where to look
    for `Berksfile` and whether to enable it (installing the Berkshelf plugin is easy:
    `vagrant plugin install vagrant-berkshelf`). Here''s the code to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting Vagrant at this point will just deploy everything from scratch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'If the run succeeds, meaning the code from the Docker role is applied, we''re
    safe. Let''s destroy the VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Including this Vagrant command in our CI system will ensure this particular
    role will run flawlessly in this particular environment and with this particular
    system, and that potentially, it's a matter of three minutes and 30 seconds to
    recover from nothing to a working state.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-machine recovery
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s move to a more complicated setup. Vagrant supports multi-machine setups,
    letting us define profiles for each one of them. In a previous example of this
    chapter, we deployed a WordPress installation with a database configured and the
    Apache web server configured as well, all with encrypted data bags and templates.
    We''ll implement the same idea, except that `Vagrantfile` will include multiple
    machine profiles: one to start a virtual machine only with the `webserver` role,
    another to deploy only the database part, and the third one to launch everything
    together, including the web application. So we''ll make sure all the parts of
    the final product can be redeployed from scratch (which is the main point).'
  prefs: []
  type: TYPE_NORMAL
- en: 'All VM definitions will live inside the main Vagrant configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We suggest disabling the automatic start of VMs so we don't make the mistake
    of launching dozens of VMs by error.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure our code is capable of bootstrapping only the `webserver` role
    from scratch, we will need to do the following—setting paths for everything, including
    the specific `Berksfile` for the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'To launch only this box in order to make sure the `webserver` role can be deployed
    from scratch, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'To make sure our code is capable of bootstrapping only the database part of
    this platform from scratch, just execute the `mysite::mysql` recipe in a similar
    context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'To launch only this box in order to make sure the database recipe can be deployed
    from scratch, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'To make sure our code is capable of bootstrapping the whole platform from scratch,
    we''ll have to simply execute the whole `mysite::default` recipe with one more
    step. One of the included recipes uses an encrypted data bag. It''s stored encrypted
    on the Chef server, but locally, our `./data_bags/` directory currently includes
    only the unencrypted JSON versions. We have to make sure another folder hosts
    the encrypted versions (maybe you already have one to store them on GitHub for
    example). Otherwise, import the encrypted version from the Chef server to a new
    directory, say, in JSON (using `-Fj`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can define the full VM like the others with the modified data bag path
    for the encrypted version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'To launch only this box in order to make sure the whole recipe is deployed
    from scratch, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Put these commands (with their destroy counterparts) in the CI or whatever system
    you prefer at a regular interval, like daily or weekly, for each and every automated
    part of the infrastructure. With this, you'll always be certain you can redeploy
    the system when a disaster comes.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using Puppet, all the examples we used were based on Vagrant, and it is easy
    to rebuild nodes from scratch. But, in the real word, you probably won't deploy
    and maintain a production system running from Vagrant on your workstation.
  prefs: []
  type: TYPE_NORMAL
- en: However, these examples show that it is possible to simulate a complete infrastructure
    using a simple `vagrant up` command, and therefore, it is easy to put it into
    any CI system to ensure you will be able to rebuild your production system easily.
  prefs: []
  type: TYPE_NORMAL
