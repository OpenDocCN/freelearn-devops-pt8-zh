- en: Chapter 8. Maintaining Systems Using Chef and Puppet
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章：使用Chef和Puppet维护系统
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将介绍以下几种配方：
- en: Maintaining consistent systems using scheduled convergence
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用计划的收敛性保持一致的系统
- en: Creating environments
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建环境
- en: Using Chef encrypted data bags and Hiera-eyaml with Puppet
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Chef加密数据包和Puppet中的Hiera-eyaml
- en: Using Chef Vault encryption
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Chef Vault加密
- en: Accessing and manipulating system information with Ohai
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ohai访问和操作系统信息
- en: Automating application deployment (a WordPress example)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化应用部署（以WordPress为例）
- en: Using a TDD workflow
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用TDD工作流
- en: Planning for the worse – train to rebuild working systems
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为最坏情况做好准备——训练重建工作系统
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: We've previously seen how to automate systems with code and how to properly
    test this code. Now we're ready for prime time; there's a whole set of features,
    constraints, and objectives to be properly set. We'll want to isolate environments
    such as dev, staging, and production. We'll need our infrastructure code to stay
    consistent without our intervention. Security and confidentiality will start becoming
    an issue, and maybe those passwords and secret keys should not be stored in clear
    text at all. After a few months, our automated infrastructure will grow into a
    large number of managed nodes, and it will become critical to have coherent behaviour
    according to systems profiles—we'll need to gather and process system information.
    We'll eventually end up deploying web applications directly from Chef. To keep
    a high level of quality while our code base gets more and more complex, we'll
    switch to the **Test-Driven Development** (**TDD**) approach for our workflow.
    And finally, we'll make sure we're always ready to redeploy any part of the infrastructure
    at any time (think of a disaster).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经看到如何用代码自动化系统，以及如何正确测试这些代码。现在我们已经准备好迎接正式应用；有一整套特性、约束和目标需要正确设置。我们将希望将开发、测试和生产环境隔离开。我们需要确保基础设施代码在没有干预的情况下保持一致。安全性和机密性将开始成为一个问题，也许那些密码和密钥根本不应该以明文存储。几个月后，我们的自动化基础设施将扩展到大量的管理节点，且必须确保系统按照配置文件一致地运行——我们将需要收集和处理系统信息。最终，我们将直接从Chef部署Web应用。为了保持代码质量，即便我们的代码库越来越复杂，我们将采用**测试驱动开发**（**TDD**）方法来优化工作流。最后，我们将确保随时准备重新部署任何基础设施部分（想象一下灾难发生时）。
- en: All recipes are based on Chef. However, when possible, we'll try to show how
    things work similarly with Puppet, Chef's direct alternative.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的配方都是基于Chef的。然而，在可能的情况下，我们将尝试展示如何使用Chef的直接替代品——Puppet来实现类似的功能。
- en: Maintaining consistent systems using scheduled convergence
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用计划的收敛性保持一致的系统
- en: Once initially deployed and configured, it's hardly imaginable to let our systems
    be manually updated afterwards by logging in to each host and launching the `chef-client`
    command. Systems maintained with Chef have the opportunity to be converged at
    a predetermined time, either through a `chef-client` daemon or a cron job. We'll
    go through both these options.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦初步部署并配置好系统，几乎无法想象仍然通过登录每台主机并启动`chef-client`命令来手动更新系统。使用Chef维护的系统可以在预定时间通过`chef-client`守护进程或cron作业进行收敛。我们将详细讲解这两种选项。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步执行此配方，你需要：
- en: A working Chef DK installation on the workstation
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在工作站上安装一个可用的Chef DK
- en: A working Vagrant installation on the workstation
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在工作站上安装一个可用的Vagrant
- en: The Chef code (optionally) from either [Chapter 6](ch06.html "Chapter 6. Fundamentals
    of Managing Servers with Chef and Puppet"), *Fundamentals of Managing Servers
    with Chef and Puppet*, [Chapter 7](ch07.html "Chapter 7. Testing and Writing Better
    Infrastructure Code with Chef and Puppet"), *Testing and Writing Better Infrastructure
    Code with Chef and Puppet*, or any custom Chef code
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chef代码（可选）来自[第6章](ch06.html "第6章：使用Chef和Puppet管理服务器的基础知识")，*使用Chef和Puppet管理服务器的基础知识*，[第7章](ch07.html
    "第7章：使用Chef和Puppet编写更好的基础设施代码并进行测试")，*使用Chef和Puppet编写更好的基础设施代码并进行测试*，或任何自定义的Chef代码
- en: How to do it…
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We recommend that you create a cookbook, different from other cookbooks, dedicated
    to configuring the underlying host. Let''s call this cookbook `common`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议你创建一个与其他cookbook不同的cookbook，专门用于配置底层主机。我们称这个cookbook为`common`：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To configure the Chef client, there''s an official cookbook aptly named `chef-client`.
    Let''s declare a `cookbook` requirement to it, specifically to `Berksfile`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置Chef客户端，有一个官方食谱名为`chef-client`。让我们在`Berksfile`中声明对它的`cookbook`依赖：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To the `common/metadata.rb` file, add the dependency:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在`common/metadata.rb`文件中，添加依赖项：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using the Chef client as a daemon
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将Chef客户端作为守护进程使用
- en: 'The documentation tells us that including the default recipe will automatically
    detect the host platform and configure `chef-client` accordingly to run as a daemon.
    Here are the steps to enable `chef-client`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 文档告诉我们，包含默认食谱将自动检测主机平台，并相应配置`chef-client`以作为守护进程运行。以下是启用`chef-client`的步骤：
- en: 'Add the following to `recipes/default.rb`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到`recipes/default.rb`中：
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Install the dependencies using Berkshelf:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Berkshelf安装依赖项：
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now upload the `common` cookbook with all its dependencies:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在上传`common`食谱及其所有依赖项：
- en: '[PRE5]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the `common` cookbook to the host `run-list`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`common`食谱添加到主机的`run-list`中：
- en: '[PRE6]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'On the target host, launch the Chef client one last time to make it deploy
    itself as a service:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目标主机上，最后一次启动Chef客户端以使其作为服务部署：
- en: '[PRE7]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The logs seem pretty optimistic, but let''s double-check the daemon is really
    running on the host:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 日志看起来相当乐观，但我们还是再检查一下守护进程是否真的在主机上运行：
- en: '[PRE8]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `chef-client` service is indeed enabled and running!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`chef-client`服务已经启用并在运行！'
- en: Tweaking the convergence interval time
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调整收敛间隔时间
- en: 'Interesting enough, we see that the interval is introduced every 1,800 seconds
    (30 minutes). What if we want a different convergence interval, say, every 900
    seconds (15 minutes)? Let''s transform the `default.rb` recipe:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 足够有趣的是，我们看到间隔是每1800秒（30分钟）引入的。如果我们想要不同的收敛间隔，比如每900秒（15分钟）呢？让我们来修改`default.rb`食谱：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Bump the version in `metadata.rb`, upload the new version, wait for the new
    `chef-client` execution, or launch it yourself to save some time. The `systemd`
    unit is now updated:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在`metadata.rb`中提升版本，上传新版本，等待新的`chef-client`执行，或者自己启动它以节省一些时间。`systemd`单元已更新：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Our system is now configured to converge every 15 minutes with a controlled
    variation of 300 seconds.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的系统已经配置为每15分钟收敛一次，变动控制在300秒以内。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We highly suggest that you include this `common` cookbook in every new host
    deployment process so they could all be automatically configured to converge at
    a predetermined interval.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议在每次新的主机部署过程中都包含这个`common`食谱，这样它们都能被自动配置为按照预定的间隔进行收敛。
- en: Running the Chef client as a cron
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将Chef客户端作为cron作业运行
- en: 'Under certain circumstances, we might not want to run the Chef client as a
    daemon (such as memory or security requirements). So luckily, we can simply fall
    back to a simple method that is based on a cron. Let''s transform the default
    `recipe.rb` recipe to match this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能不希望将Chef客户端作为守护进程运行（例如内存或安全需求）。幸运的是，我们可以简单地退回到基于cron的简单方法。让我们修改默认的`recipe.rb`食谱以匹配这一点：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Upload this cookbook version using Berkshelf and execute `chef-client` on the
    target host. See root''s `crontab` file:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Berkshelf上传这个食谱版本，并在目标主机上执行`chef-client`。查看root的`crontab`文件：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: By default, it's executing `chef-client` every four hours with, in this case,
    a `69` seconds delay to avoid every node from hammering the Chef server at the
    same time.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，它每四小时执行一次`chef-client`，并在此情况下延迟`69`秒，以避免每个节点同时向Chef服务器发送请求。
- en: Tweaking the Chef cron job
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调整Chef的cron作业
- en: 'If converging every four hours is not enough for you and you would like to
    converge every 15 minutes, like we did with the daemon in the `default.rb` recipe,
    here''s what you need to do:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每四小时收敛一次还不够，你希望像我们在`default.rb`食谱中做的那样每15分钟收敛一次，以下是你需要做的：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Upload the cookbook and run `chef-client` (or wait for the next scheduled run).
    The interval is now set to run every 15 minutes:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 上传食谱并运行`chef-client`（或等待下一次计划的运行）。间隔现在已设置为每15分钟运行一次：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There's more…
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: With Puppet, the agent can also run as a service or a cron.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在Puppet中，代理也可以作为服务或cron作业运行。
- en: 'The following command is used to enable the service mode:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令用于启用服务模式：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this mode, the Puppet agent will apply the configuration every 30 minutes
    by default. This delay can be changed in `/etc/puppetlabs/puppet.conf`. Here is
    an example to reduce this delay to five minutes:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模式下，Puppet代理将默认每30分钟应用一次配置。这个延迟可以在`/etc/puppetlabs/puppet.conf`中更改。以下是将延迟减少到五分钟的示例：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To run the Puppet agent as a cron, we need to declare a Puppet cron resource
    as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Puppet代理作为cron作业运行，我们需要声明一个Puppet cron资源，如下所示：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The generated `crontab` file is:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的`crontab`文件是：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, the Puppet agent will run every hour. The `splay` option is
    used to introduce a random delay before the run itself, and this delay cannot
    exceed 60 minutes (the value of the `splaylimit` option). This is particularly
    useful when a lot of nodes are connected to the same Puppet server in order to
    spread the Puppet agent's requests in time.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，Puppet代理将每小时运行一次。`splay`选项用于在运行之前引入一个随机延迟，该延迟不能超过60分钟（即`splaylimit`选项的值）。这对于有很多节点连接到同一个Puppet服务器的情况特别有用，可以将Puppet代理的请求分散到不同的时间点。
- en: 'Of course, if there are many nodes in your infrastructure, you should create
    a module containing these Puppet resources and include it for each node. Based
    on our previous Vagrant-based LAMP setup, let''s create a local module with a
    single file, namely `module/baseconfig/manifests/init.pp`, with:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果您的基础设施中有许多节点，您应该创建一个包含这些Puppet资源的模块，并为每个节点包含该模块。基于我们之前的Vagrant LAMP环境设置，让我们创建一个本地模块，并创建一个文件`module/baseconfig/manifests/init.pp`，其内容为：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we can define the requested mode from the main manifest:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以从主清单中定义所需的模式：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If there is any future change between `service` versus `cron`, our `baseconfig`
    module will remove the configuration for the previous mode.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将来在`service`与`cron`之间发生任何更改，我们的`baseconfig`模块将删除之前模式的配置。
- en: See also
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The `chef-client` cookbook source at [https://github.com/chef-coo](https://github.com/chef-coo)[kbooks/chef-client](http://kbooks/chef-client)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chef-client`菜谱源，参考[https://github.com/chef-coo](https://github.com/chef-coo)[kbooks/chef-client](http://kbooks/chef-client)'
- en: The Puppet cron resource at [https://docs.puppet.com/puppet/4.8/types/cron.html](https://docs.puppet.com/puppet/4.8/types/cron.html)
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet的cron资源，参考[https://docs.puppet.com/puppet/4.8/types/cron.html](https://docs.puppet.com/puppet/4.8/types/cron.html)
- en: Creating environments
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建环境
- en: 'A classic organization has a minimum of two environments in which the infrastructure
    is run: development and production. Very often, a lot of environments are seen,
    such as staging, testing, alpha or beta. It''s entirely up to the organization
    to model the infrastructure according to its needs, and the complexity can grow
    very quickly. The good news is that Chef helps a lot in mapping this model to
    the infrastructure. There''s a set of information that will be different in two
    distinct environments, such as cookbook versions or attributes, and Chef makes
    it as easy as possible to manage these environments. By default, nodes without
    an environment set will run in a `_default` environment.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经典的组织至少有两个运行基础设施的环境：开发环境和生产环境。通常会看到许多不同的环境，如暂存环境、测试环境、Alpha或Beta环境。组织可以根据自身需求来建模基础设施，复杂性也可能迅速增长。好消息是，Chef在将这一模型映射到基础设施时提供了很大帮助。有一组信息会在两个不同的环境中有所不同，例如菜谱版本或属性，而Chef尽可能简化了管理这些环境的过程。默认情况下，未设置环境的节点将运行在`_default`环境中。
- en: In this section, we'll see how to create different environments, how to set
    nodes (both existing and new) in a dedicated environment, how to set cookbook
    constraints, and finally how to override the attributes in each environment.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何创建不同的环境，如何将节点（包括现有节点和新节点）设置到专用环境中，如何设置菜谱约束，最后如何在每个环境中覆盖属性。
- en: Getting ready
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步执行此配方，您需要：
- en: A working Chef DK installation on the workstation
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作站上已安装的Chef DK
- en: A working Vagrant installation on the workstation
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作站上已安装的Vagrant
- en: The Chef code (optionally) from [Chapter 6](ch06.html "Chapter 6. Fundamentals
    of Managing Servers with Chef and Puppet"), *Fundamentals of Managing Servers
    with Chef and Puppet*, [Chapter 7](ch07.html "Chapter 7. Testing and Writing Better
    Infrastructure Code with Chef and Puppet"), *Testing and Writing Better Infrastructure
    Code with Chef and Puppet*, or any custom Chef code
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chef代码（可选）来自[第6章](ch06.html "第6章。使用Chef和Puppet管理服务器的基础"), *使用Chef和Puppet管理服务器的基础*，[第7章](ch07.html
    "第7章。用Chef和Puppet编写和测试更好的基础设施代码"), *用Chef和Puppet编写和测试更好的基础设施代码*，或任何自定义Chef代码
- en: How to do it…
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Chef environments live in a folder named `environments` at the root of `chef-repo`.
    If the folder doesn''t exist, create it:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Chef环境存储在名为`environments`的文件夹中，该文件夹位于`chef-repo`的根目录。如果该文件夹不存在，请创建它：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Creating a production environment
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建生产环境
- en: 'To create a production environment, follow these steps:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建生产环境，请按照以下步骤操作：
- en: 'Let''s start by creating a `production` environment in a `production.rb` file:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为`production.rb`的`production`环境开始：
- en: '[PRE22]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is the simplest environment possible; it does nothing. Upload it to the
    Chef server:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是最简单的环境，它什么也不做。将其上传到 Chef 服务器：
- en: '[PRE23]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'List the available remote environments:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出可用的远程环境：
- en: '[PRE24]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We see we have two environments available: `production` and `_default`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到有两个可用环境：`production` 和 `_default`。
- en: Setting an environment to a node
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将环境设置为节点
- en: 'To set an already existing node to this new `production` environment, execute
    the following command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要将已存在的节点设置为新的 `production` 环境，请执行以下命令：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Bootstrapping a node with an environment
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用环境引导节点
- en: 'If we''re bootstrapping a node with the `knife bootstrap` command, we can start
    in the required environment right from the beginning (using an user named `vagrant`
    like the previous examples):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在使用 `knife bootstrap` 命令引导一个节点，我们可以从一开始就使用所需的环境（使用名为 `vagrant` 的用户，如前面的示例所示）：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Fixing cookbook versions for an environment
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为环境修正配方版本
- en: 'Let''s say our production systems are running a perfectly stable `mysite` cookbook
    in version 0.3.1, but we want to try a new feature in the development infrastructure
    in the 0.4.0 version of the same cookbook. As every cookbook version can live
    together, each environment can call its own version. The `production.rb` file
    would contain the following for the `production` environment:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的生产系统运行的是版本为 0.3.1 的稳定 `mysite` 配方，但我们希望在开发基础设施中尝试同一配方的 0.4.0 版本新特性。由于每个配方版本可以共存，因此每个环境可以调用其自己的版本。`production.rb`
    文件将包含以下内容，用于 `production` 环境：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `development.rb` file would contain the following for the development environment:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`development.rb` 文件将包含以下内容，用于开发环境：'
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'A Chef environment file may contain many cookbook constraints, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Chef 环境文件可能包含多个配方约束，如下所示：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Overriding attributes for an environment
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为环境覆盖属性
- en: 'Each environment can override any value, and, in Chef, it''s the highest level
    of override. Nothing else can override a value set for an environment. So, if
    we simply want to override the value of the `sitename` attribute to `production.rb`,
    it will look like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 每个环境可以覆盖任何值，在 Chef 中，这是覆盖的最高级别。没有其他内容可以覆盖为环境设置的值。所以，如果我们仅想将 `sitename` 属性的值覆盖为
    `production.rb`，它将像这样：
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Accessing the environment from a recipe
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从配方中访问环境
- en: The node's environment is available from any recipe through the `node.chef_environment`
    attribute.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的环境可以通过 `node.chef_environment` 属性从任何配方中访问。
- en: 'So if our wish is to create a file that would display the environment inside
    which the node is running, we would need to create a template like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果我们的目标是创建一个显示节点正在运行的环境的文件，我们需要创建一个像这样的模板：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: There's more...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: With Puppet, environments are located in distinct directories on the Puppet
    server. You probably noticed this in [Chapter 6](ch06.html "Chapter 6. Fundamentals
    of Managing Servers with Chef and Puppet"), *Fundamentals of Managing Servers
    with Chef and Puppet*; we created the code in the `/etc/puppetlabs/code/environments/production`
    directory.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Puppet 时，环境位于 Puppet 服务器上的不同目录中。你可能在 [第 6 章](ch06.html "第6章 管理 Chef 和 Puppet
    服务器的基础")，*管理 Chef 和 Puppet 服务器的基础* 中注意到这一点；我们在 `/etc/puppetlabs/code/environments/production`
    目录中创建了代码。
- en: This is because the default Puppet environment is `production`. Other environments,
    for example `test`, should be created under `/etc/puppetlabs/code/environments/`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为默认的 Puppet 环境是 `production`。其他环境，例如 `test`，应该在 `/etc/puppetlabs/code/environments/`
    下创建。
- en: Manual environment creation in the Puppet server
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Puppet 服务器上手动创建环境
- en: 'Let''s start with samples from [Chapter 6](ch06.html "Chapter 6. Fundamentals
    of Managing Servers with Chef and Puppet"), *Fundamentals of Managing Servers
    with Chef and Puppet*, and try creating a new environment, namely `test`. On the
    Puppet server, we just need to do this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 [第 6 章](ch06.html "第6章 管理 Chef 和 Puppet 服务器的基础")，*管理 Chef 和 Puppet 服务器的基础*，开始，尝试创建一个新的环境，命名为
    `test`。在 Puppet 服务器上，我们只需要执行如下操作：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Node environment selection
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 节点环境选择
- en: 'On the node side, the environment to use can be controlled using `--environment`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在节点端，使用的环境可以通过 `--environment` 控制：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To use this environment as the default one, without using `--environment`,
    we can configure it in `/etc/puppetlabs/puppet/puppet.conf` with the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 若要将此环境设置为默认环境，而不使用 `--environment`，我们可以在 `/etc/puppetlabs/puppet/puppet.conf`
    中配置如下：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Getting the environment from manifests
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从清单中获取环境
- en: As for Chef, we can get the name of the running environment from any manifest.
    This is done by using the `$environment` variable, which is set by the Puppet
    server.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Chef，我们可以从任何清单中获取正在运行的环境名称。通过使用由 Puppet 服务器设置的`$environment`变量来实现。
- en: 'To illustrate this, let''s modify our `index.php` file (`manifests/site.pp`),
    both in `production` and `test`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们修改 `index.php` 文件（`manifests/site.pp`），分别在`production`和`test`中进行修改：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can now switch between `test` and `production` and see the changes:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在`test`和`production`之间切换并查看更改：
- en: '[PRE36]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The dynamic way – r10k
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态方式 – r10k
- en: 'We edited the environments and code directly in the Puppet master, which is
    not recommended. Fortunately, r10k (which we already used in [Chapter 6](ch06.html
    "Chapter 6. Fundamentals of Managing Servers with Chef and Puppet"), *Fundamentals
    of Managing Servers with Chef and Puppet*, to install modules) can be used to
    create environments from a Git repository. Each branch from the Git repository
    will be checked out into a distinct directory and will be available as an environment.
    This feature is dynamic: each new branch added to the Git repository will be deployed
    by r10k.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们直接在 Puppet 主机中编辑了环境和代码，这是不推荐的。幸运的是，r10k（我们在[第六章](ch06.html "第六章. 使用 Chef 和
    Puppet 管理服务器的基础知识")中已经使用过，用于安装模块）可以用来从 Git 仓库创建环境。每个 Git 仓库中的分支将被检出到一个独立的目录，并作为一个环境提供。这一特性是动态的：每次向
    Git 仓库添加新分支，r10k 都会部署它。
- en: Let's try it from our workstation. Until now, the job of the shared folder of
    our Vagrant setup was to map the relative directory `puppetcode` to `/etc/puppetlabs/code/environments/production`
    in the `puppet.pomes.pro` box. We are about to use multiple environments, so we
    need to change the mapping to `/etc/puppetlabs/code/`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从工作站尝试一下。到目前为止，我们的 Vagrant 设置中共享文件夹的工作是将相对目录`puppetcode`映射到`/etc/puppetlabs/code/environments/production`路径上，位于`puppet.pomes.pro`箱中。我们即将使用多个环境，因此需要将映射更改为`/etc/puppetlabs/code/`。
- en: We need a Git repository with two branches, `production` and `test`, with all
    of the previous code. An example is available at [https://github.com/ppomes/r10k_sample.git](https://github.com/ppomes/r10k_sample.git).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个包含两个分支（`production`和`test`）的 Git 仓库，里面包含所有先前的代码。一个示例可以在 [https://github.com/ppomes/r10k_sample.git](https://github.com/ppomes/r10k_sample.git)
    找到。
- en: 'The r10k tool needs a global configuration file, which must be created at the
    same level as our Vagrantfile, with the following content:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: r10k 工具需要一个全局配置文件，必须在与 Vagrantfile 同一级别创建，文件内容如下：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now let''s use r10k:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用 r10k：
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Both branches from the Git repository have been deployed, and we can now fire
    up Vagrant and play with our boxes and branches.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Git 仓库中的两个分支都已部署，我们现在可以启动 Vagrant，操作我们的盒子和分支。
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The r10k tool also takes care of the `Puppetfile` file in each branch, as we
    already saw in [Chapter 6](ch06.html "Chapter 6. Fundamentals of Managing Servers
    with Chef and Puppet"), *Fundamentals of Managing Servers with Chef and Puppet*,
    and deploys external modules, if any.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: r10k 工具还会处理每个分支中的`Puppetfile`文件，正如我们在[第六章](ch06.html "第六章. 使用 Chef 和 Puppet
    管理服务器的基础知识")中所看到的，*使用 Chef 和 Puppet 管理服务器的基础知识*，并部署外部模块（如果有的话）。
- en: See also
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: The Chef environment documentation at [https://docs.chef.io/environments.html](http://://docs.chef.io/environments.html)
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chef 环境文档：[https://docs.chef.io/environments.html](http://://docs.chef.io/environments.html)
- en: Puppet's r10k at [https://github.com/puppetlabs/r10k](https://github.com/puppetlabs/r10k)
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet 的 r10k：[https://github.com/puppetlabs/r10k](https://github.com/puppetlabs/r10k)
- en: Using Chef encrypted data bags and Hiera-eyaml with Puppet
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Chef 加密数据包和 Hiera-eyaml 与 Puppet
- en: Some information in data bags can be safely stored in the Chef server in plain
    text, but under some circumstances, sensitive information might be safer if encrypted.
    Companies might not like production API keys, private keys, or similar sensitive
    content to be stored in plain text on the Chef server or on third-party services,
    such as GitHub. We'll see how to encrypt and decrypt data in the command line
    and from inside a Chef recipe.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包中的一些信息可以安全地以明文存储在 Chef 服务器中，但在某些情况下，敏感信息加密后可能更为安全。公司可能不希望生产环境的 API 密钥、私钥或类似的敏感内容以明文形式存储在
    Chef 服务器或第三方服务（如 GitHub）中。我们将看到如何在命令行中以及在 Chef 配方中对数据进行加密和解密。
- en: Getting ready
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此配方，你将需要：
- en: A working Chef DK installation on the workstation
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作站上安装好的 Chef DK
- en: A working Vagrant installation on the workstation
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作站上安装好的 Vagrant
- en: The Chef code (optionally) from [Chapter 6](ch06.html "Chapter 6. Fundamentals
    of Managing Servers with Chef and Puppet"), *Fundamentals of Managing Servers
    with Chef and Puppet*, [Chapter 7](ch07.html "Chapter 7. Testing and Writing Better
    Infrastructure Code with Chef and Puppet"), *Testing and Writing Better Infrastructure
    Code with Chef and Puppet*, or any custom Chef code
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自[第六章](ch06.html "第六章. 使用Chef和Puppet管理服务器的基础知识")的Chef代码（可选），*使用Chef和Puppet管理服务器的基础知识*，[第七章](ch07.html
    "第七章. 使用Chef和Puppet测试和编写更好的基础架构代码")，*使用Chef和Puppet测试和编写更好的基础架构代码*，或者任何自定义Chef代码
- en: How to do it…
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Our goal is to create a configuration file containing our AWS credentials for
    the `us-east-1` region, and it''s not acceptable that you store the credentials
    in clear text on the Chef server. We''d like to use a data bag, as it can be encrypted:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是创建一个包含`us-east-1`区域AWS凭证的配置文件，且不允许将凭证以明文存储在Chef服务器上。我们希望使用数据包，因为它可以加密：
- en: 'Create a data bag folder `aws` to store the credentials for the `us-east-1`
    region:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`aws`的数据包文件夹来存储`us-east-1`区域的凭证：
- en: '[PRE39]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create the data bag on the Chef server while we''re at it:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Chef服务器上创建数据包，顺便说一下：
- en: '[PRE40]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Inside this `aws` data bag folder, create a sample `us-east-1.json` file containing
    the credentials:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`aws`数据包文件夹内，创建一个示例文件`us-east-1.json`，其中包含凭证：
- en: '[PRE41]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is the standard procedure for a normal data bag. If we upload it now as
    is, it won't be encrypted.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正常数据包的标准过程。如果我们现在按原样上传，它将不会被加密。
- en: Encrypting data bags with a shared secret
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用共享密钥加密数据包
- en: 'The solution to use an encrypted data bag is to send it encrypted from our
    workstation. The encryption is done through a shared secret, the secret being
    either a file or a string. Let''s use the string `s3cr3t` as an encryption key
    (weak). To simply send the encrypted version of the data bag, let''s use the encryption
    feature of the `knife` command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用加密数据包的解决方案是从我们的工作站发送加密数据。加密通过共享密钥完成，密钥可以是文件或字符串。我们使用字符串`s3cr3t`作为加密密钥（弱密钥）。为了简单地发送加密版本的数据包，我们可以使用`knife`命令的加密功能：
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If we request the data without providing a decryption key, we''ll get the encrypted
    data from the Chef server:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们请求数据但没有提供解密密钥，我们将从Chef服务器获取加密数据：
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'It looks like we got what we wanted: data is stored encrypted on the Chef server!'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们得到了我们想要的：数据已经加密存储在Chef服务器上！
- en: 'As it may not be a secure move to store unencrypted data bags on version control
    systems, such as Git, we can ask for a JSON-formatted encrypted version, such
    as the following, and redirect the output to a JSON file for storage purposes:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于将未加密的数据包存储在版本控制系统（如Git）中可能不是一个安全的做法，我们可以请求一个JSON格式的加密版本，如下所示，并将输出重定向到JSON文件以便存储：
- en: '[PRE44]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This might be the content you'd like to store on Git!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是你想存储到Git中的内容！
- en: Accessing an encrypted data bag in the CLI
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在CLI中访问加密数据包
- en: 'To access unencrypted data from the knife CLI, the process is as easy as encrypting
    data—pass the shared secret as an argument:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要从knife CLI访问未加密的数据，过程与加密数据一样简单——将共享密钥作为参数传递：
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now we have access to our data but in an unencrypted form.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以访问我们的数据，但它是未加密的。
- en: Using an encrypted data bag from a recipe
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从食谱中使用加密数据包
- en: 'Now that the data is safely stored on the Chef server, how do we access it
    from inside a Chef recipe? Let''s say our objective is to create a file named
    `/etc/aws/credentials` that will contain the unencrypted value from the encrypted
    version on the Chef server. The final file should look like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据已安全存储在Chef服务器上，我们如何从Chef食谱中访问它？假设我们的目标是创建一个名为`/etc/aws/credentials`的文件，里面包含Chef服务器上加密版本的未加密值。最终的文件应如下所示：
- en: '[PRE46]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To do so, create a new recipe named `aws` inside the `mysite` cookbook:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，在`mysite`食谱中创建一个名为`aws`的新食谱：
- en: '[PRE47]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: Don't forget to bump the cookbook version and environment constraints accordingly.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要忘记相应地增加食谱版本和环境限制。
- en: 'Start by creating the `/etc/aws` folder using the `directory` resource:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先使用`directory`资源创建`/etc/aws`文件夹：
- en: '[PRE48]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here''s a `templates/aws.erb` ERB template file for our destination, namely
    `/etc/aws/credentials`:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们目标文件`/etc/aws/credentials`的`templates/aws.erb` ERB模板文件：
- en: '[PRE49]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We see the template is expecting the `aws_region`, `aws_access_key`, and `aws_secret_key`
    variables. Let''s write the code to inject these values to the `aws.rb` recipe.
    To begin with, let''s access our encrypted data bag item `us-east-1` from the
    `aws` data bag, using the inline shared secret `s3cr3t`:'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们看到模板期望`aws_region`、`aws_access_key`和`aws_secret_key`变量。让我们编写代码将这些值注入到`aws.rb`食谱中。首先，我们通过内联共享密钥`s3cr3t`访问加密的数据包项`us-east-1`，该数据包项位于`aws`数据包中：
- en: '[PRE50]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All of this information can be set as attributes if we like. If the file method
    is chosen for the shared secret, the final argument will be the path to the secret
    key file to decrypt the data.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果需要，我们可以将所有这些信息设置为属性。如果选择文件方法来共享密钥，最后一个参数将是解密数据的密钥文件路径。
- en: 'Now let''s create the template, writing the decrypted credentials to the `/etc/aws/credentials`
    file:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建模板，将解密后的凭据写入`/etc/aws/credentials`文件：
- en: '[PRE51]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here we are! The Chef server is now safely storing encrypted data. For added
    security, it's better to not hardcode the shared key—use the key file that is
    sent separately (but this creates an added layer of complexity in the deployment
    system).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了！现在，Chef服务器已经安全地存储了加密数据。为了提高安全性，最好不要硬编码共享密钥——使用单独发送的密钥文件（但这会在部署系统中增加复杂性）。
- en: There's more…
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: While using Puppet, it is a good practice to store the credentials and site
    information in Hiera, as we saw in [Chapter 6](ch06.html "Chapter 6. Fundamentals
    of Managing Servers with Chef and Puppet"), *Fundamentals of Managing Servers
    with Chef and Puppet*. Using `hiera-eyaml`, it is possible to encrypt sensitive
    data. Using our previous LAMP setup with Vagrant, let's try to encrypt the root
    password for MySQL.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Puppet时，最好将凭据和站点信息存储在Hiera中，正如我们在[第6章](ch06.html "第6章. 使用Chef和Puppet管理服务器的基础知识")，*使用Chef和Puppet管理服务器的基础知识*中看到的那样。使用`hiera-eyaml`，可以加密敏感数据。使用我们之前的LAMP设置和Vagrant，让我们尝试加密MySQL的root密码。
- en: Preparing the Puppet server
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备Puppet服务器。
- en: 'We need to install a new backend for Hiera. We have not discussed a lot about
    Hiera yet, and it''s time to do so. Hiera is used to store data out of manifests,
    and is based on a hierarchy to look up data. A default configuration is provided
    with the Puppet server installation and is located at `/etc/puppetlabs/puppet/hiera.yaml`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为Hiera安装一个新的后端。我们还没有深入讨论Hiera，现在是时候这样做了。Hiera用于将数据存储在清单之外，并基于层级结构查找数据。安装Puppet服务器时会提供默认配置，位于`/etc/puppetlabs/puppet/hiera.yaml`：
- en: '[PRE52]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, a `yaml` backend is defined, allowing us to use `yaml` files in the `hieradata`
    directory of our environments. Then, a hierarchy is defined. Puppet will first
    try to look up data in a `yaml` file with the name matching the name of the client
    certificate (that is, the FQDN node) and located under the `nodes` subdirectory.
    If no data is found, Puppet will try to look up a `common.yaml` file.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，定义了一个`yaml`后端，允许我们在环境的`hieradata`目录中使用`yaml`文件。然后，定义了一个层级结构。Puppet将首先尝试查找与客户端证书名称（即FQDN节点）匹配的`yaml`文件，并将其放置在`nodes`子目录下。如果没有找到数据，Puppet将尝试查找`common.yaml`文件。
- en: With `hiera-eyaml`, we need to declare a new backend to look up data in encrypted
    files. This backend is `eyaml`, and by default, we will look for files with the
    `.eyaml` extension. This backend relies on a key pair to read data, so we need
    to generate these keys.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`hiera-eyaml`时，我们需要声明一个新的后端来查找加密文件中的数据。这个后端是`eyaml`，默认情况下，我们将查找扩展名为`.eyaml`的文件。这个后端依赖于一对密钥来读取数据，因此我们需要生成这些密钥。
- en: 'Fortunately, a Puppet module, named `puppet/hiera`, exists to handle all of
    this for us. So we just need to add it to `Puppetfile` with its dependencies (do
    not forget to run `r10k puppetfile install`):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，存在一个名为`puppet/hiera`的Puppet模块来处理这一切。因此，我们只需将其与依赖项添加到`Puppetfile`中（不要忘记运行`r10k
    puppetfile install`）：
- en: '[PRE53]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'With this module, it is now very easy to prepare the Puppet server using the
    following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个模块，现在可以非常轻松地使用以下命令准备Puppet服务器：
- en: '[PRE54]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This piece of code will:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将会：
- en: Declare a service resource for the Puppet server. This is needed by the `puppet/hiera`
    module (see parameter `master_service`)
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Puppet服务器声明一个服务资源。这是`puppet/hiera`模块所需的（请参见参数`master_service`）。
- en: Install the `eyaml` backend in the Puppet server
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Puppet服务器中安装`eyaml`后端。
- en: Update the Hiera configuration in order to use this backend
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新Hiera配置以便使用这个后端。
- en: Generate the private and public keys
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成私钥和公钥。
- en: Restart the Puppet server
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重启Puppet服务器。
- en: Private and public keys will be respectively placed in `/etc/puppetlabs/puppet/keys/private_key.pkcs7.pem`
    and `/etc/puppetlabs/puppet/keys/public_key.pkcs7.pem`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 私钥和公钥将分别放置在 `/etc/puppetlabs/puppet/keys/private_key.pkcs7.pem` 和 `/etc/puppetlabs/puppet/keys/public_key.pkcs7.pem`
    中。
- en: Preparing the workstation
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作站
- en: 'To prepare the workstation, follow these steps:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备工作站，按照以下步骤操作：
- en: 'To create and edit encrypted data, we need `eyaml`. Let''s install it using
    the following:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建和编辑加密数据，我们需要`eyaml`。让我们通过以下命令来安装它：
- en: '[PRE55]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let''s copy the keys from the Puppet server and store them in a `keys` folder
    under `$HOME`:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从 Puppet 服务器复制密钥，并将它们存储在 `$HOME` 下的 `keys` 文件夹中：
- en: '[PRE56]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'For security reasons, it is a good idea to restrict access to the private key:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 出于安全原因，限制对私钥的访问是个好主意：
- en: '[PRE57]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We also need an `eyaml` configuration file, located in `~/.eyaml/config.yaml`,
    with this content (do not forget to adjust the path of your `$HOME` directory):'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个 `eyaml` 配置文件，位于 `~/.eyaml/config.yaml`，内容如下（不要忘记调整你的 `$HOME` 目录路径）：
- en: '[PRE58]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We are now ready to encrypt sensitive data.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备加密敏感数据。
- en: Securing the MySQL root password
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全地设置 MySQL 根密码
- en: 'From the command line, `eyaml` can encrypt values. Here is a session example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行，`eyaml` 可以加密值。以下是一个会话示例：
- en: '[PRE59]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Since the `eyaml` backend is looking for files with the `.eyaml` extension,
    we just need to create a `hieradata/nodes/web.pomes.pro.eyaml` file with the following
    content:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `eyaml` 后端正在寻找扩展名为 `.eyaml` 的文件，我们只需创建一个 `hieradata/nodes/web.pomes.pro.eyaml`
    文件，内容如下：
- en: '[PRE60]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'However, `eyaml` has a very handy feature—the `edit` mode—allowing us to create
    and edit encrypted values in plain text, based on the keys stored in the `$HOME`
    directory:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`eyaml` 具有一个非常方便的功能——`edit` 模式——允许我们基于存储在 `$HOME` 目录中的密钥，创建和编辑加密的明文值：
- en: '[PRE61]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This command will launch an editor, and we just need to enter the following
    content:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将启动一个编辑器，我们只需输入以下内容：
- en: '[PRE62]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: While saving, `eyaml` will write the file with the encrypted content for `root_password`.
    If needed, we can edit the file again and all the encrypted values will be automatically
    decrypted.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存时，`eyaml` 将写入包含加密内容的文件用于 `root_password`。如果需要，我们可以再次编辑文件，所有加密值将被自动解密。
- en: Note
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When editing with `eyaml edit`, all the new values should be contained in a
    `DEC::PKCS7[value]!` block. For existing values, `eyaml` will add an index called
    `num` to `DEC(<num>)::PKCS7[value]!` blocks. This index must remain unchanged.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `eyaml edit` 编辑时，所有新的值应包含在 `DEC::PKCS7[value]!` 块中。对于现有值，`eyaml` 将为 `DEC(<num>)::PKCS7[value]!`
    块添加一个名为 `num` 的索引。此索引必须保持不变。
- en: 'As our last step, we need to modify the main manifest to do a Hiera lookup
    in order to get the password:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们需要修改主清单文件，进行 Hiera 查找，以便获取密码：
- en: '[PRE63]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now the root password is encrypted in Hiera, and only people having the keys
    can recover it.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，根密码已经在 Hiera 中加密，只有持有密钥的人才能恢复它。
- en: See also
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The `hiera-eyaml` GitHub repository with its documentation at [https://github.com/TomPoulton/hiera-eyaml](https://github.com/TomPoulton/hiera-eyaml)
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hiera-eyaml` GitHub 仓库及其文档在 [https://github.com/TomPoulton/hiera-eyaml](https://github.com/TomPoulton/hiera-eyaml)'
- en: The `puppet-hiera` GitHub repository with its documentation at [https://github.com/voxpupuli/puppet-hiera](https://github.com/voxpupuli/puppet-hiera)
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`puppet-hiera` GitHub 仓库及其文档在 [https://github.com/voxpupuli/puppet-hiera](https://github.com/voxpupuli/puppet-hiera)'
- en: Using Chef Vault encryption
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Chef Vault 加密
- en: 'A different way of encrypting data is proposed through Chef Vault, and this
    does not require you to include the key somewhere in the code. The concept is
    elegant and simple: shared key encryption is done for each and every existing
    Chef node through their already existing client keys. This way, only the nodes
    allowed to access the data can decrypt it—each with their own private key—ensuring
    no clear-text shared keys are being sent, like with the classic encrypted data
    bag scheme.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种加密数据的方法是通过 Chef Vault 提供的，它不要求你将密钥包含在代码中。这个概念既优雅又简单：共享密钥加密针对每个现有的 Chef 节点进行，并通过它们已经存在的客户端密钥完成。这样，只有被授权访问数据的节点才能解密数据——每个节点使用自己的私钥——确保没有明文共享的密钥像经典的加密数据包方案那样发送。
- en: Getting ready
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To step through this recipe, you will need:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照这个步骤操作，你需要：
- en: A working Chef DK installation on the workstation
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作站上的 Chef DK 安装已就绪
- en: A working Vagrant installation on the workstation
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作站上的 Vagrant 安装已就绪
- en: The Chef code (optionally) from [Chapter 6](ch06.html "Chapter 6. Fundamentals
    of Managing Servers with Chef and Puppet"), *Fundamentals of Managing Servers
    with Chef and Puppet*, [Chapter 7](ch07.html "Chapter 7. Testing and Writing Better
    Infrastructure Code with Chef and Puppet"), *Testing and Writing Better Infrastructure
    Code with Chef and Puppet*, or any custom Chef code
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自[第6章](ch06.html "第6章。使用Chef和Puppet管理服务器的基础"), *使用Chef和Puppet管理服务器的基础*， [第7章](ch07.html
    "第7章。使用Chef和Puppet测试与编写更好的基础设施代码"), *使用Chef和Puppet测试与编写更好的基础设施代码*，或者任何自定义的Chef代码
- en: How to do it…
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'We''ll build on the previous, already existing, `mysite` cookbook; however,
    any other situation will work similarly. Instead of using the `us-east-1` item
    from the `aws` data bag, let''s create a new `eu-west-1` item, very similar to
    the other item for `us-east-1` in `data_bags/aws/eu-west-1.json`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在之前已有的`mysite`食谱基础上进行扩展；不过，任何其他情况也可以类似处理。我们将创建一个新的`eu-west-1`条目，类似于`data_bags/aws/eu-west-1.json`中`us-east-1`的条目：
- en: '[PRE64]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'As we know, the data will be encrypted for each and every running node''s public
    key. It means we have to filter hosts based on a search. I propose, that you search
    for every node using `search(*:*)`; however, feel free to limit to whatever is
    more secure or appropriate for you, such as tags or roles, like `search(tags:aws)`
    or `search(role:mysite)`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，数据将为每个运行节点的公钥进行加密。这意味着我们必须根据搜索来过滤主机。我建议你使用`search(*:*)`来搜索每个节点；然而，你可以根据自己的需要，限制搜索条件，以提高安全性或适应实际情况，比如使用标签或角色，例如`search(tags:aws)`或`search(role:mysite)`：
- en: '[PRE65]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Don't forget the `--mode "client"` option when executing with a Chef server
    like we do!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时别忘了`--mode "client"`选项，尤其是当使用Chef服务器时，就像我们一样！
- en: Accessing the encrypted vault from a cookbook
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从一个食谱中访问加密的Vault
- en: 'The companion to `knife vault` is the `chef-vault` cookbook. We''ll use it
    to easily access encrypted data in our recipe. If you''re using Berkshelf to manage
    dependencies, don''t forget to add the cookbook where required (either `metadata.rb`
    or `Berksfile`). In the `aws.rb` file, include the `chef-vault` recipe and set
    `aws` to the result of the `chef_vault_item` helper search:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`knife vault`的配套工具是`chef-vault`食谱。我们将用它来轻松地在我们的食谱中访问加密的数据。如果你使用Berkshelf管理依赖项，请不要忘记在需要的地方添加食谱（无论是`metadata.rb`还是`Berksfile`）。在`aws.rb`文件中，包含`chef-vault`食谱，并将`aws`设置为`chef_vault_item`帮助器搜索的结果：'
- en: '[PRE66]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If the node making the request isn''t allowed to decrypt the data with its
    private key, we''ll get an error. If the node can decrypt it, like we did previously
    with traditional data bags, the data will be available for use:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发起请求的节点没有权限用其私钥解密数据，则会出现错误。如果节点能够解密数据，就像我们之前使用传统数据包那样，数据就会可供使用：
- en: '[PRE67]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In the end, the `/etc/aws/credentials` file is populated with valid unencrypted
    data:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，`/etc/aws/credentials`文件会填充有效的未加密数据：
- en: '[PRE68]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Using Chef Vault, no shared key has ever transited in clear text, and only filtered
    and existing nodes can decrypt data that has been encrypted specifically for them.
    Much more can be done with this tool!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Chef Vault时，从未有任何共享密钥以明文形式传输，只有过滤后的和现有的节点才能解密专门为它们加密的数据。这个工具能做的远不止这些！
- en: See also
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The Chef Vault gem at [https://github.com/chef/chef-vault](https://github.com/chef/chef-vault)
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chef Vault宝石在[https://github.com/chef/chef-vault](https://github.com/chef/chef-vault)
- en: The Chef Vault cookbook at [https://github.com/chef-cookbooks/chef-vault](https://github.com/chef-cookbooks/chef-vault)
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chef Vault食谱在[https://github.com/chef-cookbooks/chef-vault](https://github.com/chef-cookbooks/chef-vault)
- en: Accessing and manipulating system information with Ohai
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ohai访问和操作系统信息
- en: A vast amount of information from a given system is available to Chef through
    Ohai. This program is executed during each Chef run and stores all of the gathered
    information in the Chef database to make it available right from the cookbooks.
    The kind of information gathered by default is quite large.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Chef通过Ohai可以获取大量来自系统的信息。这个程序在每次Chef运行时执行，并将收集的所有信息存储在Chef数据库中，使其能够直接在食谱中使用。默认情况下收集的信息量非常庞大。
- en: It ranges from networking details—such as link speed, MTU, or addresses—to all
    the memory usage details you'd find on a utility such as `top`, all of the imaginable
    data regarding filesystems or virtualization systems, or the list of every single
    installed package and logged-in users.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 它涵盖了从网络详细信息——比如链路速度、MTU或地址——到你在像`top`这样的工具上看到的所有内存使用详情，再到文件系统或虚拟化系统的所有可想象的数据，甚至包括每个已安装的包和登录用户的列表。
- en: On top of this, Ohai is a modular system with a lot of community plugins to
    integrate Dell DRAC information with support information related to a KVM, LXC,
    or XenServer.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: It can even be used to retrieve some specific data related to **Windows Management
    Instrumentation** (**WMI**). We obviously can write our own plugins, but that's
    way beyond the scope of this book.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: A working Chef DK installation on the workstation
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working Vagrant installation on the workstation
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Chef code (optionally) from [Chapter 6](ch06.html "Chapter 6. Fundamentals
    of Managing Servers with Chef and Puppet"), *Fundamentals of Managing Servers
    with Chef and Puppet*, [Chapter 7](ch07.html "Chapter 7. Testing and Writing Better
    Infrastructure Code with Chef and Puppet"), *Testing and Writing Better Infrastructure
    Code with Chef and Puppet*, or any custom Chef code
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a fresh and minimal installation of a CentOS 7.2 virtual machine, the `ohai`
    output is 5,292 lines long, which is full of information. To see it bit by bit,
    refer to the following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Alternatively, another solution is to redirect its content to a file so it''s
    easier to process with a dedicated tool:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'All of this information is also graphically available on the Chef interface
    when you select a node in the **Attributes** tab:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B05671_08_01.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
- en: Accessing Ohai information from a Chef recipe
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let''s access this information from a recipe. We''d like an `index.html`
    page with some of this information, so let''s edit the one we already have from
    the `apache` cookbook; however, you can start from scratch as well. We''d like
    this page to dynamically display something like this:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'All the information we need is stored somewhere in ohai: `platform`, `platform_version`,
    `os`, `os_version`, `ipaddress`, or `uptime` are all valid values. Let''s use
    them.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'In `apache/templates/index.html.erb`, add the following:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'To build something more interesting, as the platform name is available, let''s
    make our `apache` cookbook a bit more portable across Linux distributions. When
    running on Ubuntu, install the `apache2` package; else, install the `httpd` package.
    (This will have to be more precise to handle all the real cases.) In the `apache::default`
    recipe, make the following change so the `httpd` variable is set to `apache2`
    when running Ubuntu and to the default `httpd` elsewhere:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This is how we can start leveraging the use of the powerful `ohai` command in
    our Chef infrastructure.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The counterpart for Puppet is `facter`, which is installed with the Puppet
    agent. Like `ohai`, `facter` is a command-line tool:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: As for Chef, the `facter` information can be accessed from a Puppet manifest.
    Such information in the Puppet world is named **facts**.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting from Puppet 4.x, facts can be accessed from manifests using the `$facts`
    hash. Let''s try to create more portable lines of code for the `apache` module:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Note
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may find pieces of codes that are accessing facts using variables, such
    as `$osfamily` instead of `$facts['os']['family']`. This method works with previous
    versions of Puppet, but it is not obvious here that a fact is being used.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到一些访问事实的代码片段，使用变量，如 `$osfamily` 而不是 `$facts['os']['family']`。这种方法适用于旧版本的
    Puppet，但这里没有明显显示正在使用一个事实。
- en: See also
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: Ohai plugins at [https://docs.chef.io/plugin_com](http://ttps://docs.chef.io/plugin_com)[munity.html#ohai](http://munity.html#ohai)
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ohai 插件在 [https://docs.chef.io/plugin_com](http://ttps://docs.chef.io/plugin_com)[munity.html#ohai](http://munity.html#ohai)
- en: '[https://docs.puppet.com/puppet/4.8/lang_facts_and_builtin_vars.html](https://docs.puppet.com/puppet/4.8/lang_facts_and_builtin_vars.html)'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.puppet.com/puppet/4.8/lang_facts_and_builtin_vars.html](https://docs.puppet.com/puppet/4.8/lang_facts_and_builtin_vars.html)'
- en: Automating application deployment (a WordPress example)
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化应用程序部署（一个 WordPress 示例）
- en: Chef can also be used to deploy applications from code repositories. It combines
    one of the most complete, feature rich, and complicated Chef resources available—the
    `deploy` resource—and the various powerful and popular cookbooks, such as the
    `database` cookbook. We'll show you how to deploy a simple WordPress application
    right from the GitHub repository, creating a dedicated database and user as well
    as all the required dependencies. This builds on what has already been done previously,
    but the resources and cookbook shown here are made to be reusable anywhere.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Chef 也可以用来从代码仓库部署应用程序。它结合了最完整、功能最丰富、最复杂的 Chef 资源之一——`deploy` 资源——以及各种强大而流行的食谱，如
    `database` 食谱。我们将展示如何直接从 GitHub 仓库部署一个简单的 WordPress 应用程序，创建专用的数据库和用户，以及所有必要的依赖项。这在先前的基础上进行了扩展，但这里展示的资源和食谱可以在任何地方重用。
- en: Getting ready
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步执行此食谱，您将需要：
- en: A working Chef DK installation on the workstation
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作站上有一个可用的 Chef DK 安装
- en: A working Vagrant installation on the workstation
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作站上有一个可用的 Vagrant 安装
- en: The Chef code (optionally) from [Chapter 6](ch06.html "Chapter 6. Fundamentals
    of Managing Servers with Chef and Puppet"), *Fundamentals of Managing Servers
    with Chef and Puppet*, [Chapter 7](ch07.html "Chapter 7. Testing and Writing Better
    Infrastructure Code with Chef and Puppet"), *Testing and Writing Better Infrastructure
    Code with Chef and Puppet*, or any custom Chef code
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 [第 6 章](ch06.html "第6章：使用 Chef 和 Puppet 管理服务器的基础知识")，*使用 Chef 和 Puppet 管理服务器的基础知识*，[第
    7 章](ch07.html "第7章：使用 Chef 和 Puppet 测试和编写更好的基础设施代码")，*测试和编写更好的基础设施代码*，或任何自定义的
    Chef 代码
- en: How to do it…
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'As we''re going to deploy an application for MySite (maybe an engineering blog
    for the MySite company), let''s call this recipe `mysite::deploy`. Create the
    recipe like this from `chef-repo`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将为 MySite 部署一个应用程序（可能是 MySite 公司的工程博客），让我们将此食谱命名为 `mysite::deploy`。从 `chef-repo`
    中创建该食谱：
- en: '[PRE76]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Our next steps will be to include the Apache and MySQL dependencies, configure
    everything on MySQL so that WordPress can be installed, and finally deploy the
    WordPress code from GitHub.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的步骤将包括 Apache 和 MySQL 依赖项，配置 MySQL 以便安装 WordPress，并最终从 GitHub 部署 WordPress
    代码。
- en: Including dependencies
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包括依赖项
- en: 'A WordPress installation needs at least an HTTP server and a database. Start
    by including the known dependencies to the service we already have: an Apache
    virtual host and MySQL. Include them in `deploy.rb`:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 WordPress 安装至少需要一个 HTTP 服务器和一个数据库。首先，通过包括我们已经拥有的服务的已知依赖项来启动：一个 Apache 虚拟主机和
    MySQL。在 `deploy.rb` 中包含它们：
- en: '[PRE77]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Creating the application's database
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建应用程序的数据库
- en: 'Before we deploy anything, we need to create a database on our already running
    MySQL server with a dedicated WordPress user. There''s a wonderful cookbook meant
    just for this: the `database` cookbook. We''ll reuse this one very often. It gives
    access to many helpers for most use cases and most types of databases. According
    to the documentation, we''ll need to deploy a gem named `mysql2_chef_gem`, which
    fortunately comes with a dedicated cookbook as well. And finally, as we''re using
    MySQL, let''s make sure we depend on its official cookbook. Let''s include all
    of this information in our `mysite` cookbook''s `metadata.rb`:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们部署任何内容之前，我们需要在已经运行的 MySQL 服务器上创建一个数据库，并为 WordPress 创建一个专用用户。这里有一个专门用于此目的的精彩食谱：`database`
    食谱。我们将频繁重用这个食谱。它提供了许多帮助函数，适用于大多数用例和各种类型的数据库。根据文档，我们需要部署一个名为 `mysql2_chef_gem`
    的 gem，幸运的是，它也带有一个专门的食谱。最后，由于我们使用的是 MySQL，让我们确保依赖于其官方食谱。我们将所有这些信息包括在我们的 `mysite`
    食谱的 `metadata.rb` 中：
- en: '[PRE78]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'To build the `mysql2` gem using the cookbook''s new `mysql2_chef_gem` resource,
    we''ll need the MySQL development package named `mysql-community-devel`. Let''s
    add the following to our `deploy.rb` recipe:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The database cookbook created, among others, two useful resources for us: `mysql_database`
    and `mysql_database_user`. As we can guess by their names, they respectively help
    create MySQL databases and MySQL users. Let''s create the MySQL connection information
    variable so it can be reused in our two resources:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Note
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a proper `production` environment, we should use encrypted data bags for
    this matter, as seen in this chapter. We're trying to keep the code simple here.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can create our database named `wordpress` using the `mysql_database`
    resource:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Also, create a `wordpress_user` MySQL user with the password `changeme`. This
    will create the user and grant all the privileges to it:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: At this point, we should have everything we need related to the database.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an application from git or GitHub
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now on to application deployment! We know we want to deploy from `git`. Let''s
    make sure `git` is installed:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The `deploy_revision` resource is the most complex of all. It has a multitude
    of options, and a full chapter about it wouldn''t be enough. Let''s keep it simple
    here and refer to the complete online documentation for more complex uses. Let''s
    keep it simple here, and please refer to the very complete online documentation
    for more complex uses—because this resource is absolutely powerful and does wonders
    when properly manipulated. We know the following:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Our code is available at [https://github.com/WordPress/WordPress](https://github.com/WordPress/WordPress)
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to try the latest revision (`HEAD`) and keep the last five revisions
    to allow rollbacks
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our HTTP web server runs under the `apache` user
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The virtual host folder is inherited from an attribute set earlier (`/var/www/#{node['sitename']}`)
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's no database migrations to execute with WordPress
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `deploy_revision` resource is modeled after Capistrano and therefore comes
    from the Ruby on Rails world. But the concepts still apply to most languages,
    and it''s a good practice in production to create shared folders and symlinks
    for long-lasting configurations and files. It includes certificates, database
    configuration files, local assets, and so on. However, to keep the current deployment
    simple, we won''t use these right now, even though you''ll probably start looking
    into it as soon as you''ll need it. We''ll include the symlinks configuration
    and initialize them to nothing so the code is already present when the time arises.
    Here''s how all this ties together:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Once the code is applied, the `/var/www/mysite` (or whatever name you may have
    overridden) structure will change a little:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'There''s a `current`, `releases`, and `shared` folder. The `shared` folder
    contains everything that will last through the releases, including a cached copy
    of the current code. The `releases` folder contains all the stored releases. The
    `current` folder is itself a symlink to a specific release, which is the git commit
    SHA on GitHub (`72606bed348e61b6f98318cf920684765aa08b37`). Each subsequent release
    will be identified by its SHA indicating its unique identification and symlinked
    to `current` at the end of the deployment process. The number of kept releases
    is set by the `keep_releases` integer:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有 `current`、`releases` 和 `shared` 文件夹。`shared` 文件夹包含所有在发布版本之间保留的内容，包括当前代码的缓存副本。`releases`
    文件夹包含所有已存储的发布版本。`current` 文件夹本身是一个指向特定发布版本的符号链接，该版本是 GitHub 上的 git 提交 SHA（`72606bed348e61b6f98318cf920684765aa08b37`）。每个随后的发布版本将通过其
    SHA 标识，指示其唯一标识，并在部署过程结束时符号链接到 `current`。保留的发布版本数量由 `keep_releases` 整数设置：
- en: '[PRE86]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Once this code is applied to our node, if we navigate to `http://<node_ip>/current/`,
    we''ll see the WordPress setup page:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个代码应用到我们的节点，如果我们访问 `http://<node_ip>/current/`，就会看到 WordPress 安装页面：
- en: '![Deploying an application from git or GitHub](img/B05671_08_02.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![从 git 或 GitHub 部署应用程序](img/B05671_08_02.jpg)'
- en: 'To check whether the connection to the database is working correctly, type
    in all of the information from our Chef code:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查与数据库的连接是否正常，输入我们 Chef 代码中的所有信息：
- en: '![Deploying an application from git or GitHub](img/B05671_08_03.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![从 git 或 GitHub 部署应用程序](img/B05671_08_03.jpg)'
- en: And, job done! The WordPress installer says, **All right, sparky! You’ve made
    it through this part of the installation. WordPress can now communicate with your
    database. If you are ready, time now to... run the installer!**.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 干得漂亮！WordPress 安装程序说，**好样的，sparky！你已经完成了安装的这一部分。WordPress 现在可以与数据库通信。如果你准备好了，现在是...
    运行安装程序的时候了！**
- en: We're now basically able to deploy any WordPress installation from scratch,
    at will, and in seconds, again and again.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们基本上可以随时随地、反复无常地从零开始部署任何 WordPress 安装。
- en: Note
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Let''s insist again**:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**让我们再坚持一遍**：'
- en: Once you're comfortable with this, refer to the deploy resource documentation
    to discover everything this resource has to offer. It works wonders.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你熟悉了这个，参考 `deploy` 资源文档，发现这个资源能提供的一切功能。它效果非凡。
- en: There's more…
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: With Puppet, there is no deploy resource. However, Puppet Labs is providing
    a useful module—`vcsrepo`. With this module, we will be able to deploy a WordPress
    site from git.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Puppet 时，没有 `deploy` 资源。然而，Puppet Labs 提供了一个有用的模块——`vcsrepo`。通过这个模块，我们将能够从
    git 部署一个 WordPress 网站。
- en: 'Let''s reuse our Vagrant LAMP example in [Chapter 6](ch06.html "Chapter 6. Fundamentals
    of Managing Servers with Chef and Puppet"), *Fundamentals of Managing Servers
    with Chef and Puppet*. We just need to add the `vcsrepo` module to `Puppetfile`
    (do not forget to run `r10k puppetfile install`):'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 [第 6 章](ch06.html "第 6 章：使用 Chef 和 Puppet 管理服务器的基础")中重用我们的 Vagrant LAMP
    示例，*使用 Chef 和 Puppet 管理服务器的基础*。我们只需将 `vcsrepo` 模块添加到 `Puppetfile` 中（不要忘记运行 `r10k
    puppetfile install`）：
- en: '[PRE87]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now we are ready to modify the main manifest of the box, namely `web.pomes.pro`,
    to include the WordPress deployment. First, install the `git` package:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备修改箱子的主清单，即 `web.pomes.pro`，以包括 WordPress 部署。首先，安装 `git` 包：
- en: '[PRE88]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Then, create a database for WordPress:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为 WordPress 创建一个数据库：
- en: '[PRE89]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Also, update our virtual definition to change `DocumentRoot`:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，更新我们的虚拟定义以更改 `DocumentRoot`：
- en: '[PRE90]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'And finally, install WordPress from `git` and give rights to Apache:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，从 `git` 安装 WordPress，并赋予 Apache 权限：
- en: '[PRE91]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: See also
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: The `deploy` resource documentation at [https://docs.chef.io/resource_](https://docs.chef.io/resource_)[deploy.html](http://deploy.html)
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deploy` 资源文档，网址为 [https://docs.chef.io/resource_](https://docs.chef.io/resource_)[deploy.html](http://deploy.html)'
- en: The PuppetLabs `vcsrepo` module at [https://forge.puppet.com/puppetlabs/vcsrepo](https://forge.puppet.com/puppetlabs/vcsrepo)
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PuppetLabs 的 `vcsrepo` 模块，网址为 [https://forge.puppet.com/puppetlabs/vcsrepo](https://forge.puppet.com/puppetlabs/vcsrepo)
- en: The WordPress hardening guide at [https://codex.wordpress.org/Hardening_WordPress](https://codex.wordpress.org/Hardening_WordPress)
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WordPress 强化指南，网址为 [https://codex.wordpress.org/Hardening_WordPress](https://codex.wordpress.org/Hardening_WordPress)
- en: Using a TDD workflow
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 TDD 工作流
- en: 'TDD is a popular technique in development teams that consists of this: you
    begin by writing tests that will fail because no code is actually written and
    then write the code that will make these tests pass. This way, we ensure that
    the code we write is already tested, that it really covers the tested area; if
    some regression was to happen someday, it would be immediately noticed. Here,
    we''ll show a whole workflow, from development to production, where we deploy
    Docker on CentOS 7 and Ubuntu 16.04 using the TDD technique. Using Git branches,
    Chef tools, Test Kitchen, linting, and ServerSpec, we''ll go through each and
    every step of a small project led by TDD principles. We''ll do this to achieve
    maximum code quality among teams, from the development phase in the beginning
    to the final production environment.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: TDD（测试驱动开发）是开发团队中一种流行的技术，其包含以下步骤：首先编写测试，这些测试会失败，因为实际上没有编写代码，然后编写代码使得这些测试通过。通过这种方式，我们确保编写的代码已经过测试，并且真正覆盖了测试的范围；如果有某天出现回归问题，它会立即被发现。这里，我们将展示一个完整的工作流程，从开发到生产，我们将在
    CentOS 7 和 Ubuntu 16.04 上使用 TDD 技术部署 Docker。通过使用 Git 分支、Chef 工具、Test Kitchen、linting
    和 ServerSpec，我们将按照 TDD 原则的每个步骤进行一个小项目的开发。我们这样做是为了在团队中实现最高的代码质量，从最初的开发阶段一直到最终的生产环境。
- en: Getting ready
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行这个食谱，你需要：
- en: A working Chef DK installation on the workstation
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在工作站上安装一个可用的 Chef DK。
- en: A working Vagrant installation on the workstation
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在工作站上安装一个可用的 Vagrant。
- en: The Chef code (optionally) from [Chapter 6](ch06.html "Chapter 6. Fundamentals
    of Managing Servers with Chef and Puppet"), *Fundamentals of Managing Servers
    with Chef and Puppet*, [Chapter 7](ch07.html "Chapter 7. Testing and Writing Better
    Infrastructure Code with Chef and Puppet"), *Testing and Writing Better Infrastructure
    Code with Chef and Puppet*, or any custom Chef code
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chef 代码（可选）来自 [第 6 章](ch06.html "第 6 章：使用 Chef 和 Puppet 管理服务器的基础知识")，*使用 Chef
    和 Puppet 管理服务器的基础知识*，[第 7 章](ch07.html "第 7 章：使用 Chef 和 Puppet 编写更好的基础设施代码")，*使用
    Chef 和 Puppet 编写更好的基础设施代码*，或任何自定义的 Chef 代码。
- en: How to do it…
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何执行……
- en: 'Our goal is to start a new platform based on Docker. To do this, follow these
    steps:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是基于 Docker 启动一个新平台。为此，请按照以下步骤操作：
- en: 'Start by creating the `platform` cookbook:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从创建 `platform` cookbook 开始：
- en: '[PRE92]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Now create the empty `platform::docker` recipe:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个空的 `platform::docker` 食谱：
- en: '[PRE93]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Initialize a `git` repo if it''s not already done:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果还未初始化 `git` 仓库，请执行初始化操作：
- en: '[PRE94]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Add and commit whatever work is in the repository right now, if any:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果当前有任何工作内容，请添加并提交到仓库：
- en: '[PRE95]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Create a feature branch for we''re about to work on supporting `docker` in
    our platform:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们即将处理的 `docker` 支持创建一个功能分支：
- en: '[PRE96]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Infrastructure TDD – writing tests first
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基础设施 TDD —— 先编写测试
- en: Let's write our tests first so they will fail for sure, and we'll know we're
    building from there correctly.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先编写测试，以便它们肯定会失败，这样我们就知道我们是从正确的地方开始构建的。
- en: 'Create the ServerSpec integration folder inside the platform cookbook:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在平台 cookbook 中创建 ServerSpec 集成文件夹：
- en: '[PRE97]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Create `.kitchen.yml` at the root of the `platform` cookbook file with the
    following content. We''ll use Vagrant and simulate a Chef server with the `chef_zero`
    provisioner. We''d like our platform to work on both Ubuntu 16.04 and CentOS 7.2,
    and we want the entry point for our cookbook as its default recipe:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `platform` cookbook 文件的根目录创建 `.kitchen.yml` 文件，内容如下。我们将使用 Vagrant 并通过 `chef_zero`
    提供程序模拟一个 Chef 服务器。我们希望我们的平台能够在 Ubuntu 16.04 和 CentOS 7.2 上运行，并希望将 cookbook 的默认食谱作为其入口点：
- en: '[PRE98]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'As we''ve seen earlier in this book, create a helper script in the `serverspec`
    folder named `spec_helper.rb`:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 如本书前面所述，在 `serverspec` 文件夹中创建一个名为 `spec_helper.rb` 的助手脚本：
- en: '[PRE99]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Let''s start our test and see what is it we want to do according to our needs:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始测试，看看根据我们的需求，想要做什么：
- en: We want the `docker-engine` package to be installed
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望安装 `docker-engine` 包。
- en: We want the `docker` service to be enabled and started
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望 `docker` 服务能够启用并启动。
- en: We want a specific `docker` image to be pulled (that is, `sjourdan/terraform:0.7.10`)
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望拉取一个特定的 `docker` 镜像（即 `sjourdan/terraform:0.7.10`）。
- en: 'let''s write these tests in `docker_spec.rb`, in the `serverspec` folder:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `serverspec` 文件夹中的 `docker_spec.rb` 中编写这些测试：
- en: '[PRE100]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'This is good enough for our needs! Let''s launch our test environment by firing
    up `kitchen`:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经足够满足我们的需求！让我们通过启动 `kitchen` 来启动我们的测试环境：
- en: '[PRE101]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: We've failed successfully! Docker is neither installed, enabled, nor started,
    and no `docker` image is there.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功地失败了！Docker 既未安装，也未启用，也未启动，且没有 `docker` 镜像。
- en: Let's get to work.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始工作。
- en: Deploying Docker with Chef
  id: totrans-412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Chef 部署 Docker。
- en: 'There''s a very nice cookbook, which is extremely well-documented, that does
    everything we need ([https://github.com/chef-cookbooks/docker](https://github.com/chef-cookbooks/docker)).
    Let''s add it to `metadata.rb` so we depend on it:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Add it to Berkshelf as well if you plan to use it in `Berksfile`:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'As we''ll be writing our Docker code in the `platform::docker` recipe, let''s
    start by including it in the `default.rb` recipe:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The `docker` cookbook provides us with a new resource named `docker_installation`
    that does just this: install `docker`. There''s a myriad of installation options
    you can toy around with. Let''s keep it simple and install the current stable
    Docker version from Docker repositories (not from our Linux distribution). Add
    the following to the `docker.rb` recipe:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Execute `kitchen` again to apply our code and see whether the tests are passing
    or failing:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Good! What was failing a few minutes ago is now passing. It proves our action
    has fixed the problem, and we're on the right track. However, other tests are
    still failing, though.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the Docker service and start it using the `docker_service` resource
    the cookbook is offering us:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Execute `kitchen` again to apply our code and see what the tests say:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Good! The service is now tested and enabled and it is running. Let''s add this
    little requirement to have an image pulled right from the beginning, and we''ve
    chosen the Docker image `sjourdan/terraform` in its version 0.7.10:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Execute `kitchen` again to apply our new code and check whether the tests pass:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Our code seems to do exactly what our tests expected! Let''s destroy our testing
    environment:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Linting the code
  id: totrans-434
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s not forget to check how clean our code is with `cookstyle` from inside
    the `platform` cookbook:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: No offenses! Our code is clean. Let's move on.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: Supporting another platform
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s check whether this code would work on Ubuntu 16.04 as well. Wouldn''t
    it be awesome to have it working on both the current platforms with long-term
    support? Simply add the platform to the cookbook''s `kitchen.yml` file:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Launch `kitchen` again and check whether it works with Ubuntu 16.04 as well:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: We're now sure that our code supports Ubuntu 16.04 as well!
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: Team working using Chef and git
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that our `platform` cookbook works pretty well in our `docker_support`
    git branch, let''s commit that work. Start by verifying what''s not tracked:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Commit that work:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Is our `git` tree clean so that we can ship it to our team? Check this using
    the following code:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Then, let''s push it to our `git` repository (supposedly GitHub, but it might
    be anything):'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Now one of our coworkers can peer review the code and eventually merge `docker_support`
    with the `master` branch:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Our new cookbook is now ready for prime time and can be deployed to staging.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a more complex setup, it's highly recommended that you run those integration
    tests in a continuous integration system, such as Jenkins. These systems can integrate
    very well with services such as GitHub or GitLab and launch tests automatically
    after a push or pull request. This is an added value, ensuring quality in the
    process before shipping.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to staging
  id: totrans-458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let''s deploy this new platform cookbook to our staging environment. Let''s
    begin by making sure we have all the required cookbook dependencies:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Then, upload all the required cookbooks:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Use already existing environments, such as `staging`, and add our new `platform`
    cookbook version constraint to `environments/staging.rb` or any similar environment
    you''re using:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Update that environment using the `knife` command:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Check this code into `git`:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Add the platform cookbook to the target node''s run_list:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Wait for the next Chef run or run it yourself and Docker will be available on
    any node, including this recipe.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to production
  id: totrans-472
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Deploying to production at this stage is totally similar to shipping to staging;
    there''s no difference. The `environments/production.rb` file should now look
    like this:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Don''t forget to upload it to the Chef server:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Commit the changes to `git`:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Wait for the next Chef run or execute it yourself, and from now on, we''ll
    have a nice four-step workflow:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: Storing the TDD infrastructure code locally
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Peer reviewing and merging
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deployment to staging
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deployment to production
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, each time we're interested in testing or staging a new version of the cookbook
    that has passed steps 1 and 2, we just bump the cookbook's version number constraint,
    validating the results in the staging environment without impacting production,
    and finally deploy it in production whenever possible.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-485
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With Puppet, the same logic applies. In [Chapter 7](ch07.html "Chapter 7. Testing
    and Writing Better Infrastructure Code with Chef and Puppet"), *Testing and Writing
    Better Infrastructure Code with Chef and Puppet*, we introduced Beaker as an acceptance
    test tool. In a TDD workflow, we can first write acceptance tests in the `specs/acceptance`
    subdirectory of any module and then write the code itself.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: 'Using multiple `nodesets`, we can also ensure tests can be validated on multiple
    platforms. In [Chapter 7](ch07.html "Chapter 7. Testing and Writing Better Infrastructure
    Code with Chef and Puppet"), *Testing and Writing Better Infrastructure Code with
    Chef and Puppet*, we used only one platform (Ubuntu) in `spec/acceptance/nodesets/default.yml`.
    However, we can create as many as needed. Here is an example of a CentOS node
    that should be defined in `spec/acceptance/nodesets/centos-7-x64.yml`:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Using the environment variable `BEAKER_set`, it is then possible to specify
    on which platform the test needs to be run:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: And using git and r10k, the same team workflow applies. We first develop in
    a `test` branch. When all the tests have passed successfully, we merge them into
    the `production` branch and use r10k to deploy the code.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-492
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Docker chef cookbook at [https://github.com/chef-cookbooks/docker](https://github.com/chef-cookbooks/docker)
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning for the worse – train to rebuild working systems
  id: totrans-494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's one thing to get a full infrastructure finally managed by Chef—block by
    block, weeks after weeks, modification after modification—keeping the Chef run
    always smooth and working. However, it's something quite different to be able
    to rebootstrap a working system from scratch. What if the current setup that works
    perfectly well is in fact working because there's a script or a binary somewhere
    left from last year, which does the thing that makes it work? What if the application
    servers get corrupted tonight? If this happens, will we be able to rebuild it
    from scratch? If tomorrow our IaaS cloud provider crashes, in what timeframe will
    we be able to rebuild systems somewhere else (provided the backups are working;
    well, that's another story)?
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: Now our systems are as much as possible automated, hopefully 100 percent. It's
    important to know whether we'd be able to fully rebootstrap these systems in case
    of a disaster; if yes, how long it would take. You may be surprised when you collect
    some data and discover that many systems can be recovered in minutes. Compare
    this with the time it might take to find an outdated documentation, apply untested
    manual processes, and finally do whatever it takes to get something up and running
    under the pressure of an emergency. We'll all spend better nights and weekends
    if we know that all the system profiles are being continuously rebootstrapped
    successfully; in fact, why not use the CI system every night so every morning
    we would know whether the previous day's changes have impacted something. We,
    as a team, always know that we're ready to redeploy a system if required.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: A working Chef DK installation on the workstation
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working Vagrant installation on the workstation
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Chef code (optionally) from [Chapter 6](ch06.html "Chapter 6. Fundamentals
    of Managing Servers with Chef and Puppet"), *Fundamentals of Managing Servers
    with Chef and Puppet*, [Chapter 7](ch07.html "Chapter 7. Testing and Writing Better
    Infrastructure Code with Chef and Puppet"), *Testing and Writing Better Infrastructure
    Code with Chef and Puppet*, or any custom Chef code
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-502
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no single way to achieve our goal. We've already covered Test Kitchen,
    and this might be a good solution, especially if we have written extensive tests.
    Integrate this in the company's **Continuous Integration** (**CI**) system and
    this will do the job.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: 'A simpler and quicker solution can also be to just launch Vagrant boxes with
    the right Chef-provisioning profiles for each use case: `docker`, `webserver`,
    database server, or full deployment.'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refer to the Vagrant chapter of this book for more information about the Vagrant
    tool!
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: 'Our production servers are configured by the application of some Chef code,
    and currently, it does this job pretty well. Are we able to easily rebootstrap
    a similar CentOS 7.2 server from scratch to the point that it is similarly installed
    without any Chef or system error? Let''s find this out by including `Vagrantfile`
    at the root of the infrastructure repository, using the previous project code
    for deploying Docker (but the idea is the same for any kind of Chef repo). The
    minimum we can do is boot a fresh CentOS 7.2:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'We''d like to automatically install Chef on our temporary node, so let''s use
    the `vagrant-omnibus` plugin (remember, installing it is easy: `vagrant plugin
    install vagrant-omnibus`). Here''s the code to do this:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Let''s configure the Vagrant provisioning system to use Chef Zero in order
    to simulate a Chef server. We can also directly use a real Chef server; if we
    have one behind the firewall, it can be handy. We have to specify where is everything
    placed (cookbooks, environments, roles, and so on) with the added subtlety of
    a `nodes` folder that will be left empty in our case. Our virtual machine will
    run in the `production` environment and apply the `docker` role:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'We''re almost done! We need to tell the Vagrant Berkshelf plugin where to look
    for `Berksfile` and whether to enable it (installing the Berkshelf plugin is easy:
    `vagrant plugin install vagrant-berkshelf`). Here''s the code to do this:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Starting Vagrant at this point will just deploy everything from scratch:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'If the run succeeds, meaning the code from the Docker role is applied, we''re
    safe. Let''s destroy the VM:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Including this Vagrant command in our CI system will ensure this particular
    role will run flawlessly in this particular environment and with this particular
    system, and that potentially, it's a matter of three minutes and 30 seconds to
    recover from nothing to a working state.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: Multi-machine recovery
  id: totrans-520
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s move to a more complicated setup. Vagrant supports multi-machine setups,
    letting us define profiles for each one of them. In a previous example of this
    chapter, we deployed a WordPress installation with a database configured and the
    Apache web server configured as well, all with encrypted data bags and templates.
    We''ll implement the same idea, except that `Vagrantfile` will include multiple
    machine profiles: one to start a virtual machine only with the `webserver` role,
    another to deploy only the database part, and the third one to launch everything
    together, including the web application. So we''ll make sure all the parts of
    the final product can be redeployed from scratch (which is the main point).'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: 'All VM definitions will live inside the main Vagrant configuration:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Note
  id: totrans-524
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We suggest disabling the automatic start of VMs so we don't make the mistake
    of launching dozens of VMs by error.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure our code is capable of bootstrapping only the `webserver` role
    from scratch, we will need to do the following—setting paths for everything, including
    the specific `Berksfile` for the job:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'To launch only this box in order to make sure the `webserver` role can be deployed
    from scratch, use the following command:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'To make sure our code is capable of bootstrapping only the database part of
    this platform from scratch, just execute the `mysite::mysql` recipe in a similar
    context:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'To launch only this box in order to make sure the database recipe can be deployed
    from scratch, use the following command:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'To make sure our code is capable of bootstrapping the whole platform from scratch,
    we''ll have to simply execute the whole `mysite::default` recipe with one more
    step. One of the included recipes uses an encrypted data bag. It''s stored encrypted
    on the Chef server, but locally, our `./data_bags/` directory currently includes
    only the unencrypted JSON versions. We have to make sure another folder hosts
    the encrypted versions (maybe you already have one to store them on GitHub for
    example). Otherwise, import the encrypted version from the Chef server to a new
    directory, say, in JSON (using `-Fj`):'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Now we can define the full VM like the others with the modified data bag path
    for the encrypted version:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'To launch only this box in order to make sure the whole recipe is deployed
    from scratch, use the following command:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Put these commands (with their destroy counterparts) in the CI or whatever system
    you prefer at a regular interval, like daily or weekly, for each and every automated
    part of the infrastructure. With this, you'll always be certain you can redeploy
    the system when a disaster comes.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-541
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using Puppet, all the examples we used were based on Vagrant, and it is easy
    to rebuild nodes from scratch. But, in the real word, you probably won't deploy
    and maintain a production system running from Vagrant on your workstation.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: However, these examples show that it is possible to simulate a complete infrastructure
    using a simple `vagrant up` command, and therefore, it is easy to put it into
    any CI system to ensure you will be able to rebuild your production system easily.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
