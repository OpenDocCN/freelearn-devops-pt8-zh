- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using HashiCorp Configuration Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first chapter, we examined Terraform’s architecture. It is a simple command-line
    tool that takes in code and creates a plan that it can later execute at the user’s
    behest. In this chapter, we will examine how to leverage Terraform’s language—**HashiCorp
    Configuration Language** (**HCL**)—to define infrastructure as code so that we
    can build sophisticated cloud-based architectures using Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Resources and data sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locals and types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables and outputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meta arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loops and iterations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resources and data sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Resources and data sources play a critical role in Terraform and are probably
    the most important language constructs to understand as they allow you to access
    existing and create new resources.
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Resources are the most common block that you use when coding in HCL. The `resource`
    block is what Terraform is all about. You can think of each resource as a digital
    twin of something Terraform will provision in the real world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A block’s definition has three parts: the `resource`, the resource type is
    `random_string`, and the reference name is `foobar`. To create dependencies between
    resources, we use the reference name and type to access output values from the
    resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we create an Azure resource group by referencing the
    `foobar` random string’s output value, `result`.
  prefs: []
  type: TYPE_NORMAL
- en: Each resource within a Terraform provider is a tiny semi-independent computer
    program designed to manage a particular underlying system architecture. These
    resources define a schema that allows you to control the configuration of those
    underlying components. Sometimes, this schema is straightforward; at other times,
    it can be very complex, composed of primitive type attributes and additional custom
    block definitions nested within the resource block.
  prefs: []
  type: TYPE_NORMAL
- en: These nested blocks allow you to declare one or more sub-resources within a
    resource. The resource dictates the number of each type of nested block it expects.
    Sometimes, resources allow many instances of the same nested block, while at other
    times, they may allow precisely one.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the Azure Cosmos DB service allows you to create hyper-scale NoSQL
    databases and quickly set up replication across multiple geo-locations. Each geo-location
    is a nested block within the Cosmos DB `resource` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `geo_location` block is repeated multiple times within the
    `azurerm_cosmosdb_account` block. Each instance of the `geo_location` nested block
    tells this Cosmos DB account where to replicate the MongoDB databases and the
    failover priority.
  prefs: []
  type: TYPE_NORMAL
- en: Data sources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In its most primitive form, Terraform is about provisioning resources, but as
    we saw, there is a lot more to it than that. Once Terraform provisions the resources,
    then what? What happens when you provision a resource by some other means? Can
    you still reference it from Terraform? Resources create something new. Data sources
    access something that already exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data sources are less prolific but still play a critical role. First, they
    allow you to reference resources provisioned outside the current Terraform workspace
    no matter how they were provisioned—through a GUI, another automation tool, or
    another Terraform workspace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the resource, a data source block’s definition has three parts: the block
    type, the resource type, and the reference name. In the preceding example, the
    block type is `data`, the resource type is `azurerm_resource_group`, and the reference
    name is `bar`. To create dependencies between resources and data sources, we use
    the reference name and type to access output values from the data source just
    like we did with a resource, but we also need to prefix the reference with `data`
    to clarify to Terraform whether this reference is to a new item or an existing
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we create an Azure Storage account by referencing the
    `bar` Azure resource group’s output values: `name` and `location`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the core components that Terraform is responsible for
    (resources and data sources—something new and something old), let’s look at the
    data types we will use for internal and external data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Locals and types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After resources and data sources, the next most important thing to be familiar
    with is how to work with locals, which allow us to create internal variables and
    types that allow us to manipulate data within our Terraform solution.
  prefs: []
  type: TYPE_NORMAL
- en: Locals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Terraform allows you to perform sophisticated operations on a variety of types.
    Sometimes, it’s necessary to use intermediate values that store a calculated value
    you can reference across your code base. It’s essential to understand how to do
    this, and what data types are available when working with internal data inside
    a module and when defining the contract between your Terraform modules.
  prefs: []
  type: TYPE_NORMAL
- en: The `locals` block allows you to declare local variables. You can think of these
    as member variables in a class or local variables in a function, except they merge
    into one construct within the flattened scope of a Terraform workspace.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define a local variable anywhere in your HCL code simply by declaring
    a `locals` block and declaring and defining a local variable within it. You must
    specify a value when declaring a local variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code declares a local variable called `foo`. Terraform infers
    the type to be `string` simply by the use of double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can declare as many `locals` blocks as you want in any `.tf` file. As in
    other languages, you can nest local variables inside the value of other local
    variables. You can do this by using the `local` object prefix. Using the element’s
    type to reference it from elsewhere in the code is similar to referencing resources
    and data sources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It can be tricky to remember, but locals are always declared in a plural block
    name (`locals` versus `local`) and referenced in the singular, `local.*`. The
    mixture of singular and plural terminology can seem strange as most other blocks
    in Terraform are declared in a singular block and referenced in the singular.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By design, HCL supports a limited number of data types. This design encourages
    simplicity in your code and avoids overly complex logic around type conversion.
    In principle, you should avoid doing complex logic in HCL and rely on the consistent
    input-output model ingrained into Terraform’s modular architecture to do any heavy
    lifting outside of Terraform and pass in a known good value as input in one of
    the supported types.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are only three primitive types: `string`, `number`, and `bool`.'
  prefs: []
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While there are `number` and `bool`, their use or function is not very complicated.
    However, `string` can become very difficult very quickly. If you go spelunking
    in GitHub for HCL code, you will see a predisposition for complex string manipulation
    operations embedded in the code. Just because you can doesn’t mean you should.
    This is the way.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid complex string manipulation where possible, and when it is necessary,
    encapsulate it into a local value so that it can be easily output for testing
    purposes before you run `apply`.
  prefs: []
  type: TYPE_NORMAL
- en: String interpolation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`string` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we pass in two variables and concatenate them to
    construct the `Name` tag, commonly used by the AWS console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can declare a `local` that constructs the name and directly
    sets the tag with the value of the `local`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It simplifies our resource block for the AWS VPC by eliminating the string interpolation
    syntax (consisting of two double quotes, `"`, and two interpolation blocks, `${
    ... }`). It also creates a reusable `local` that we can use to tag our resources
    consistently. This can improve the readability and, ultimately, the maintainability
    of the code, especially if the string needs to be reused across multiple resources.
  prefs: []
  type: TYPE_NORMAL
- en: A string that spans multiple lines
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Depending on the provider and resource you use, sometimes you must embed large
    strings spanning multiple lines. Terraform uses a `heredoc` style of declaring
    multi-line strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: String content can be structured or unstructured. If HCL supports the structure
    of your string, you should consider using native syntax to represent the content.
    The most common cases of structured content embedded in HCL are JSON or YAML formatted
    strings because many cloud platforms have services that define their configuration
    schema that you must supply in either of these two formats. In this case, you
    should use the `jsonencode` or `yamlencode` functions to convert objects declared
    in native HCL into the appropriately formatted string. More on this later in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another consideration is if there is an excellent reason to maintain the content
    in its original string format. Here are a couple of situations where this might
    be the case:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Too large**: If the content is substantial and thus quite laborious to convert
    into HCL, it may not be cost-effective to do the conversion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collection types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'HCL supports only two collection types: `list` and `map`.'
  prefs: []
  type: TYPE_NORMAL
- en: List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you have done any development before working with Terraform or programming
    with HCL, you will no doubt be familiar with the concept of an array. Every programming
    language uses different syntaxes, types, and classes to represent this concept.
    A **list** is an ordered list of objects where items in that list can be accessed
    using the index of the desired item:'
  prefs: []
  type: TYPE_NORMAL
- en: '`string[] array = { "westus", "``eastus" }`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array := [``4]string{"westus", "eastus"}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array = ["``westus", "eastus"]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`var array = ["``westus", "eastus"];`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array = ["``westus", "eastus"]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice any similarities with any of the languages we’ve looked at? Python is
    the clear winner in the similarity contest. JavaScript is a close second—simply
    with some extra semi-colons and such.
  prefs: []
  type: TYPE_NORMAL
- en: 'As might be expected, items contained within an HCL list are accessed similarly
    across all of these languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The value of `a` would be `eastus`.
  prefs: []
  type: TYPE_NORMAL
- en: The `list` object type is fantastic for situations where we want to provision
    a corresponding resource for each item in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like the concept of an array, a map in HCL corresponds to another prevalent
    collection type that goes by many names in other programming languages. From `Dictionary`
    to `KeyValuePair` and back to `map`. They all share this concept of a key—guaranteed
    unique within the collection—and associated with a corresponding value. To look
    up the value, you don’t access it with its index within the collection; you can
    access it with the `key` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When we want to access the value for the particular network, we specify the
    region name we are using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The value of `a` would be `10.1.0.0/16`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This solution only works when the collection’s key is unique. In the preceding
    example, this allows us to quickly set up one network for every region we choose;
    however, with the current design, we cannot do that if we want to set up two networks
    for the same region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We can’t because adding a second entry for any region would produce an error.
    The error would be subtle. When we attempted to access `eastus` values in our
    `map`, only their last matching entry would come back. Therefore, it is the same
    as if `10.1.0.0/16` did not exist. Having such a discrepancy in your code and
    what Terraform provisions can lead to confusion and misaligned expectations, so
    remember that when working with `map`, you should reserve it for situations where
    the key is unique.
  prefs: []
  type: TYPE_NORMAL
- en: Complex objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HCL is not object-oriented; therefore, it does not have a mechanism for defining
    classes like other languages that represent complex types. However, it does support
    complex objects. It uses dynamic types, meaning Terraform will evaluate the object’s
    type at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamic typing** can be a blessing and a curse. It is a blessing because
    we don’t have to conform to strict structures of objects. If we need another attribute,
    we can quickly add it. It is a curse because it means we need an official source
    of truth for how the object should be structured, and we’ll have to rely on reference
    tracing when refactoring the structure of objects passed from one module or resource
    to another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Defining an object is as simple as declaring the object reference and setting
    it to the value of a block—as indicated by the `{` and `}` symbols. This block
    can contain any number of primitive types, collections, or complex objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we understand the data types that Terraform recognizes and how to
    use them to construct internal `local` variables, we can look externally to see
    how we can define the data contract between our module and the outside world:
    its inputs and outputs.'
  prefs: []
  type: TYPE_NORMAL
- en: Inputs and outputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, let's look at how to get data into and out of Terraform using input variables
    and outputs.
  prefs: []
  type: TYPE_NORMAL
- en: Inputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we learned in the previous chapter, Terraform operates within the context
    of a module. That module is scoped physically within a directory. The **root module**
    is a special case where its directory is the same as Terraform’s working directory.
    Whenever you are writing HCL, you are writing within the context of a module,
    whether the root module or some other module; therefore, you need to consider
    how to get data into your module and how to get data out of it.
  prefs: []
  type: TYPE_NORMAL
- en: Input variables are an essential design consideration because Terraform modules
    are simple machines that take inputs and produce outputs.
  prefs: []
  type: TYPE_NORMAL
- en: The input is all about what information the module needs to provision itself,
    and those inputs can come from wherever. As you design inputs, they should be
    atomic.
  prefs: []
  type: TYPE_NORMAL
- en: The module should be able to take the input without any additional manipulation
    or logic to parse the input variable’s value. You should parse the value outside
    of the module. That doesn’t mean that inputs can’t be complex objects or collections,
    but keeping the interface as simple as possible is a good idea. The more complex
    your inputs are, the more complex your module will be—whether it’s your root module
    or reusable modules that you share across workspaces.
  prefs: []
  type: TYPE_NORMAL
- en: Your root module will likely have the most complex inputs. Consider your input’s
    structure for root modules based on how you inject the parameter into the variable.
    If you use a variable file written in HCL, using complex types that span multiple
    lines, whether a list, a map, or a complex object, is effortless. However, suppose
    you plan to use a **Linux environment variable** or command-line argument method
    to pass in the parameter. In that case, you should reconsider using complex objects
    as inputs, as they can be challenging to troubleshoot and verify that you are
    getting the correct value into that input.
  prefs: []
  type: TYPE_NORMAL
- en: When you use Linux environment variables, it’s important to remember they are
    not very good at storing structured data with complex schema. The most complex
    schema you see in a Linux environment variable is some delimited text. `PATH`
    is an excellent example of this, as it is a delimited text value. You could use
    a delimited text value as an input variable to simplify injecting the value. The
    downside is that you’ll have to parse the value after you get it into Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of a root module, this could be desirable because it reduces the
    complexity of the interface of the two tools: Terraform and other executables.
    This sort of integration is widespread within automation pipelines where separate
    pipeline tasks execute different tools, and you pipe the output from one tool
    into the inputs of the other. Passing values into Terraform from the command-line
    interface is similar to how we pipe the outputs of one module into the inputs
    of another module. However, this is more seamless within Terraform because HCL
    can be used to transfer the value. In contrast, with command-line tools, you would
    need additional parsing steps to transform the value into the desired format for
    Terraform to consume quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we declare an input variable, `foo`, with a type of `string`
    and provide some guidance to the user of our module on how to use this input variable
    within `description`.
  prefs: []
  type: TYPE_NORMAL
- en: Sensitive data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, you may need to input sensitive data such as a password, connection
    string, or access key. You must annotate your input variables to ensure that Terraform
    knows not to display them in its output, as this can lead to secret leakage through
    the operational logs that Terraform emits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are annotating our super secret password with the
    `sensitive` attribute to prevent this secret from being output by Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Optional
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When building modules that can support many scenarios, you will often need to
    provide input variables to support the data needs of each scenario. Each supported
    scenario may only require a subset of the input variables to be specified. In
    this situation, we should make our input variable optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'For primitive types, you can accomplish this quite simply by setting the default
    value to `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we set `default` to `null`, allowing the user to ignore
    this input variable completely.
  prefs: []
  type: TYPE_NORMAL
- en: Setting an input variable to be optional can be more complicated when working
    with complex objects, as we may want the entire object or its attributes to be
    optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we declare a variable called `person`. Unfortunately,
    not only is it a non-optional input variable, but every attribute on the `person`
    object needs to be specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see whether we can loosen things up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, notice that adding `default = null` on the `person` variable
    block allows users of this module to ignore this input variable completely. Additionally,
    if the user supplies a `person` object, the `middle_name` attribute is not required.
    Now, the supported inputs are much more flexible for the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following value sets the entire object to `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following value sets the input variable to an object but omits the `middle_name`
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we set the input variable to an object and specify values for all attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to the inclusion of `default` and `optional` within our input variable
    declaration, all are equally valid parameter values for our module.
  prefs: []
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When creating modules you will use more broadly in your organization, consider
    adding some basic validations to your modules’ inputs. The `validation` block
    provides a way to add primitive data validation on incoming input variable values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding validation can significantly reduce apply-time failures that can plague
    your user if an input value has requirements from the underlying provider that
    may not be evident through your module’s interface. For example, a cloud platform
    may impose naming conventions on resources such as alpha-numeric only, all lowercase,
    less than 30 characters, and so on. Unless the consumer of your module is aware
    of the platform-specific constraints, they could encounter difficulties using
    your module as they attempt to figure out how to get the correct set of values
    as inputs—especially if your module abstracts the underlying cloud platform’s
    resources in any way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we specify a condition that checks that the length of
    the input variable is less than `30`. We could use any valid Boolean expression.
    We are good if it returns either `true` or `false`. We can use any number of functions
    that Terraform supports. However, prior to version 1.9.0 of Terraform, we can
    only reference the variable that the `validation` block lives on—meaning, we can’t
    reference other variables to create complex multi-variable input validation, nor
    can we make validation conditional on other elements declared within Terraform,
    be they other variables, resources, data sources, locals, or otherwise. This all
    changed in version 1.9.0 of Terraform, where input variable validation was opened
    up to referencing other blocks within the module. This allows you to implement
    much more sophisticated validation using locals and data sources that might be
    useful to verify inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Outputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Output variables are an essential consideration as well. It’s crucial to only
    output values that you will need. You should avoid putting unnecessary outputs—this
    is a pretty easy rule to follow within the root module. Still, when authoring
    reusable modules, it becomes more difficult because it is harder to predict what
    the consumer of your module will need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we declare an output called `foo` that returns a constant
    value of `bar`. While this example could be more practical, its simplicity will
    be instructive. Namely, that output values can be any valid expression in HCL.
    I draw your attention to this because you will no doubt encounter dozens of examples
    that output an attribute on a resource, but the output block is much more potent
    than that. Coupled with all the tools available within HCL—many that we’ll get
    into later in this chapter—you can construct any value you need. Knowledge of
    this capability is crucial in enabling you to smooth the edges between how you
    integrate Terraform and other tools.
  prefs: []
  type: TYPE_NORMAL
- en: It is a good practice to annotate your outputs with a `description` attribute
    to inform the consumer of your module (whether it is a user using your module
    via the command-line tool or from within another Terraform module) of what you
    intend the output to be and its purpose and what type of data they can expect.
  prefs: []
  type: TYPE_NORMAL
- en: Sensitive data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, you may need to output sensitive data such as a password, connection
    string, or access key. Most resources will define which attributes are considered
    sensitive, so Terraform will warn you if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we annotate our super secret password with the `is_sensitive`
    attribute to inform Terraform that this is not data that we would like it to shout
    to the world from the rooftops!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how to declare inputs and outputs within our Terraform
    modules and the basic structures—resources, data sources, and locals—that we work
    with so frequently, we are ready to move on to some more complex structures in
    the language. Our first stop is meta-arguments. Sounds fun, right?
  prefs: []
  type: TYPE_NORMAL
- en: Meta-arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Meta-arguments** are attributes that you can set on any resource block. They
    allow you to control different aspects of the resource related to its context,
    dependencies, and lifecycle. Each meta-argument enables finer-grained control
    over that resource by allowing the developer to give very focused resource-specific
    instructions to Terraform.'
  prefs: []
  type: TYPE_NORMAL
- en: Provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `provider` meta-argument is a reference that allows you to specify under
    which provider context you would like to deploy the resource. The scope of the
    context is dependent on the provider you are using. The two most common scopes
    are which region you are deploying to within a public cloud and what authentication
    credential you are using.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to understand the specific scoping mechanism of your providers.
    This book will use the `aws`, `azurerm`, and `google` providers. Each provider
    defines its scope differently. The scope of the AWS provider is an AWS account
    and an AWS Region. The scope for the GCP provider is a GCP project and a GCP region.
    The Azure provider is scoped only to an Azure subscription:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, when attaching to resources, if you do not specify the `provider` meta-argument,
    all the resources you declare will be provisioned by Terraform using the default
    `aws` provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When you want to provision to the `secondary` instance of the `aws` provider,
    you will need to declare it using the `provider` meta-argument on the `resource`
    block itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, when using AWS and GCP to do multi-region deployments, you will see
    the `provider` meta-argument to provision resources to different AWS and GCP regions.
    However, on Azure, you’ll only see the `provider` meta-argument to provision across
    multiple subscriptions—a very exotic deployment type.
  prefs: []
  type: TYPE_NORMAL
- en: Depends on
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, when Terraform is planning, it needs help to get the dependency
    graph right. That’s because Terraform can only detect explicit dependencies—but
    sometimes, you can have implicit dependencies, depending on the provider and the
    resource within that provider. These implicit dependencies occur when a resource
    requires another, but there is no direct relationship between the resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Implicit dependency between the Key Vault secret and Key Vault
    access policy](img/B21183_02_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Implicit dependency between the Key Vault secret and Key Vault
    access policy
  prefs: []
  type: TYPE_NORMAL
- en: 'A great example is whenever you use Azure Key Vault. You need permissions within
    the key vault itself before creating secrets. Therefore, by default, the identity
    running Terraform does not have access to create secrets within the key vault
    it just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will fail. You need to explicitly grant the identity that
    Terraform is running under access to Key Vault to create secrets. You can do this
    by adding an **access** **policy resource**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, after adding this access policy resource, my code still won’t
    work. When I run `apply`, it will tell in my code! Because there is no explicit
    dependency between the secret and the access policy, Terraform thinks that both
    can be created in parallel—thus creating a race condition that will inevitably
    fail when Terraform attempts to make the secret.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we need to make sure that we define the dependency of the secret
    on the access policy so that Terraform knows that it needs to create the access
    policy before we attempt to create the secret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: By explicitly declaring the dependency between the secret and the access policy,
    we will solve the problem in our Terraform plan that creates a race condition
    between them.
  prefs: []
  type: TYPE_NORMAL
- en: Lifecycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `lifecycle` meta-argument is a block that can appear on any resource block
    and is used to alter the control of that resource’s—well—lifecycle. That is the
    resource’s creation and deletion—the birth and death. Each option allows you to
    handle edge cases where you want Terraform to behave differently than usual.
  prefs: []
  type: TYPE_NORMAL
- en: Create before destroy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This situation reminds me of that classic movie scene from *Indiana Jones and
    the Raiders of the Lost Ark*, where Indy is in a booby-trapped Peruvian temple.
    To acquire the golden statue, he must replace it with something. First, Indy has
    to create a bag of dirt to replace the golden statue. Then, he must delicately
    replace the golden statue with it. The situation that our hero, Indy, finds himself
    in is the essence of `create_before_destroy`. In these situations, you need the
    new thing before you get rid of the old. There are many examples of this scenario.
    It can apply to certificates, security groups, and the like.
  prefs: []
  type: TYPE_NORMAL
- en: Lock resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For some resources, you don’t want to take the chance that a less-than-careful
    administrator will blow them away without thoroughly analyzing `terraform plan`—an
    unfortunately common occurrence. This situation is where `prevent_destroy` comes
    into play. By adding this meta-argument to your resources, you are adding yet
    another gate that the user must explicitly remove before they can destroy the
    resource. Many cloud services natively support this feature, but not all. Therefore,
    Terraform allows you to enable this feature within your HCL code on any resource
    vital to the environment’s health or may contain stateful data that you would
    lose in the case of destruction.
  prefs: []
  type: TYPE_NORMAL
- en: Ignore changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, Terraform is one of many tools that operate in an environment, or
    you want to allow manual administration of a particular feature after deployment.
    In this case, the `ignore_changes` option will enable you to provision the resource
    with Terraform but ignore changes made outside of Terraform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Ignore changes is an array of object references relative to the `resource` block
    you defined. You can imagine `this` before any reference within the list. You
    will get an error if you attempt to reference an external resource.
  prefs: []
  type: TYPE_NORMAL
- en: Replace triggered by
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many Terraform resources already know what circumstances should cause Terraform
    to trigger a replacement. The cause is usually a change in the value of a critical
    attribute. However, sometimes, there are situations where you want Terraform to
    replace the resource when another resource is updated or replaced. Often, this
    can happen when there is no direct dependency between the resources, making it
    difficult for Terraform to determine that a destructive action is taking place.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, with an Azure Virtual Desktop host pool, the host pool and its
    **virtual machines** (**VMs**) are declared independently. Still, they are associated
    with a third resource called a VM extension that will initiate the joining of
    the VM with the host pool. In this scenario, Terraform knows about the VM’s relationship
    with the VM extension and the VM extension’s relationship with the host pool.
    Still, because you create the host pool’s relationship with the VM through an
    attribute in the VM extension, it does not cause a replacement if it is updated.
    Therefore, the VM will never be reattached to the host pool if it changes:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.2 – Implicit dependency between the host pool and VM prevent\uFEFF\
    s Terraform from replacing the VM if the host pool changes](img/B21183_02_2.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Implicit dependency between the host pool and VM prevents Terraform
    from replacing the VM if the host pool changes
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how to modify Terraform’s default behavior using meta-arguments,
    we can handle better edge cases specific to the cloud resources we plan on provisioning
    with whatever providers we want to use. Now, it’s time to scale things up by learning
    to turn Terraform into a resource factory—pumping out complex configurations without
    all the copypasta!
  prefs: []
  type: TYPE_NORMAL
- en: Loops and iterations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are three different ways to iterate within HCL. The most common are two
    meta-arguments, `for_each` and `count`, which operate on a resource, module, or
    data source block. At the same time, the third option uses the `for` expression,
    which operations on any collection.
  prefs: []
  type: TYPE_NORMAL
- en: Count
  prefs: []
  type: TYPE_NORMAL
- en: 'The `count` meta-argument is Terraform’s oldest method of iterating resources:
    an oldie but a goodie. The `count` meta-argument is excellent when you want to
    provision the same block multiple times and have no unique identifier to key off
    of. In this situation, you will use the item’s index in a list to determine its
    uniqueness. This approach can pose challenges in the future if the items in the
    list need to change in such a way that would cause the indices of each item to
    change.'
  prefs: []
  type: TYPE_NORMAL
- en: The best way to manage this is to treat your list as append-only, as this will
    avoid replacing related resources. Adding or removing items from the middle of
    the list will cause all the items below that item to shift their index, resulting
    in destruction and recreation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you want to provision a five-node cluster, you wouldn’t remove
    a specific node from the cluster when you scale down. You would reduce the number
    of nodes. You don’t care which nodes get removed. You only care how many there
    are. In this situation, it is ideal to use `count`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: For each
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An alternative to `count` is the `for_each` meta-argument, which allows you
    to create multiple blocks from a `map` collection. This approach can be a distinct
    improvement over the `count` technique because the order of the items in the collection
    does not matter—only the key. If you update the code to remove the key, Terraform
    will remove the corresponding item. If the item changes order with other items
    in the collection, it will not affect Terraform’s plan.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is only possible with a `map` collection as the source of the
    iteration because, with a `map` collection type, each item must have a key that
    uniquely identifies it amongst its peers.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, using `for_each` works well when deploying to multiple regions
    as, typically, you wouldn’t have more than one deployment in the same region;
    hence, the region name makes an excellent unique key for the `map` that drives
    the `for_each` loop. You can add or remove regions without worrying about shifting
    the index of the items in the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the preceding `map` configuration. Using this as the collection, we
    can drive any number of resources, data sources, or modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we see that we are setting the `for_each` source to be
    the map stored in `local.regions`. We then can use the `each` prefix anywhere
    within the module block to access either the key or the value using `each.key`
    and `each.value`, respectively. No matter the value’s type, we can address it
    how we normally would, using `each.value` as a reference to the object.
  prefs: []
  type: TYPE_NORMAL
- en: For expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `for` expression is a way of iterating within Terraform that does not require
    you to attach it to a block (i.e., resource, data source, or module). You can
    use the `for` expression to construct in-memory objects to apply object transformations
    to streamline block-based iteration or for output.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over a list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When iterating over a `list`, you must specify only one parameter to the `for`
    expression. This parameter will represent each item within your `list` so that
    you can access each item within the output block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are iterating over all the objects in `var.regions`.
    As we do, during each iteration, the current value is accessible in the `s` parameter.
    We can use the output block to generate any object we desire to be created in
    the new list that this `for` expression will create.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over a map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When iterating over a `map`, you must change how you structure your `for` expression.
    You must specify two instead of one parameter declared immediately after the `for`
    keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, you’ll see that we specify two parameters for the
    `for` expression: `k` and `v`. We chose these names as a convention to help us
    remember what these variables mean within the scope of the `for` expression. `k`
    represents the map’s key, while `v` represents the value. The value can be any
    type, be it a primitive, collection, or complex object. If we want to access the
    `value` object, we access it based on its type. In this example, the value is
    a complex object with two attributes. In the `for` expression’s output block,
    we specify the structure of the object we want each item in the resulting array
    to have.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we are creating an array of objects with three attributes: `region`,
    `address_space`, and `node_count`, essentially flattening the original map into
    an array of objects. The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Outputting a list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `for` expression will always output either a `list` or an object. You can
    select the output type you want by the character in which you wrap the `for` block.
    If you wrap the `for` expression in square brackets, then the expression will
    output a `list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `for` expression will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, the names of the module or resource outputs don’t align precisely
    with other resources’ desired inputs. Therefore, using a `for` expression and
    outputting a list can help transform these incongruent output values into a format
    convenient for consumption within another part of your code.
  prefs: []
  type: TYPE_NORMAL
- en: Outputting an object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Wrapping the `for` expression with curly braces will output an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach will output an object with attributes for each item in the list
    of regions in the `regions` input variable. Each attribute will take the name
    of the concatenation of the region and country names, and its value will be an
    object with a single attribute called `node_count`. The output will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Outputting an object can be very useful in scenarios where you need to generate
    a JSON or YAML payload. You can reference this payload in another resource or
    output it so another tool can extract that value from Terraform using the `terraform`
    `output` command.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a list to a map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One common problem is converting a list into a map. This is needed because,
    while a list is sometimes the most concise way of storing a simple collection,
    it cannot be used with the `for_each` iterator. Therefore, if you want to have
    your cake and eat it too, you need to convert that list into a map. This can be
    done with a simple `for` expression that iterates over the list in memory and
    outputs a map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are invoking the `for` expression and outputting an
    object using curly braces (`{}`). We are taking each element within the list and
    setting it as the key of our `map` and taking the element’s index within the `list`
    and setting it as the value. It’s important to note that this will only work when
    the items in the `list` are not duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to loop, swoop, iterate, and cross-mojinate, we can avoid
    the pitfalls of copypasta by leveraging Terraform’s three extremely powerful iterators—`count`,
    `for_each`, and `for`—to build dynamic collections of resources, data sources,
    or anything really!
  prefs: []
  type: TYPE_NORMAL
- en: We are nearing the end of our journey into the depths of HCL. Next, we will
    look at a few more language expressions that help us cope when we want to use
    dynamic collections and conditional logic to jazz up our modules!
  prefs: []
  type: TYPE_NORMAL
- en: Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HCL has some unique expressions to handle complex scenarios such as conditional
    logic, referencing dynamic types, and iterating nested blocks. We will learn about
    these final language structures before we delve into the library of functions
    available to us within the language.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In other languages, this technique is called a ternary conditional operator—namely,
    of the imperative variety. That’s fancy talk for an `if` statement in HCL. Typically,
    an `if` block spans multiple lines of code and uses some method for scoping the
    two conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This classic example shows how a conditional statement manifests in an imperative
    language. The curly brackets provide scope for the code that the computer will
    execute when the Boolean expression is `true` or `false`. In imperative code,
    you can do anything inside these scoped regions.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between this approach and using a **ternary conditional operator**
    is that, with the former, the goal is always to produce a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a ternary conditional operator, each condition must return a value. Consider
    the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding expression will set the value of `y` to be `50` when `x` is `5`,
    and it will set the value to `0` for any other value of `x`. The equivalent imperative
    code would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The difference between this imperative alternative and the ternary conditional
    operator statement is that the developer can do other things in the scope regions
    that are either related or unrelated to setting the value of `y` appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Splat expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `count` or `for_each` meta-argument attached:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this collection of AWS EC2 instances. This block uses the `count`
    meta-argument to create a dynamic number of these resources from `0` to `n`, where
    `n` is the value of `var.node_count`. As a result, we can’t just access output
    values from this resource like we usually would if it were singular. We need to
    access it using an index to specify which instance of the `resource` block we
    want to access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we specify the index of `0` and access its `id` attribute. But
    what if we wanted to get all of the values of `id` for every EC2 instance simultaneously?
    Using a `for` expression, we could iterate over the list of `aws_instance` resources.
    However, there is a better way—using the splat expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Using `*` instead of an actual numeric index tells Terraform that we want to
    activate a splat expression. Instead of accessing a single object, we want to
    access all the objects in the array. Once done, `id` returns a `list` containing
    all the `id` values for our EC2 instances.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We know that Terraform represents the objects it provisions as `resource` blocks,
    which, as we know, support nested blocks within them. When a nested block supports
    many instances, it can sometimes be helpful to declare them dynamically using
    an approach called `resource` block based on a collection of objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take the example of our Cosmos DB account that needs to replicate its
    databases across multiple geo-locations. We can add as many `geo_location` nested
    blocks as we want and configure them accordingly, but this can get tedious—especially
    if the configuration for each block is relatively uniform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We can accomplish the same thing using a dynamic block. Suppose we declare
    a map that defines the regions we want to replicate across and the failover priority
    of each region. In that case, we can use this map to drive a dynamic block that
    sets up our Cosmos DB account correctly—and concisely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, with the `map` configured with our replication region settings, we can
    use a dynamic block to instruct the Cosmos DB resource on how to set up its `geo_location`
    nested blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `geo_location` becomes a reference to each item in `local.regions`
    as we iterate through it, and because `local.regions` is a `map`, that means that
    `geo_location` is an item within this `map`. That means that each `geo_location`
    is a key/value pair, and we can use `key` and `value` to access the respective
    values when we set `location` and `failover_priority` on the `content` of the
    nested block.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! We have completed all the concepts, syntax, and modifiers within
    HCL. We are ready to start rocking the Terraform world, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Hold up—before we do that, let’s pack our **bat belt** with tools to help us
    out of many tricky situations: functions!'
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HCL includes dozens of functions that you can use to help develop your infrastructure
    with Terraform. However, I don’t plan on draining the ocean on every single function
    because I think many of them cover concepts that are outside the scope of this
    book. I will focus on the most pertinent and practical functions of developing
    excellent cloud infrastructure. Another exciting new feature that is available
    in Terraform 1.8.0 is the introduction of provider-specific functions. This allows
    provider authors (e.g., `aws`, `azurerm`, etc.) to create functions that provide
    useful functionality that is specific for that provider. This could be for common
    utilities such as parsing and AWS ARN or an Azure Resource Identifier.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Numeric functions operate on objects of the `number` type. The usual suspects
    are present—everything from absolute value, ceiling/floor, min/max, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Given that these functions cover fundamental concepts in math, they are primarily
    outside the scope of this book. I’d encourage you to check out the excellent documentation
    provided by HashiCorp on these functions.
  prefs: []
  type: TYPE_NORMAL
- en: String functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: String functions operate on objects of the `string` type. Like the numeric functions,
    the usual suspects are present.
  prefs: []
  type: TYPE_NORMAL
- en: There are several functions related to string manipulation, such as `split`,
    `replace`, and `join`.
  prefs: []
  type: TYPE_NORMAL
- en: Split
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `split` function can be helpful when working with comma-delimited values
    that you might pass in as input variables. You can use input variables of the
    `string` type to pass in a collection of values. Using environment variables or
    command-line arguments makes it difficult to reliably pass in complex structures
    such as `list`, `map`, or `object`. Therefore, it is widespread to simplify those
    complex structures into multiple comma-delimited `string` input variables.
  prefs: []
  type: TYPE_NORMAL
- en: Several functions are used for cleansing data of unnecessary whitespaces, which
    can occur when you do string manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: Format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `format` function can be a cleaner way to perform string manipulation without
    really nasty string interpolation—which can degrade the readability of your code
    with all the extra `${}` symbols added to separate object tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'You can replace the preceding code with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `fizz`, `buzz`, and `wizz` values are passed into the corresponding `%s`.
    The `%s` symbol is a token to inject values passed in with specific formatting
    instructions. There are different verbs for different data types and formatting
    options.
  prefs: []
  type: TYPE_NORMAL
- en: A variant of this function called `formatlist` does the same thing but operates
    on `list(string)`. It is a convenience function that avoids the additional complexity
    of wrapping a `format` function in a `for` expression.
  prefs: []
  type: TYPE_NORMAL
- en: Replace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `replace` function is another commonly used string function. Many cloud
    services have particular requirements for naming conventions, so `replace` is
    very useful when you want to cleanse your names of invalid characters when naming
    conditions are incongruent across different services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, Azure Storage accounts do not allow hyphens in their names, while
    Azure resource groups do. Therefore, if you pass in an input variable to set a
    common prefix across all your resources and include a hyphen, you will run into
    trouble when Terraform attempts to provision the Azure Storage account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Replace can be used to eliminate this naming convention faux pax quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Collection functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Collection functions are an assortment of functions that let you work with objects
    of the `list` or `map` type. These contain everyday set-based operations, Boolean
    checks, and accessors.
  prefs: []
  type: TYPE_NORMAL
- en: Length
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `length` function is probably the most common collection function. It is
    often used with the `count` meta-argument as it provides a simple and dynamic
    method for obtaining the number of items in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we calculate the number of fault domains using the `length`
    method on the `fault_domains` list. This approach will produce a value of `5`
    for the `fault_domain_count` local variable.
  prefs: []
  type: TYPE_NORMAL
- en: Range
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `range` function can be useful for taking a count and creating an array
    of indices for them. There are three overloads, but the most useful of the overloads
    is the one that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This overload of the `range` function takes a `start` number and a `limit` number.
    This capability is helpful because cloud platforms often have deployment boundaries
    that are important to how we structure our architecture. These boundaries significantly
    impact the resiliency of our architecture—such as regions, Availability Zones,
    fault domains, and so on—so we must take them seriously.
  prefs: []
  type: TYPE_NORMAL
- en: A common problem we face when working within and across these boundaries is
    that our deployments often need to be very specific about which area to target
    within a boundary. For example, I need to specify that my subnet is in Availability
    Zone 2 or that my VM needs to be in fault domain 3.
  prefs: []
  type: TYPE_NORMAL
- en: The problem arises because cloud platforms often don’t have a uniform or consistent
    way of telling us the domain of values for a particular boundary. For example,
    rather than giving us a list of *Availability Zone 1*, *Availability Zone 2*,
    and *Availability Zone 3*—the values we need to target our resources to the target
    area correctly—the cloud platform might give us a more cryptic *“This region has
    5 Availability Zones, Good Luck!”*. When we need to be specific, they are generic.
    This incongruence does not produce ideal outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: If we are hardcoding our resources, this would be fine. Still, when you want
    to provision to a dynamic list of Availability Zones, which allows you to iterate
    across the list of Availability Zones and provision some resources to each, you
    need to somehow convert a range into a discrete list of elements such that you
    can align each item in that list. Queue the music; here comes `range` to the rescue!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, let’s pretend the cloud platform provided the hardcoded
    number of fault domains. We need to create a list that we can iterate across to
    provision a VM to each of the fault domains. Thanks to `range`, we can produce
    the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding list, we can quickly iterate to create a VM in the correct
    subnet using the `count` meta-argument and the length of the `fault_domains` list.
  prefs: []
  type: TYPE_NORMAL
- en: Flatten
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `flatten` function can be helpful when you have homogenous data elements
    stored within different arrays. This situation might occur when you have a module
    return a collection of sub-resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – The Network module; each produces its list of subnets that you
    need to aggregate into a single list of subnets](img/B21183_02_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – The Network module; each produces its list of subnets that you
    need to aggregate into a single list of subnets
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, we can see that we have a module that provisions a
    network. This module outputs a list of subnets. Often, we want a module to encapsulate
    relevant sub-resources that are tightly coupled with the primary resource of the
    module. While this approach makes the code more maintainable, it also creates
    difficulties upstream if we want to act uniformly across all the sub-resources
    it outputs.
  prefs: []
  type: TYPE_NORMAL
- en: With `flatten`, we can collapse the list of lists into a single flattened list
    with each subnet as an item. Doing so will enable us to work uniformly with all
    of the subnets from the consuming module we are developing.
  prefs: []
  type: TYPE_NORMAL
- en: Transpose
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `transpose` function is also beneficial when working with hierarchies of
    objects with complex relationships with their children:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Resource VMs associated with a collection of security groups](img/B21183_02_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Resource VMs associated with a collection of security groups
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the preceding diagram, two VMs are associated with a collection
    of security groups. We have set this up as a `map` collection in this situation.
    The key would be the VM and the value of a collection of security groups.
  prefs: []
  type: TYPE_NORMAL
- en: This `map` works excellently when we want to iterate over the top-level object—the
    VMs—but what if we’re going to iterate over the child objects, the security groups?
    We flip this relationship upside down using the `transpose` function on this map!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Security groups associated with a collection of VMs](img/B21183_02_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Security groups associated with a collection of VMs
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows that instead of having the top-level object be the
    VM, it’s now the security groups. The `transpose` operation has also replaced
    child objects with VMs. However, you’ll notice that the function has maintained
    the relationships between parent and child—we’re just looking at the relationship
    through a different lens.
  prefs: []
  type: TYPE_NORMAL
- en: Zipmap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `zipmap` function is handy when you have two `list` objects, one containing
    the keys and the other containing the corresponding values. Both list corresponding
    items in the same index, and the lists must be the same length.
  prefs: []
  type: TYPE_NORMAL
- en: 'The name is interesting as it is an attempt at word painting. Imagine the construction
    of a zipper: two independent but parallel lists of notches, but when the zipper
    is applied sequentially, each notch on the left side is attached to the corresponding
    notch on the right side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – VMs list and a corresponding security group list](img/B21183_02_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – VMs list and a corresponding security group list
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, we have two lists, one containing VMs and another
    containing security groups. With the `zipmap` function, we can create a new `map`
    object that creates an association between each element in the VM and security
    group lists.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Encoding functions let you work with text of various encoding formats and convert
    back and forth between them. These include string-based operations such as Base64
    and string-to-object encoding formats such as JSON and YAML.
  prefs: []
  type: TYPE_NORMAL
- en: Many services will often require input data to be encoded in Base64 to simplify
    the transmission of complex data, and the two corresponding `encode` and `decode`
    functions work as you would expect them.
  prefs: []
  type: TYPE_NORMAL
- en: The JSON and YAML `encode` and `decode` functions work like typical serializers,
    with the `encode` functions taking in an object and producing a string—while the
    `decode` functions take in a string and produce an object.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Filesystem functions provide a set of utilities that make it easier to work
    with local files, which can come in extremely handy if you need to drop a config
    file for the next step in your automation pipeline or if you need to access files
    containing content needed for resource provisioning.
  prefs: []
  type: TYPE_NORMAL
- en: File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `file` function simply loads the contents from the file at the specified
    path on the disk into a string. The `path.module` special variable is used to
    specify the current working directory of the current module. This is useful during
    module development because it allows you to embed and use files to store content
    needed within your module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is commonly used in conjunction with the `jsondecode` and `yamldecode`
    functions to take the string content and convert it into an object that can be
    used more easily within HCL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Template file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `templatefile` function works just like the `file` function but with a
    twist. It allows you to pass in parameters to be replaced with corresponding placeholders
    in the file specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The parameters of `hostname` and `ip_address` indicate the tokens that should
    be replaced in the file with their corresponding values, `foo` and `10.0.1.8`,
    respectively. If the contents of the file contain the `${hostname}` or `${ip_address}`
    tokens, they will be replaced with the corresponding value. This can be a very
    convenient way to drop important configuration details into your infrastructure
    that is only available after Terraform has executed its plan.
  prefs: []
  type: TYPE_NORMAL
- en: Date/time functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Date/time functions provide a set of utilities for creating timestamps. These
    functions can help set expiration dates for short-term access tokens or transform
    a date/time string into the correct format expected by the specific resource you
    use.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with time in Terraform, it’s important to note that there is no
    explicit date/time type. Terraform handles date/time values using the `string`
    type. The default format that Terraform uses is the RFC 3339 format, which looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding value has the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This behavior is essential to understand because all the date/time functions
    that are available will either take in or produce a timestamp in this format.
  prefs: []
  type: TYPE_NORMAL
- en: Hash/crypto functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like the encoding functions, there are several options when it comes to
    hashing and cryptographic functions. These functions implement a variety of hashing
    algorithms such as MD5 and SHA and encryption algorithms such as RSA. There are
    also corresponding file-based operations that allow you to read content from a
    file.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to remember that hashing is not the same thing as encryption
    and that when using encryption, you should secure the keys you use both inside
    and outside of the Terraform state.
  prefs: []
  type: TYPE_NORMAL
- en: IP network functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The IP network functions make it easier to work with CIDR blocks to split address
    spaces into subnets.
  prefs: []
  type: TYPE_NORMAL
- en: Although Terraform’s networking functions support IPv4 and IPv6, we’ll look
    at IPv4 addresses in our examples to make it easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: An IPv4 address is a 32-bit value with 4 octets and 8 bits per octet. We construct
    CIDR blocks to identify a range of IP addresses to allocate to a virtual network
    or a subnet within that virtual network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Terraform has the `cidrsubnet` function, which calculates these CIDR block
    ranges, making it easier to generate CIDR block ranges dynamically rather than
    hardcoding them or using string manipulation to construct them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The `prefix` argument is the network space you want to split up. The `newbits`
    argument is how big we want the chunks that the prefix splits into to be—its value
    has an inverse relationship with the size of the address space chunks. As the
    `newbits` value goes up, the size of the chunks decreases. As the value of `newbits`
    goes down, the size of the chunks increases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are splitting up the address space of `10.0.0.0/16`
    with chunks that have `8` additional bits. That means we are looking for chunks
    with the size of `/24`—or 256 IP addresses. If we used `6` instead, we would be
    looking to split into chunks of `/22`—or 1,024 IP addresses. As you can see, the
    fewer additional bits, the more IP addresses in each chunk, and the fewer chunks
    we can fit into the primary address space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we can use this function to construct the address space
    for each subnet within an AWS VPC. Thanks to the `count` meta-argument, we don’t
    need the `for` expression to construct a list of address spaces. We can use `count.index`
    to specify the `netnum` input to select which chunk we want our subnet to use.
  prefs: []
  type: TYPE_NORMAL
- en: Type conversion functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Explicit type conversions are exceptionally rare in Terraform, but several functions
    are available to aid you if necessary, e.g., `tonumber`, `tobool`, `tolist`, etc.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we took an in-depth look at the language that powers Terraform:
    HCL. We looked at its core structures: resources, data sources, locals, and modules.
    We looked at inputs and outputs that will help us design better contracts between
    our modules and the outside world. We looked at language structures that allow
    us to build dynamic collections of resources—helping us scale our code without
    all the copypasta. And lastly, we looked at an arsenal of functions that can help
    us when coding in HCL to solve complex problems quickly and efficiently.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the utility providers HashiCorp publishes
    that provide critical cross-platform functionality to our Terraform solutions.
  prefs: []
  type: TYPE_NORMAL
