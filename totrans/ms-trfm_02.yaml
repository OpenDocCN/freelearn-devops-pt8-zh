- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Using HashiCorp Configuration Language
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 HashiCorp 配置语言
- en: In the first chapter, we examined Terraform’s architecture. It is a simple command-line
    tool that takes in code and creates a plan that it can later execute at the user’s
    behest. In this chapter, we will examine how to leverage Terraform’s language—**HashiCorp
    Configuration Language** (**HCL**)—to define infrastructure as code so that we
    can build sophisticated cloud-based architectures using Terraform.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们研究了 Terraform 的架构。它是一个简单的命令行工具，接收代码并创建一个计划，之后可以根据用户的要求执行。在这一章中，我们将研究如何利用
    Terraform 的语言——**HashiCorp 配置语言**（**HCL**）——来定义基础设施作为代码，以便我们可以使用 Terraform 构建复杂的云架构。
- en: 'The chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Resources and data sources
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源和数据源
- en: Locals and types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地变量和类型
- en: Variables and outputs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量和输出
- en: Meta arguments
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元参数
- en: Loops and iterations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环和迭代
- en: Expressions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式
- en: Functions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Resources and data sources
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源和数据源
- en: Resources and data sources play a critical role in Terraform and are probably
    the most important language constructs to understand as they allow you to access
    existing and create new resources.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 资源和数据源在 Terraform 中扮演着至关重要的角色，它们可能是最重要的语言构造，理解它们非常关键，因为它们允许你访问现有资源并创建新资源。
- en: Resources
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源
- en: 'Resources are the most common block that you use when coding in HCL. The `resource`
    block is what Terraform is all about. You can think of each resource as a digital
    twin of something Terraform will provision in the real world:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 资源是你在 HCL 编程时最常使用的块。`resource` 块就是 Terraform 的核心。你可以将每个资源视为 Terraform 将在现实世界中配置的某物的数字双胞胎：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A block’s definition has three parts: the `resource`, the resource type is
    `random_string`, and the reference name is `foobar`. To create dependencies between
    resources, we use the reference name and type to access output values from the
    resource:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 块的定义包含三个部分：`resource`，资源类型是 `random_string`，引用名称是 `foobar`。为了在资源之间创建依赖关系，我们使用引用名称和类型来访问资源的输出值：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, we create an Azure resource group by referencing the
    `foobar` random string’s output value, `result`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过引用 `foobar` 随机字符串的输出值 `result` 来创建一个 Azure 资源组。
- en: Each resource within a Terraform provider is a tiny semi-independent computer
    program designed to manage a particular underlying system architecture. These
    resources define a schema that allows you to control the configuration of those
    underlying components. Sometimes, this schema is straightforward; at other times,
    it can be very complex, composed of primitive type attributes and additional custom
    block definitions nested within the resource block.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Terraform 提供者中的资源都是一个小型的半独立计算机程序，旨在管理特定的底层系统架构。这些资源定义了一个架构，允许你控制这些底层组件的配置。有时，这个架构是简单的；而有时，它可能非常复杂，由原始类型属性和额外的自定义块定义组成，嵌套在资源块中。
- en: These nested blocks allow you to declare one or more sub-resources within a
    resource. The resource dictates the number of each type of nested block it expects.
    Sometimes, resources allow many instances of the same nested block, while at other
    times, they may allow precisely one.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些嵌套块允许你在一个资源中声明一个或多个子资源。资源决定了它期望的每种类型的嵌套块的数量。有时，资源允许多个相同的嵌套块实例，而有时，它们可能只允许一个。
- en: 'For example, the Azure Cosmos DB service allows you to create hyper-scale NoSQL
    databases and quickly set up replication across multiple geo-locations. Each geo-location
    is a nested block within the Cosmos DB `resource` block:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Azure Cosmos DB 服务允许你创建超大规模的 NoSQL 数据库，并迅速在多个地理位置之间设置复制。每个地理位置都是 Cosmos DB
    `resource` 块中的嵌套块：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, the `geo_location` block is repeated multiple times within the
    `azurerm_cosmosdb_account` block. Each instance of the `geo_location` nested block
    tells this Cosmos DB account where to replicate the MongoDB databases and the
    failover priority.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`geo_location` 块在 `azurerm_cosmosdb_account` 块内被重复多次。每个 `geo_location`
    嵌套块的实例告诉这个 Cosmos DB 账户在哪里复制 MongoDB 数据库，以及故障转移优先级。
- en: Data sources
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据源
- en: In its most primitive form, Terraform is about provisioning resources, but as
    we saw, there is a lot more to it than that. Once Terraform provisions the resources,
    then what? What happens when you provision a resource by some other means? Can
    you still reference it from Terraform? Resources create something new. Data sources
    access something that already exists.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从最基础的形式来看，Terraform 主要是用来配置资源的，但正如我们所看到的，它远不止这些。一旦 Terraform 配置了资源，接下来会发生什么？当你通过其他方式配置资源时会发生什么？你还能从
    Terraform 中引用它吗？资源创建的是新的东西，而数据源访问的是已经存在的东西。
- en: 'Data sources are less prolific but still play a critical role. First, they
    allow you to reference resources provisioned outside the current Terraform workspace
    no matter how they were provisioned—through a GUI, another automation tool, or
    another Terraform workspace:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 数据源虽然不如资源普遍，但仍然扮演着关键角色。首先，它们允许你引用在当前 Terraform 工作区外部配置的资源，无论它们是如何配置的——通过 GUI、其他自动化工具或其他
    Terraform 工作区：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Like the resource, a data source block’s definition has three parts: the block
    type, the resource type, and the reference name. In the preceding example, the
    block type is `data`, the resource type is `azurerm_resource_group`, and the reference
    name is `bar`. To create dependencies between resources and data sources, we use
    the reference name and type to access output values from the data source just
    like we did with a resource, but we also need to prefix the reference with `data`
    to clarify to Terraform whether this reference is to a new item or an existing
    one:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 和资源一样，数据源块的定义有三部分：块类型、资源类型和引用名称。在上面的示例中，块类型是 `data`，资源类型是 `azurerm_resource_group`，引用名称是
    `bar`。为了在资源和数据源之间创建依赖关系，我们使用引用名称和类型来访问数据源中的输出值，就像我们在资源中做的那样，但我们还需要在引用前加上 `data`，以明确告诉
    Terraform 该引用的是新项还是现有项：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding code, we create an Azure Storage account by referencing the
    `bar` Azure resource group’s output values: `name` and `location`.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们通过引用 `bar` Azure 资源组的输出值（`name` 和 `location`）来创建一个 Azure 存储账户。
- en: Now that we understand the core components that Terraform is responsible for
    (resources and data sources—something new and something old), let’s look at the
    data types we will use for internal and external data structures.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了 Terraform 负责的核心组件（资源和数据源——新东西和旧东西），让我们来看一下我们将用于内部和外部数据结构的数据类型。
- en: Locals and types
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 局部变量和类型
- en: After resources and data sources, the next most important thing to be familiar
    with is how to work with locals, which allow us to create internal variables and
    types that allow us to manipulate data within our Terraform solution.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在资源和数据源之后，下一个最重要的内容是如何使用局部变量，这使我们能够在 Terraform 解决方案中创建内部变量和类型，以便操作数据。
- en: Locals
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局部变量
- en: Terraform allows you to perform sophisticated operations on a variety of types.
    Sometimes, it’s necessary to use intermediate values that store a calculated value
    you can reference across your code base. It’s essential to understand how to do
    this, and what data types are available when working with internal data inside
    a module and when defining the contract between your Terraform modules.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 允许你对多种类型执行复杂的操作。有时，有必要使用中间值来存储计算出的值，以便在整个代码库中进行引用。理解如何做到这一点，以及在模块内部处理内部数据时和在定义
    Terraform 模块之间契约时可用的数据类型，至关重要。
- en: The `locals` block allows you to declare local variables. You can think of these
    as member variables in a class or local variables in a function, except they merge
    into one construct within the flattened scope of a Terraform workspace.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`locals` 块允许你声明局部变量。你可以把它们想象成类中的成员变量或函数中的局部变量，只不过它们在 Terraform 工作区的扁平化作用域中合并成一个构造。'
- en: 'You can define a local variable anywhere in your HCL code simply by declaring
    a `locals` block and declaring and defining a local variable within it. You must
    specify a value when declaring a local variable:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过声明一个 `locals` 块，并在其中声明和定义局部变量，在 HCL 代码中的任何位置定义一个局部变量。在声明局部变量时，你必须指定一个值：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code declares a local variable called `foo`. Terraform infers
    the type to be `string` simply by the use of double quotes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码声明了一个名为`foo`的局部变量。Terraform 通过使用双引号来推断该类型为 `string`。
- en: 'You can declare as many `locals` blocks as you want in any `.tf` file. As in
    other languages, you can nest local variables inside the value of other local
    variables. You can do this by using the `local` object prefix. Using the element’s
    type to reference it from elsewhere in the code is similar to referencing resources
    and data sources:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何 `.tf` 文件中声明任意数量的 `locals` 块。像其他语言一样，你可以将局部变量嵌套在其他局部变量的值中。你可以通过使用 `local`
    对象前缀来做到这一点。使用元素的类型从代码中的其他地方引用它，类似于引用资源和数据源：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It can be tricky to remember, but locals are always declared in a plural block
    name (`locals` versus `local`) and referenced in the singular, `local.*`. The
    mixture of singular and plural terminology can seem strange as most other blocks
    in Terraform are declared in a singular block and referenced in the singular.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 记住可能有些棘手，但局部变量总是以复数块名称（`locals` 而不是 `local`）声明，并在单数中引用，`local.*`。复数和单数术语的混合可能会显得奇怪，因为
    Terraform 中的大多数块是以单数块声明并以单数形式引用的。
- en: Primitive types
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始数据类型
- en: By design, HCL supports a limited number of data types. This design encourages
    simplicity in your code and avoids overly complex logic around type conversion.
    In principle, you should avoid doing complex logic in HCL and rely on the consistent
    input-output model ingrained into Terraform’s modular architecture to do any heavy
    lifting outside of Terraform and pass in a known good value as input in one of
    the supported types.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于设计原因，HCL 仅支持有限数量的数据类型。这个设计鼓励代码简洁，并避免在类型转换上使用过于复杂的逻辑。原则上，你应该避免在 HCL 中进行复杂逻辑运算，依赖
    Terraform 模块化架构中内建的一致输入输出模型，在 Terraform 之外完成繁重的工作，然后传递已知有效的值作为输入，并使用支持的类型。
- en: 'There are only three primitive types: `string`, `number`, and `bool`.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 只有三种原始数据类型：`string`、`number` 和 `bool`。
- en: String
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串
- en: While there are `number` and `bool`, their use or function is not very complicated.
    However, `string` can become very difficult very quickly. If you go spelunking
    in GitHub for HCL code, you will see a predisposition for complex string manipulation
    operations embedded in the code. Just because you can doesn’t mean you should.
    This is the way.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有 `number` 和 `bool`，它们的使用或功能并不复杂。然而，`string` 很容易变得非常复杂。如果你在 GitHub 上查找 HCL
    代码，会发现代码中通常嵌入了复杂的字符串操作。仅仅因为你能做，并不意味着你应该这么做。这就是方式。
- en: Avoid complex string manipulation where possible, and when it is necessary,
    encapsulate it into a local value so that it can be easily output for testing
    purposes before you run `apply`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量避免复杂的字符串操作，必要时将其封装成局部值，以便在运行`apply`之前，方便测试输出。
- en: String interpolation
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串插值
- en: '`string` object:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`string` 对象：'
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding example, we pass in two variables and concatenate them to
    construct the `Name` tag, commonly used by the AWS console:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们传入两个变量并将它们连接起来构造 `Name` 标签，这是 AWS 控制台常用的标签：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Alternatively, we can declare a `local` that constructs the name and directly
    sets the tag with the value of the `local`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以声明一个构造名称的`local`，并直接使用`local`的值来设置标签：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It simplifies our resource block for the AWS VPC by eliminating the string interpolation
    syntax (consisting of two double quotes, `"`, and two interpolation blocks, `${
    ... }`). It also creates a reusable `local` that we can use to tag our resources
    consistently. This can improve the readability and, ultimately, the maintainability
    of the code, especially if the string needs to be reused across multiple resources.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 它简化了我们 AWS VPC 的资源块，通过消除了字符串插值语法（由两个双引号 `"` 和两个插值块 `${ ... }` 组成）。它还创建了一个可复用的
    `local`，我们可以用来一致地标记我们的资源。这能提高代码的可读性，最终提升代码的可维护性，特别是当字符串需要在多个资源中重用时。
- en: A string that spans multiple lines
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 跨越多行的字符串
- en: 'Depending on the provider and resource you use, sometimes you must embed large
    strings spanning multiple lines. Terraform uses a `heredoc` style of declaring
    multi-line strings:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 根据使用的提供者和资源，有时必须嵌入跨越多行的大字符串。Terraform 使用`heredoc`风格来声明多行字符串：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: String content can be structured or unstructured. If HCL supports the structure
    of your string, you should consider using native syntax to represent the content.
    The most common cases of structured content embedded in HCL are JSON or YAML formatted
    strings because many cloud platforms have services that define their configuration
    schema that you must supply in either of these two formats. In this case, you
    should use the `jsonencode` or `yamlencode` functions to convert objects declared
    in native HCL into the appropriately formatted string. More on this later in this
    chapter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串内容可以是结构化的，也可以是非结构化的。如果HCL支持字符串的结构，您应该考虑使用本地语法来表示内容。嵌入HCL中的结构化内容最常见的形式是JSON或YAML格式的字符串，因为许多云平台的服务定义了其配置架构，您必须以这两种格式之一提供。在这种情况下，您应该使用`jsonencode`或`yamlencode`函数将本地HCL声明的对象转换为适当格式的字符串。后续章节将进一步介绍此内容。
- en: 'Another consideration is if there is an excellent reason to maintain the content
    in its original string format. Here are a couple of situations where this might
    be the case:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个考虑因素是是否有充分的理由保持内容的原始字符串格式。以下是一些可能需要保持原格式的情况：
- en: '**Too large**: If the content is substantial and thus quite laborious to convert
    into HCL, it may not be cost-effective to do the conversion.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**太大**：如果内容庞大，且转换为HCL相当繁琐，进行转换可能并不具备成本效益。'
- en: '`file` function.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file`函数。'
- en: Collection types
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合类型
- en: 'HCL supports only two collection types: `list` and `map`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: HCL只支持两种集合类型：`list`和`map`。
- en: List
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: List
- en: 'If you have done any development before working with Terraform or programming
    with HCL, you will no doubt be familiar with the concept of an array. Every programming
    language uses different syntaxes, types, and classes to represent this concept.
    A **list** is an ordered list of objects where items in that list can be accessed
    using the index of the desired item:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在使用Terraform之前有过开发经验，或者在编程时使用过HCL，您一定对数组的概念非常熟悉。每种编程语言使用不同的语法、类型和类来表示这一概念。**列表**是一个有序的对象列表，可以通过列表中项的索引来访问该项：
- en: '`string[] array = { "westus", "``eastus" }`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string[] array = { "westus", "``eastus" }`'
- en: '`array := [``4]string{"westus", "eastus"}`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array := [``4]string{"westus", "eastus"}`'
- en: '`array = ["``westus", "eastus"]`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array = ["``westus", "eastus"]`'
- en: '`var array = ["``westus", "eastus"];`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var array = ["``westus", "eastus"];`'
- en: '`array = ["``westus", "eastus"]`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array = ["``westus", "eastus"]`'
- en: Notice any similarities with any of the languages we’ve looked at? Python is
    the clear winner in the similarity contest. JavaScript is a close second—simply
    with some extra semi-colons and such.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到与我们所看过的语言有任何相似之处吗？Python无疑是最相似的语言。JavaScript紧随其后，只是多了一些分号等。
- en: 'As might be expected, items contained within an HCL list are accessed similarly
    across all of these languages:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，HCL列表中的项在这些语言中具有相似的访问方式：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The value of `a` would be `eastus`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`a`的值将是`eastus`。'
- en: The `list` object type is fantastic for situations where we want to provision
    a corresponding resource for each item in the list.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`list`对象类型在需要为列表中的每个项配置一个对应资源的场景中非常有用。'
- en: Map
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Map
- en: 'Like the concept of an array, a map in HCL corresponds to another prevalent
    collection type that goes by many names in other programming languages. From `Dictionary`
    to `KeyValuePair` and back to `map`. They all share this concept of a key—guaranteed
    unique within the collection—and associated with a corresponding value. To look
    up the value, you don’t access it with its index within the collection; you can
    access it with the `key` value:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于数组的概念，HCL中的`map`对应着其他编程语言中许多名称所指的另一种常见集合类型。从`Dictionary`到`KeyValuePair`再到`map`。它们都共享一个概念：键——在集合中是唯一的——与对应的值相关联。要查找值时，您不通过其在集合中的索引来访问它，而是通过`key`值来访问：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When we want to access the value for the particular network, we specify the
    region name we are using:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们希望访问特定网络的值时，我们指定所使用的区域名称：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The value of `a` would be `10.1.0.0/16`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`a`的值将是`10.1.0.0/16`。'
- en: 'This solution only works when the collection’s key is unique. In the preceding
    example, this allows us to quickly set up one network for every region we choose;
    however, with the current design, we cannot do that if we want to set up two networks
    for the same region:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案仅在集合的键是唯一时有效。在前面的示例中，这允许我们快速为我们选择的每个区域设置一个网络；然而，按照当前设计，如果我们想为同一区域设置两个网络，便无法做到：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can’t because adding a second entry for any region would produce an error.
    The error would be subtle. When we attempted to access `eastus` values in our
    `map`, only their last matching entry would come back. Therefore, it is the same
    as if `10.1.0.0/16` did not exist. Having such a discrepancy in your code and
    what Terraform provisions can lead to confusion and misaligned expectations, so
    remember that when working with `map`, you should reserve it for situations where
    the key is unique.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能这么做，因为为任何区域添加第二个条目会导致错误。这个错误非常隐蔽。当我们尝试在我们的`map`中访问`eastus`的值时，只有最后匹配的条目会返回。因此，结果就像是`10.1.0.0/16`并不存在一样。代码中与
    Terraform 配置之间的这种不一致可能导致困惑和预期不一致，因此请记住，在使用`map`时，应该仅在键是唯一的情况下使用它。
- en: Complex objects
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复杂对象
- en: HCL is not object-oriented; therefore, it does not have a mechanism for defining
    classes like other languages that represent complex types. However, it does support
    complex objects. It uses dynamic types, meaning Terraform will evaluate the object’s
    type at runtime.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: HCL 不是面向对象的；因此，它不像其他语言那样有定义类的机制来表示复杂类型。然而，它支持复杂对象。它使用动态类型，这意味着 Terraform 会在运行时评估对象的类型。
- en: '**Dynamic typing** can be a blessing and a curse. It is a blessing because
    we don’t have to conform to strict structures of objects. If we need another attribute,
    we can quickly add it. It is a curse because it means we need an official source
    of truth for how the object should be structured, and we’ll have to rely on reference
    tracing when refactoring the structure of objects passed from one module or resource
    to another:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**动态类型**既是福也是祸。它是福，因为我们不需要遵守严格的对象结构。如果我们需要另一个属性，可以迅速添加它。它是祸，因为这意味着我们需要一个官方的结构定义来源，并且在重构从一个模块或资源传递到另一个模块或资源的对象结构时，我们不得不依赖引用追踪。'
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Defining an object is as simple as declaring the object reference and setting
    it to the value of a block—as indicated by the `{` and `}` symbols. This block
    can contain any number of primitive types, collections, or complex objects.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个对象就像声明对象引用并将其设置为一个块的值一样简单——这个块由`{`和`}`符号表示。这个块可以包含任何数量的原始类型、集合或复杂对象。
- en: 'Now that we understand the data types that Terraform recognizes and how to
    use them to construct internal `local` variables, we can look externally to see
    how we can define the data contract between our module and the outside world:
    its inputs and outputs.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了 Terraform 识别的数据类型以及如何使用它们构造内部`local`变量，我们可以从外部来看看如何定义我们模块与外部世界之间的数据契约：即它的输入和输出。
- en: Inputs and outputs
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入与输出
- en: Next, let's look at how to get data into and out of Terraform using input variables
    and outputs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何使用输入变量和输出将数据传入和传出 Terraform。
- en: Inputs
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入
- en: As we learned in the previous chapter, Terraform operates within the context
    of a module. That module is scoped physically within a directory. The **root module**
    is a special case where its directory is the same as Terraform’s working directory.
    Whenever you are writing HCL, you are writing within the context of a module,
    whether the root module or some other module; therefore, you need to consider
    how to get data into your module and how to get data out of it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中学习的那样，Terraform 在模块的上下文中运行。这个模块在物理上被限定在一个目录内。**根模块**是一个特殊的情况，它的目录与
    Terraform 的工作目录相同。无论你是在写根模块还是其他模块的 HCL，你都在模块的上下文中进行编写；因此，你需要考虑如何将数据传入模块以及如何将数据从模块传出。
- en: Input variables are an essential design consideration because Terraform modules
    are simple machines that take inputs and produce outputs.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 输入变量是一个重要的设计考虑因素，因为 Terraform 模块是简单的机器，它们接受输入并生成输出。
- en: The input is all about what information the module needs to provision itself,
    and those inputs can come from wherever. As you design inputs, they should be
    atomic.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 输入完全是关于模块需要什么信息来进行配置，这些输入可以来自任何地方。在设计输入时，它们应该是原子的。
- en: The module should be able to take the input without any additional manipulation
    or logic to parse the input variable’s value. You should parse the value outside
    of the module. That doesn’t mean that inputs can’t be complex objects or collections,
    but keeping the interface as simple as possible is a good idea. The more complex
    your inputs are, the more complex your module will be—whether it’s your root module
    or reusable modules that you share across workspaces.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 模块应该能够接收输入，而无需任何额外的操作或逻辑来解析输入变量的值。你应该在模块之外解析值。这并不意味着输入不能是复杂对象或集合，但保持接口尽可能简单是个好主意。输入越复杂，你的模块也会越复杂——无论是根模块还是你在工作区间共享的可重用模块。
- en: Your root module will likely have the most complex inputs. Consider your input’s
    structure for root modules based on how you inject the parameter into the variable.
    If you use a variable file written in HCL, using complex types that span multiple
    lines, whether a list, a map, or a complex object, is effortless. However, suppose
    you plan to use a **Linux environment variable** or command-line argument method
    to pass in the parameter. In that case, you should reconsider using complex objects
    as inputs, as they can be challenging to troubleshoot and verify that you are
    getting the correct value into that input.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你的根模块可能具有最复杂的输入。考虑根据如何将参数注入到变量中的方式，来设计根模块的输入结构。如果你使用的是以 HCL 编写的变量文件，使用跨越多行的复杂类型，无论是列表、映射还是复杂对象，都非常简单。然而，如果你计划使用**Linux
    环境变量**或命令行参数的方法来传入参数，那么你应该重新考虑使用复杂对象作为输入，因为它们可能会导致故障排除变得困难，并且很难验证你是否将正确的值传递到了该输入中。
- en: When you use Linux environment variables, it’s important to remember they are
    not very good at storing structured data with complex schema. The most complex
    schema you see in a Linux environment variable is some delimited text. `PATH`
    is an excellent example of this, as it is a delimited text value. You could use
    a delimited text value as an input variable to simplify injecting the value. The
    downside is that you’ll have to parse the value after you get it into Terraform.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 Linux 环境变量时，记住它们并不适合存储具有复杂模式的结构化数据是很重要的。你在 Linux 环境变量中看到的最复杂的模式是某些分隔文本。`PATH`
    就是一个很好的例子，它是一个分隔文本值。你可以使用分隔文本值作为输入变量来简化值的注入。缺点是，你必须在将值传入 Terraform 后进行解析。
- en: 'In the case of a root module, this could be desirable because it reduces the
    complexity of the interface of the two tools: Terraform and other executables.
    This sort of integration is widespread within automation pipelines where separate
    pipeline tasks execute different tools, and you pipe the output from one tool
    into the inputs of the other. Passing values into Terraform from the command-line
    interface is similar to how we pipe the outputs of one module into the inputs
    of another module. However, this is more seamless within Terraform because HCL
    can be used to transfer the value. In contrast, with command-line tools, you would
    need additional parsing steps to transform the value into the desired format for
    Terraform to consume quickly:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于根模块来说，这可能是理想的，因为它减少了两个工具（Terraform 和其他可执行文件）接口的复杂性。这种集成在自动化流水线中很常见，其中独立的流水线任务执行不同的工具，并将一个工具的输出传递到另一个工具的输入中。从命令行界面将值传递到
    Terraform，类似于我们将一个模块的输出传递到另一个模块的输入。然而，这在 Terraform 中更加无缝，因为可以使用 HCL 来传递值。相比之下，使用命令行工具时，你需要额外的解析步骤，将值转换为
    Terraform 可以快速处理的所需格式：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, we declare an input variable, `foo`, with a type of `string`
    and provide some guidance to the user of our module on how to use this input variable
    within `description`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们声明了一个输入变量 `foo`，类型为 `string`，并在 `description` 中向模块的用户提供了关于如何使用该输入变量的指导。
- en: Sensitive data
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 敏感数据
- en: 'Sometimes, you may need to input sensitive data such as a password, connection
    string, or access key. You must annotate your input variables to ensure that Terraform
    knows not to display them in its output, as this can lead to secret leakage through
    the operational logs that Terraform emits:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能需要输入敏感数据，如密码、连接字符串或访问密钥。你必须对输入变量进行标注，以确保 Terraform 不会在其输出中显示它们，因为这可能会导致通过
    Terraform 发出的操作日志泄露秘密：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, we are annotating our super secret password with the
    `sensitive` attribute to prevent this secret from being output by Terraform.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用 `sensitive` 属性标注了我们的超级机密密码，以防止 Terraform 输出该机密。
- en: Optional
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选
- en: When building modules that can support many scenarios, you will often need to
    provide input variables to support the data needs of each scenario. Each supported
    scenario may only require a subset of the input variables to be specified. In
    this situation, we should make our input variable optional.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建可以支持多种场景的模块时，你通常需要提供输入变量，以支持每个场景的数据需求。每个支持的场景可能只需要指定输入变量的一个子集。在这种情况下，我们应该将输入变量设置为可选。
- en: 'For primitive types, you can accomplish this quite simply by setting the default
    value to `null`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于原始类型，你可以通过将默认值设置为`null`来简单地实现这一点：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, we set `default` to `null`, allowing the user to ignore
    this input variable completely.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将`default`设置为`null`，允许用户完全忽略此输入变量。
- en: Setting an input variable to be optional can be more complicated when working
    with complex objects, as we may want the entire object or its attributes to be
    optional.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理复杂对象时，将输入变量设置为可选可能更加复杂，因为我们可能希望整个对象或其属性都为可选。
- en: 'Consider the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下代码：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code, we declare a variable called `person`. Unfortunately,
    not only is it a non-optional input variable, but every attribute on the `person`
    object needs to be specified.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了一个名为`person`的变量。不幸的是，它不仅是一个非可选的输入变量，而且`person`对象上的每个属性都必须被指定。
- en: 'Let’s see whether we can loosen things up:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看是否能放宽一些限制：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code, notice that adding `default = null` on the `person` variable
    block allows users of this module to ignore this input variable completely. Additionally,
    if the user supplies a `person` object, the `middle_name` attribute is not required.
    Now, the supported inputs are much more flexible for the user.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，请注意，添加`default = null`到`person`变量块，允许使用此模块的用户完全忽略此输入变量。此外，如果用户提供了`person`对象，则`middle_name`属性不是必需的。现在，支持的输入对于用户来说更加灵活。
- en: 'The following value sets the entire object to `null`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下值将整个对象设置为`null`：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following value sets the input variable to an object but omits the `middle_name`
    attribute:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下值将输入变量设置为对象，但省略了`middle_name`属性：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Lastly, we set the input variable to an object and specify values for all attributes:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将输入变量设置为对象，并为所有属性指定值：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Thanks to the inclusion of `default` and `optional` within our input variable
    declaration, all are equally valid parameter values for our module.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了在输入变量声明中包含了`default`和`optional`，所有这些都是我们模块有效的参数值。
- en: Validation
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证
- en: When creating modules you will use more broadly in your organization, consider
    adding some basic validations to your modules’ inputs. The `validation` block
    provides a way to add primitive data validation on incoming input variable values.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建你将在组织中更广泛使用的模块时，考虑在模块的输入中添加一些基本的验证。`validation`块提供了一种方法，可以对传入的输入变量值进行基本的数据验证。
- en: 'Adding validation can significantly reduce apply-time failures that can plague
    your user if an input value has requirements from the underlying provider that
    may not be evident through your module’s interface. For example, a cloud platform
    may impose naming conventions on resources such as alpha-numeric only, all lowercase,
    less than 30 characters, and so on. Unless the consumer of your module is aware
    of the platform-specific constraints, they could encounter difficulties using
    your module as they attempt to figure out how to get the correct set of values
    as inputs—especially if your module abstracts the underlying cloud platform’s
    resources in any way:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 添加验证可以显著减少应用时的失败，特别是当输入值有来自底层提供者的要求时，而这些要求可能无法通过模块的界面显现出来。例如，云平台可能对资源强制执行命名约定，如只能使用字母和数字、全部小写、少于30个字符等等。除非使用者了解平台特定的限制，否则他们在尝试弄清楚如何提供正确的输入值时，可能会遇到困难——尤其是当你的模块以某种方式抽象了底层云平台的资源时：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding code, we specify a condition that checks that the length of
    the input variable is less than `30`. We could use any valid Boolean expression.
    We are good if it returns either `true` or `false`. We can use any number of functions
    that Terraform supports. However, prior to version 1.9.0 of Terraform, we can
    only reference the variable that the `validation` block lives on—meaning, we can’t
    reference other variables to create complex multi-variable input validation, nor
    can we make validation conditional on other elements declared within Terraform,
    be they other variables, resources, data sources, locals, or otherwise. This all
    changed in version 1.9.0 of Terraform, where input variable validation was opened
    up to referencing other blocks within the module. This allows you to implement
    much more sophisticated validation using locals and data sources that might be
    useful to verify inputs.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们指定了一个条件，检查输入变量的长度是否小于`30`。我们可以使用任何有效的布尔表达式。如果返回`true`或`false`，都可以。我们可以使用
    Terraform 支持的任何函数。然而，在 Terraform 1.9.0 版本之前，我们只能引用定义`validation`块所在的变量——这意味着我们无法引用其他变量来创建复杂的多变量输入验证，也无法使验证基于
    Terraform 中声明的其他元素（无论是其他变量、资源、数据源、局部变量等）有条件。这一切在 Terraform 1.9.0 版本中发生了变化，输入变量验证可以引用模块内的其他块。这使得你可以使用局部变量和数据源等来实现更加复杂的验证，帮助验证输入。
- en: Outputs
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输出
- en: 'Output variables are an essential consideration as well. It’s crucial to only
    output values that you will need. You should avoid putting unnecessary outputs—this
    is a pretty easy rule to follow within the root module. Still, when authoring
    reusable modules, it becomes more difficult because it is harder to predict what
    the consumer of your module will need:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 输出变量也是一个至关重要的考虑因素。只输出你需要的值非常关键。你应该避免输出不必要的内容——这一点在根模块中比较容易遵循，但在编写可重用模块时会更难，因为你更难预测模块的使用者会需要什么：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, we declare an output called `foo` that returns a constant
    value of `bar`. While this example could be more practical, its simplicity will
    be instructive. Namely, that output values can be any valid expression in HCL.
    I draw your attention to this because you will no doubt encounter dozens of examples
    that output an attribute on a resource, but the output block is much more potent
    than that. Coupled with all the tools available within HCL—many that we’ll get
    into later in this chapter—you can construct any value you need. Knowledge of
    this capability is crucial in enabling you to smooth the edges between how you
    integrate Terraform and other tools.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了一个名为`foo`的输出，它返回一个常量值`bar`。尽管这个示例可以更具实际意义，但它的简洁性具有教学意义。也就是说，输出值可以是
    HCL 中的任何有效表达式。我特别提到这一点，因为你无疑会遇到许多示例，它们输出资源上的某个属性，但输出块远比这强大。结合 HCL 中可用的所有工具——我们将在本章后面详细介绍——你可以构建任何你需要的值。了解这一能力对于帮助你平滑地整合
    Terraform 和其他工具至关重要。
- en: It is a good practice to annotate your outputs with a `description` attribute
    to inform the consumer of your module (whether it is a user using your module
    via the command-line tool or from within another Terraform module) of what you
    intend the output to be and its purpose and what type of data they can expect.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了告知模块的使用者（无论是通过命令行工具使用模块的用户，还是通过其他 Terraform 模块使用的用户）你打算输出的内容及其用途，并且告知他们可以期待的数据类型，建议给输出加上`description`属性进行注释。
- en: Sensitive data
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 敏感数据
- en: 'Sometimes, you may need to output sensitive data such as a password, connection
    string, or access key. Most resources will define which attributes are considered
    sensitive, so Terraform will warn you if necessary:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能需要输出敏感数据，例如密码、连接字符串或访问密钥。大多数资源都会定义哪些属性被视为敏感，因此 Terraform 如果需要，会发出警告：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code, we annotate our super secret password with the `is_sensitive`
    attribute to inform Terraform that this is not data that we would like it to shout
    to the world from the rooftops!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`is_sensitive`属性来标注我们超级秘密的密码，告知 Terraform 这不是我们希望它大声公布于世的数据！
- en: Now that we understand how to declare inputs and outputs within our Terraform
    modules and the basic structures—resources, data sources, and locals—that we work
    with so frequently, we are ready to move on to some more complex structures in
    the language. Our first stop is meta-arguments. Sounds fun, right?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了如何在 Terraform 模块中声明输入和输出，以及我们经常使用的基本结构——资源、数据源和本地变量——我们可以继续学习语言中的一些更复杂的结构。我们的第一站是元参数。听起来很有趣，对吧？
- en: Meta-arguments
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元参数
- en: '**Meta-arguments** are attributes that you can set on any resource block. They
    allow you to control different aspects of the resource related to its context,
    dependencies, and lifecycle. Each meta-argument enables finer-grained control
    over that resource by allowing the developer to give very focused resource-specific
    instructions to Terraform.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**元参数** 是你可以在任何资源块上设置的属性。它们允许你控制与资源相关的不同方面，如上下文、依赖关系和生命周期。每个元参数都允许更精细的控制，开发者可以向
    Terraform 提供非常专注的资源特定指令。'
- en: Provider
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供者
- en: The `provider` meta-argument is a reference that allows you to specify under
    which provider context you would like to deploy the resource. The scope of the
    context is dependent on the provider you are using. The two most common scopes
    are which region you are deploying to within a public cloud and what authentication
    credential you are using.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`provider` 元参数是一个引用，它允许你指定在哪个提供者上下文中部署资源。上下文的范围取决于你使用的提供者。最常见的两个范围是你要部署到的公共云区域和你正在使用的认证凭证。'
- en: 'You will need to understand the specific scoping mechanism of your providers.
    This book will use the `aws`, `azurerm`, and `google` providers. Each provider
    defines its scope differently. The scope of the AWS provider is an AWS account
    and an AWS Region. The scope for the GCP provider is a GCP project and a GCP region.
    The Azure provider is scoped only to an Azure subscription:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要理解你所使用的提供者的特定作用域机制。本书将使用 `aws`、`azurerm` 和 `google` 提供者。每个提供者定义的作用域不同。AWS
    提供者的作用域是 AWS 账户和 AWS 区域。GCP 提供者的作用域是 GCP 项目和 GCP 区域。Azure 提供者的作用域仅限于 Azure 订阅：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, when attaching to resources, if you do not specify the `provider` meta-argument,
    all the resources you declare will be provisioned by Terraform using the default
    `aws` provider:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在附加到资源时，如果你没有指定 `provider` 元参数，所有你声明的资源将由 Terraform 使用默认的 `aws` 提供者进行部署：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When you want to provision to the `secondary` instance of the `aws` provider,
    you will need to declare it using the `provider` meta-argument on the `resource`
    block itself:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要将资源部署到 `aws` 提供者的 `secondary` 实例时，你需要在 `resource` 块中使用 `provider` 元参数进行声明：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Therefore, when using AWS and GCP to do multi-region deployments, you will see
    the `provider` meta-argument to provision resources to different AWS and GCP regions.
    However, on Azure, you’ll only see the `provider` meta-argument to provision across
    multiple subscriptions—a very exotic deployment type.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当使用 AWS 和 GCP 进行多区域部署时，你会看到 `provider` 元参数用于将资源部署到不同的 AWS 和 GCP 区域。然而，在 Azure
    上，你只会看到 `provider` 元参数用于跨多个订阅进行部署——这是一种非常独特的部署方式。
- en: Depends on
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖于
- en: 'Sometimes, when Terraform is planning, it needs help to get the dependency
    graph right. That’s because Terraform can only detect explicit dependencies—but
    sometimes, you can have implicit dependencies, depending on the provider and the
    resource within that provider. These implicit dependencies occur when a resource
    requires another, but there is no direct relationship between the resources:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，当 Terraform 进行计划时，它需要帮助来正确获取依赖图。这是因为 Terraform 只能检测显式依赖关系——但有时，依赖关系是隐式的，取决于提供者和该提供者下的资源。这些隐式依赖关系发生在某个资源需要另一个资源时，但资源之间没有直接关系：
- en: '![Figure 2.1 – Implicit dependency between the Key Vault secret and Key Vault
    access policy](img/B21183_02_1.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – Key Vault 密钥和 Key Vault 访问策略之间的隐式依赖关系](img/B21183_02_1.jpg)'
- en: Figure 2.1 – Implicit dependency between the Key Vault secret and Key Vault
    access policy
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – Key Vault 密钥和 Key Vault 访问策略之间的隐式依赖关系
- en: 'A great example is whenever you use Azure Key Vault. You need permissions within
    the key vault itself before creating secrets. Therefore, by default, the identity
    running Terraform does not have access to create secrets within the key vault
    it just created:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是，当你使用 Azure Key Vault 时。在创建机密之前，你需要在密钥保管库本身中获得权限。因此，默认情况下，运行 Terraform
    的身份无法在它刚创建的密钥保管库中创建机密：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding code will fail. You need to explicitly grant the identity that
    Terraform is running under access to Key Vault to create secrets. You can do this
    by adding an **access** **policy resource**:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码会失败。你需要显式地授予 Terraform 所运行的身份访问 Key Vault 的权限，以便创建机密。你可以通过添加一个 **访问** **策略资源**
    来实现这一点：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Unfortunately, after adding this access policy resource, my code still won’t
    work. When I run `apply`, it will tell in my code! Because there is no explicit
    dependency between the secret and the access policy, Terraform thinks that both
    can be created in parallel—thus creating a race condition that will inevitably
    fail when Terraform attempts to make the secret.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在添加了这个访问策略资源后，我的代码仍然无法正常工作。当我运行 `apply` 时，它会告诉我代码中出现了问题！因为机密和访问策略之间没有显式的依赖关系，Terraform
    认为它们可以并行创建——从而在 Terraform 尝试创建机密时导致竞争条件并最终失败。
- en: 'Therefore, we need to make sure that we define the dependency of the secret
    on the access policy so that Terraform knows that it needs to create the access
    policy before we attempt to create the secret:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要确保定义机密对访问策略的依赖关系，这样 Terraform 才知道它需要在尝试创建机密之前先创建访问策略：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: By explicitly declaring the dependency between the secret and the access policy,
    we will solve the problem in our Terraform plan that creates a race condition
    between them.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过显式声明机密和访问策略之间的依赖关系，我们将在我们的 Terraform 计划中解决它们之间的竞争条件问题。
- en: Lifecycle
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生命周期
- en: The `lifecycle` meta-argument is a block that can appear on any resource block
    and is used to alter the control of that resource’s—well—lifecycle. That is the
    resource’s creation and deletion—the birth and death. Each option allows you to
    handle edge cases where you want Terraform to behave differently than usual.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`lifecycle` 元数据参数是可以出现在任何资源块中的一段代码，用于改变该资源的生命周期控制——即资源的创建与删除——诞生与消亡。每个选项允许你处理那些希望
    Terraform 按照不同于通常行为的方式处理的边缘情况。'
- en: Create before destroy
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建先于销毁
- en: This situation reminds me of that classic movie scene from *Indiana Jones and
    the Raiders of the Lost Ark*, where Indy is in a booby-trapped Peruvian temple.
    To acquire the golden statue, he must replace it with something. First, Indy has
    to create a bag of dirt to replace the golden statue. Then, he must delicately
    replace the golden statue with it. The situation that our hero, Indy, finds himself
    in is the essence of `create_before_destroy`. In these situations, you need the
    new thing before you get rid of the old. There are many examples of this scenario.
    It can apply to certificates, security groups, and the like.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况让我想起了经典电影场景《*印第安纳·琼斯与失落的宝藏*》中的一幕，印第安纳在一个布满陷阱的秘鲁神庙里。为了获得金色雕像，他必须用某个东西替换它。首先，印第安纳需要制作一袋泥土来替换金色雕像。然后，他必须小心翼翼地将金色雕像替换成这袋泥土。我们英雄印第安纳所面临的情境就是
    `create_before_destroy` 的精髓。在这种情况下，你需要在销毁旧物之前先获得新物。这个场景有很多例子，适用于证书、安全组等。
- en: Lock resources
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 锁定资源
- en: For some resources, you don’t want to take the chance that a less-than-careful
    administrator will blow them away without thoroughly analyzing `terraform plan`—an
    unfortunately common occurrence. This situation is where `prevent_destroy` comes
    into play. By adding this meta-argument to your resources, you are adding yet
    another gate that the user must explicitly remove before they can destroy the
    resource. Many cloud services natively support this feature, but not all. Therefore,
    Terraform allows you to enable this feature within your HCL code on any resource
    vital to the environment’s health or may contain stateful data that you would
    lose in the case of destruction.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些资源，你可能不希望冒险让一个不够小心的管理员在没有彻底分析 `terraform plan` 的情况下销毁它们——这种情况不幸地很常见。在这种情况下，`prevent_destroy`
    就派上用场了。通过将这个元数据参数添加到你的资源中，你就添加了另一个用户必须明确删除的门槛，才能销毁该资源。许多云服务原生支持此功能，但并非所有云服务都支持。因此，Terraform
    允许你在 HCL 代码中为任何对环境健康至关重要或可能包含状态数据的资源启用此功能，这些数据在销毁时会丢失。
- en: Ignore changes
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 忽略更改
- en: 'Sometimes, Terraform is one of many tools that operate in an environment, or
    you want to allow manual administration of a particular feature after deployment.
    In this case, the `ignore_changes` option will enable you to provision the resource
    with Terraform but ignore changes made outside of Terraform:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，Terraform 是多个在同一环境中操作的工具之一，或者你希望在部署后手动管理某个特定功能。在这种情况下，`ignore_changes` 选项允许你用
    Terraform 配置资源，但忽略 Terraform 外部做出的更改：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Ignore changes is an array of object references relative to the `resource` block
    you defined. You can imagine `this` before any reference within the list. You
    will get an error if you attempt to reference an external resource.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略更改是相对于你定义的 `resource` 块的对象引用数组。你可以想象在列表中的任何引用前都有 `this`。如果尝试引用外部资源，你将会收到错误。
- en: Replace triggered by
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换触发条件
- en: Many Terraform resources already know what circumstances should cause Terraform
    to trigger a replacement. The cause is usually a change in the value of a critical
    attribute. However, sometimes, there are situations where you want Terraform to
    replace the resource when another resource is updated or replaced. Often, this
    can happen when there is no direct dependency between the resources, making it
    difficult for Terraform to determine that a destructive action is taking place.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Terraform 资源已经知道在什么情况下应触发 Terraform 替换资源。通常，触发替换的原因是某个关键属性的值发生了变化。然而，有时你希望在更新或替换另一个资源时触发
    Terraform 替换资源。通常，这种情况发生在资源之间没有直接依赖关系时，这使得 Terraform 难以判断是否发生了破坏性操作。
- en: 'For example, with an Azure Virtual Desktop host pool, the host pool and its
    **virtual machines** (**VMs**) are declared independently. Still, they are associated
    with a third resource called a VM extension that will initiate the joining of
    the VM with the host pool. In this scenario, Terraform knows about the VM’s relationship
    with the VM extension and the VM extension’s relationship with the host pool.
    Still, because you create the host pool’s relationship with the VM through an
    attribute in the VM extension, it does not cause a replacement if it is updated.
    Therefore, the VM will never be reattached to the host pool if it changes:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于 Azure 虚拟桌面主机池，主机池及其 **虚拟机**（**VMs**）是独立声明的。但它们与一个名为 VM 扩展的第三方资源相关联，VM
    扩展会启动虚拟机与主机池的连接。在这种情况下，Terraform 知道虚拟机与 VM 扩展的关系，以及 VM 扩展与主机池的关系。然而，由于你通过 VM 扩展中的一个属性来创建主机池与虚拟机的关系，如果该属性被更新，也不会触发替换。因此，如果虚拟机发生变化，它将不会重新连接到主机池：
- en: "![Figure 2.2 – Implicit dependency between the host pool and VM prevent\uFEFF\
    s Terraform from replacing the VM if the host pool changes](img/B21183_02_2.jpg)"
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 主机池与虚拟机之间的隐式依赖关系阻止 Terraform 在主机池变化时替换虚拟机](img/B21183_02_2.jpg)'
- en: Figure 2.2 – Implicit dependency between the host pool and VM prevents Terraform
    from replacing the VM if the host pool changes
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 主机池与虚拟机之间的隐式依赖关系阻止 Terraform 在主机池变化时替换虚拟机
- en: Now that we understand how to modify Terraform’s default behavior using meta-arguments,
    we can handle better edge cases specific to the cloud resources we plan on provisioning
    with whatever providers we want to use. Now, it’s time to scale things up by learning
    to turn Terraform into a resource factory—pumping out complex configurations without
    all the copypasta!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了如何通过元参数修改 Terraform 的默认行为，我们可以更好地处理与云资源相关的边缘情况，无论使用哪个提供商。接下来，是时候通过学习如何将
    Terraform 转变为资源工厂，从而批量生成复杂的配置，而无需复制粘贴所有内容了！
- en: Loops and iterations
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环和迭代
- en: There are three different ways to iterate within HCL. The most common are two
    meta-arguments, `for_each` and `count`, which operate on a resource, module, or
    data source block. At the same time, the third option uses the `for` expression,
    which operations on any collection.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HCL 中有三种不同的迭代方式。最常用的是两个元参数 `for_each` 和 `count`，它们作用于资源、模块或数据源块。同时，第三种选项是使用
    `for` 表达式，它作用于任何集合。
- en: Count
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 数量
- en: 'The `count` meta-argument is Terraform’s oldest method of iterating resources:
    an oldie but a goodie. The `count` meta-argument is excellent when you want to
    provision the same block multiple times and have no unique identifier to key off
    of. In this situation, you will use the item’s index in a list to determine its
    uniqueness. This approach can pose challenges in the future if the items in the
    list need to change in such a way that would cause the indices of each item to
    change.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`count` 元参数是 Terraform 最早的资源迭代方法：虽然是老方法，但依然非常好用。`count` 元参数非常适合当你需要多次创建相同的资源块，并且没有唯一标识符作为依据时。在这种情况下，你将使用列表中的项的索引来确定其唯一性。如果列表中的项发生变化，从而导致每个项的索引发生变化，可能会带来挑战。'
- en: The best way to manage this is to treat your list as append-only, as this will
    avoid replacing related resources. Adding or removing items from the middle of
    the list will cause all the items below that item to shift their index, resulting
    in destruction and recreation.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 管理此问题的最佳方法是将你的列表视为仅追加（append-only）的方式，因为这样可以避免替换相关的资源。从列表中间添加或删除项目将导致该项下方的所有项目其索引发生变化，进而导致销毁和重建。
- en: 'For example, if you want to provision a five-node cluster, you wouldn’t remove
    a specific node from the cluster when you scale down. You would reduce the number
    of nodes. You don’t care which nodes get removed. You only care how many there
    are. In this situation, it is ideal to use `count`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想配置一个五节点集群，当你缩减节点时，你不会从集群中删除一个特定的节点，而是减少节点的数量。你不在乎删除哪些节点，只在乎节点的数量。在这种情况下，使用
    `count` 是理想的选择：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: For each
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个
- en: An alternative to `count` is the `for_each` meta-argument, which allows you
    to create multiple blocks from a `map` collection. This approach can be a distinct
    improvement over the `count` technique because the order of the items in the collection
    does not matter—only the key. If you update the code to remove the key, Terraform
    will remove the corresponding item. If the item changes order with other items
    in the collection, it will not affect Terraform’s plan.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`count` 的替代方法是 `for_each` 元参数，它允许你从 `map` 集合中创建多个块。与 `count` 技术相比，这种方法有显著的改进，因为集合中项目的顺序并不重要，只有键才重要。如果你更新代码以删除某个键，Terraform
    将删除相应的项。如果该项与集合中的其他项交换了顺序，它不会影响 Terraform 的计划。'
- en: This approach is only possible with a `map` collection as the source of the
    iteration because, with a `map` collection type, each item must have a key that
    uniquely identifies it amongst its peers.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法仅适用于 `map` 类型的集合，因为对于 `map` 集合类型，每个项目必须有一个唯一的键来标识它。
- en: 'As a result, using `for_each` works well when deploying to multiple regions
    as, typically, you wouldn’t have more than one deployment in the same region;
    hence, the region name makes an excellent unique key for the `map` that drives
    the `for_each` loop. You can add or remove regions without worrying about shifting
    the index of the items in the collection:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用 `for_each` 在部署到多个区域时效果很好，因为通常情况下，你不会在同一地区进行多个部署；因此，区域名称作为驱动 `for_each`
    循环的 `map` 的唯一键非常适用。你可以添加或删除区域而不必担心移动集合中项目的索引。
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Consider the preceding `map` configuration. Using this as the collection, we
    can drive any number of resources, data sources, or modules:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑前面的 `map` 配置。使用它作为集合，我们可以驱动任意数量的资源、数据源或模块：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding code, we see that we are setting the `for_each` source to be
    the map stored in `local.regions`. We then can use the `each` prefix anywhere
    within the module block to access either the key or the value using `each.key`
    and `each.value`, respectively. No matter the value’s type, we can address it
    how we normally would, using `each.value` as a reference to the object.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们看到我们将 `for_each` 源设置为存储在 `local.regions` 中的 `map`。然后，我们可以在模块块中的任何位置使用
    `each` 前缀来访问键或值，分别使用 `each.key` 和 `each.value`。无论值的类型如何，我们都可以像平常一样通过 `each.value`
    来引用对象。
- en: For expressions
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`for` 表达式'
- en: The `for` expression is a way of iterating within Terraform that does not require
    you to attach it to a block (i.e., resource, data source, or module). You can
    use the `for` expression to construct in-memory objects to apply object transformations
    to streamline block-based iteration or for output.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 表达式是 Terraform 中一种迭代方式，它不需要你将其附加到一个块（例如，资源、数据源或模块）中。你可以使用 `for` 表达式在内存中构造对象，并应用对象转换来简化基于块的迭代或用于输出。'
- en: Iterating over a list
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历一个列表
- en: 'When iterating over a `list`, you must specify only one parameter to the `for`
    expression. This parameter will represent each item within your `list` so that
    you can access each item within the output block:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在遍历 `list` 时，你必须只为 `for` 表达式指定一个参数。这个参数将代表你 `list` 中的每个项，以便你可以在输出块中访问每个项：
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding example, we are iterating over all the objects in `var.regions`.
    As we do, during each iteration, the current value is accessible in the `s` parameter.
    We can use the output block to generate any object we desire to be created in
    the new list that this `for` expression will create.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们遍历了 `var.regions` 中的所有对象。在每次迭代中，当前的值可以通过 `s` 参数访问。我们可以使用输出块生成我们希望在这个
    `for` 表达式创建的新列表中创建的任何对象。
- en: Iterating over a map
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历一个 `map`
- en: 'When iterating over a `map`, you must change how you structure your `for` expression.
    You must specify two instead of one parameter declared immediately after the `for`
    keyword:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在迭代一个`map`时，必须改变`for`表达式的结构。你需要在`for`关键字后立即指定两个参数，而不是一个：
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the preceding example, you’ll see that we specify two parameters for the
    `for` expression: `k` and `v`. We chose these names as a convention to help us
    remember what these variables mean within the scope of the `for` expression. `k`
    represents the map’s key, while `v` represents the value. The value can be any
    type, be it a primitive, collection, or complex object. If we want to access the
    `value` object, we access it based on its type. In this example, the value is
    a complex object with two attributes. In the `for` expression’s output block,
    we specify the structure of the object we want each item in the resulting array
    to have.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，你会看到我们为`for`表达式指定了两个参数：`k`和`v`。我们选择这些名称作为一种约定，帮助我们记住这些变量在`for`表达式范围内的含义。`k`表示映射的键，而`v`表示值。值可以是任何类型，无论是基本类型、集合还是复杂对象。如果我们想访问`value`对象，我们根据它的类型来访问它。在这个示例中，值是一个具有两个属性的复杂对象。在`for`表达式的输出块中，我们指定了我们希望结果数组中每个项的对象结构。
- en: 'In this case, we are creating an array of objects with three attributes: `region`,
    `address_space`, and `node_count`, essentially flattening the original map into
    an array of objects. The output looks like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在创建一个包含三个属性的对象数组：`region`、`address_space`和`node_count`，基本上是将原始的`map`扁平化为一个对象数组。输出如下所示：
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Outputting a list
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出一个列表
- en: 'The `for` expression will always output either a `list` or an object. You can
    select the output type you want by the character in which you wrap the `for` block.
    If you wrap the `for` expression in square brackets, then the expression will
    output a `list`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`表达式将始终输出一个`list`或一个对象。你可以通过将`for`块包裹在特定字符中来选择你想要的输出类型。如果将`for`表达式包裹在方括号中，则该表达式将输出一个`list`：'
- en: '[PRE40]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The preceding `for` expression will produce the following output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的`for`表达式将生成以下输出：
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Sometimes, the names of the module or resource outputs don’t align precisely
    with other resources’ desired inputs. Therefore, using a `for` expression and
    outputting a list can help transform these incongruent output values into a format
    convenient for consumption within another part of your code.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，模块或资源输出的名称与其他资源所需的输入不完全对齐。因此，使用`for`表达式并输出一个列表可以帮助将这些不一致的输出值转换为适合在代码的另一部分中使用的格式。
- en: Outputting an object
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出一个对象
- en: 'Wrapping the `for` expression with curly braces will output an object:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 将`for`表达式包裹在大括号中将输出一个对象：
- en: '[PRE42]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This approach will output an object with attributes for each item in the list
    of regions in the `regions` input variable. Each attribute will take the name
    of the concatenation of the region and country names, and its value will be an
    object with a single attribute called `node_count`. The output will look like
    this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法将输出一个对象，其中包含`regions`输入变量中每个区域项的属性。每个属性将采用区域和国家名称的连接作为名称，其值将是一个具有单个属性`node_count`的对象。输出结果如下所示：
- en: '[PRE43]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Outputting an object can be very useful in scenarios where you need to generate
    a JSON or YAML payload. You can reference this payload in another resource or
    output it so another tool can extract that value from Terraform using the `terraform`
    `output` command.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 输出一个对象在需要生成JSON或YAML负载的场景中非常有用。你可以在另一个资源中引用该负载，或者将其输出，以便通过`terraform`的`output`命令让另一个工具从Terraform中提取该值。
- en: Converting a list to a map
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将列表转换为映射
- en: 'One common problem is converting a list into a map. This is needed because,
    while a list is sometimes the most concise way of storing a simple collection,
    it cannot be used with the `for_each` iterator. Therefore, if you want to have
    your cake and eat it too, you need to convert that list into a map. This can be
    done with a simple `for` expression that iterates over the list in memory and
    outputs a map:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见问题是将列表转换为映射。这是必要的，因为尽管列表有时是存储简单集合的最简洁方式，但它不能与`for_each`迭代器一起使用。因此，如果你想两者兼得，就需要将该列表转换为一个映射。这可以通过一个简单的`for`表达式来完成，该表达式在内存中迭代列表并输出一个映射：
- en: '[PRE44]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding code, we are invoking the `for` expression and outputting an
    object using curly braces (`{}`). We are taking each element within the list and
    setting it as the key of our `map` and taking the element’s index within the `list`
    and setting it as the value. It’s important to note that this will only work when
    the items in the `list` are not duplicates.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们调用了 `for` 表达式并使用大括号 (`{}`) 输出一个对象。我们将列表中的每个元素设为 `map` 的键，将该元素在 `list`
    中的索引设为值。需要注意的是，这只有在 `list` 中的项目不是重复项时才有效。
- en: Now that we know how to loop, swoop, iterate, and cross-mojinate, we can avoid
    the pitfalls of copypasta by leveraging Terraform’s three extremely powerful iterators—`count`,
    `for_each`, and `for`—to build dynamic collections of resources, data sources,
    or anything really!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经了解了如何进行循环、跳跃、迭代和交叉组合，可以通过利用 Terraform 的三种极其强大的迭代器——`count`、`for_each`
    和 `for`——来构建资源、数据源或任何事物的动态集合，从而避免了复制粘贴的陷阱！
- en: We are nearing the end of our journey into the depths of HCL. Next, we will
    look at a few more language expressions that help us cope when we want to use
    dynamic collections and conditional logic to jazz up our modules!
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将结束对 HCL 深入探讨的旅程。接下来，我们将看看一些语言表达式，这些表达式帮助我们在使用动态集合和条件逻辑来丰富模块时应对挑战！
- en: Expressions
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式
- en: The HCL has some unique expressions to handle complex scenarios such as conditional
    logic, referencing dynamic types, and iterating nested blocks. We will learn about
    these final language structures before we delve into the library of functions
    available to us within the language.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: HCL 有一些独特的表达式，用于处理复杂的场景，比如条件逻辑、引用动态类型以及迭代嵌套块。在深入了解该语言中的函数库之前，我们将学习这些最终的语言结构。
- en: Conditional expressions
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件表达式
- en: 'In other languages, this technique is called a ternary conditional operator—namely,
    of the imperative variety. That’s fancy talk for an `if` statement in HCL. Typically,
    an `if` block spans multiple lines of code and uses some method for scoping the
    two conditions:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他编程语言中，这种技术称为三元条件运算符——即命令式的那种。这个术语其实是在说 HCL 中的 `if` 语句。通常，一个 `if` 块会跨越多行代码，并使用某种方式来作用域化这两个条件：
- en: '[PRE45]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This classic example shows how a conditional statement manifests in an imperative
    language. The curly brackets provide scope for the code that the computer will
    execute when the Boolean expression is `true` or `false`. In imperative code,
    you can do anything inside these scoped regions.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个经典例子展示了条件语句在命令式语言中的表现形式。大括号提供了代码作用域，当布尔表达式为 `true` 或 `false` 时，计算机会执行相应的代码。在命令式代码中，你可以在这些作用域内做任何事情。
- en: The difference between this approach and using a **ternary conditional operator**
    is that, with the former, the goal is always to produce a value.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与使用 **三元条件运算符** 的区别在于，前者的目标始终是生成一个值。
- en: 'With a ternary conditional operator, each condition must return a value. Consider
    the following expression:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三元条件运算符时，每个条件必须返回一个值。请考虑以下表达式：
- en: '[PRE46]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The preceding expression will set the value of `y` to be `50` when `x` is `5`,
    and it will set the value to `0` for any other value of `x`. The equivalent imperative
    code would look like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表达式会在 `x` 为 `5` 时将 `y` 的值设置为 `50`，对于 `x` 的其他任何值，它会将值设置为 `0`。等效的命令式代码如下所示：
- en: '[PRE47]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The difference between this imperative alternative and the ternary conditional
    operator statement is that the developer can do other things in the scope regions
    that are either related or unrelated to setting the value of `y` appropriately.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这种命令式替代方案与三元条件运算符语句的区别在于，开发者可以在作用域区域内做其他与设置 `y` 值相关或无关的事情。
- en: Splat expressions
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展开表达式
- en: 'A `count` or `for_each` meta-argument attached:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 附加了 `count` 或 `for_each` 元参数：
- en: '[PRE48]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Consider this collection of AWS EC2 instances. This block uses the `count`
    meta-argument to create a dynamic number of these resources from `0` to `n`, where
    `n` is the value of `var.node_count`. As a result, we can’t just access output
    values from this resource like we usually would if it were singular. We need to
    access it using an index to specify which instance of the `resource` block we
    want to access:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个 AWS EC2 实例集合。该块使用 `count` 元参数动态创建这些资源，从 `0` 到 `n`，其中 `n` 是 `var.node_count`
    的值。因此，我们不能像通常那样直接访问该资源的输出值，因为它不是单个资源。我们需要使用索引来指定要访问的 `resource` 块的实例：
- en: '[PRE49]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In this case, we specify the index of `0` and access its `id` attribute. But
    what if we wanted to get all of the values of `id` for every EC2 instance simultaneously?
    Using a `for` expression, we could iterate over the list of `aws_instance` resources.
    However, there is a better way—using the splat expression:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们指定索引`0`并访问其`id`属性。但如果我们想要同时获取所有EC2实例的`id`值呢？使用`for`表达式，我们可以遍历`aws_instance`资源的列表。然而，有一种更好的方法——使用splat表达式：
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Using `*` instead of an actual numeric index tells Terraform that we want to
    activate a splat expression. Instead of accessing a single object, we want to
    access all the objects in the array. Once done, `id` returns a `list` containing
    all the `id` values for our EC2 instances.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`*`而不是实际的数字索引，告诉Terraform我们想要激活一个splat表达式。我们不再访问单一对象，而是想访问数组中的所有对象。完成后，`id`返回一个`list`，包含我们所有EC2实例的`id`值。
- en: Dynamic blocks
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态块
- en: We know that Terraform represents the objects it provisions as `resource` blocks,
    which, as we know, support nested blocks within them. When a nested block supports
    many instances, it can sometimes be helpful to declare them dynamically using
    an approach called `resource` block based on a collection of objects.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，Terraform将它所提供的对象表示为`resource`块，而我们也知道，`resource`块支持嵌套块。当嵌套块支持多个实例时，有时使用基于对象集合的`resource`块动态声明它们会更有帮助。
- en: 'Let’s take the example of our Cosmos DB account that needs to replicate its
    databases across multiple geo-locations. We can add as many `geo_location` nested
    blocks as we want and configure them accordingly, but this can get tedious—especially
    if the configuration for each block is relatively uniform:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以Cosmos DB账户的示例来说明，它需要在多个地理位置之间复制数据库。我们可以根据需要添加任意数量的`geo_location`嵌套块，并相应地配置它们，但这可能会变得繁琐——尤其是当每个块的配置相对一致时：
- en: '[PRE51]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can accomplish the same thing using a dynamic block. Suppose we declare
    a map that defines the regions we want to replicate across and the failover priority
    of each region. In that case, we can use this map to drive a dynamic block that
    sets up our Cosmos DB account correctly—and concisely:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用动态块来实现相同的效果。假设我们声明一个映射，定义我们希望跨区域复制的区域和每个区域的故障转移优先级。在这种情况下，我们可以使用这个映射来驱动一个动态块，正确且简洁地设置我们的Cosmos
    DB账户：
- en: '[PRE52]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, with the `map` configured with our replication region settings, we can
    use a dynamic block to instruct the Cosmos DB resource on how to set up its `geo_location`
    nested blocks:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，配置了包含我们复制区域设置的`map`后，我们可以使用动态块来指示Cosmos DB资源如何设置其`geo_location`嵌套块：
- en: '[PRE53]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Notice that `geo_location` becomes a reference to each item in `local.regions`
    as we iterate through it, and because `local.regions` is a `map`, that means that
    `geo_location` is an item within this `map`. That means that each `geo_location`
    is a key/value pair, and we can use `key` and `value` to access the respective
    values when we set `location` and `failover_priority` on the `content` of the
    nested block.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`geo_location`在我们遍历`local.regions`时，变成了对`local.regions`中每个项的引用，因为`local.regions`是一个`map`，这意味着`geo_location`是这个`map`中的一项。也就是说，每个`geo_location`都是一个键值对，我们可以使用`key`和`value`来访问它们，在我们为嵌套块的`content`设置`location`和`failover_priority`时。
- en: That’s it! We have completed all the concepts, syntax, and modifiers within
    HCL. We are ready to start rocking the Terraform world, right?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们已经完成了HCL中的所有概念、语法和修饰符。我们已经准备好征服Terraform世界了，对吧？
- en: 'Hold up—before we do that, let’s pack our **bat belt** with tools to help us
    out of many tricky situations: functions!'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下——在我们做这个之前，让我们给我们的**战斗腰带**装上能帮助我们应对各种棘手情况的工具：函数！
- en: Functions
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: HCL includes dozens of functions that you can use to help develop your infrastructure
    with Terraform. However, I don’t plan on draining the ocean on every single function
    because I think many of them cover concepts that are outside the scope of this
    book. I will focus on the most pertinent and practical functions of developing
    excellent cloud infrastructure. Another exciting new feature that is available
    in Terraform 1.8.0 is the introduction of provider-specific functions. This allows
    provider authors (e.g., `aws`, `azurerm`, etc.) to create functions that provide
    useful functionality that is specific for that provider. This could be for common
    utilities such as parsing and AWS ARN or an Azure Resource Identifier.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: HCL包括了许多可以帮助你使用Terraform开发基础设施的函数。然而，我不打算一一讲解每个函数，因为我认为很多函数涉及的概念超出了本书的范围。我会专注于开发优质云基础设施中最相关和实用的函数。Terraform
    1.8.0版本的一个新特性是引入了提供商特定的函数。这允许提供商的作者（如`aws`、`azurerm`等）创建特定于该提供商的有用功能。这些功能可以是常用工具，比如解析AWS
    ARN或Azure资源标识符。
- en: Numeric functions
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数值函数
- en: Numeric functions operate on objects of the `number` type. The usual suspects
    are present—everything from absolute value, ceiling/floor, min/max, and so on.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 数值函数作用于`number`类型的对象。常见的数值操作包括绝对值、向上取整/向下取整、最小值/最大值等。
- en: Given that these functions cover fundamental concepts in math, they are primarily
    outside the scope of this book. I’d encourage you to check out the excellent documentation
    provided by HashiCorp on these functions.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这些函数涉及到数学中的基础概念，因此它们主要不在本书的讨论范围之内。我建议你查看HashiCorp提供的关于这些函数的优秀文档。
- en: String functions
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串函数
- en: String functions operate on objects of the `string` type. Like the numeric functions,
    the usual suspects are present.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串函数作用于`string`类型的对象。和数值函数一样，常见的字符串操作都可以用这些函数实现。
- en: There are several functions related to string manipulation, such as `split`,
    `replace`, and `join`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些与字符串处理相关的函数，比如`split`、`replace`和`join`。
- en: Split
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拆分
- en: The `split` function can be helpful when working with comma-delimited values
    that you might pass in as input variables. You can use input variables of the
    `string` type to pass in a collection of values. Using environment variables or
    command-line arguments makes it difficult to reliably pass in complex structures
    such as `list`, `map`, or `object`. Therefore, it is widespread to simplify those
    complex structures into multiple comma-delimited `string` input variables.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`split`函数在处理逗号分隔的值时非常有用，尤其是当你将其作为输入变量传入时。你可以使用`string`类型的输入变量传递一组值。使用环境变量或命令行参数使得可靠地传入像`list`、`map`或`object`这样的复杂结构变得困难。因此，简化这些复杂结构为多个逗号分隔的`string`输入变量是很常见的做法。'
- en: Several functions are used for cleansing data of unnecessary whitespaces, which
    can occur when you do string manipulation.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些函数用于清除数据中不必要的空格，这些空格可能是字符串处理时产生的。
- en: Format
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式化
- en: 'The `format` function can be a cleaner way to perform string manipulation without
    really nasty string interpolation—which can degrade the readability of your code
    with all the extra `${}` symbols added to separate object tokens:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`format`函数可以作为一种更简洁的字符串处理方式，避免了真正难看的字符串插值—那些额外的`${}`符号可能会影响代码的可读性，并将对象标记分隔开：'
- en: '[PRE54]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You can replace the preceding code with this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用以下代码替换之前的代码：
- en: '[PRE55]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `fizz`, `buzz`, and `wizz` values are passed into the corresponding `%s`.
    The `%s` symbol is a token to inject values passed in with specific formatting
    instructions. There are different verbs for different data types and formatting
    options.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`fizz`、`buzz`和`wizz`值被传递到相应的`%s`中。`%s`符号是一个标记，用来插入具有特定格式指令的传入值。不同的数据类型和格式选项有不同的动词。'
- en: A variant of this function called `formatlist` does the same thing but operates
    on `list(string)`. It is a convenience function that avoids the additional complexity
    of wrapping a `format` function in a `for` expression.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的一个变种叫做`formatlist`，它的功能相同，但作用于`list(string)`。它是一个便捷函数，避免了在`for`表达式中包裹`format`函数的额外复杂性。
- en: Replace
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换
- en: 'The `replace` function is another commonly used string function. Many cloud
    services have particular requirements for naming conventions, so `replace` is
    very useful when you want to cleanse your names of invalid characters when naming
    conditions are incongruent across different services:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`replace`函数是另一种常用的字符串函数。许多云服务对命名约定有特定要求，因此当你想要清除无效字符以使命名在不同服务中一致时，`replace`非常有用：'
- en: '[PRE56]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'For example, Azure Storage accounts do not allow hyphens in their names, while
    Azure resource groups do. Therefore, if you pass in an input variable to set a
    common prefix across all your resources and include a hyphen, you will run into
    trouble when Terraform attempts to provision the Azure Storage account:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Azure存储账户不允许在名称中使用连字符，而Azure资源组则允许。因此，如果你传递一个输入变量以在所有资源中设置一个公共前缀并包含连字符，当Terraform尝试创建Azure存储账户时，你将遇到问题：
- en: '[PRE57]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Replace can be used to eliminate this naming convention faux pax quickly.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 替换（Replace）可以快速消除这种命名约定的失误。
- en: Collection functions
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合函数
- en: Collection functions are an assortment of functions that let you work with objects
    of the `list` or `map` type. These contain everyday set-based operations, Boolean
    checks, and accessors.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 集合函数是一组允许你操作`list`或`map`类型对象的函数。它们包含日常的集合操作、布尔检查和访问器。
- en: Length
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 长度
- en: 'The `length` function is probably the most common collection function. It is
    often used with the `count` meta-argument as it provides a simple and dynamic
    method for obtaining the number of items in a list:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`length`函数可能是最常见的集合函数。它通常与`count`元参数一起使用，因为它提供了一种简单而动态的方法来获取列表中项目的数量：'
- en: '[PRE58]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In the preceding code, we calculate the number of fault domains using the `length`
    method on the `fault_domains` list. This approach will produce a value of `5`
    for the `fault_domain_count` local variable.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`length`方法来计算`fault_domains`列表中的故障域数量。此方法将为`fault_domain_count`局部变量生成一个值`5`。
- en: Range
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 范围
- en: 'The `range` function can be useful for taking a count and creating an array
    of indices for them. There are three overloads, but the most useful of the overloads
    is the one that follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`range`函数对于计算数量并为其创建索引数组非常有用。它有三个重载，其中最有用的重载如下：'
- en: '[PRE59]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This overload of the `range` function takes a `start` number and a `limit` number.
    This capability is helpful because cloud platforms often have deployment boundaries
    that are important to how we structure our architecture. These boundaries significantly
    impact the resiliency of our architecture—such as regions, Availability Zones,
    fault domains, and so on—so we must take them seriously.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`range`函数的这个重载接受一个`start`数值和一个`limit`数值。这种功能很有用，因为云平台通常有部署边界，这对于我们如何构建架构至关重要。这些边界显著影响架构的可靠性——比如地区、可用区、故障域等等——所以我们必须认真对待它们。'
- en: A common problem we face when working within and across these boundaries is
    that our deployments often need to be very specific about which area to target
    within a boundary. For example, I need to specify that my subnet is in Availability
    Zone 2 or that my VM needs to be in fault domain 3.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在这些边界内外工作时，常见的一个问题是，我们的部署往往需要非常具体地指定目标边界中的某个区域。例如，我需要指定我的子网位于可用区2，或者我的虚拟机需要位于故障域3。
- en: The problem arises because cloud platforms often don’t have a uniform or consistent
    way of telling us the domain of values for a particular boundary. For example,
    rather than giving us a list of *Availability Zone 1*, *Availability Zone 2*,
    and *Availability Zone 3*—the values we need to target our resources to the target
    area correctly—the cloud platform might give us a more cryptic *“This region has
    5 Availability Zones, Good Luck!”*. When we need to be specific, they are generic.
    This incongruence does not produce ideal outcomes.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 问题的根源在于，云平台通常没有一种统一或一致的方式告诉我们特定边界的值域。例如，云平台可能不会给我们一个*可用区1*、*可用区2*和*可用区3*的列表——这些是我们需要的值，以便将资源准确地定位到目标区域——而是可能会给我们一个更为晦涩的*“该区域有5个可用区，祝你好运！”*。当我们需要具体信息时，它们却给了我们笼统的信息。这种不一致性往往不能产生理想的结果。
- en: If we are hardcoding our resources, this would be fine. Still, when you want
    to provision to a dynamic list of Availability Zones, which allows you to iterate
    across the list of Availability Zones and provision some resources to each, you
    need to somehow convert a range into a discrete list of elements such that you
    can align each item in that list. Queue the music; here comes `range` to the rescue!
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在硬编码资源时，这种做法是可以接受的。但当你希望为动态的可用区列表进行部署时，这将允许你遍历可用区列表并为每个可用区部署一些资源，你就需要以某种方式将范围转换为一个离散的元素列表，以便你能对列表中的每个项目进行对齐。听音乐吧，`range`来拯救你了！
- en: '[PRE60]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In the preceding code, let’s pretend the cloud platform provided the hardcoded
    number of fault domains. We need to create a list that we can iterate across to
    provision a VM to each of the fault domains. Thanks to `range`, we can produce
    the following list:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，假设云平台提供了硬编码的故障域数量。我们需要创建一个可以迭代的列表，为每个故障域配置一个虚拟机。多亏了 `range`，我们可以生成以下列表：
- en: '[PRE61]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: With the preceding list, we can quickly iterate to create a VM in the correct
    subnet using the `count` meta-argument and the length of the `fault_domains` list.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的列表，我们可以快速迭代，利用 `count` 元参数和 `fault_domains` 列表的长度在正确的子网中创建虚拟机。
- en: Flatten
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Flatten
- en: 'The `flatten` function can be helpful when you have homogenous data elements
    stored within different arrays. This situation might occur when you have a module
    return a collection of sub-resources:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatten` 函数在处理存储在不同数组中的同质数据元素时非常有用。当一个模块返回一组子资源时，可能会出现这种情况：'
- en: '![Figure 2.3 – The Network module; each produces its list of subnets that you
    need to aggregate into a single list of subnets](img/B21183_02_3.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 网络模块；每个模块生成其子网列表，您需要将其聚合为一个单一的子网列表](img/B21183_02_3.jpg)'
- en: Figure 2.3 – The Network module; each produces its list of subnets that you
    need to aggregate into a single list of subnets
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 网络模块；每个模块生成其子网列表，您需要将其聚合为一个单一的子网列表
- en: In the preceding diagram, we can see that we have a module that provisions a
    network. This module outputs a list of subnets. Often, we want a module to encapsulate
    relevant sub-resources that are tightly coupled with the primary resource of the
    module. While this approach makes the code more maintainable, it also creates
    difficulties upstream if we want to act uniformly across all the sub-resources
    it outputs.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图示中，我们可以看到有一个模块用于配置网络。该模块输出一个子网列表。通常，我们希望一个模块能够封装与模块的主资源紧密相关的子资源。尽管这种方法使代码更具可维护性，但如果我们希望在其输出的所有子资源上统一操作，也会带来上游的困难。
- en: With `flatten`, we can collapse the list of lists into a single flattened list
    with each subnet as an item. Doing so will enable us to work uniformly with all
    of the subnets from the consuming module we are developing.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `flatten`，我们可以将多个列表压缩成一个单一的平铺列表，其中每个子网作为一个项目。这样做将使我们能够统一处理从我们正在开发的消费模块中获取的所有子网。
- en: Transpose
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Transpose
- en: 'The `transpose` function is also beneficial when working with hierarchies of
    objects with complex relationships with their children:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`transpose` 函数在处理具有复杂父子关系的对象层次结构时也非常有用：'
- en: '![Figure 2.4 – Resource VMs associated with a collection of security groups](img/B21183_02_4.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – 与一组安全组关联的资源虚拟机](img/B21183_02_4.jpg)'
- en: Figure 2.4 – Resource VMs associated with a collection of security groups
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 与一组安全组关联的资源虚拟机
- en: For example, in the preceding diagram, two VMs are associated with a collection
    of security groups. We have set this up as a `map` collection in this situation.
    The key would be the VM and the value of a collection of security groups.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在前面的图示中，两个虚拟机与一组安全组关联。我们在这种情况下将其设置为一个 `map` 集合。键将是虚拟机，值将是一个安全组集合。
- en: This `map` works excellently when we want to iterate over the top-level object—the
    VMs—but what if we’re going to iterate over the child objects, the security groups?
    We flip this relationship upside down using the `transpose` function on this map!
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要迭代顶级对象——虚拟机时，这个 `map` 表现得非常好，但如果我们想要迭代子对象——安全组呢？我们使用 `transpose` 函数翻转这个关系！
- en: '![Figure 2.5 – Security groups associated with a collection of VMs](img/B21183_02_5.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – 与一组虚拟机关联的安全组](img/B21183_02_5.jpg)'
- en: Figure 2.5 – Security groups associated with a collection of VMs
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 与一组虚拟机关联的安全组
- en: The preceding diagram shows that instead of having the top-level object be the
    VM, it’s now the security groups. The `transpose` operation has also replaced
    child objects with VMs. However, you’ll notice that the function has maintained
    the relationships between parent and child—we’re just looking at the relationship
    through a different lens.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示表明，与其将顶级对象设置为虚拟机，现在是安全组。`transpose` 操作还将子对象替换为虚拟机。然而，您会注意到，该函数保持了父子关系——我们只是通过不同的视角来看待这种关系。
- en: Zipmap
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Zipmap
- en: The `zipmap` function is handy when you have two `list` objects, one containing
    the keys and the other containing the corresponding values. Both list corresponding
    items in the same index, and the lists must be the same length.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`zipmap` 函数在你有两个 `list` 对象时非常有用，一个包含键，另一个包含相应的值。两个列表的对应项位于相同的索引处，且这两个列表的长度必须相同。'
- en: 'The name is interesting as it is an attempt at word painting. Imagine the construction
    of a zipper: two independent but parallel lists of notches, but when the zipper
    is applied sequentially, each notch on the left side is attached to the corresponding
    notch on the right side:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名称很有趣，因为它尝试进行文字描绘。想象一下拉链的构造：两个独立但平行的凹槽列表，当拉链依次应用时，左侧的每个凹槽都与右侧的对应凹槽连接：
- en: '![Figure 2.6 – VMs list and a corresponding security group list](img/B21183_02_6.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – 虚拟机列表及其对应的安全组列表](img/B21183_02_6.jpg)'
- en: Figure 2.6 – VMs list and a corresponding security group list
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 虚拟机列表及其对应的安全组列表
- en: In the preceding diagram, we have two lists, one containing VMs and another
    containing security groups. With the `zipmap` function, we can create a new `map`
    object that creates an association between each element in the VM and security
    group lists.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图示中，我们有两个列表，一个包含虚拟机，另一个包含安全组。通过 `zipmap` 函数，我们可以创建一个新的 `map` 对象，将虚拟机和安全组列表中的每个元素关联起来。
- en: Encoding functions
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码函数
- en: Encoding functions let you work with text of various encoding formats and convert
    back and forth between them. These include string-based operations such as Base64
    and string-to-object encoding formats such as JSON and YAML.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 编码函数让你能够处理各种编码格式的文本，并在它们之间进行相互转换。这些包括基于字符串的操作，如 Base64，以及字符串到对象的编码格式，如 JSON
    和 YAML。
- en: Many services will often require input data to be encoded in Base64 to simplify
    the transmission of complex data, and the two corresponding `encode` and `decode`
    functions work as you would expect them.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 许多服务通常要求将输入数据编码为 Base64，以简化复杂数据的传输，对应的两个 `encode` 和 `decode` 函数如你所料地工作。
- en: The JSON and YAML `encode` and `decode` functions work like typical serializers,
    with the `encode` functions taking in an object and producing a string—while the
    `decode` functions take in a string and produce an object.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 和 YAML 的 `encode` 和 `decode` 函数像典型的序列化器一样工作，`encode` 函数接收一个对象并生成一个字符串，而
    `decode` 函数接收一个字符串并生成一个对象。
- en: Filesystem functions
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件系统函数
- en: Filesystem functions provide a set of utilities that make it easier to work
    with local files, which can come in extremely handy if you need to drop a config
    file for the next step in your automation pipeline or if you need to access files
    containing content needed for resource provisioning.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统函数提供了一组工具，使得与本地文件的操作更加简便。如果你需要为自动化管道的下一步创建一个配置文件，或者需要访问包含资源配置所需内容的文件，这些工具将非常有用。
- en: File
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件
- en: 'The `file` function simply loads the contents from the file at the specified
    path on the disk into a string. The `path.module` special variable is used to
    specify the current working directory of the current module. This is useful during
    module development because it allows you to embed and use files to store content
    needed within your module:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`file` 函数会简单地将磁盘上指定路径的文件内容加载到一个字符串中。`path.module` 特殊变量用于指定当前模块的工作目录。在模块开发过程中，这非常有用，因为它允许你嵌入并使用文件来存储模块内所需的内容：'
- en: '[PRE62]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This method is commonly used in conjunction with the `jsondecode` and `yamldecode`
    functions to take the string content and convert it into an object that can be
    used more easily within HCL:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法通常与 `jsondecode` 和 `yamldecode` 函数一起使用，将字符串内容转换为一个可以更轻松地在 HCL 中使用的对象：
- en: '[PRE63]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Template file
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板文件
- en: 'The `templatefile` function works just like the `file` function but with a
    twist. It allows you to pass in parameters to be replaced with corresponding placeholders
    in the file specified:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`templatefile` 函数与 `file` 函数的作用相似，但有所不同。它允许你传入参数，并将这些参数替换文件中相应的占位符：'
- en: '[PRE64]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The parameters of `hostname` and `ip_address` indicate the tokens that should
    be replaced in the file with their corresponding values, `foo` and `10.0.1.8`,
    respectively. If the contents of the file contain the `${hostname}` or `${ip_address}`
    tokens, they will be replaced with the corresponding value. This can be a very
    convenient way to drop important configuration details into your infrastructure
    that is only available after Terraform has executed its plan.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`hostname` 和 `ip_address` 参数表示文件中应替换为其对应值（`foo` 和 `10.0.1.8`）的令牌。如果文件内容包含 `${hostname}`
    或 `${ip_address}` 令牌，它们将被替换为相应的值。这是将重要配置细节动态注入到基础设施中，在Terraform执行其计划后才可使用的一种非常方便的方法。'
- en: Date/time functions
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日期/时间函数
- en: Date/time functions provide a set of utilities for creating timestamps. These
    functions can help set expiration dates for short-term access tokens or transform
    a date/time string into the correct format expected by the specific resource you
    use.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 日期/时间函数提供了一组用于创建时间戳的工具。这些函数可以帮助为短期访问令牌设置过期日期，或将日期/时间字符串转换为特定资源所期望的正确格式。
- en: 'When working with time in Terraform, it’s important to note that there is no
    explicit date/time type. Terraform handles date/time values using the `string`
    type. The default format that Terraform uses is the RFC 3339 format, which looks
    like this:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在Terraform中处理时间时，重要的是要注意没有显式的日期/时间类型。Terraform使用 `string` 类型处理日期/时间值。Terraform使用的默认格式是RFC
    3339格式，格式如下：
- en: '[PRE65]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The preceding value has the following format:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 上述值具有以下格式：
- en: '[PRE66]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This behavior is essential to understand because all the date/time functions
    that are available will either take in or produce a timestamp in this format.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这个行为非常重要，因为所有可用的日期/时间函数都会接收或生成这种格式的时间戳。
- en: Hash/crypto functions
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哈希/加密函数
- en: Just like the encoding functions, there are several options when it comes to
    hashing and cryptographic functions. These functions implement a variety of hashing
    algorithms such as MD5 and SHA and encryption algorithms such as RSA. There are
    also corresponding file-based operations that allow you to read content from a
    file.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 就像编码函数一样，哈希和加密函数也有多个选项。这些函数实现了多种哈希算法，如MD5和SHA，以及加密算法，如RSA。还有对应的基于文件的操作，允许你从文件中读取内容。
- en: It’s important to remember that hashing is not the same thing as encryption
    and that when using encryption, you should secure the keys you use both inside
    and outside of the Terraform state.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，哈希（hashing）与加密（encryption）是不同的，当使用加密时，应该确保你在Terraform状态文件中使用的密钥在内外部都得到保护。
- en: IP network functions
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IP网络函数
- en: The IP network functions make it easier to work with CIDR blocks to split address
    spaces into subnets.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: IP网络函数使得操作CIDR块更容易，将地址空间划分为子网。
- en: Although Terraform’s networking functions support IPv4 and IPv6, we’ll look
    at IPv4 addresses in our examples to make it easier to understand.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Terraform的网络函数支持IPv4和IPv6，我们的示例将聚焦于IPv4地址，以便更容易理解。
- en: An IPv4 address is a 32-bit value with 4 octets and 8 bits per octet. We construct
    CIDR blocks to identify a range of IP addresses to allocate to a virtual network
    or a subnet within that virtual network.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4地址是一个32位值，包含4个字节，每个字节8位。我们构造CIDR块来识别一组IP地址，这些地址分配给虚拟网络或该虚拟网络内的子网。
- en: 'Terraform has the `cidrsubnet` function, which calculates these CIDR block
    ranges, making it easier to generate CIDR block ranges dynamically rather than
    hardcoding them or using string manipulation to construct them:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform有一个 `cidrsubnet` 函数，它计算这些CIDR块范围，使得动态生成CIDR块范围变得更加容易，而不是硬编码它们或使用字符串操作来构建它们：
- en: '[PRE67]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `prefix` argument is the network space you want to split up. The `newbits`
    argument is how big we want the chunks that the prefix splits into to be—its value
    has an inverse relationship with the size of the address space chunks. As the
    `newbits` value goes up, the size of the chunks decreases. As the value of `newbits`
    goes down, the size of the chunks increases:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`prefix` 参数是你想要拆分的网络空间。`newbits` 参数是你希望拆分后每个子块的大小——它的值与地址空间块的大小成反比。随着 `newbits`
    值的增大，子块的大小会减小；而随着 `newbits` 值的减小，子块的大小会增大：'
- en: '[PRE68]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In the preceding code, we are splitting up the address space of `10.0.0.0/16`
    with chunks that have `8` additional bits. That means we are looking for chunks
    with the size of `/24`—or 256 IP addresses. If we used `6` instead, we would be
    looking to split into chunks of `/22`—or 1,024 IP addresses. As you can see, the
    fewer additional bits, the more IP addresses in each chunk, and the fewer chunks
    we can fit into the primary address space:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们正在使用`10.0.0.0/16`的地址空间进行划分，每个块增加了`8`个额外的位。这意味着我们正在寻找大小为`/24`的块 — 即256个IP地址。如果我们使用`6`，我们将寻找大小为`/22`的块
    — 即1,024个IP地址。正如你所见，额外的位数越少，每个块中的IP地址就越多，我们能够容纳的块数就越少，因为它们占用了主地址空间：
- en: '[PRE69]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In the preceding code, we can use this function to construct the address space
    for each subnet within an AWS VPC. Thanks to the `count` meta-argument, we don’t
    need the `for` expression to construct a list of address spaces. We can use `count.index`
    to specify the `netnum` input to select which chunk we want our subnet to use.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们可以使用此函数在AWS VPC中为每个子网构建地址空间。由于`count`元参数的存在，我们不需要`for`表达式来构建地址空间列表。我们可以使用`count.index`来指定`netnum`输入，以选择我们希望我们的子网使用的块。
- en: Type conversion functions
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型转换函数
- en: Explicit type conversions are exceptionally rare in Terraform, but several functions
    are available to aid you if necessary, e.g., `tonumber`, `tobool`, `tolist`, etc.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 明确的类型转换在Terraform中非常少见，但如果有必要，可以使用多个函数来帮助你，例如`tonumber`、`tobool`、`tolist`等。
- en: Summary
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we took an in-depth look at the language that powers Terraform:
    HCL. We looked at its core structures: resources, data sources, locals, and modules.
    We looked at inputs and outputs that will help us design better contracts between
    our modules and the outside world. We looked at language structures that allow
    us to build dynamic collections of resources—helping us scale our code without
    all the copypasta. And lastly, we looked at an arsenal of functions that can help
    us when coding in HCL to solve complex problems quickly and efficiently.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入研究了驱动Terraform的语言：HCL。我们看了它的核心结构：资源、数据源、本地变量和模块。我们查看了输入和输出，这将帮助我们在模块和外部世界之间设计更好的合同。我们看了允许我们构建动态资源集合的语言结构
    — 这帮助我们在没有所有复制粘贴的情况下扩展我们的代码。最后，我们看了一系列函数，这些函数可以帮助我们在HCL中编码，快速高效地解决复杂问题。
- en: In the next chapter, we will explore the utility providers HashiCorp publishes
    that provide critical cross-platform functionality to our Terraform solutions.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨HashiCorp发布的实用程序提供程序，这些提供程序为我们的Terraform解决方案提供关键的跨平台功能。
