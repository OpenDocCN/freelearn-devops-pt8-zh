- en: Combining Classes, Configuration Files, and Extensions into Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about the tools that create modularized
    and reusable Puppet code in the form of classes and defined types. We discussed
    that almost all Puppet resources should be separated into appropriate classes,
    except if they logically need to be part of a defined type. This is almost enough
    syntax to build manifests for an entire fleet of agent nodes; each selecting the
    appropriate composite classes, which in turn include further required classes,
    with all the classes recursively instantiating the defined types.
  prefs: []
  type: TYPE_NORMAL
- en: What has not been discussed up until now is the organization of the manifests
    in the filesystem. It is obviously undesirable to stuff all of your code into
    one large `site.pp` file. The answer to this problem is provided by modules and
    will be explained in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Besides organizing classes and defines, modules are also a way to share common
    code. They are software libraries for Puppet manifests and plugins. They also
    offer a convenient place to locate the interface descriptions that were hinted
    at in the previous chapter. Puppet Labs runs a dedicated service for hosting open
    source modules, called the Puppet Forge.
  prefs: []
  type: TYPE_NORMAL
- en: 'The existence and general location of the modules were mentioned briefly in
    [Chapter 3](be2d7b8b-9ea8-4459-b415-081e77db07c7.xhtml), *A Peek into the Ruby
    Part of Puppet - Facts, Types, and Providers*. It is now time to explore these
    and other aspects in greater detail. We''ll cover the following topics in this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The contents of Puppet's modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a component module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding helpful Forge modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The contents of Puppet's modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A module can be seen as a higher-order organizational unit. It bundles up classes
    and defined types that contribute to a common management goal (specific system
    aspects or a piece of software, for example). These manifests are not all that
    is organized through modules; most modules also bundle files and file templates.
    There can also be several kinds of Puppet plugins in a module. This section will
    explain these different parts of a module and show you where they are located.
    You will also learn about the means of module documentation and how to obtain
    existing modules for your own use.
  prefs: []
  type: TYPE_NORMAL
- en: Parts of a module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For most modules, **manifests** form the most important part - the core functionality.
    The manifests consist of classes and defined types, which all share a namespace,
    rooted at the module name. For example, an `ntp` module will contain only classes
    and defines whose names start with the `ntp::` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many modules contain files that can be synced to the agent''s filesystem. This
    is often used for configuration files or snippets. You have seen examples of this,
    but let''s repeat them. A frequent occurrence in many manifests is `file` resources
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The previous resource references a file that ships with a hypothetical `ntp`
    module. It has been prepared to provide generally suitable configuration data.
    However, there is often the need to tweak some parameters inside such a file,
    so that the node manifests can declare customized config settings for the respective
    agent. The tool of choice for this is templates, which will be discussed inÂ [Chapter
    6](60cec52e-6b29-4028-bc15-3b5685598e6b.xhtml), *The Puppet Beginners Advanced
    Parts*.
  prefs: []
  type: TYPE_NORMAL
- en: Another possible component of a module that you have already read about is custom
    facts-code that gets synchronized to the agent and runs before a catalog is requested,
    so that the output becomes available as facts about the agent system.
  prefs: []
  type: TYPE_NORMAL
- en: These facts are not the only Puppet plugins that can be shipped with modules.
    There are also **parser functions** (also called **custom functions**), for one.
    These are actual functions that you can use in your manifests. In many situations,
    they are the most convenient way, if not the only way, to build some specific
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: The final plugin type that has also been hinted at in an earlier chapter is
    the custom native types and providers, which are conveniently placed in modules
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Module structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the mentioned components need to be located in specific filesystem locations
    for the master to pick them up. Each module forms a directory tree. Its root is
    named after the module itself. For example, the `ntp` module is stored in a directory
    called `ntp/`.
  prefs: []
  type: TYPE_NORMAL
- en: All manifests are stored in a subdirectory called `manifests/`. Each class and
    defined type has its own respective file. The `ntp::package` class will be found
    in `manifests/package.pp`, and the defined type called `ntp::monitoring::nagios`
    will be found in `manifests/monitoring/nagios.pp`. The first particle of the container
    name (`ntp`) is always the module name, and the rest describes the location under
    `manifests/`. You can refer to the module tree in the following paragraphs for
    more examples.
  prefs: []
  type: TYPE_NORMAL
- en: The `manifests/init.pp` file is special. It can be thought of as a default manifest
    location, because it is looked up for any definition from the module in question.
  prefs: []
  type: TYPE_NORMAL
- en: Both the examples that were just mentioned can be put into `init.pp` and will
    still work. Doing this makes it harder to locate the definitions, though.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, `init.pp` should only hold one class, which is named after the
    module (such as the `ntp` class), if your module implements such a class. This
    is a common practice, as it allows the manifests to use a simple statement to
    tap the core functionality of the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can refer to the *Module best practices* section for some more notes on
    this subject.
  prefs: []
  type: TYPE_NORMAL
- en: 'The files and templates that a module serves to the agents are not this strictly
    sorted into specific locations. It is only important that they be placed in the
    `files/` and `templates/` subdirectories, respectively. The contents of these
    subtrees can be structured to the module author''s liking, and the manifest must
    reference them correctly. Static files should always be addressed through URLs,
    such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'These files are found in the corresponding subdirectories of `files/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `modules` prefix in the URI is mandatory and is always followed by the module
    name. The rest of the path translates directly to the contents of the `files/`
    directory. There are similar rules for templates. You can refer to [Chapter 6](60cec52e-6b29-4028-bc15-3b5685598e6b.xhtml),
    *The Puppet Beginners Advanced Parts*, for the details.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, all plugins are located in the `lib/` subtree. Custom facts are Ruby
    files in `lib/facter/`. Parser functions are stored in `lib/puppet/parser/functions/`,
    the Puppet 4 API functions are located in `lib/puppet/functions/`, and for custom
    resource types and providers, there is `lib/puppet/type/` and `lib/puppet/provider/`,
    respectively. This is not a coincidence; these Ruby libraries are looked up by
    the master and the agent in the according namespaces. There are examples for all
    these components later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, the following are the contents of a possible module in a tree view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Documentation in modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A module can and should include documentation. The Puppet master does not process
    any module documentation by itself. As such, it is largely up to the authors to
    decide how to structure the documentation of the modules that are created for
    their specific site only. That being said, there are some common practices, and
    it's a good idea to adhere to them. Besides, if a module should end up being published
    on the Forge, appropriate documentation should be considered mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: The process of publishing modules is beyond the scope of this book. You can
    find a guide at [https://docs.puppetlabs.com/puppet/latest/reference/modules_publishing.html.](https://docs.puppet.com/puppet/latest/modules_publishing.html)
  prefs: []
  type: TYPE_NORMAL
- en: For many modules, the main focus of the documentation is centered on the `README`
    file, which is located right in the module's root directory. It is customarily
    formatted in Markdown as `README.md` or `README.markdown`. The `README` file should
    contain explanations and, often, there is a reference documentation as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Puppet DSL interfaces can also be documented right in the manifest, in the
    `rdoc`Â and `YARD` format. This applies to classes and defined types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can generate HTML documentation (including navigation) for all your modules
    using the `puppet strings` subcommand. This subcommand is available after installation
    of the puppet-strings Ruby extension: `puppet resource package puppet-strings
    provider=puppet_gem`. This practice is somewhat obscure, so it won''t be discussed
    here in great detail. However, if this option is attractive to you, we encourage
    you to peruse the documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command provides an overview of possible puppet strings functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Managing environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Puppet doesn''t organize things in modules exclusively. There is a higher-level
    unit called **environment** that groups and contains the modules. An environment
    mainly consists of:'
  prefs: []
  type: TYPE_NORMAL
- en: One or more site manifest files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `modules` directory with your modules inside
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional `environment.conf` configuration file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: "When the master compiles the manifest for a node, it uses exactly one environment\
    \ for this task. As described in [Chapter 2](7cafeeab-0e5c-4848-9eb0-1bae38ed3525.xhtml)\uFEFF\
    , *Puppet Server and Agents*, it always starts in `manifests/*.pp`, which form\
    \ the environment's site manifest. Before we take a look at how this works in\
    \ practice, let's look at an example `environment` directory:"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `environment.conf` file can customize the environment. Normally, Puppet
    uses `site.pp` and the other files in the `manifests` directory. To make Puppet
    read all the `pp` files in another directory, set the `manifest` option in `environment.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In most circumstances, the manifest option need not be changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `site.pp` file will include node classification with classes from the modules.
    Puppet looks for modules in the `modules` subdirectory of the active environment.
    You can define additional subdirectories that hold the modules by setting the
    `modulepath` option in `environment.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The directory structure can be made more distinctive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Configuring environment locations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Puppet uses the `production` environment by default. This and the other environments
    are expected to be located in `/opt/puppetlabs/code/environments`. You can override
    this default by setting the `environmentpath` option in `puppet.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Obtaining and installing modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Downloading existing modules is very common. Puppet Labs hosts a dedicated site
    for sharing and obtaining the modules - the Puppet Forge. It works justÂ the same
    as RubyGems or CPAN and makes it simple for the user to retrieve a given module
    through a command-line interface. In the Forge, the modules are fully named by
    prefixing the actual module name with the author's name, such as `puppetlabs-stdlib`
    or `ffrank-constraints`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `puppet module install` command installs a module in the active environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The *Testing your modules* section has information on using different environments.
  prefs: []
  type: TYPE_NORMAL
- en: The current release of the `stdlib` module (authored by the user `puppetlabs`)
    is downloaded from the Forge and installed in the standard modules' location.
    This is the first location in the current environment's `modulepath`, which is
    usually the `modules` subdirectory. Specifically, the modules will most likely
    end up in the `environments/production/modules` directory.
  prefs: []
  type: TYPE_NORMAL
- en: The `stdlib` module in particular should be considered mandatory; it adds a
    large number of useful functions to the Puppet language. Examples include the
    `keys`, `values`, and `has_key` functions, which are essential for implementing
    the proper handling of hash structures, to name only a few. The functions are
    available to your manifests as soon as the module is installed, there is no need
    to include any class or other explicit loading. If you write your own modules
    that add functions, these are loaded automatically in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Module best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With all the current versions of Puppet, you should make it a habit to put
    all the manifest code into modules, with only the following few exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: The `node` blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `include` statements for very select classes that should be omnipresent
    (the most common design pattern does this in the so-called base role, however;
    see [Chapter 9](0a0cf4b0-23fa-48fd-abf9-77ed851bb581.xhtml), *Puppet Roles and
    Profiles*, for the roles and profiles pattern)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declarations of helpful variables that should have the same availability as
    the Facter facts in your manifests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This section provides details on how to organize your manifests accordingly.
    It also advises some design practices and strategies in order to test the changes
    to the modules.
  prefs: []
  type: TYPE_NORMAL
- en: Putting everything in modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might find some manifests in very old installations that gather lots of
    manifest files in one or more directories and use the `import` statements in the
    `site.pp` file, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: All classes and defined types in these files are then available globally.
  prefs: []
  type: TYPE_NORMAL
- en: This whole approach had scalability issues and has long been deprecated. The
    `import` keyword is missing from Puppet 4 and the newer versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is far more efficient to give meaningful names to the classes and defined
    types so that Puppet can look them up in the collection of modules. The scheme
    has been discussed in an earlier section already, so let''s just look at another
    example where the Puppet compiler encounters a class name, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Puppet will go ahead and locate the `ntp` module in all the configured module
    locations of the active environment (path names in the `modulepath` setting).
    It will then try and read the `ntp/manifests/server/component/watchdog.pp` file
    in order to find the class definition. Failing this, it will try `ntp/manifests/init.pp`.
  prefs: []
  type: TYPE_NORMAL
- en: This makes compilation very efficient. Puppet dynamically identifies the required
    manifest files and includes only those for parsing. It also aids code inspection
    and development, as it is abundantly clear where you should look for specific
    definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, it is possible to stuff all of a module's manifests into its `init.pp`
    file, but you lose the advantages that a structured tree of module manifests offers.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding generalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each module should ideally serve a specific purpose. On a site that relies on
    Puppet to manage a diverse server infrastructure, there are likely modules for
    each respective service, such as `apache`, `ssh`, `nagios`, `nginx`, and so forth.
    Most of these modules will be taken from an upstream development and are referred
    to as "technical component modules". There can also be site-specific modules,
    such as `users` or `shell_settings,` if the operations require this kind of fine-grained
    control. Such customized modules are sometimes just named after the group or the
    company that owns them.
  prefs: []
  type: TYPE_NORMAL
- en: The ideal granularity depends on the individual requirements of your setup.
    What you generally want to avoid are modules with names such as `utilities` or
    `helpers,` which serve as a melting pot for ideas that don't fit in any of the
    existing modules. Such a lack of organization can be detrimental to discipline
    and can lead to chaotic modules that include definitions that should have become
    their own respective modules instead.
  prefs: []
  type: TYPE_NORMAL
- en: Adding more modules is cheap. A module generally incurs no cost for the Puppet
    master operation, and your user experience will usually become more efficient
    with more modules, not less so. Of course, this balance can tip if your site imposes
    special documentation or other handling prerequisites on each module. Such rulings
    must then be weighed into the decisions about module organization.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on the size of your agent network, some or many of your modules can
    be used by a large variety of nodes. Despite these commonalities, these nodes
    can be quite different from one another. A change to a central module, such as
    `ssh` or `ntp`, which are likely used by a large number of agents, can have quite
    extensive consequences.
  prefs: []
  type: TYPE_NORMAL
- en: The first and the most important tool for testing your work is the `--noop`
    option for Puppet. It works for `puppet agent`, as well as `puppet apply`. If
    it is given on the command-line, Puppet will not perform any necessary sync actions,
    and will merely present the respective line of output to you instead. There is
    an example of this in [Chapter 1](8a22dc0e-3fe2-4153-b60e-935b7e6d9f94.xhtml),
    *Writing Your First Manifests*.
  prefs: []
  type: TYPE_NORMAL
- en: When using a master instead of working locally with `puppet apply`, a new problem
    arises, though. The master is queried by all your agents. Unless all the agents
    are disabled while you are testing a new manifest, it is very likely that one
    will check in and accidentally run the untested code.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, even your test agent can trigger its regular run while you are logged
    in, transparently in the background.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to guard against such uncontrolled manifest applications.
    A small mistake can damage a number of agent machines in a short time period.
    The best way to go about this is to define multiple environments on the master
    and stage code changes. [Chapter 9](0a0cf4b0-23fa-48fd-abf9-77ed851bb581.xhtml)*,
    Puppet Roles and Profiles,* will provide further information on this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Safe testing with environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides the `production` environment, you should create at least one testing
    environment. You can call it `testing` or whatever you like. When using the directory
    environments, just create its directory in `environmentpath`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Such an additional environment is very useful for testing changes. The test
    environment or environments should be copies of the production data. Prepare all
    the manifest changes in `testing` first. You can make your agents test this change
    before you copy it to production:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can even omit the `noop` flag on some or all of your agents so that the
    change is actually deployed. Some subtle mistakes in the manifests cannot be detected
    from an inspection of the `noop` output, so it is usually a good idea to run the
    code at least once before releasing it.
  prefs: []
  type: TYPE_NORMAL
- en: Environments are even more effective when used in conjunction with source control,
    especially distributed systems such as `git` or `mercurial`. Versioning your Puppet
    code is a good idea independently of environments and testing; this is one of
    the greatest advantages that Puppet has to offer you through its infrastructure
    as code paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using environments and the `noop` mode form a pragmatic approach to testing
    that can serve in most scenarios. The safety against erroneous Puppet behavior
    is limited, of course. There are more formal ways of testing the modules:'
  prefs: []
  type: TYPE_NORMAL
- en: The `rspec-puppet` tool allows the module authors to implement unit tests based
    on `rspec`. You can find more details at [http://rspec-puppet.com/](http://rspec-puppet.com/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acceptance testing can be performed through `beaker`. You can refer to [https://github.com/puppetlabs/beaker/wiki/How-To-Beaker](https://github.com/puppetlabs/beaker/wiki/How-To-Beaker)Â for
    details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining these tools in detail is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Building a component module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has discussed many theoretical and operational aspects of modules,
    but you are yet to gain an insight into the process of writing modules. For this
    purpose, the rest of this chapter will have you create an example module step
    by step.
  prefs: []
  type: TYPE_NORMAL
- en: It should be stressed again that, for the most part, you will want to find general
    purpose modules from the Forge. The number of available modules is ever-growing,
    so the odds are good that there is something already there to help you with what
    you need to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that you want to add Cacti to your network: an RRD tool-based trend
    monitor and graphing server, including a web interface. If you would check the
    Forge first, you would indeed find some modules. However, let''s further assume
    that none of them speak to you, because either the feature set or the implementation
    is not to your liking. If even the respective interfaces don''t meet your requirements,
    it doesn''t make much sense to base your own module on an existing one (in the
    form of a fork on GitHub) either. You will, then, need to write your own module
    from scratch.'
  prefs: []
  type: TYPE_NORMAL
- en: Naming your module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Module names should be concise and to the point. If you manage a specific piece
    of software, name your module after it - `apache`, `java`, `mysql`, and so forth.
    Avoid verbs such as `install_cacti` or `manage_cacti`. If your module name does
    need to consist of several words (because the target subsystem has a long name),
    they should be divided by underscore characters. Spaces, dashes, and other non-alphanumeric
    characters are not allowed.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the module should just be named `cacti`.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, you will never write a module with names such as apache, mysql, java,
    as these are names already used from upstream development. When learning Puppet,
    one wants to start with a simple module implementation, maybe the upstream module
    is yet too complicated to understand. In this case, you want to prefix your modules
    with a company or team name. Keep in mind to not use the hyphen but an underscore
    to separate company/team name, for example, `packt_apache`, `infra_mysql`. This
    pattern will keep the original namepsace available and allow easier migration
    to upstream modules later.
  prefs: []
  type: TYPE_NORMAL
- en: Making your module available to Puppet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use your own module, you don't need to make it available for installation
    through `puppet module`. For that, you will need to upload the module to the Forge
    first, which will require quite some additional effort. Luckily, a module will
    work just fine without all this preparation, if you just put the source code in
    the proper location on your master.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create your own `cacti` module, create the basic directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to synchronize all the changes to `production` once the agents
    use them.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing basic module functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most modules perform all of their work through their manifests.
  prefs: []
  type: TYPE_NORMAL
- en: There are notable exceptions, such as the `stdlib` module. It mainly adds the
    parser functions and a few general-purpose resource types.
  prefs: []
  type: TYPE_NORMAL
- en: When planning the classes for your module, it is most straightforward to think
    about how you would like to use the finished module. There is a wide range of
    possible interface designs. The de facto standard stipulates that the managed
    subsystem is initialized on the agent system by including the module's main class;
    the class that bears the same name as the module and is implemented in the module's
    `init.pp` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our Cacti module, the user should use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As a result, Puppet would take all the required steps in order to install the
    software and, if necessary, perform any additional initialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating the `cacti` class and implementing the setup in the way you
    would from the command-line, replacing the commands with appropriate Puppet resources.
    On a Debian system, installing the `cacti` package is enough. Other required software
    is brought in through the dependencies (completing the LAMP stack), and after
    the package installation, the interface becomes available through the web URI
    `/cacti/` on the server machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Your module is now ready for testing. Invoke it from your agent''s manifest
    in `site.pp` or `nodes.pp` of the `testing` environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply it on your agent directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This will work on Debian, and Cacti is reachable via `http://<address>/cacti/`.
  prefs: []
  type: TYPE_NORMAL
- en: Some sites use an **External Node Classifier** (**ENC**), such as the Foreman.
    Among other helpful things, it can centrally assign environments to the nodes.
    In this scenario, the `--environment` switch will not work.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s unfortunate that the Cacti web interface will not come up when the home
    page is requested through the `/` URI. To enable this, give the module the ability
    to configure an appropriate redirection. Prepare an Apache configuration snippet
    in the module in `/opt/puppetlabs/code/environments/testing/packt_cacti/files/etc/apache2/conf.d/cacti-redirect.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The warning notice is helpful, especially when multiple administrators have
    access to the Cacti server.
  prefs: []
  type: TYPE_NORMAL
- en: 'It makes sense to add a dedicated class that will sync this file to the agent
    machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'A short file such as this can also be managed through the `file` type''s `content`
    property instead of `source`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is more efficient, because the content is part of the catalog and so the
    agent does not need to retrieve the checksum through another request to the master.
  prefs: []
  type: TYPE_NORMAL
- en: 'The module now allows the user to `include packt_cacti::redirect` in order
    to get this functionality. This is not a bad interface as such, but this kind
    of modification is actually well-suited to become a parameter of the `cacti` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The redirect is now installed by default when a manifest uses `include cacti`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the web server has other virtual hosts that serve things that are not Cacti,
    this might be undesirable. In such cases, the manifest will declare the class
    with the following parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Speaking of best practices, most modules will also separate the installation
    routine into a class of its own. In our case, this is hardly helpful, because
    the installation status is ensured through a single resource, but let''s do it
    anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s sensible to use `contain` here in order to make the Cacti management
    a solid unit. The `cacti::install` class is put into a separate `install.pp` manifest
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: On Debian, the installation process of the `cacti` package copies another Apache
    configuration file to `/etc/apache2/conf.d`. Since Puppet performs a normal `apt`
    installation, this result will be achieved. However, Puppet does not make sure
    that the configuration stays in this desired state.
  prefs: []
  type: TYPE_NORMAL
- en: There is an actual risk that the configuration might get broken. If the `puppetlabs-apache`
    module is in use for a given node, it will usually purge any unmanaged configuration
    files from the `/etc/apache2/` tree. Be very careful when you enable this module
    for an existing server. Test it in the `noop` mode. If required, amend the manifest
    to include the existing configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is prudent to add a `file` resource to the manifest that keeps the configuration
    snippet in its post-installation state. Usually with Puppet, this will require
    you to copy the config file contents to the module, just as the redirect configuration
    is in a file on the master. However, since the Debian package for Cacti includes
    a copy of the snippet in `/usr/share/doc/cacti/cacti.apache.conf`, you can instruct
    the agent to sync the actual configuration with that. Perform this in yet another
    de facto standard for modules the `config` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This class should be contained by the `packt_cacti` class as well. Running the
    agent again will now have no effect, because the configuration is already in place.
  prefs: []
  type: TYPE_NORMAL
- en: Creating utilities for derived manifests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have now created several classes that compartmentalize the basic installation
    and configuration work for your module. Classes lend themselves very well to implementing
    global settings that are relevant for the managed software as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: However, just installing Cacti and making its web interface available is not
    an especially powerful capability after all, the module does little beyond what
    a user can achieve by installing Cacti through the package manager. The much greater
    pain point with Cacti is that it usually requires configuration via its web interface;
    adding servers as well as choosing and configuring graphs for each server can
    be an arduous task and require dozens of clicks per server, depending on the complexity
    of your graphing needs.
  prefs: []
  type: TYPE_NORMAL
- en: This is where Puppet can be the most helpful. A textual representation of the
    desired states allows for quick copy and paste repetition and name substitution
    through regular expressions. Better yet, once there is a Puppet interface, users
    can devise their own defined types in order to save themselves from the copy and
    paste work.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of defined types, they are what is required for your module to allow
    this kind of configuration. Each machine in Cacti's configuration should be an
    instance of a defined type. The graphs can have their own type as well.
  prefs: []
  type: TYPE_NORMAL
- en: As with the implementation of the classes, the first thing you always need to
    ask yourself is how this task would be done from the command-line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, the better question can be what API you should use for this, preferably
    from Ruby. However, this is only important if you intend to write Puppet plugins:
    resource types and providers. We will look into this later in this very chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Cacti comes with a set of CLI scripts. The Debian package makes these available
    in `/usr/share/cacti/cli`. Let's discover these while we step through the implementation
    of the Puppet interface. The goals are defined types that will effectively wrap
    the command-line tools so that Puppet can always maintain the defined configuration
    state through appropriate queries and update commands.
  prefs: []
  type: TYPE_NORMAL
- en: Adding configuration items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When designing more capabilities for the Cacti module, first comes the ability
    to register a machine for monitoring - or rather, a **device**, as Cacti itself
    calls it (network infrastructure such as switches and routers are frequently monitored
    as well, and not only computers). The name for the first defined type should,
    therefore, be `cacti::device`.
  prefs: []
  type: TYPE_NORMAL
- en: The same warnings from the *Naming your module* subsection apply - don't give
    in to the temptation to give names such as `create_device` or `define_domain`
    to your type, unless you have very good reasons, such as the removal being impossible.
    Even then, it's probably better to skip the verb.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CLI script used to register a device is named `add_device.php`. Its help
    output readily indicate that it requires two parameters, which are `description`
    and `ip`. A custom description of an entity is often a good use for the respective
    Puppet resource''s title. The type almost writes itself now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In practice, it is often unnecessary to use so many variables, but it serves
    readability with the limited horizontal space of the page.
  prefs: []
  type: TYPE_NORMAL
- en: This `exec` resource gives Puppet the ability to use the CLI to create a new
    device in the Cacti configuration. Since PHP is among the Cacti package's requirements,
    it's sufficient to make the `exec` resource `require` the `cacti` class. Note
    the use of `$title`, not only for the `--description` parameter, but in the resource
    name for the `exec` resource as well. This ensures that each `packt_cacti::device`
    instance declares a unique `exec` resource in order to create itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `exec` resource type allows one to run arbitrary commands with root privileges
    and an empty shell environment. This allows one to flexibly wrap configuration
    commands in puppet DSL. But the exec resource type has its downside: the `exec`
    resource type is not, per-se idempotent and bares the risk that everything is
    done with running commands, which is against Puppet''s nature of being a declarative
    configuration management system. The best option is to see the `exec` resource
    type as an emergency exit: only use it if one sees no other possibilities to achieve
    the goals.'
  prefs: []
  type: TYPE_NORMAL
- en: Usually, a custom resource type is more suitable, especially when running difficult
    commands with difficult check options. The custom resource type is explained later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: However, this still lacks an important aspect. Written as in the preceding example,
    this `exec` resource will make the Puppet agent run the CLI script always, under
    any circumstances. This is incorrect though - it should only run if the device
    has not yet been added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every `exec` resource should have one of the `creates`, `onlyif`, or `unless`
    parameters. It defines a query for Puppet to determine the current sync state.
    The `add_device` call must be made unless the device exists already. The query
    for the existing devices must be made through the `add_graphs.php` script (counterintuitively).
    When called with the `--list-hosts` option, it prints one header line and a table
    of devices, with the description in the fourth column. The following `unless`
    query will find the resource in question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `path` parameter is useful, as it allows for calling the core utilities
    without the respective full path.
  prefs: []
  type: TYPE_NORMAL
- en: It is a good idea to generally set a standard list of search paths, because
    some tools will not work with an empty `PATH` environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: The `unless` command will return `0` if the exact resource title is found among
    the list of devices. The final `$` sign is escaped so that Puppet includes it
    in the `$search` command string literally.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now test your new define by adding the following resource to the agent
    machine''s manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: On the next `puppet agent --test` run, you will be notified that the command
    for adding the device has been run. Repeat the run and Puppet will determine that
    everything is now already synchronized with the catalog.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing customization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `add_device.php` script has a range of optional parameters that allow the
    user to customize the device. The Puppet module should expose these dials as well.
    Let''s pick one and implement it in the `packt_cacti::device` type. Each Cacti
    device has a `ping_method` that defaults to `tcp`. With the module, we can even
    superimpose our own defaults over those of the software:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The module uses a default of `icmp` instead of `tcp`. The value is always passed
    to the CLI script, whether it was passed to the `packt_cacti::device` instance
    or not. The parameter default is used in the latter case.
  prefs: []
  type: TYPE_NORMAL
- en: If you plan to publish your module, it is more sensible to try and use the same
    defaults as the managed software whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Once you incorporate all the available CLI switches, you will have successfully
    created a Puppet API in order to add devices to your Cacti configuration, giving
    the user the benefits of easy reproduction, sharing, implicit documentation, simple
    versioning, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Removing unwanted configuration items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is still one remaining wrinkle. It is atypical for Puppet types to be
    unable to remove the entities that they create. As it stands, this is a technical
    limitation of the CLI that powers your module, because it does not implement a
    `remove_device` function yet. Such scripts have been made available on the internet,
    but are not properly a part of Cacti at the time of writing this.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give the module more functionality, it would make sense to incorporate additional
    CLI scripts among the module''s files. Put the appropriate file into the right
    directory under `modules/cacti/files/` and add another `file` resource to the
    `cacti::install` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then add an `ensure` attribute to the `cacti::device` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note that we took some liberties with the indentation here, so as to not break
    too many lines. This new `exec` resource is quite a mouthful, because the `remove_device.php`
    script requires the numeric ID of the device to be removed. This is retrieved
    with a `--list-devices` call that is piped to `awk`. To impair readability even
    more, some things such as double quotes, `$` signs, and backslashes must be escaped
    so that Puppet includes a valid `awk` script in the catalog.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note that the query for the sync state of this `exec` resource is identical
    to the one for the `add` resource, except that now it is used with the `onlyif`
    parameter: only take action *if* the device in question is still found in the
    configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with complexity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The commands we implemented for the `packt_cacti::device` define are quite convoluted.
    At this level of complexity, shell one-liners become unwieldy for powering Puppet's
    resources. It gets even worse when handling the Cacti graphs; the `add_graphs.php`
    CLI script requires numeric IDs of not only the devices, but of the graphs as
    well. At this point, it makes sense to move the complexity out of the manifest
    and write wrapper scripts for the actual CLI. I will just sketch the implementation.
    The wrapper script will follow this general pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, you can add a straightforward `graph` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This also requires, an additional `cacti-find-graph` script. Adding this poses
    an additional challenge as the current CLI has no capabilities for listing configured
    graphs. There are many more functionalities that can be added to a `cacti` module,
    such as the management of Cacti's data sources and the ability to change options
    of the devices and, possibly, other objects that already exist in the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Such commodities are beyond the essentials and won't be detailed here. Let's
    look at some other parts for your exemplary `cacti` module instead.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing the agent through plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The reusable classes and defines give manifests that use your module much more
    expressive power. Installing and configuring Cacti now works concisely, and the
    manifest to do this becomes very readable and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: "It's time to tap into the even more powerful aspect of modules: Puppet plugins.\
    \ The different types of plugins are custom facts (which were discussed in [Chapter\
    \ 3\uFEFF](be2d7b8b-9ea8-4459-b415-081e77db07c7.xhtml), *A Peek into the Ruby\
    \ Part of Puppet - Facts, Types, and Providers*), parser functions, resource types,\
    \ and providers. All these plugins are stored in the modules on the master and\
    \ get synchronized to all the agents. The agent will not use the parser functions\
    \ (they are available to the users of `puppet apply` on the agent machine once\
    \ they are synchronized, however); instead, the facts and resource types do most\
    \ of their work on the agent. Let's concentrate on the types and providers for\
    \ now; the other plugins will be discussed in dedicated sections later."
  prefs: []
  type: TYPE_NORMAL
- en: This section can be considered optional. Many users will never touch the code
    for any resource type or provider the manifests give you all the flexibility you
    will ever need. If you don't care for plugins, do skip ahead to the final sections
    about finding the Forge modules. On the other hand, if you are confident about
    your Ruby skills and would like to take advantage of them in your Puppet installations,
    read on to find the ways in which custom types and providers can help you.
  prefs: []
  type: TYPE_NORMAL
- en: While the custom resource types are functional on both the master and the agent,
    the provider will do all its work on the agent side. Although the resource types
    also perform mainly through the agent, they have one effect on the master; they
    enable manifests to declare resources of the type. The code not only describes
    what properties and parameters exist, but it can also include the validation and
    transformation code for the respective values. This part is invoked by the agent.
    Some resource types even do the synchronization and queries themselves, although
    there is usually at least one provider that takes care of this.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, you implemented a defined type that did all its synchronization
    by wrapping some `exec` resources. By installing binaries and scripts through
    Puppet, you can implement almost any kind of functionality this way and extend
    Puppet without ever writing one plugin. This does have some disadvantages, however:'
  prefs: []
  type: TYPE_NORMAL
- en: The output is cryptic in the ideal case and overwhelming in the case of errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Puppet shells out to at least one external process per resource; and in many
    cases, multiple forks are required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, you pay a price, both in terms of usability and performance. Consider
    the `packt_cacti::device` type. For each declared resource, Puppet will have to
    run an `exec` resource's `unless` query on each run (or `onlyif` when `ensure
    => absent` is specified). This consists of one call to a PHP script (which can
    be expensive) as well as several core utilities that have to parse the output.
    On a Cacti server with dozens or hundreds of managed devices, these calls add
    up and make the agent spend a lot of time forking off and waiting for these child
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a provider, on the other hand. It can implement an `instances` hook,
    which will create an internal list of configured Cacti devices once during initialization.
    This requires only one PHP call in total, and all the processing of the output
    can be done in the Ruby code directly inside the agent process. These savings
    alone will make each run much less expensive: resources that are already synchronized
    will incur no penalty, because no additional external commands need to be run.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a quick look at the agent output before we go ahead and implement
    a simple type/provider pair. The following is the output of the `cacti::device`
    type when it creates a device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The native types express such actions in a much cleaner manner, such as the
    output from a `file` resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Replacing a defined type with a native type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of creating a custom resource type with a matching provider
  prefs: []
  type: TYPE_NORMAL
- en: '(or several providers) is not easy. Let''s go through the steps involved:'
  prefs: []
  type: TYPE_NORMAL
- en: Naming your type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the resource type's interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing sensible parameter hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using resource names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring management commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the basic functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing the provider to prefetch existing resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making the type robust during provisioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naming your type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first important difference between the native and defined types is the naming.
    There is no module namespacing for the custom types as you get with the defined
    types, which are manifest-based. Native types from all the installed modules mingle
    freely, if you will. They use plain names. It would, therefore, be unwise to call
    the native implementation of `packt_cacti::device` just `device -` this will easily
    clash with whatever notion of devices another module might have. The obvious choice
    for naming your first resource type is `cacti_device`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type must be completely implemented in `packt_cacti/lib/puppet/type/cacti_device.rb`.
    All hooks and calls will be enclosed in a `Type.newtype` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The documentation string in `@doc` should be considered mandatory, and it should
    be a bit more substantial than this example. Consider including one or more example
    resource declarations. Put all the further code pieces between the `EOD` terminator
    and the final `end`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the resource type's interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, the type should have the `ensure` property. Puppet''s resource
    types have a handy helper method that generates all the necessary type code for
    it through a simple invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'With this method call in the body of the type, you add the typical `ensure`
    property, including all the necessary hooks. This line is all that is needed in
    the type code (actual implementation will follow in the provider). Most properties
    and parameters require more code, just the same as the `ip` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This should usually be an `ip` property instead, but the provider will rely
    on the Cacti CLI, which has no capability for changing the already configured
    devices. If the IP address was a property, such changes would be required in order
    to perform property-value synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the IP address parameter code consists mostly of validation.
  prefs: []
  type: TYPE_NORMAL
- en: Add the `require 'ipaddr'` line near the top of the file rather than inside
    the `Type.newtype` block.
  prefs: []
  type: TYPE_NORMAL
- en: The parameter is now available for the `cacti_device` resources, and the agent
    will even refuse to add devices whose IP addresses are not valid. This is helpful
    forÂ users, because obvious typos in the addresses will be detected early. Let's
    implement the next parameter before we look at the `munge` hook more closely.
  prefs: []
  type: TYPE_NORMAL
- en: Designing sensible parameter hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Moving right along to the `ping_method` parameter, it accepts values only from
    a limited set, so validation is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the `munge` blocks carefully, you will notice that they aim at unifying
    the input values. This is much less critical for the parameters than the properties,
    but if either of these parameters is changed to a property in a future release
    of your Cacti module, it will not try to sync a `ping_method` of `tcp` to `TCP.`
    The latter might appear if the users prefer uppercase in their manifest. Both
    values just become `:tcp` through munging. For the IP address, invoking `downcase`
    has an effect only for IPv6.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond the scope of Puppet itself, the munging of a parameter's value is important
    as well. It allows Puppet to accept more convenient values than the subsystem
    being managed. For example, Cacti might not accept `TCP` as a value, but Puppet
    will, and it will do the right thing with it.
  prefs: []
  type: TYPE_NORMAL
- en: Using resource names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to take care of one final requirement: each Puppet resource type must
    declare a `name variable` or `namevar`, for short. This parameter will use the
    resource title from the manifest as its value, if the parameter itself is not
    specified for the resource. For example, the `exec` type has the `command` parameter
    for its `namevar`. You can either put the executable command into the resource
    title or explicitly declare the parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: To mark one of the existing parameters as the name variable, call the `isnamevar`
    method in that parameter's body. If a type has a parameter called `:name`, it
    automatically becomes the name variable. This is a safe default.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The resource type is now already usable inside a manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This code will get compiled into a catalog, but the agent will produce an error,
    due to the reason that there is no provider available.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The resource type itself is ready for action, but it lacks a provider to do
    the actual work of inspecting the system and performing the synchronization. Let's
    build it step by step, just the same as the type. The name of the provider need
    not reflect the resource type it's for. Instead, it should contain a reference
    to the management approach it implements. Since your provider will rely on the
    Cacti CLI, name it `cli`. It's fine for multiple providers to share a name if
    they provide functionality to different types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the skeleton structure in `packt_cacti/lib/puppet/provider/cacti_device/cli.rb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Specifying `:parent => Puppet::Provider` is not necessary, actually. `Puppet::Provider`
    is the default base class for the providers. If you write a couple of similar
    providers for a subsystem (each catering to a different resource type), all of
    which rely on the same toolchain, you might want to implement a base provider
    that becomes the parent for all the sibling providers.
  prefs: []
  type: TYPE_NORMAL
- en: For now, let's concentrate on putting together a self-sufficient `cli` provider
    for the `cacti_device` type. First of all, declare the commands that you are going
    to need.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring management commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Providers use the `commands` method to conveniently bind executables to
  prefs: []
  type: TYPE_NORMAL
- en: 'Ruby identifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You won''t be invoking `php` directly. It''s included here because declaring
    commands serves two purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: You can conveniently call the commands through a generated method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The provider will mark itself as `valid` only if all the commands are found
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, if the `php` CLI command is not found in Puppet's search path, Puppet will
    consider the provider to be dysfunctional. The user can determine this error condition
    quite quickly through Puppet's debug output.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the basic functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic functions of the provider can now be implemented in three instance
    methods. The names of these methods are not magic as such, but these are the methods
    that the default `ensure` property expects to be available (remember that you
    used the `ensurable` shortcut in the type code).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is the method that creates a resource if it does not exist yet. It
    must gather all the resource parameter''s values and build an appropriate call
    to `add_device.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Don't quote the parameter values as you would quote them on the command-line.
    Puppet takes care of this for you. It also escapes any quotes that are in the
    arguments, so in this case, Cacti will receive any quotes for inclusion in the
    configuration. For example, this will lead to an incorrect title.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The provider must also be able to remove or `destroy` an entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `property_hash` variable is an instance member of the provider. Each resource
    gets its specific provider instance. Read on to learn how it gets initialized
    to include the device's ID number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get to that, let''s add the final provider method in order to implement
    the `ensure` property. This is a query method that the agent uses to determine
    whether a resource is already present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `ensure` property relies on the provider class method `instances` in order
    to get a list of `providers` for all the entities on the system. It compares each
    of them with the `resource` attribute, which is the resource type instance for
    which this current provider instance is performing the work. If this is rather
    confusing, please refer to the diagram in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing the provider to prefetch existing resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `instances` method is truly special - it implements the prefetching of
    the system resources during the provider initialization. You have to add it to
    the provider yourself. Some subsystems are not suitable for the mass-fetching
    of all the existing resources (such as the `file` type). These providers don''t
    have an `instances` method. Enumerating the Cacti devices, on the other hand,
    is quite possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `ensure` value of the provider instance reflects the current state. The
    method creates instances for the resources that are found on the system, so for
    these, the value is always `present`. Also note that the result of the method
    is cached in the `@instances` class member variable. This is important, because
    the `exists?` method calls `instances`, which can happen a lot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Puppet requires another method to perform proper prefetching. The mass-fetching
    you implemented through `instances` supplies the agent with a list of provider
    instances that represent the entities found on the system. From the master, the
    agent received a list of the resource type instances. However, Puppet has not
    yet built a relation between the resources (type instances) and providers. You
    need to add a `prefetch` method to the provider class in order to make this happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The agent passes the `cacti_device` resources as a hash, with the resource title
    as the respective key. This makes lookups very simple (and quick).
  prefs: []
  type: TYPE_NORMAL
- en: 'This completes the `cli` provider for the `cacti_device` type. You can now
    replace your `cacti::device` resources with the `cacti_device` instances to enjoy
    improved performance and cleaner agent output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Note that, unlike your defined type `cacti::device`, a native type will not
    assume a default value of `present` for its `ensure` property. Therefore, you
    have to specify it for any `cacti_device` resource. Otherwise, Puppet will only
    manage the properties of the resources that already exist and not care about whether
    the entity exists or not. In the particular case of `cacti_device`, this will
    never do anything, because there are no other properties (only parameters).
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to [Chapter 6](60cec52e-6b29-4028-bc15-3b5685598e6b.xhtml), *The
    Puppet Beginners Advanced Parts*, on how to use resource defaults to save you
    from the repetition of the `ensure => present` specification.
  prefs: []
  type: TYPE_NORMAL
- en: Making the type robust during provisioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is yet another small issue with the `packt_cacti` module. It is self-sufficient
    and handles both the installation and configuration of Cacti. However, this means
    that during Puppet's first run, the `cacti` package and its CLI will not be available,
    and the agent will correctly determine that the `cli` provider is not yet suitable.
    Since it is the only provider for the `cacti_device` type, any resource of this
    type that is synchronized before the `cacti` package will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the defined type `packt_cacti::device`, you just added the `require`
    metaparameters to the inner resources. To achieve the same end for the native
    type instances, you can work with the `autorequire` feature. Just as the files
    automatically depend on their containing directory, the Cacti resources should
    depend on the successful synchronization of the `cacti` package. Add the following
    block to the `cacti_device` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Enhancing Puppet's system knowledge through facts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When facts were introduced in [Chapter 3](be2d7b8b-9ea8-4459-b415-081e77db07c7.xhtml),
    *A Peek into the Ruby Part of Puppet - Facts, Types, and Providers*, you got a
    small tour of the process of creating your own custom facts.
  prefs: []
  type: TYPE_NORMAL
- en: We hinted at modules at that point, and now, we can take a closer look at how
    the fact code is deployed, using the example of the `Cacti` module. Let's focus
    on native Ruby facts - they are more portable than the external facts. As the
    latter are easy to create, there is no need to discuss them in depth here.
  prefs: []
  type: TYPE_NORMAL
- en: For details on external facts, you can refer to the online documentation on
    custom facts on the Puppet Labs site at [http://docs.puppetlabs.com/facter/latest/custom_facts.html#external-facts](http://docs.puppetlabs.com/facter/latest/custom_facts.html#external-facts).
  prefs: []
  type: TYPE_NORMAL
- en: 'Facts are part of the Puppet plugins that a module can contain, just as the
    types and providers from the previous sections. They belong in the `lib/facter/`
    subtree. For users of the `cacti` module, it might be helpful to learn which graph
    templates are available on a given Cacti server (once the graph management is
    implemented, that is). The complete list can be passed through a fact. The following
    code in `packt_cacti/lib/facter/cacti_graph_templates.rb` will do just this job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The code will call the CLI script, skip its first line of output, and join the
    values from the second column of each remaining line in a list. Manifests can
    access this list through the global `$cacti_graph_templates` variable, just the
    same as any other fact.
  prefs: []
  type: TYPE_NORMAL
- en: Refining the interface of your module through custom functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions can be of great help in keeping your manifest clean and maintainable,
    and some tasks cannot even be implemented without resorting to a Ruby function.
  prefs: []
  type: TYPE_NORMAL
- en: A frequent use of the custom functions (especially in Puppet 3) is input validation.
    You can do this in the manifest itself, but it can be a frustrating exercise because
    of the limitations of the language. The resulting Puppet DSL code can be hard
    to read and maintain. The `stdlib` module comes with the `validate_X` functions
    for many basic data types, such as `validate_bool`. Typed parameters in Puppet
    4 and later versions make this more convenient and natural, because for the supported
    variable types, no validation function is needed anymore.
  prefs: []
  type: TYPE_NORMAL
- en: As with all the plugins, the functions need not be specific to the module's
    domain, and they instantly become available for all the manifests. A case in point
    is the `packt_cacti` module that can use the validation functions for the `packt_cacti::device`
    parameters. Checking whether a string contains a valid IP address is not at all
    specific to Cacti. On the other hand, checking whether `ping_method` is one of
    those that Cacti recognizes is not that generic.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how it works, let''s just implement a function that does the job of
    the `validate` and `munge` hooks from the custom `cacti_device` type for the IP
    address parameter of `packt_cacti::device`. This should fail the compilation if
    the address is invalid; otherwise, it should return the unified address value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In the exception message, `@resource.ref` is expanded to the textual reference
    of the offending resource type instance, such as `Packt_cacti::Device[Edge Switch
    03]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates the use of the function in the simple version
    of `cacti::device` without the `ensure` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The manifest will then fail to compile if an IP address has (conveniently)
  prefs: []
  type: TYPE_NORMAL
- en: 'transposed digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: IPv6 addresses will be converted to all lowercase letters.
  prefs: []
  type: TYPE_NORMAL
- en: Puppet 4 introduced a more powerful API for defining the custom functions. Refer
    to [Chapter 6](60cec52e-6b29-4028-bc15-3b5685598e6b.xhtml), *The Puppet Beginners
    Advanced Parts*, to learn about its advantages.
  prefs: []
  type: TYPE_NORMAL
- en: Making your module portable across platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sadly, our `Cacti` module is very specific to the Debian package. It expects
    to find the CLI at a certain place and the Apache configuration snippet at another.
    These locations are most likely specific to the Debian package. It would be useful
    for the module to work on the Red Hat derivatives as well.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to get an overview of the differences by performing a manual
    installation. I chose to test this with a virtual machine running Fedora 18\.
    The basic installation is identical to Debian, except using `yum` instead of `apt-get`,
    of course. Puppet will automatically do the right thing here. The `puppet::install`
    class also contains a CLI file, though. The Red Hat package installs the CLI in
    `/var/lib/cacti/cli`, rather than `/usr/share/cacti/cli`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the module is supposed to support both platforms, the target location for
    the `remove_device.php` script is no longer fixed. Therefore, it''s best to deploy
    the script from a central location in the module, while the target location on
    the agent system becomes a module parameter, if you will. Such values are customarily
    gathered in a `params` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: It is best to fail the compilation for unsupported agent platforms. Users will
    have to remove the declaration of the `cacti` class from their module, rather
    than have Puppet try untested installation steps that most likely will not work
    (this might concern Gentoo or a BSD variant).
  prefs: []
  type: TYPE_NORMAL
- en: 'Classes that need to access the variable value must include the `params` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Similar transformations will be required for the `cacti::redirect` class and
    the `cacti::config` class. Just add more variables to the `params` class. This
    is not limited to the manifests, either; the facts and providers must behave in
    accordance with the agent platform as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will often see that the `params` class is inherited rather than included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This is done because an `include` statement in the class body won't allow the
    use of variable values from the `params` class as the class parameter's default
    values, such as the `$redirect` parameter in this example.
  prefs: []
  type: TYPE_NORMAL
- en: The portability practices are often not required for your own custom modules.
    In the ideal case, you won't use them on more than one platform. The practice
    should be considered mandatory if you intend to share them on the Forge, though.
    For most of your Puppet needs, you will not want to write modules anyway, but
    download existing solutions from the Forge instead.
  prefs: []
  type: TYPE_NORMAL
- en: In Puppet 4.9 and later versions, the params class pattern will no longer be
    necessary to ship the default parameter values. There is a new data binding mechanism
    instead. This mechanism is explained in [Chapter 8](6d37b9a7-780a-49f2-a965-4431d8517de6.xhtml),
    *Separation of Code and Data with Hiera*.
  prefs: []
  type: TYPE_NORMAL
- en: Finding helpful Forge modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the web interface at [http://forge.puppetlabs.com](http://forge.puppetlabs.com/)
    is very straightforward. By filling the search form with the name of the software,
    system, or service you need to manage, you will usually get a list of very fitting
    modules often with just your search term as their name. In fact, for common terms,
    the number of available modules can be overwhelming.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get immediate feedback about the maturity and popularity of each module.
    A module is being actively used and maintained if:'
  prefs: []
  type: TYPE_NORMAL
- en: It has a score close to 5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a version number that indicates releases past 1.0.0 (or even 0.1.0)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its most recent release was not too long ago, perhaps less than half a year
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a significant number of downloads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The latter three numbers can vary a lot though, depending on the number of features
    that the module implements and how widespread its subject is. Even more importantly,
    just because a particular module gets much attention and regular contributions,
    it does necessarily mean that it is the best choice for your situation.
  prefs: []
  type: TYPE_NORMAL
- en: You are encouraged to evaluate less trafficked modules as well - you can unearth
    some hidden gems this way. The next section details some deeper indicators of
    quality for you to take into consideration.
  prefs: []
  type: TYPE_NORMAL
- en: If you cannot, or don't want to, spend too much time digging for the best module,
    you can also just refer to the sidebar with the Puppet Supported and Puppet Approved
    modules. All modules that are featured in these categories have got a seal of
    quality from Puppet Labs.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying module characteristics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When navigating to a module's details in the Forge, you are presented with its
    `README` file. An empty or very sparse documentation speaks of little care taken
    by the module author. A sample manifest in the `README` file is often a good starting
    point in order to put a module to work quickly.
  prefs: []
  type: TYPE_NORMAL
- en: If you are looking for a module that will enhance your agents through additional
    resource types and providers, look for the Types tab on the module details page.
    It can also be enlightening to click on the Project URL link near the top of the
    module description. This usually leads to GitHub. Here, you can not only conveniently
    browse the plugins in the `lib/` subtree, but also get a feel of how the module's
    manifests are structured.
  prefs: []
  type: TYPE_NORMAL
- en: Another sign of a carefully maintained module are unit tests. These are found
    in the `spec/` subtree. This tree does exist for most of the Forge modules. It
    tends to be devoid of actual tests, though. There may be test code files for all
    the classes and the defined types that are part of the module's manifest; these
    are typically in the `spec/classes/` and `spec/defines/` subdirectories, respectively.
    For plugins, there will ideally be unit tests in `spec/unit/` and `spec/functions/`.
  prefs: []
  type: TYPE_NORMAL
- en: Some `README` files of the modules contain a small greenish tag saying **build
    passing**. This can turn red on occasions, stating **build failing**. These modules
    use the Travis CI through GitHub, so they are likely to have at least a few unit
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the development in Puppet should be done in modules, and each such module
    should serve as specific a purpose as possible. Most modules comprise only manifests.
    This suffices to provide very effective and readable node manifests that clearly
    and concisely express their intent by including aptly named classes and instantiating
    defined types.
  prefs: []
  type: TYPE_NORMAL
- en: Modules can also contain Puppet plugins in the form of resource types and providers,
    parser functions, or facts. All of these are usually Ruby code. External facts
    can be written in any language, though. Writing your own types and providers is
    not required, but it can boost your performance and management flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: It is not necessary to write all your modules yourself. On the contrary, it's
    advisable to rely on the open source modules from the Puppet Forge as much as
    possible. The Puppet Forge is an ever-growing collection of helpful code for virtually
    all the systems and software that Puppet can manage. In particular, the modules
    that are curated by Puppet Labs are usually of very high quality. As with any
    open source software, you are more than welcome to add any missing requirements
    to the modules yourself.
  prefs: []
  type: TYPE_NORMAL
- en: After this broad view on Puppet's larger building blocks,Â [Chapter 6](60cec52e-6b29-4028-bc15-3b5685598e6b.xhtml),
    *The Puppet Beginners Advanced Parts*, narrows the scope a little. Now that you
    have the tools to structure and compose a manifest code base, you will learn some
    refined techniques in order to elegantly solve some distinct problems with Puppet.
  prefs: []
  type: TYPE_NORMAL
