- en: Chapter 9. Working with Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker usage overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing the right Docker base image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing the Docker image size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Versioning Docker images with tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a Ruby-on-Rails web application in Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and using Golang applications with Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Networking with Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating more dynamic containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto-configuring dynamic containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better security with unprivileged users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orchestrating with Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linting a Dockerfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a private Docker registry with S3 storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll discover the best bits of using Docker in a development
    environment: from Docker image optimizations to versioning, security, and networking,
    tips on how to choose the right base Docker image and how to make them dynamic
    and self-configurable, and how to leverage Docker to cross-compile Go programs
    or deploy Ruby-on-Rails web applications. Still with a focus on developers and
    achieving the highest code quality possible, we''ll spend some time linting our
    code, and finally deploy our own Docker Registry to store our own images internally—both
    on local storage and on AWS S3 for infinite space.'
  prefs: []
  type: TYPE_NORMAL
- en: Docker usage overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is an introduction to Docker for newcomers, and can be used as
    a refresher for others. We'll see how to quickly use Docker to achieve some tasks
    such as executing an Ubuntu container or networked webserver, sharing data with
    a container, building an image, and accessing a registry other than the default
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need a working Docker installation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll quickly manipulate Docker, so we're up and running with some basic usage.
  prefs: []
  type: TYPE_NORMAL
- en: Running Bash in an Ubuntu 16.04 container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To execute `/bin/bash` in an Ubuntu container, tag 16.04 (`ubuntu:16.04`).
    Our environment will be interactive (use `-i`) and we want a pseudo-terminal to
    be allocated (use `-t`). We want the container to be destroyed afterwards (use
    `--rm`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We've run our first container! Now do whatever you want with it. Quitting it
    destroys it and its content is lost forever as we specified the `--rm` option.
  prefs: []
  type: TYPE_NORMAL
- en: Running Nginx in a container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Nginx is officially packaged as a Docker container. We want to access port
    `80` from the container on port `80` of our host using the `-p` option, with the
    latest Nginx version available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Make some HTTP requests such as a `curl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The logs on the Docker stdout are displaying the logs as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Maybe for some reason we need to launch a specific Nginx version, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTTP headers will reflect that we''re now running the current stable version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Sharing data with a container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We want our own content to be displayed instead of the default Nginx page.
    Let''s create an `index.html` file in the `www` directory, with some custom content
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Nginx is serving content by default in `/usr/share/nginx/html`; let''s use
    the `-v` option to share our own directory with the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see our new content served:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Building a container with utilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s create our own Ubuntu 16.04 image with some utilities such as `curl`,
    `dig`, and `netcat` in it, so that whatever machine we''re using, we can always
    have our tools at hand. To build our container, we need a file named `Dockerfile`,
    acting like a script, executed line by line, to build the final container. We
    know we want to start from an Ubuntu 16.04, then update the APT base, and finally
    install our utilities. Let''s do just that using the `FROM` and `RUN` instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now build using the `docker build` command, passing it the name of the container
    with the `-t` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can see each line of our `Dockerfile` is a *step* in the build process, each
    step being a container itself (hence the different ID each time).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now execute our container to make a DNS request using `dig`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we may use `curl` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Using a private registry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When not specifying anything else than the container name, Docker is looking
    for it locally, then on Docker Hub ([https://hub.docker.com](https://hub.docker.com)).
    However, we can run our own registry or use an alternative registry such as [https://quay.io/](https://quay.io/).
    Here''s how it works: instead of specifying only the container name, or the combo
    `username/container_name`, we prefix both by the DNS name of the registry, for
    example, [https://quay.io/](https://quay.io/). Here, we''ll launch the HTTP/2
    Caddy webserver hosted in the CoreOS account on the Quay.io registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here's for this quick introduction on how to use Docker.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Docker run reference: [https://docs.docker.com/engine/reference/run/](https://docs.docker.com/engine/reference/run/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dockerfile reference: [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Quay.io alternative registry: [https://quay.io/](https://quay.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker Hub: [https://hub.docker.com/](https://hub.docker.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker Store: [https://store.docker.com/](https://store.docker.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing the right Docker base image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on our end goal, using the image of our favorite Linux distribution
    might or might not be the best solution. Starting with a full CentOS container
    image might be a waste of resources, while an Alpine Linux image might not contain
    the most complete libc for our usage. In other cases, using the image from our
    favorite programming language might also be a good idea, or not. Let's see this
    in depth and learn when to choose what source.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need a working Docker installation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most common distributions are available as a container form.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from an Ubuntu image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Ubuntu ships official images that are all tagged with both their release version
    and name: `ubuntu:16.04` is equivalent to `ubuntu:xenial`. At the time of writing,
    the supported Ubuntu releases are 12.04 (precise), 14.04 (trusty), 16.04 (xenial),
    and 16.10 (yakkety).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with an Ubuntu image in a Dockerfile, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Starting from a CentOS image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The CentOS team ships official container images, all tagged with versions. It's
    highly recommended that you stick with the *rolling builds* that are continuously
    updated because these are tagged only with major versions such as `centos:7`.
    At the time of writing, the supported CentOS releases are CentOS 7, 6, and 5\.
    If for some compliance reason we were to use a specific CentOS 7 release, specific
    tags such as `centos:7.3.1611`, `centos:7.2.1511`, `centos:7.1.1503`, and `centos:7.0.1406`
    are available.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with the latest CentOS 7 available, in a Dockerfile execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Starting from a Red Hat Enterprise Linux (RHEL) image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Red Hat also ships containers for RHEL. At the time of writing, images are
    hosted on Red Hat''s Docker registry servers ([https://access.redhat.com/containers/](https://access.redhat.com/containers/)).
    These images aren''t tagged with release versions, but directly with their name:
    `rhel7` for RHEL 7 and `rhel6` for RHEL 6\. Similarly, subversions are also directly
    in the name of the image: RHEL 7.3 has the image named `rhel7.3`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with the latest RHEL 7, in a Dockerfile execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Starting from a Fedora image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Fedora is officially built for Docker and each release is simply tagged with
    its version number. Fedora 25 has `fedora:25`, and it goes back to `fedora:20`
    at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start a with the latest Fedora release, use the following in a Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Starting from an Alpine Linux image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Alpine Linux is a very popular and secure lightweight Linux distribution in
    the container world. It''s dozens of times smaller in size than other main distributions:
    less than 5 MB. It became so popular that Docker (the company) is now using it
    as a base for all its official images—and the Alpine founder is now working at
    Docker. Alpine versions are found in the image tags: Alpine 3.1 is `alpine:3.1`,
    and similarly, Alpine 3.4 is `alpine:3.4`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with the 3.4 release of Alpine Linux, use this in a Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Starting from a Debian image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Debian distribution is present as well, with many different tags: we can
    find the usual `debian:stable`, `debian:unstable`, and `debian:sid` we''re used
    to, and also some other tags, such as `debian:oldstable`. Release names are tagged
    like the corresponding versions, so the image `debian:8` is the same as `debian:jessie`.
    Debian ships *slim* images for each release: debian:jessie-slim is 30% smaller
    than the main one (80 MB compared to 126 MB at the time of writing).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with the Debian 8 (Jessie) release, use the following in a Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Linux distributions container image size table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s a table with the current size for each referenced image:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Linux distribution image | Size |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Alpine 3.4 | 4.799 MB |'
  prefs: []
  type: TYPE_TB
- en: '| Debian 8 (slim) | 80 MB |'
  prefs: []
  type: TYPE_TB
- en: '| Debian 8 | 123 MB |'
  prefs: []
  type: TYPE_TB
- en: '| Ubuntu 16.04 | 126.6 MB |'
  prefs: []
  type: TYPE_TB
- en: '| RHEL 7.3 | 192.5 MB |'
  prefs: []
  type: TYPE_TB
- en: '| CentOS 7.3 | 191.8 MB |'
  prefs: []
  type: TYPE_TB
- en: '| Fedora 25 | 199.9 MB |'
  prefs: []
  type: TYPE_TB
- en: With this information in hand, we can now decide to go for any one of these.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, many popular programming languages (Go, Node, Java, Python,
    Ruby, PHP, and more) are also shipping their own container images. They are all
    very often based on the images from the operating system container images in the
    preceding table. It will be interesting to use them if our product is definitely
    going to use the corresponding language as they often offer custom versions and
    features.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from a Node JS image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The official repository for the Node Docker image includes many tagged versions
    with many base images: `node:7` is based on Debian Jessie, while `node:7-alpine`
    is based on Alpine 3.4\. `node:7-slim` will be based on the slim Debian Jessie,
    and there''s even `node:7-wheezy` if we feel like running Node 7 on Debian Wheezy.
    Also available are Node 6, 4, and below.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start from the latest Node 7 image version, use this in a Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: For the record, a `node:7` image will be around 650 MB, while `node:4-slim`
    will be around 205 MB.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from a Golang image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Go is well distributed as a Docker image. Its releases are tagged by release
    (such as `golang:1.7`) and with alternatives such as one based on Alpine (`golang:1.7-alpine`)
    or even for Windows Server (`golang:1.7-windowsservercore` and `golang:1.7-nanoserver`).
  prefs: []
  type: TYPE_NORMAL
- en: 'To start from the Go image, use the following in a Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The main Go `1.7` image is 672 MB.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from a Ruby image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Ruby is also distributed as an official Docker image: all the latest releases
    are found tagged like `ruby:2.3`. Alternative builds from Alpine Linux and Debian
    Jessie slim images are also available.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A distinct Ruby-on-Rails Docker image used to exist, but is now deprecated in
    favor of the main Ruby Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start from the Ruby `2.3` image, use the following to start a Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The main Ruby `2.3` image is 725 MB.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from a Python image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python is officially distributed and many of its versions are supported as tagged
    Docker images. We can find versions 2.7, 3.3, 3.4, 3.5, and current beta versions
    based on Debian Jessie or Wheezy, Alpine, and Windows Server.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start our project using the Python `3.5` image, add the following in a Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The main `python:3.5` image is around 683 MB.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from a Java image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Java users are also getting official releases on Docker. Both OpenJDK and JRE
    are available, for versions 6, 7, 8, and 9, based on Debian Jessie or Alpine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using the OpenJDK 9 image, use the following in a Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The main `openjdk:9` image is 548 MB—one of the smallest programming language
    images available.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from a PHP image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The PHP Docker image is very popular, and available in many different flavors.
    It's one of the easiest ways of easily testing newer and older releases of PHP
    on a platform. PHP 5.6 and 7.0 (and all beta versions) are available, and each
    is also available with a different flavor, that is, based on Alpine (`php:7-alpine`),
    Debian Jessie with Apache (`php:7-apache`), or Debian Jessie with FPM (`php:7-fpm`),
    but if we still like FPM with Alpine, it's also ok (`php:7-fpm-alpine`).
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using a classic PHP 7 Docker image, start with the following in a
    Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The main `php:7` image is 363 MB—this is the smallest programming language image
    available.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Images on the Docker Hub: [https://hub.docker.com/explore/](https://hub.docker.com/explore/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Red Hat Container catalog: [https://access.redhat.com/containers](https://access.redhat.com/containers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing the Docker image size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker images are generated instruction by instruction from the Dockerfile.
    Though perfectly correct, many images are sub-optimized when we're talking about
    size. Let's see what we can do about it by building an Apache Docker container
    on Ubuntu 16.04.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need a working Docker installation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take the following `Dockerfile`, which updates the Ubuntu image, installs the
    `apache2` package, and then removes the `/var/lib/apt` cache folder. It''s perfectly
    correct, and if you build it, the image size is around 260 MB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, each layer is added on top of the previous. So, what's written during the
    `apt-get update` layer is written forever, even if we remove it in the last `RUN`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite this `Dockerfile` using a one-liner, to save some space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This image is exactly the same, but is only around 220 MB. That's 15% space
    saved!
  prefs: []
  type: TYPE_NORMAL
- en: 'Replacing the `ubuntu:16.04` image with the `debian:stable-slim` image gets
    the same result, but with a size of 135 MB (a 48% reduction in size!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each layer is added to its predecessor. By combining all the related commands
    from download to deletion, we keep a clean state on this particular layer. Another
    good example is when the Dockerfile downloads a compressed archive; downloading
    it, uncompressing it, and then removing the archive uses a lot of added layer
    space when done separately. The same in one line does everything at once, so instead
    of having the cumulated space taken from the archive and its uncompressed content,
    the space taken is only from the uncompressed content alone. Often, there's a
    very nice gain in size!
  prefs: []
  type: TYPE_NORMAL
- en: Versioning Docker images with tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very common need is to quickly identify what version of the software a Docker
    image is running and optionally stick to it, or to be sure to always run a stable
    version. This is a perfect use for the Docker tags. We'll build a Terraform container,
    with both a stable and an unstable tag, so multiple versions can coexist—one for
    production and one for testing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Docker *tags* are not to be mistaken with Docker *labels*. Labels are purely
    informative when tags can be requested directly to make images distinct from an
    operational point of view.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need a working Docker installation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s a simple Dockerfile to create a Terraform container (Terraform was
    covered earlier in this book):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the current, stable, and latest version, and it''s 0.7.12 as well.
    We''d like our users to be able to request one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`terraform:latest` (for those of our users who always want the latest version
    available)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`terraform:stable` (for those of our users who always want the stable version,
    opposed to a beta version)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`terraform:0.7.12` (for those of our users who always want a very specific
    version, such as for compatibility issues)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is easily achievable by building directly with all these different tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when requesting which images are available, we can see they all have the
    same image ID, but with different tags. This is what we wanted, since it''s the
    same image that shares all those tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Some days later, we release a new version of the software as a Docker container
    for our team to test it out. This time it''s an unstable, 0.8.0-rc1 version. We''d
    like our users to request this image as one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`terraform:latest` (it''s still the latest version available, even unstable)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`terraform:unstable` (it''s a release candidate, not a stable version)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`terraform:0.8.0-rc1` (it''s this specific version)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Change the `TERRAFORM_VERSION` variable in the `Dockerfile`, and build the
    image with the following tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we look at the available Terraform images, we can confirm that it''s
    the same image ID shared by the `latest`, `unstable`, and `0.8.0-rc1` tags, while
    our users preferring the stable version are not impacted by our changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This leads to a very important question: as the latest tag is by default when
    not specifying any, should it be also used for unstable releases? This is something
    you have to answer according to your needs and environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a Ruby-on-Rails web application in Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The great thing with Docker is that, as developers, we can ship whatever is
    working on this particular container on one environment (such as development or
    staging) and be sure it will run similarly in another environment (such as production).
    Deploys are less stressful, and rollbacks are easier. However, to achieve this
    peace of mind, we need more than a Ruby-on-Rails application, for example, we
    need to ship a Dockerfile containing everything to build a self-sufficient container
    so anyone can run it. Here's how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Docker installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Rails application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are our standard requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: This Rails application needs Ruby 2.3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All dependencies are handled by Bundler, and need to be installed in the container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node 5 is also needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want assets to be precompiled in the image (putting them somewhere else is
    out of scope)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s how we''ll proceed. To match our main requirement, we''ll start with
    the `ruby:2.3` image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'One way to enable the official Node 5 repositories is to download and execute
    a setup script. Let''s do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to install Node 5 (`apt-get install nodejs`) and remove all the
    cache files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The Ruby image documentation suggests using `/usr/src/app` as a destination
    folder for our code. Let''s ensure it''s created and switch to it until the rest
    of the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: To install all the declared dependencies, we need to send both `Gemfile` and
    `Gemfile.lock` to the destination folder, `/usr/src/app`. We include it as a distinct
    step, so we can optionally customize this step later. Then we execute Bundler
    (without the test and development sections if we have them). If you're a Ruby
    developer, customize accordingly!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s now time to copy the application code itself to the destination folder,
    `/usr/src/app` (in this case, it''s the current folder):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to precompile the assets, with a `RAILS_ENV` set to production,
    but feel free to adapt, including the compilation command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, run the Rails server on all interfaces through bundler (by default,
    it listens on TCP/`3000`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We can now build this Dockerfile and have our complete, standalone, and fully
    working Ruby-on-Rails application ready on Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is a good practice to plug the build process in CI and execute tests against
    running this new image!
  prefs: []
  type: TYPE_NORMAL
- en: Building and using Golang applications with Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Golang is a great language able to create statically linked binaries for different
    platforms such as Linux (ELF binaries) or Mac OS (Mach-O binaries). These binaries
    are often very small in size, and the language is getting increasingly popular
    in the microservices world because of their portability and the speed of deployment
    it enables: deploying a self-sufficient 10 MB Docker image on dozens of servers
    is just more convenient and fast than a 1.5 GB image full of libs. Golang and
    containers are two technologies that go perfectly well together, and shipping
    or managing infrastructures using Go programs is a breeze.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Docker installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Golang application source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say our application code is checked in `src/hello`. We'd like to begin
    by at least compiling the program, either for the Linux platform or for the Mac
    operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Using the golang Docker image to cross-compile a Go program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can compile our program sharing the code folder, and setting the work directory
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, even on a Mac OS system, we can generate a proper ELF binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'That said, if we explicitly want a Mac binary, we can pass the standard Go
    environment variables `GOOS` and `GOARCH` so even a Linux machine can build a
    Mac binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Confirm we have a Mach-O executable and not an ELF binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Using the golang Docker image to build and ship a Go program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now if we want to build our program right from a Dockerfile and generate a
    Docker image out of it, that would translate like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Just build that image and execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Using the scratch Docker image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, it''s a bit of a waste of space to have a 675 MB+ image for the very often
    small Golang application that often is only a few MB, and it takes time to deploy
    on servers. Here comes the scratch image: it just doesn''t exist. We start from
    nothing, copy the binary, and execute it. Our build process (Makefile, build process,
    and CI) builds the app with the `golang` image, but does not ship the compiled
    application with it, saving usually 95–99% of the space, depending on the size
    of our binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This generates the smallest image imaginable. Think only a few megabytes.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Alpine Linux alternative for a Go program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The main problem with the scratch image solution is the impossibility to debug
    it easily from inside the container, and the impossibility to rely on external
    libraries or dependencies such as SSL and certificates. Alpine Linux is this small
    image (~5 MB) that can greatly help us if we''d like to access a shell (`/bin/sh`
    is available) and a package manager to debug our application. This is how we''d
    do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Such an image usually is only a handful of megabytes more than the application
    binary, but helps greatly for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Networking with Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker has some pretty nice networking options, from choosing which ports to
    expose to concurrently running isolated or bridged networks. It's pretty useful
    to quickly and easily simulate production environments, create better architectures,
    and increase container exposure on the network front. We'll see different ways
    to expose ports, create new networks, execute Docker containers inside them, and
    even have multiple networks per container.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Docker installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sample HTTP server binary (sample code included)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make a container network port available to others, it first needs to be
    *exposed*. Consider any service listening on a port not reachable unless properly
    exposed in the 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This service is listening on port `8000`, and any other Docker container running
    on the host can access it, by default on the same network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this service is not available to the host system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To make it available to the host system, the container has to be run with an
    explicit port redirection. It can be option `-P` to map exposed ports randomly
    (the port `8000` can be mapped to 32768 on the local machine), or the other option
    `-p 8000:8000` to make it fixed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'On another terminal, find the port redirection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, try to connect to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: These are the basics of networking with Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: Docker networks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Containers can also live inside dedicated networks for added security and isolation.
    To create a new Docker network, just give it a name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Grab some information about this network using the `docker network inspect`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a new subnet: `172.18.0.0/16` (in this case).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute a container in this specific Docker network, use the `--network
    <docker_network_name>` option like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Confirm this container is in the 172.18.0.0/16 network space from the `hello_network`
    network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This container will be protected from unauthorized access from any container
    not running on the correct network. Here''s an example from a container running
    in the default network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'However, connecting from a container in the same network is allowed and working
    as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Connecting multiple networks for one container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It can be useful to have a few specific containers available on more than one
    network; proxies, internal services, and other similar services can face different
    networking configurations. A single Docker container can connect multiple Docker
    networks. Take this simple HTTP service listening on port 8000 and launch it on
    the default bridged network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This service is now available to any other container on the default network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we''d like it to be also available on the *hello_network* Docker network.
    Let''s connect them to the host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The container now has a new network interface in the `hello_network` subnet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This means that it's also available to answer requests from containers on this
    network!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll eventually remove the link to the original network after we''re done
    with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Creating more dynamic containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can create better containers than just fixing their usage in advance and
    executing them. Maybe part of the command is the one to keep (like we always want
    the OpenVPN binary and options to be executed, no matter what), maybe everything
    needs to be overridden (that's the toolbox container model, such as a `/bin/bash`
    command by default, but any other command given in argument can otherwise be executed),
    or a combination of the two, for a much more dynamic container.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need a working Docker installation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To have a fixed command executed by the container, use the `ENTRYPOINT` instruction.
    Use an array if the command is followed by arguments to be enforced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'To override the whole command at runtime, use the `--entrypoint` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'To have a command that can be simply overridden with an argument, use the `CMD`
    instruction instead of `ENTRYPOINT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'To override the command, simply give another command as an argument at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We can combine both instructions to have a more dynamic container. In this
    case, we want to obtain a container always executing `/usr/sbin/apache2ctl`, and
    by default starting the daemon in foreground, otherwise overridden by any argument
    at container launch time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: If this container is executed as is, nothing changes; `apache2ctl` gets executed
    with the `-D FOREGROUND` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it becomes a more useful container when giving it arguments, as it
    dynamically will add them to the `apache2ctl` command, replacing the original
    command specified by the `CMD` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: We can interactively pass `/usr/sbin/apache2ctl` arguments without the need
    to override the entrypoint, for example, to propose alternatives Apache configuration
    files or options.
  prefs: []
  type: TYPE_NORMAL
- en: Auto-configuring dynamic containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can't always execute a binary to get what we want. A configuration done dynamically
    is a very common situation; system paths can be dynamic, users and passwords can
    be auto-generated, network ports can be contextual, third-party credentials will
    be different in development and in production, slaves will join their masters,
    cluster members will find other nodes, and most other similar changing elements
    will need to adapt at runtime. The trick here is to combine environment variables
    with the use of a script as an entry point that will be executed no matter what,
    and behave according to the environment variables, optionally combined with a
    command from the Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need a working Docker installation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our objective is to create a temporary, dynamic SSH server in a Docker container,
    with credentials we can''t know in advance. So, to make it work as intended, we''ll
    want to execute this container like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Take this simple `Dockerfile` that creates what''s necessary to run the Dropbear
    SSH server on the Alpine Docker image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'When built, this container will start by executing the `entrypoint.sh` script,
    and then the `dropbear` binary. Here''s a sample `entrypoint.sh` that only does
    simple checks for the `USER` and `PASSWORD` environment variable, creates the
    required users on the container, sets some permissions, and finally executes the
    `CMD` instruction from the original Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'If this container is executed without any arguments, it errors out, thanks
    to the check from the `entrypoint.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'To properly use this dynamically configured container, use environment variables
    as required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Now try connecting to this container from another terminal or container with
    proper credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: We're logged in to our SSH container!
  prefs: []
  type: TYPE_NORMAL
- en: Such a dynamic system can be used to give temporary, controlled, and secure
    SSH access to someone needing, for example, shared volume storage access or similar
    usages. Shutting down the container just revokes everything and we're done with
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Better security with unprivileged users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, containers execute everything as the `root` user. Granted that containers
    are running in an isolated environment, but still, a publicly facing daemon is
    running as root on a system, and a security breach may give an attacker access
    to this particular container, and maybe root shell access, giving access at least
    to the container's Docker overlay network. Would we like to see this issue combined
    with a 0-day local kernel security breach that would give the attacker access
    to the Docker host? Probably not. Then, maybe we should keep some of the good
    old practices and start by executing our daemon as a user other than root.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Docker installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sample HTTP server binary (sample code included)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a simple HTTP server that answers on the port `8000` of the container.
    Executed through a container, it would look like this, as seen earlier in this
    book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'This will work, but things aren''t looking that great security-wise; our daemon
    is, in fact, running as the `root` user, even though it''s running on an unprivileged
    port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'This is suboptimal from a security point of view. Containers are real systems,
    so they too can have users. Combined with the `USER` instruction in the Dockerfile,
    we''ll be able to execute commands as an unprivileged user! Here''s how an optimized
    Dockerfile looks, adding a normal user and group for the `hello` user, and then
    executing the `/usr/bin/hello` HTTP server as this new unprivileged user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Once built and running, the daemon still runs correctly, but as an unprivileged
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: We're now building tougher containers!
  prefs: []
  type: TYPE_NORMAL
- en: Orchestrating with Docker Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Launching multiple containers manually can be a hassle, especially when the
    infrastructure goes increasingly complex. Dependencies, shared variables, and
    common networking can be easily handled with the orchestration tool named Docker
    Compose. In a simply YAML file, we can describe what services are needed to run
    our application (proxy, application, databases, and so on). In this section, we'll
    show how to create a simple LAMP docker-compose file, then we'll show how we can
    iterate from that to build some staging and production specific changes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Docker installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working Docker Compose installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To orchestrate multiple containers together using Docker Compose, let''s start
    with an easy WordPress example. The team at WordPress built a container that auto-configures
    to some extent through environment variables similar to what we saw earlier in
    this chapter. If we just apply the documentation shipped with the WordPress Docker
    container, we end up with the following `docker-compose.yml` at the root of some
    new directory (it can be a Git repository if needed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This has the great advantage to work out of the box; the latest WordPress and
    MariaDB images get downloaded, local HTTP port 80 gets redirected on port 8080
    on the host, and MySQL stays isolated. The WordPress container takes one environment
    variable in this case—the MySQL root password, which should match the environment
    variable from MySQL. We'll see that many more are possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing Docker Compose will automatically create a Docker network and run
    the containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s verify we can connect to the WordPress HTTP server locally, on the redirected
    port `8080`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'More information can be seen using the `ps` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s ensure the password used for the MySQL root password is really the one
    provided by the `docker-compose.yml` file, using the `docker-compose exec` command,
    very similar to the `docker run` command (it takes `docker-compose.yml` names):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'When we''re done with our initial Docker Compose environment, let''s destroy
    it; the containers and networks will be removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Extending Docker Compose
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we know the basics, let''s extend the usage a little. We''re not happy
    with the default password and would like to use a better one, so simulate the
    staging environment. Let''s use the overriding feature of Docker Compose for that
    and create a `docker-compose.staging.yml` file that will simply override the concerned
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The two environment variables `WORDPRESS_DB_PASSWORD` and `MYSQL_ROOT_PASSWORD`
    will be overridden when `docker-compose` is executed with multiple configuration
    files taken in order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the new password is indeed working for MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: We're very easily overriding values with simple YAML files!
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we now want to include a reverse proxy to the mix, with a slightly
    earlier version of the Docker image and another MySQL password, to mimic a specific
    situation we have in production. We can use the excellent dynamic Nginx image
    from `jwilder/nginx-proxy` to do this job and add a new *proxy* service, sharing
    port `80` and the local Docker socket as read-only (to dynamically access running
    containers) on a `docker-compose.production.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'This `nginx-proxy` container needs a variable named `VIRTUAL_HOST` to know
    what to answer in case of multiple virtual hosts. Let''s add it as localhost (or
    adapt to your local hostname), along with the better password and the WordPress
    image version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Make the password match in the MySQL section as well and we''ll be done with
    our production environment simulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Confirm `nginx-proxy` is answering in HTTP/`80` and forwarding a proper HTTP
    answer from the WordPress container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: We've seen how, with only a few lines of YAML, we can easily orchestrate containers,
    how it can be used to handle different cases and environments, and how it can
    also be successfully extended. This is, however, just a small introduction to
    what can be done with Docker Compose—it's quite a powerful tool!
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Nginx-proxy: [https://github.com/jwilder/nginx-proxy](https://github.com/jwilder/nginx-proxy)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'WordPress Docker image: [https://hub.docker.com/_/wordpress/](https://hub.docker.com/_/wordpress/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Docker Compose documentation: [https://docs.docker.com/compose/](https://docs.docker.com/compose/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linting a Dockerfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like any other language, Dockerfiles can and should be linted for updated best
    practices and code quality checks. Docker is no exception to the rule, and good
    practices are always moving, getting updates, and might also be a little different
    between communities. In this section, we'll start with a basic Dockerfile found
    earlier and end up with a fully double-checked linted file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Docker installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AWS account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many different linters exist for linting Dockerfiles: Hadolint ([http://hadolint.lukasmartinelli.ch/](http://hadolint.lukasmartinelli.ch/))
    maybe the most used linter, while Project Atomic''s `dockerfile_lint` project
    is perhaps the most complete one ([https://github.com/projectatomic/dockerfile_lint](https://github.com/projectatomic/dockerfile_lint)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the working Dockerfile from earlier in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Hadolint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s start working with Hadolint, as it''s easy to install (prebuilt binaries
    and Docker images) and use. All rules are explained in Hadolint''s wiki ([https://github.com/lukasmartinelli/hadolint/wiki](https://github.com/lukasmartinelli/hadolint/wiki)),
    and usage is really simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, use the Docker containerized version; it''s probably good in
    CI scripts. Beware of the image size; at the time of writing, the image is 1.7
    GB, while the hadolint binary is less than 20 MB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Linting Dockerfiles from this chapter, we''ll notice different warnings. Maybe
    some are false positives, or maybe some rules are just not yet updated to the
    latest deprecation notices, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, this Dockerfile is following Docker 1.13 recommendations, which include
    to no more include a `maintainer` instruction. However, Hadolint is not yet up
    to date for this deprecation change, so execute the following to ignore one or
    more IDs, to still be cool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Dockerfile_lint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This project lead by the Project Atomic team ([http://www.projectatomic.io/](http://www.projectatomic.io/))
    is also proposing different checks and strong opinions on how a Dockerfile should
    be written. These propositions are very often good advice, though.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute this to launch `dockerfile_lint` from the official Docker image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: A certain amount of suggestions will arise (errors, warnings, and info), each
    with a related reference URL to refer to.
  prefs: []
  type: TYPE_NORMAL
- en: When in doubt, it's often a good move to follow the suggestions and fix the
    code accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of this double linting process, our Dockerfile changed a lot, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: We added labels to identify the image, versions, and maintainer, and we fixed
    a proper version of the apache2 package. So no bad surprise can happen with an
    untested update (updating the package will need a rebuild of the image), we're
    cleaning the apt cache more precisely, and we're explicitly exposing a port from
    the container.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, those changes proposed by the linters helped us a lot in building a
    much better and stronger container. Their role in CI is crucial; include the linters
    in your Jenkins, Circle, or Travis CI jobs!
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a private Docker registry with S3 storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Docker registry is a central image distribution service. When we *pull*
    or *push* an image, it's from the Docker registry. It can be commercially hosted
    (CoreOS Quay [https://quay.io/](https://quay.io/) is an example, Docker's own
    [https://hub.docker.com/](https://hub.docker.com/) is another), or it can be self-hosted
    (for privacy, speed, bandwidth issues, or company policy). Docker Inc. made it
    simple for us to deploy it; it's extensively documented and packaged. Amongst
    the many deployable features, we'll start by simply deploying a single registry
    ready to be load-balanced, and then we'll switch its backend storage to AWS S3,
    so disk space will never be an issue again.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Docker installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AWS account with full S3 access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll use Docker Compose to work through this recipe. Our objective is to host
    our own private Docker registry, initially using local storage, then an S3 bucket
    for infinite space. The registry will be available on `http://localhost:5000`,
    but feel free to use any other resolvable name or a dedicated server with a locally
    available name.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, we need the Docker registry v2 image: `registry:2`. We know
    from the documentation that port `5000` is exposed by the registry server, so
    we need to forward it to our host to use it locally. If we are running multiple
    registries behind a load balancer, it''s safe to share a common secret, let''s
    set it to `s3cr3t`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what our initial `docker-compose.yml` file looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'With this simple setup, we already are able to run our own local Docker registry
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'To upload an image to our private registry, the process is to simply tag the
    image with the local registry URL and then push it. Execute the following to tag
    the `ubuntu:16.04` image with `localhost:5000/ubuntu`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to push the image to the local registry, execute this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: This Docker image is now stored locally and can be reused without accessing
    the public network nor the Docker Hub or similar services.
  prefs: []
  type: TYPE_NORMAL
- en: Using an S3 backend
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An issue with a highly used local Docker registry is disk space management—it''s
    finite. The good news is that the Docker Registry handles easily an S3 backend
    (or Swift if we have an internal OpenStack). For the record, Google Cloud and
    Azure storage are also supported. To enable the S3 backend, only a few variables
    need to be set in the `docker-compose.yml` file: the AWS region to contact, the
    keys, and the bucket name.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Destroy (`docker-compose down`) the previous example if you tried it, and start
    this updated one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Now tag again an image locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, push the image to the local registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Depending on your uplink speed, it will take more or less time for the Registry
    to sync the layers we push with the AWS S3 backend.
  prefs: []
  type: TYPE_NORMAL
- en: We now have our own local registry with infinite storage!
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Docker Registry documentation: [https://docs.docker.com/registry/configuration/](https://docs.docker.com/registry/configuration/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
