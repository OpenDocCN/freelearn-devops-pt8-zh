- en: Chapter 9. Working with Docker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章：与 Docker 一起工作
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Docker usage overview
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 使用概览
- en: Choosing the right Docker base image
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择合适的 Docker 基础镜像
- en: Optimizing the Docker image size
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化 Docker 镜像大小
- en: Versioning Docker images with tags
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标签版本化 Docker 镜像
- en: Deploying a Ruby-on-Rails web application in Docker
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Docker 中部署 Ruby-on-Rails Web 应用
- en: Building and using Golang applications with Docker
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 构建和使用 Golang 应用
- en: Networking with Docker
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 进行网络配置
- en: Creating more dynamic containers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建更动态的容器
- en: Auto-configuring dynamic containers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动配置动态容器
- en: Better security with unprivileged users
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用非特权用户提高安全性
- en: Orchestrating with Docker Compose
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 进行编排
- en: Linting a Dockerfile
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 Dockerfile 进行代码检查
- en: Deploying a private Docker registry with S3 storage
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 S3 存储部署私有 Docker 注册表
- en: Introduction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'In this chapter, we''ll discover the best bits of using Docker in a development
    environment: from Docker image optimizations to versioning, security, and networking,
    tips on how to choose the right base Docker image and how to make them dynamic
    and self-configurable, and how to leverage Docker to cross-compile Go programs
    or deploy Ruby-on-Rails web applications. Still with a focus on developers and
    achieving the highest code quality possible, we''ll spend some time linting our
    code, and finally deploy our own Docker Registry to store our own images internally—both
    on local storage and on AWS S3 for infinite space.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索在开发环境中使用 Docker 的最佳实践：从 Docker 镜像优化到版本控制、安全性和网络配置，选择合适的基础 Docker 镜像的技巧，以及如何使其动态和自配置；如何利用
    Docker 进行 Go 程序的交叉编译或部署 Ruby-on-Rails Web 应用。依然以开发者为中心，旨在实现尽可能高的代码质量，我们将花一些时间进行代码检查，最后部署我们自己的
    Docker 注册表来存储内部镜像——既在本地存储，也在 AWS S3 上实现无限存储空间。
- en: Docker usage overview
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 使用概览
- en: This section is an introduction to Docker for newcomers, and can be used as
    a refresher for others. We'll see how to quickly use Docker to achieve some tasks
    such as executing an Ubuntu container or networked webserver, sharing data with
    a container, building an image, and accessing a registry other than the default
    one.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本节是 Docker 初学者的入门介绍，也可以作为其他人复习的资料。我们将学习如何快速使用 Docker 完成一些任务，例如执行 Ubuntu 容器或网络
    Web 服务器、与容器共享数据、构建镜像以及访问不同于默认注册表的注册表。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need a working Docker installation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行本食谱，您需要一个工作正常的 Docker 安装。
- en: How to do it…
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: We'll quickly manipulate Docker, so we're up and running with some basic usage.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将快速操作 Docker，确保基本使用上手。
- en: Running Bash in an Ubuntu 16.04 container
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Ubuntu 16.04 容器中运行 Bash
- en: 'To execute `/bin/bash` in an Ubuntu container, tag 16.04 (`ubuntu:16.04`).
    Our environment will be interactive (use `-i`) and we want a pseudo-terminal to
    be allocated (use `-t`). We want the container to be destroyed afterwards (use
    `--rm`):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Ubuntu 容器中执行 `/bin/bash`，请使用标签 16.04（`ubuntu:16.04`）。我们的环境将是交互式的（使用 `-i`），并且希望分配一个伪终端（使用
    `-t`）。我们希望在之后销毁该容器（使用 `--rm`）：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We've run our first container! Now do whatever you want with it. Quitting it
    destroys it and its content is lost forever as we specified the `--rm` option.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经运行了第一个容器！现在可以随意操作它。退出容器将销毁它，并且由于我们指定了 `--rm` 选项，它的内容将永久丢失。
- en: Running Nginx in a container
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在容器中运行 Nginx
- en: 'Nginx is officially packaged as a Docker container. We want to access port
    `80` from the container on port `80` of our host using the `-p` option, with the
    latest Nginx version available:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx 已正式打包为 Docker 容器。我们希望通过 `-p` 选项，从容器的 `80` 端口访问宿主机的 `80` 端口，且使用最新的 Nginx
    版本：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Make some HTTP requests such as a `curl`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 发出一些 HTTP 请求，例如 `curl`：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The logs on the Docker stdout are displaying the logs as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 的标准输出日志显示日志如下：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Maybe for some reason we need to launch a specific Nginx version, like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 也许由于某些原因，我们需要启动特定版本的 Nginx，例如：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The HTTP headers will reflect that we''re now running the current stable version:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 头部将反映我们现在运行的是当前稳定版本：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Sharing data with a container
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与容器共享数据
- en: 'We want our own content to be displayed instead of the default Nginx page.
    Let''s create an `index.html` file in the `www` directory, with some custom content
    such as the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望显示我们自己的内容，而不是默认的 Nginx 页面。让我们在 `www` 目录中创建一个 `index.html` 文件，包含一些自定义内容，例如：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Nginx is serving content by default in `/usr/share/nginx/html`; let''s use
    the `-v` option to share our own directory with the container:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Nginx 在 `/usr/share/nginx/html` 提供内容；让我们使用 `-v` 选项将我们自己的目录与容器共享：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s see our new content served:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下新内容的服务：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Building a container with utilities
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建带有工具的容器
- en: 'Let''s create our own Ubuntu 16.04 image with some utilities such as `curl`,
    `dig`, and `netcat` in it, so that whatever machine we''re using, we can always
    have our tools at hand. To build our container, we need a file named `Dockerfile`,
    acting like a script, executed line by line, to build the final container. We
    know we want to start from an Ubuntu 16.04, then update the APT base, and finally
    install our utilities. Let''s do just that using the `FROM` and `RUN` instructions:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建自己的Ubuntu 16.04镜像，并在其中包含一些工具，如`curl`、`dig`和`netcat`，这样无论我们使用什么机器，都能随时使用这些工具。为了构建我们的容器，我们需要一个名为`Dockerfile`的文件，它像脚本一样按行执行，来构建最终的容器。我们知道我们想从Ubuntu
    16.04开始，然后更新APT基础，最后安装我们需要的工具。让我们使用`FROM`和`RUN`指令来完成这个任务：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now build using the `docker build` command, passing it the name of the container
    with the `-t` option:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用`docker build`命令进行构建，传入容器名称，并使用`-t`选项：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can see each line of our `Dockerfile` is a *step* in the build process, each
    step being a container itself (hence the different ID each time).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`Dockerfile`的每一行都是构建过程中的*一步*，每一步都是一个容器（因此每次都会有不同的ID）。
- en: 'Let''s now execute our container to make a DNS request using `dig`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们执行容器，使用`dig`进行DNS请求：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Alternatively, we may use `curl` as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`curl`，如下所示：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Using a private registry
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用私有注册表
- en: 'When not specifying anything else than the container name, Docker is looking
    for it locally, then on Docker Hub ([https://hub.docker.com](https://hub.docker.com)).
    However, we can run our own registry or use an alternative registry such as [https://quay.io/](https://quay.io/).
    Here''s how it works: instead of specifying only the container name, or the combo
    `username/container_name`, we prefix both by the DNS name of the registry, for
    example, [https://quay.io/](https://quay.io/). Here, we''ll launch the HTTP/2
    Caddy webserver hosted in the CoreOS account on the Quay.io registry:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有指定其他内容时，Docker会在本地查找该容器，然后再查找Docker Hub（[https://hub.docker.com](https://hub.docker.com)）。不过，我们可以运行自己的注册表或使用其他注册表，例如[https://quay.io/](https://quay.io/)。其工作方式如下：我们不仅指定容器名称或`用户名/容器名称`组合，还要在它们前面加上注册表的DNS名称，例如[https://quay.io/](https://quay.io/)。在这里，我们将启动在CoreOS账户中托管的HTTP/2
    Caddy Web服务器，该服务器位于Quay.io注册表：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here's for this quick introduction on how to use Docker.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于如何使用Docker的简短介绍。
- en: See also
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: 'Docker run reference: [https://docs.docker.com/engine/reference/run/](https://docs.docker.com/engine/reference/run/)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker运行参考：[https://docs.docker.com/engine/reference/run/](https://docs.docker.com/engine/reference/run/)
- en: 'Dockerfile reference: [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dockerfile参考：[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)
- en: 'Quay.io alternative registry: [https://quay.io/](https://quay.io/)'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Quay.io替代注册表：[https://quay.io/](https://quay.io/)
- en: 'Docker Hub: [https://hub.docker.com/](https://hub.docker.com/)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Hub：[https://hub.docker.com/](https://hub.docker.com/)
- en: 'Docker Store: [https://store.docker.com/](https://store.docker.com/)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Store：[https://store.docker.com/](https://store.docker.com/)
- en: Choosing the right Docker base image
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择正确的Docker基础镜像
- en: Depending on our end goal, using the image of our favorite Linux distribution
    might or might not be the best solution. Starting with a full CentOS container
    image might be a waste of resources, while an Alpine Linux image might not contain
    the most complete libc for our usage. In other cases, using the image from our
    favorite programming language might also be a good idea, or not. Let's see this
    in depth and learn when to choose what source.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的最终目标，使用我们最喜欢的Linux发行版的镜像可能是也可能不是最佳方案。从一个完整的CentOS容器镜像开始可能会浪费资源，而Alpine
    Linux镜像可能没有我们所需的最完整的libc。在其他情况下，使用我们最喜欢的编程语言的镜像可能是个好主意，也可能不是。让我们深入了解并学习在何时选择什么来源。
- en: Getting ready
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need a working Docker installation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此操作，您需要一个有效的Docker安装。
- en: How to do it…
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: Most common distributions are available as a container form.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数常见的发行版都可以以容器的形式使用。
- en: Starting from an Ubuntu image
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从Ubuntu镜像开始
- en: 'Ubuntu ships official images that are all tagged with both their release version
    and name: `ubuntu:16.04` is equivalent to `ubuntu:xenial`. At the time of writing,
    the supported Ubuntu releases are 12.04 (precise), 14.04 (trusty), 16.04 (xenial),
    and 16.10 (yakkety).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu提供了官方镜像，并且每个镜像都带有版本号和名称标签：`ubuntu:16.04`等同于`ubuntu:xenial`。截至目前，支持的Ubuntu版本有12.04（precise）、14.04（trusty）、16.04（xenial）和16.10（yakkety）。
- en: 'To start with an Ubuntu image in a Dockerfile, execute the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Dockerfile 中使用 Ubuntu 镜像，执行以下命令：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Starting from a CentOS image
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 CentOS 镜像开始
- en: The CentOS team ships official container images, all tagged with versions. It's
    highly recommended that you stick with the *rolling builds* that are continuously
    updated because these are tagged only with major versions such as `centos:7`.
    At the time of writing, the supported CentOS releases are CentOS 7, 6, and 5\.
    If for some compliance reason we were to use a specific CentOS 7 release, specific
    tags such as `centos:7.3.1611`, `centos:7.2.1511`, `centos:7.1.1503`, and `centos:7.0.1406`
    are available.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: CentOS 团队发布了官方容器镜像，所有镜像都带有版本标签。强烈建议使用持续更新的*滚动版本*，因为这些版本仅通过主要版本号标记，如 `centos:7`。在撰写本文时，受支持的
    CentOS 版本为 CentOS 7、6 和 5。如果由于某些合规原因需要使用特定的 CentOS 7 版本，可以使用如 `centos:7.3.1611`、`centos:7.2.1511`、`centos:7.1.1503`
    和 `centos:7.0.1406` 等特定标签。
- en: 'To start with the latest CentOS 7 available, in a Dockerfile execute the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要从最新的 CentOS 7 开始，在 Dockerfile 中执行以下命令：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Starting from a Red Hat Enterprise Linux (RHEL) image
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 Red Hat Enterprise Linux（RHEL）镜像开始
- en: 'Red Hat also ships containers for RHEL. At the time of writing, images are
    hosted on Red Hat''s Docker registry servers ([https://access.redhat.com/containers/](https://access.redhat.com/containers/)).
    These images aren''t tagged with release versions, but directly with their name:
    `rhel7` for RHEL 7 and `rhel6` for RHEL 6\. Similarly, subversions are also directly
    in the name of the image: RHEL 7.3 has the image named `rhel7.3`.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Red Hat 也发布了 RHEL 的容器镜像。撰写时，这些镜像托管在 Red Hat 的 Docker 注册服务器上（[https://access.redhat.com/containers/](https://access.redhat.com/containers/)）。这些镜像没有使用发行版版本标记，而是直接用镜像的名称标记：`rhel7`
    代表 RHEL 7，`rhel6` 代表 RHEL 6。类似地，子版本也直接体现在镜像名称中：RHEL 7.3 的镜像名为 `rhel7.3`。
- en: 'To start with the latest RHEL 7, in a Dockerfile execute the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要从最新的 RHEL 7 开始，在 Dockerfile 中执行以下命令：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Starting from a Fedora image
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 Fedora 镜像开始
- en: Fedora is officially built for Docker and each release is simply tagged with
    its version number. Fedora 25 has `fedora:25`, and it goes back to `fedora:20`
    at the time of writing.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Fedora 官方为 Docker 构建，每个版本都会简单地标记为其版本号。Fedora 25 的标签是 `fedora:25`，撰写时版本号最早可以追溯到
    `fedora:20`。
- en: 'To start a with the latest Fedora release, use the following in a Dockerfile:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要从最新的 Fedora 版本开始，在 Dockerfile 中使用以下命令：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Starting from an Alpine Linux image
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 Alpine Linux 镜像开始
- en: 'Alpine Linux is a very popular and secure lightweight Linux distribution in
    the container world. It''s dozens of times smaller in size than other main distributions:
    less than 5 MB. It became so popular that Docker (the company) is now using it
    as a base for all its official images—and the Alpine founder is now working at
    Docker. Alpine versions are found in the image tags: Alpine 3.1 is `alpine:3.1`,
    and similarly, Alpine 3.4 is `alpine:3.4`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Alpine Linux 是容器世界中非常流行且安全的轻量级 Linux 发行版。它的体积比其他主流发行版小数十倍：不到 5 MB。它变得如此流行，以至于
    Docker（公司）现在将其作为所有官方镜像的基础——而 Alpine 的创始人现在也在 Docker 工作。Alpine 的版本可以在镜像标签中找到：Alpine
    3.1 为 `alpine:3.1`，类似地，Alpine 3.4 为 `alpine:3.4`。
- en: 'To start with the 3.4 release of Alpine Linux, use this in a Dockerfile:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Alpine Linux 的 3.4 版本开始，在 Dockerfile 中使用以下命令：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Starting from a Debian image
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 Debian 镜像开始
- en: 'The Debian distribution is present as well, with many different tags: we can
    find the usual `debian:stable`, `debian:unstable`, and `debian:sid` we''re used
    to, and also some other tags, such as `debian:oldstable`. Release names are tagged
    like the corresponding versions, so the image `debian:8` is the same as `debian:jessie`.
    Debian ships *slim* images for each release: debian:jessie-slim is 30% smaller
    than the main one (80 MB compared to 126 MB at the time of writing).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Debian 发行版也有多个不同的标签：我们可以找到常见的 `debian:stable`、`debian:unstable` 和 `debian:sid`，以及一些其他标签，如
    `debian:oldstable`。发行版的名称会像相应的版本一样标记，因此镜像 `debian:8` 与 `debian:jessie` 相同。Debian
    为每个发行版发布*精简版*镜像：debian:jessie-slim 比主版本小 30%（撰写时为 80 MB，相较于 126 MB）。
- en: 'To start with the Debian 8 (Jessie) release, use the following in a Dockerfile:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Debian 8（Jessie）版本开始，在 Dockerfile 中使用以下命令：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Linux distributions container image size table
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux 发行版容器镜像大小表
- en: 'Here''s a table with the current size for each referenced image:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是当前各个引用镜像的大小表：
- en: '| Linux distribution image | Size |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| Linux 发行版镜像 | 大小 |'
- en: '| --- | --- |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Alpine 3.4 | 4.799 MB |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| Alpine 3.4 | 4.799 MB |'
- en: '| Debian 8 (slim) | 80 MB |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| Debian 8 (slim) | 80 MB |'
- en: '| Debian 8 | 123 MB |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| Debian 8 | 123 MB |'
- en: '| Ubuntu 16.04 | 126.6 MB |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| Ubuntu 16.04 | 126.6 MB |'
- en: '| RHEL 7.3 | 192.5 MB |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| RHEL 7.3 | 192.5 MB |'
- en: '| CentOS 7.3 | 191.8 MB |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| CentOS 7.3 | 191.8 MB |'
- en: '| Fedora 25 | 199.9 MB |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| Fedora 25 | 199.9 MB |'
- en: With this information in hand, we can now decide to go for any one of these.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，我们现在可以决定选择其中任何一个。
- en: That being said, many popular programming languages (Go, Node, Java, Python,
    Ruby, PHP, and more) are also shipping their own container images. They are all
    very often based on the images from the operating system container images in the
    preceding table. It will be interesting to use them if our product is definitely
    going to use the corresponding language as they often offer custom versions and
    features.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，许多流行的编程语言（Go、Node、Java、Python、Ruby、PHP 等）也在发布自己的容器镜像。它们通常基于前面表格中的操作系统容器镜像。如果我们的产品确定要使用相应的语言，使用这些镜像将会很有趣，因为它们通常提供定制的版本和功能。
- en: Starting from a Node JS image
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 Node JS 镜像开始
- en: 'The official repository for the Node Docker image includes many tagged versions
    with many base images: `node:7` is based on Debian Jessie, while `node:7-alpine`
    is based on Alpine 3.4\. `node:7-slim` will be based on the slim Debian Jessie,
    and there''s even `node:7-wheezy` if we feel like running Node 7 on Debian Wheezy.
    Also available are Node 6, 4, and below.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Node Docker 镜像的官方仓库包含多个标签版本和多个基础镜像：`node:7` 基于 Debian Jessie，而 `node:7-alpine`
    基于 Alpine 3.4。`node:7-slim` 将基于精简版的 Debian Jessie，如果我们想在 Debian Wheezy 上运行 Node
    7，还有 `node:7-wheezy`。另外，Node 6、4 及更低版本也有提供。
- en: 'To start from the latest Node 7 image version, use this in a Dockerfile:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要从最新的 Node 7 镜像版本开始，可以在 Dockerfile 中使用以下内容：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For the record, a `node:7` image will be around 650 MB, while `node:4-slim`
    will be around 205 MB.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 需要说明的是，`node:7` 镜像大约为 650 MB，而 `node:4-slim` 镜像大约为 205 MB。
- en: Starting from a Golang image
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 Golang 镜像开始
- en: Go is well distributed as a Docker image. Its releases are tagged by release
    (such as `golang:1.7`) and with alternatives such as one based on Alpine (`golang:1.7-alpine`)
    or even for Windows Server (`golang:1.7-windowsservercore` and `golang:1.7-nanoserver`).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Go 作为 Docker 镜像被广泛分发。它的版本通过版本号进行标签（例如 `golang:1.7`），还有基于 Alpine 的替代版本（`golang:1.7-alpine`）或甚至适用于
    Windows Server 的版本（`golang:1.7-windowsservercore` 和 `golang:1.7-nanoserver`）。
- en: 'To start from the Go image, use the following in a Dockerfile:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Go 镜像开始，可以在 Dockerfile 中使用以下内容：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The main Go `1.7` image is 672 MB.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 主 Go `1.7` 镜像为 672 MB。
- en: Starting from a Ruby image
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 Ruby 镜像开始
- en: 'Ruby is also distributed as an official Docker image: all the latest releases
    are found tagged like `ruby:2.3`. Alternative builds from Alpine Linux and Debian
    Jessie slim images are also available.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 也作为官方 Docker 镜像发布：所有最新的版本都以 `ruby:2.3` 的标签形式存在。此外，还有来自 Alpine Linux 和 Debian
    Jessie 精简版镜像的替代构建版本。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A distinct Ruby-on-Rails Docker image used to exist, but is now deprecated in
    favor of the main Ruby Docker image.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经有一个独立的 Ruby-on-Rails Docker 镜像，但现在已被弃用，转而使用主 Ruby Docker 镜像。
- en: 'To start from the Ruby `2.3` image, use the following to start a Dockerfile:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Ruby `2.3` 镜像开始，可以使用以下内容启动 Dockerfile：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The main Ruby `2.3` image is 725 MB.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 主 Ruby `2.3` 镜像为 725 MB。
- en: Starting from a Python image
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 Python 镜像开始
- en: Python is officially distributed and many of its versions are supported as tagged
    Docker images. We can find versions 2.7, 3.3, 3.4, 3.5, and current beta versions
    based on Debian Jessie or Wheezy, Alpine, and Windows Server.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Python 官方发布并支持多个版本的 Docker 镜像。我们可以找到版本 2.7、3.3、3.4、3.5 和当前的 beta 版本，这些版本基于 Debian
    Jessie 或 Wheezy、Alpine 和 Windows Server。
- en: 'To start our project using the Python `3.5` image, add the following in a Dockerfile:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Python `3.5` 镜像启动我们的项目，可以在 Dockerfile 中添加以下内容：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The main `python:3.5` image is around 683 MB.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 主 `python:3.5` 镜像大约为 683 MB。
- en: Starting from a Java image
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 Java 镜像开始
- en: Java users are also getting official releases on Docker. Both OpenJDK and JRE
    are available, for versions 6, 7, 8, and 9, based on Debian Jessie or Alpine.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Java 用户也可以在 Docker 上获取官方发布版本。OpenJDK 和 JRE 都可以使用，适用于 6、7、8 和 9 版本，基于 Debian
    Jessie 或 Alpine。
- en: 'To start using the OpenJDK 9 image, use the following in a Dockerfile:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 OpenJDK 9 镜像，可以在 Dockerfile 中使用以下内容：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The main `openjdk:9` image is 548 MB—one of the smallest programming language
    images available.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 主 `openjdk:9` 镜像为 548 MB——是可用的最小的编程语言镜像之一。
- en: Starting from a PHP image
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 PHP 镜像开始
- en: The PHP Docker image is very popular, and available in many different flavors.
    It's one of the easiest ways of easily testing newer and older releases of PHP
    on a platform. PHP 5.6 and 7.0 (and all beta versions) are available, and each
    is also available with a different flavor, that is, based on Alpine (`php:7-alpine`),
    Debian Jessie with Apache (`php:7-apache`), or Debian Jessie with FPM (`php:7-fpm`),
    but if we still like FPM with Alpine, it's also ok (`php:7-fpm-alpine`).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: PHP Docker 镜像非常流行，并且有很多不同的版本。它是轻松测试新旧 PHP 版本的一种非常简便的方式。PHP 5.6 和 7.0（以及所有的 beta
    版本）都有提供，而且每个版本也有不同的变种，例如基于 Alpine 的`php:7-alpine`，基于 Debian Jessie 的 Apache 版本`php:7-apache`，或者基于
    Debian Jessie 的 FPM 版本`php:7-fpm`，但如果我们仍然喜欢 Alpine 版本的 FPM，也可以使用`php:7-fpm-alpine`。
- en: 'To start using a classic PHP 7 Docker image, start with the following in a
    Dockerfile:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用经典的 PHP 7 Docker 镜像，在 Dockerfile 中使用以下内容：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The main `php:7` image is 363 MB—this is the smallest programming language image
    available.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的`php:7`镜像为363 MB——这是目前最小的编程语言镜像。
- en: See also
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'Images on the Docker Hub: [https://hub.docker.com/explore/](https://hub.docker.com/explore/)'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Docker Hub 上的镜像: [https://hub.docker.com/explore/](https://hub.docker.com/explore/)'
- en: 'Red Hat Container catalog: [https://access.redhat.com/containers](https://access.redhat.com/containers)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Red Hat 容器目录: [https://access.redhat.com/containers](https://access.redhat.com/containers)'
- en: Optimizing the Docker image size
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化 Docker 镜像大小
- en: Docker images are generated instruction by instruction from the Dockerfile.
    Though perfectly correct, many images are sub-optimized when we're talking about
    size. Let's see what we can do about it by building an Apache Docker container
    on Ubuntu 16.04.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像是按照 Dockerfile 中的指令逐步生成的。尽管完全正确，但在谈到镜像大小时，很多镜像在优化上存在不足。让我们通过在 Ubuntu
    16.04 上构建 Apache Docker 容器来看看能做些什么。
- en: Getting ready
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need a working Docker installation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行这个操作，你需要一个正常工作的 Docker 安装。
- en: How to do it…
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'Take the following `Dockerfile`, which updates the Ubuntu image, installs the
    `apache2` package, and then removes the `/var/lib/apt` cache folder. It''s perfectly
    correct, and if you build it, the image size is around 260 MB:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是更新 Ubuntu 镜像、安装`apache2`包，并删除`/var/lib/apt`缓存文件夹的`Dockerfile`。它完全正确，如果你构建它，镜像大小大约是260
    MB：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, each layer is added on top of the previous. So, what's written during the
    `apt-get update` layer is written forever, even if we remove it in the last `RUN`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每一层都是在上一层的基础上添加的。所以，在`apt-get update`这层中所写的内容会一直保留，即使我们在最后的`RUN`命令中删除它。
- en: 'Let''s rewrite this `Dockerfile` using a one-liner, to save some space:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一行代码重写这个`Dockerfile`，以节省一些空间：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This image is exactly the same, but is only around 220 MB. That's 15% space
    saved!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个镜像与原镜像完全相同，但大小仅为220 MB。节省了15%的空间！
- en: 'Replacing the `ubuntu:16.04` image with the `debian:stable-slim` image gets
    the same result, but with a size of 135 MB (a 48% reduction in size!):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 用`debian:stable-slim`镜像替代`ubuntu:16.04`镜像可以得到相同的结果，但大小为135 MB（大小减少了48%！）：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works…
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Each layer is added to its predecessor. By combining all the related commands
    from download to deletion, we keep a clean state on this particular layer. Another
    good example is when the Dockerfile downloads a compressed archive; downloading
    it, uncompressing it, and then removing the archive uses a lot of added layer
    space when done separately. The same in one line does everything at once, so instead
    of having the cumulated space taken from the archive and its uncompressed content,
    the space taken is only from the uncompressed content alone. Often, there's a
    very nice gain in size!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 每一层都在其前一层之上添加。通过将下载到删除的所有相关命令合并在一起，我们在这个特定的层上保持了一个干净的状态。另一个很好的例子是，当 Dockerfile
    下载一个压缩包时；分别下载、解压和删除这个压缩包会使用大量的额外层空间。如果把这些操作写成一行代码，它们会一次性完成。所以，代替从压缩包及其解压后的内容中累积的空间，所占空间仅来自解压后的内容。通常，这样做会带来非常可观的空间节省！
- en: Versioning Docker images with tags
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标签对 Docker 镜像进行版本控制
- en: A very common need is to quickly identify what version of the software a Docker
    image is running and optionally stick to it, or to be sure to always run a stable
    version. This is a perfect use for the Docker tags. We'll build a Terraform container,
    with both a stable and an unstable tag, so multiple versions can coexist—one for
    production and one for testing.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的需求是快速识别一个 Docker 镜像正在运行的软件版本，并选择是否固定版本，或者确保始终运行一个稳定版本。这是 Docker 标签的完美应用场景。我们将构建一个
    Terraform 容器，使用稳定和不稳定标签，这样多个版本可以并存——一个用于生产，另一个用于测试。
- en: Note
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Docker *tags* are not to be mistaken with Docker *labels*. Labels are purely
    informative when tags can be requested directly to make images distinct from an
    operational point of view.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Docker *标签*与Docker *标签*不同。标签是纯粹的信息性，而标签则可以直接请求，以便从操作角度区分镜像。
- en: Getting ready
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need a working Docker installation.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照此配方操作，您需要一个正常工作的Docker安装。
- en: How to do it…
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Here''s a simple Dockerfile to create a Terraform container (Terraform was
    covered earlier in this book):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的Dockerfile，用于创建Terraform容器（Terraform在本书前面已经介绍过）：
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is the current, stable, and latest version, and it''s 0.7.12 as well.
    We''d like our users to be able to request one of the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当前的稳定和最新版本，也是0.7.12。我们希望我们的用户能够请求以下版本之一：
- en: '`terraform:latest` (for those of our users who always want the latest version
    available)'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`terraform:latest`（对于那些始终需要最新版本的用户）'
- en: '`terraform:stable` (for those of our users who always want the stable version,
    opposed to a beta version)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`terraform:stable`（对于那些始终需要稳定版本的用户，而不是测试版）'
- en: '`terraform:0.7.12` (for those of our users who always want a very specific
    version, such as for compatibility issues)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`terraform:0.7.12`（对于那些始终需要特定版本的用户，例如由于兼容性问题）'
- en: 'This is easily achievable by building directly with all these different tags:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过直接构建所有这些不同的标签，轻松实现这一目标：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now when requesting which images are available, we can see they all have the
    same image ID, but with different tags. This is what we wanted, since it''s the
    same image that shares all those tags:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当请求哪些镜像可用时，我们可以看到它们都有相同的镜像ID，但具有不同的标签。这正是我们想要的，因为它是相同的镜像，分享所有这些标签：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Some days later, we release a new version of the software as a Docker container
    for our team to test it out. This time it''s an unstable, 0.8.0-rc1 version. We''d
    like our users to request this image as one of the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 几天后，我们发布了软件的新版本作为Docker容器供我们的团队测试。这一次是一个不稳定的0.8.0-rc1版本。我们希望我们的用户能够请求以下镜像之一：
- en: '`terraform:latest` (it''s still the latest version available, even unstable)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`terraform:latest`（它仍然是可用的最新版本，即使是不稳定的）'
- en: '`terraform:unstable` (it''s a release candidate, not a stable version)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`terraform:unstable`（这是一个发布候选版本，而不是稳定版本）'
- en: '`terraform:0.8.0-rc1` (it''s this specific version)'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`terraform:0.8.0-rc1`（这是这个特定版本）'
- en: 'Change the `TERRAFORM_VERSION` variable in the `Dockerfile`, and build the
    image with the following tags:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Dockerfile`中更改`TERRAFORM_VERSION`变量，并使用以下标签构建镜像：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, if we look at the available Terraform images, we can confirm that it''s
    the same image ID shared by the `latest`, `unstable`, and `0.8.0-rc1` tags, while
    our users preferring the stable version are not impacted by our changes:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们查看可用的Terraform镜像，我们可以确认它是相同的镜像ID，`latest`、`unstable`和`0.8.0-rc1`标签共享该镜像ID，而我们的用户如果更倾向于稳定版本，则不会受到我们更改的影响：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'This leads to a very important question: as the latest tag is by default when
    not specifying any, should it be also used for unstable releases? This is something
    you have to answer according to your needs and environment.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了一个非常重要的问题：由于默认情况下未指定任何标签时使用的是最新标签，是否也应该将其用于不稳定的版本？这需要根据您的需求和环境来回答。
- en: Deploying a Ruby-on-Rails web application in Docker
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker中部署Ruby-on-Rails Web应用程序
- en: The great thing with Docker is that, as developers, we can ship whatever is
    working on this particular container on one environment (such as development or
    staging) and be sure it will run similarly in another environment (such as production).
    Deploys are less stressful, and rollbacks are easier. However, to achieve this
    peace of mind, we need more than a Ruby-on-Rails application, for example, we
    need to ship a Dockerfile containing everything to build a self-sufficient container
    so anyone can run it. Here's how to do it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的好处在于，作为开发人员，我们可以在某个环境（如开发或预发布）上将所有工作正常的内容打包到该容器中，并确信它将在另一个环境（如生产）中类似运行。部署压力较小，回滚也更容易。然而，要实现这种安心感，我们需要的不仅仅是一个Ruby-on-Rails应用程序，例如，我们需要打包一个包含所有内容的Dockerfile，以便任何人都可以运行它。以下是操作方法。
- en: Getting ready
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照此配方操作，您需要以下内容：
- en: A working Docker installation
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的Docker安装
- en: A Rails application
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Rails应用程序
- en: How to do it…
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Here are our standard requirements:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的标准要求：
- en: This Rails application needs Ruby 2.3
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个Rails应用程序需要Ruby 2.3
- en: All dependencies are handled by Bundler, and need to be installed in the container
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有依赖项都由Bundler管理，需要在容器中安装
- en: Node 5 is also needed
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还需要Node 5
- en: We want assets to be precompiled in the image (putting them somewhere else is
    out of scope)
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望在镜像中预编译资产（将它们放到其他地方超出了此范围）。
- en: 'Here''s how we''ll proceed. To match our main requirement, we''ll start with
    the `ruby:2.3` image:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按以下步骤进行操作。为了满足我们的主要需求，我们将从 `ruby:2.3` 镜像开始：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'One way to enable the official Node 5 repositories is to download and execute
    a setup script. Let''s do it:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 启用官方 Node 5 仓库的一种方法是下载并执行一个安装脚本。我们来做一下：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now we need to install Node 5 (`apt-get install nodejs`) and remove all the
    cache files:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要安装 Node 5 (`apt-get install nodejs`) 并删除所有缓存文件：
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The Ruby image documentation suggests using `/usr/src/app` as a destination
    folder for our code. Let''s ensure it''s created and switch to it until the rest
    of the process:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 镜像文档建议将 `/usr/src/app` 用作我们代码的目标文件夹。我们确保它已创建并切换到该目录，直到完成其余过程：
- en: '[PRE37]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: To install all the declared dependencies, we need to send both `Gemfile` and
    `Gemfile.lock` to the destination folder, `/usr/src/app`. We include it as a distinct
    step, so we can optionally customize this step later. Then we execute Bundler
    (without the test and development sections if we have them). If you're a Ruby
    developer, customize accordingly!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装所有声明的依赖项，我们需要将 `Gemfile` 和 `Gemfile.lock` 发送到目标文件夹 `/usr/src/app`。我们将其作为一个独立的步骤，以便以后可以根据需要定制此步骤。然后我们执行
    Bundler（如果有的话，跳过测试和开发部分）。如果您是 Ruby 开发人员，请根据需要进行定制！
- en: '[PRE38]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It''s now time to copy the application code itself to the destination folder,
    `/usr/src/app` (in this case, it''s the current folder):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将应用程序代码本身复制到目标文件夹 `/usr/src/app`（在本例中，它是当前文件夹）：
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The next step is to precompile the assets, with a `RAILS_ENV` set to production,
    but feel free to adapt, including the compilation command:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是预编译资产，设置 `RAILS_ENV` 为生产环境，但您可以根据需要调整，包括编译命令：
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, run the Rails server on all interfaces through bundler (by default,
    it listens on TCP/`3000`):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过 Bundler 在所有接口上运行 Rails 服务器（默认情况下，它监听 TCP/`3000`）：
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We can now build this Dockerfile and have our complete, standalone, and fully
    working Ruby-on-Rails application ready on Docker.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以构建这个 Dockerfile，并使我们的完整、独立且完全可用的 Ruby-on-Rails 应用程序准备好运行在 Docker 上。
- en: Note
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is a good practice to plug the build process in CI and execute tests against
    running this new image!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CI 中插入构建过程并执行测试是一个好习惯，运行这个新镜像时一定要进行测试！
- en: Building and using Golang applications with Docker
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 构建和使用 Golang 应用程序
- en: 'Golang is a great language able to create statically linked binaries for different
    platforms such as Linux (ELF binaries) or Mac OS (Mach-O binaries). These binaries
    are often very small in size, and the language is getting increasingly popular
    in the microservices world because of their portability and the speed of deployment
    it enables: deploying a self-sufficient 10 MB Docker image on dozens of servers
    is just more convenient and fast than a 1.5 GB image full of libs. Golang and
    containers are two technologies that go perfectly well together, and shipping
    or managing infrastructures using Go programs is a breeze.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Golang 是一种伟大的编程语言，能够为不同平台创建静态链接的二进制文件，如 Linux（ELF 二进制文件）或 Mac OS（Mach-O 二进制文件）。这些二进制文件通常非常小，且该语言在微服务领域日益流行，因为它的可移植性和部署速度：在几十台服务器上部署一个自给自足的
    10 MB Docker 镜像比部署一个满是库的 1.5 GB 镜像要方便且快速得多。Golang 和容器是两种非常匹配的技术，使用 Go 程序来运输或管理基础设施轻松便捷。
- en: Getting ready
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步进行此配方，您需要以下内容：
- en: A working Docker installation
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的 Docker 安装
- en: A Golang application source code
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Golang 应用程序源代码
- en: How to do it…
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: Let's say our application code is checked in `src/hello`. We'd like to begin
    by at least compiling the program, either for the Linux platform or for the Mac
    operating system.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的应用程序代码存放在 `src/hello` 中。我们希望至少编译程序，无论是为 Linux 平台还是为 Mac 操作系统。
- en: Using the golang Docker image to cross-compile a Go program
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 golang Docker 镜像进行 Go 程序的交叉编译
- en: 'We can compile our program sharing the code folder, and setting the work directory
    to it:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过共享代码文件夹并将工作目录设置为该文件夹来编译我们的程序：
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This way, even on a Mac OS system, we can generate a proper ELF binary:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，即使在 Mac OS 系统上，我们也可以生成一个正确的 ELF 二进制文件：
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'That said, if we explicitly want a Mac binary, we can pass the standard Go
    environment variables `GOOS` and `GOARCH` so even a Linux machine can build a
    Mac binary:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，如果我们明确想要一个 Mac 二进制文件，我们可以传递标准的 Go 环境变量 `GOOS` 和 `GOARCH`，这样即使是 Linux 机器也能构建
    Mac 二进制文件：
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Confirm we have a Mach-O executable and not an ELF binary:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 确认我们有一个 Mach-O 可执行文件，而不是 ELF 二进制文件：
- en: '[PRE45]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Using the golang Docker image to build and ship a Go program
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 golang Docker 镜像构建并部署 Go 程序
- en: 'Now if we want to build our program right from a Dockerfile and generate a
    Docker image out of it, that would translate like the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想直接从 Dockerfile 构建程序并生成 Docker 镜像，那么可以按如下方式进行：
- en: '[PRE46]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Just build that image and execute it:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 只需构建该镜像并执行即可：
- en: '[PRE47]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Using the scratch Docker image
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 scratch Docker 镜像
- en: 'Now, it''s a bit of a waste of space to have a 675 MB+ image for the very often
    small Golang application that often is only a few MB, and it takes time to deploy
    on servers. Here comes the scratch image: it just doesn''t exist. We start from
    nothing, copy the binary, and execute it. Our build process (Makefile, build process,
    and CI) builds the app with the `golang` image, but does not ship the compiled
    application with it, saving usually 95–99% of the space, depending on the size
    of our binary:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于经常只有几 MB 的小型 Golang 应用程序，使用 675 MB 以上的镜像是有些浪费空间的，而且在服务器上部署也需要时间。这里就用到了
    scratch 镜像：它实际上不存在。我们从零开始，复制二进制文件并执行它。我们的构建过程（Makefile、构建过程和 CI）使用 `golang` 镜像来构建应用程序，但不会将编译后的应用程序一同打包，从而节省了通常
    95-99% 的空间，具体取决于二进制文件的大小：
- en: '[PRE48]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This generates the smallest image imaginable. Think only a few megabytes.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个最小的镜像。想象一下，只有几兆字节。
- en: Using the Alpine Linux alternative for a Go program
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Alpine Linux 作为 Go 程序的替代方案
- en: 'The main problem with the scratch image solution is the impossibility to debug
    it easily from inside the container, and the impossibility to rely on external
    libraries or dependencies such as SSL and certificates. Alpine Linux is this small
    image (~5 MB) that can greatly help us if we''d like to access a shell (`/bin/sh`
    is available) and a package manager to debug our application. This is how we''d
    do it:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 scratch 镜像的主要问题是无法轻松地从容器内部进行调试，以及无法依赖外部库或依赖项（如 SSL 和证书）。Alpine Linux 是一个非常小的镜像（约
    5 MB），如果我们希望访问 shell（`/bin/sh` 可用）和包管理器来调试应用程序，它将非常有帮助。我们可以这样做：
- en: '[PRE49]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Such an image usually is only a handful of megabytes more than the application
    binary, but helps greatly for debugging.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的镜像通常比应用程序二进制文件大几个兆字节，但在调试时非常有帮助。
- en: Networking with Docker
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 进行网络连接
- en: Docker has some pretty nice networking options, from choosing which ports to
    expose to concurrently running isolated or bridged networks. It's pretty useful
    to quickly and easily simulate production environments, create better architectures,
    and increase container exposure on the network front. We'll see different ways
    to expose ports, create new networks, execute Docker containers inside them, and
    even have multiple networks per container.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 提供了一些非常不错的网络选项，从选择暴露哪些端口到同时运行隔离或桥接的网络。它非常有用，可以快速、轻松地模拟生产环境、创建更好的架构，并增加容器在网络前端的曝光度。我们将看到不同的端口暴露方式、如何创建新网络、如何在其中执行
    Docker 容器，甚至让每个容器拥有多个网络。
- en: Getting ready
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照此教程操作，您需要以下内容：
- en: A working Docker installation
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可用的 Docker 安装
- en: A sample HTTP server binary (sample code included)
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个示例 HTTP 服务器二进制文件（示例代码包括）
- en: How to do it…
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'To make a container network port available to others, it first needs to be
    *exposed*. Consider any service listening on a port not reachable unless properly
    exposed in the 3:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要使容器网络端口对其他人可用，首先需要将其 *暴露*。考虑任何监听端口的服务，除非正确暴露在 3 中，否则无法访问：
- en: '[PRE50]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This service is listening on port `8000`, and any other Docker container running
    on the host can access it, by default on the same network:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务正在 `8000` 端口监听，默认情况下，运行在主机上的任何其他 Docker 容器都可以访问它，且都在相同的网络上：
- en: '[PRE51]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'However, this service is not available to the host system:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个服务对主机系统不可用：
- en: '[PRE52]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To make it available to the host system, the container has to be run with an
    explicit port redirection. It can be option `-P` to map exposed ports randomly
    (the port `8000` can be mapped to 32768 on the local machine), or the other option
    `-p 8000:8000` to make it fixed:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让其对主机系统可用，容器必须通过显式的端口重定向运行。可以使用选项 `-P` 随机映射暴露的端口（例如，端口 `8000` 可以映射到本地机器的 32768
    端口），或者使用另一个选项 `-p 8000:8000` 来固定端口映射：
- en: '[PRE53]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'On another terminal, find the port redirection:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端中，查找端口重定向：
- en: '[PRE54]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Also, try to connect to it:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，尝试连接到该端口：
- en: '[PRE55]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: These are the basics of networking with Docker containers.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是与 Docker 容器进行网络连接的基础知识。
- en: Docker networks
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker 网络
- en: 'Containers can also live inside dedicated networks for added security and isolation.
    To create a new Docker network, just give it a name:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 容器也可以存在于专用网络中，以增加安全性和隔离性。要创建一个新的 Docker 网络，只需给它命名即可：
- en: '[PRE56]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Grab some information about this network using the `docker network inspect`
    command:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker network inspect`命令获取有关此网络的一些信息：
- en: '[PRE57]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This is a new subnet: `172.18.0.0/16` (in this case).'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个新的子网：`172.18.0.0/16`（在此情况下）。
- en: 'To execute a container in this specific Docker network, use the `--network
    <docker_network_name>` option like this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要在这个特定的 Docker 网络中执行容器，请像这样使用`--network <docker_network_name>`选项：
- en: '[PRE58]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Confirm this container is in the 172.18.0.0/16 network space from the `hello_network`
    network:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 确认该容器位于`hello_network`网络的`172.18.0.0/16`网络空间中：
- en: '[PRE59]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This container will be protected from unauthorized access from any container
    not running on the correct network. Here''s an example from a container running
    in the default network:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这个容器将被保护，避免任何未在正确网络上运行的容器访问。这里有一个例子，来自一个在默认网络上运行的容器：
- en: '[PRE60]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'However, connecting from a container in the same network is allowed and working
    as expected:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从同一网络中的容器进行连接是允许的，并且按预期工作：
- en: '[PRE61]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Connecting multiple networks for one container
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为一个容器连接多个网络
- en: 'It can be useful to have a few specific containers available on more than one
    network; proxies, internal services, and other similar services can face different
    networking configurations. A single Docker container can connect multiple Docker
    networks. Take this simple HTTP service listening on port 8000 and launch it on
    the default bridged network:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个网络上拥有一些特定容器可能会很有用；代理、内部服务和其他类似服务可能面临不同的网络配置。一个 Docker 容器可以连接多个 Docker 网络。以这个简单的
    HTTP 服务为例，它监听 8000 端口并在默认的桥接网络上启动：
- en: '[PRE62]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This service is now available to any other container on the default network:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个服务可以供任何其他容器在默认网络上使用：
- en: '[PRE63]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'However, we''d like it to be also available on the *hello_network* Docker network.
    Let''s connect them to the host:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们希望它也可以在*hello_network* Docker 网络上使用。让我们将它们连接到主机：
- en: '[PRE64]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The container now has a new network interface in the `hello_network` subnet:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这个容器现在在`hello_network`子网中有了一个新的网络接口：
- en: '[PRE65]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This means that it's also available to answer requests from containers on this
    network!
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它也可以响应来自该网络中容器的请求！
- en: '[PRE66]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We''ll eventually remove the link to the original network after we''re done
    with it:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成后，我们最终会移除与原始网络的链接：
- en: '[PRE67]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Creating more dynamic containers
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建更动态的容器
- en: We can create better containers than just fixing their usage in advance and
    executing them. Maybe part of the command is the one to keep (like we always want
    the OpenVPN binary and options to be executed, no matter what), maybe everything
    needs to be overridden (that's the toolbox container model, such as a `/bin/bash`
    command by default, but any other command given in argument can otherwise be executed),
    or a combination of the two, for a much more dynamic container.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建比仅提前固定其用法并执行它们更好的容器。也许某些命令部分需要保留（比如我们始终希望执行 OpenVPN 二进制文件及其选项），也许所有的命令都需要被覆盖（这就是工具箱容器模型，例如默认情况下是`/bin/bash`命令，但可以执行其他传入的命令），或者两者结合，以实现一个更动态的容器。
- en: Getting ready
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need a working Docker installation.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此步骤，您需要一个正常工作的 Docker 安装。
- en: How to do it…
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'To have a fixed command executed by the container, use the `ENTRYPOINT` instruction.
    Use an array if the command is followed by arguments to be enforced:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要让容器执行固定命令，请使用`ENTRYPOINT`指令。如果命令后面有需要强制执行的参数，请使用数组：
- en: '[PRE68]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'To override the whole command at runtime, use the `--entrypoint` option:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 要在运行时覆盖整个命令，请使用`--entrypoint`选项：
- en: '[PRE69]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'To have a command that can be simply overridden with an argument, use the `CMD`
    instruction instead of `ENTRYPOINT`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用可以简单覆盖的命令，请使用`CMD`指令，而不是`ENTRYPOINT`：
- en: '[PRE70]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'To override the command, simply give another command as an argument at runtime:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 要覆盖命令，只需在运行时提供另一个命令作为参数：
- en: '[PRE71]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We can combine both instructions to have a more dynamic container. In this
    case, we want to obtain a container always executing `/usr/sbin/apache2ctl`, and
    by default starting the daemon in foreground, otherwise overridden by any argument
    at container launch time:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以结合这两条指令，创建一个更动态的容器。在这种情况下，我们希望获取一个始终执行`/usr/sbin/apache2ctl`的容器，并默认在前台启动守护进程，除非在容器启动时通过任何参数进行覆盖：
- en: '[PRE72]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: If this container is executed as is, nothing changes; `apache2ctl` gets executed
    with the `-D FOREGROUND` option.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个容器按原样执行，什么也不会改变；`apache2ctl`会使用`-D FOREGROUND`选项执行。
- en: 'However, it becomes a more useful container when giving it arguments, as it
    dynamically will add them to the `apache2ctl` command, replacing the original
    command specified by the `CMD` instruction:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，给它传递参数后，它变成了一个更有用的容器，因为它会动态地将这些参数添加到`apache2ctl`命令中，替换掉`CMD`指令中指定的原始命令：
- en: '[PRE73]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: We can interactively pass `/usr/sbin/apache2ctl` arguments without the need
    to override the entrypoint, for example, to propose alternatives Apache configuration
    files or options.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以交互式地传递`/usr/sbin/apache2ctl`参数，而无需覆盖入口点，例如，提出备选的Apache配置文件或选项。
- en: Auto-configuring dynamic containers
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动配置动态容器
- en: We can't always execute a binary to get what we want. A configuration done dynamically
    is a very common situation; system paths can be dynamic, users and passwords can
    be auto-generated, network ports can be contextual, third-party credentials will
    be different in development and in production, slaves will join their masters,
    cluster members will find other nodes, and most other similar changing elements
    will need to adapt at runtime. The trick here is to combine environment variables
    with the use of a script as an entry point that will be executed no matter what,
    and behave according to the environment variables, optionally combined with a
    command from the Dockerfile.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能总是执行二进制文件来获取我们想要的内容。动态配置是一种非常常见的情况；系统路径可以是动态的，用户和密码可以是自动生成的，网络端口可以是上下文相关的，第三方凭证在开发和生产环境中可能不同，工作节点会加入其主节点，集群成员会找到其他节点，其他类似的变化元素都需要在运行时进行适应。这里的关键是将环境变量与作为入口点执行的脚本结合起来，无论如何都会执行，并根据环境变量进行行为调整，可以选择性地与Dockerfile中的命令结合使用。
- en: Getting ready
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To step through this recipe, you will need a working Docker installation.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照这个配方进行操作，您需要有一个正常工作的Docker安装。
- en: How to do it…
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'Our objective is to create a temporary, dynamic SSH server in a Docker container,
    with credentials we can''t know in advance. So, to make it work as intended, we''ll
    want to execute this container like this:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是创建一个临时、动态的SSH服务器，容器中的凭证我们无法事先知道。所以，为了按预期工作，我们需要像这样执行该容器：
- en: '[PRE74]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Take this simple `Dockerfile` that creates what''s necessary to run the Dropbear
    SSH server on the Alpine Docker image:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 以这个简单的`Dockerfile`为例，它在Alpine Docker镜像上创建了运行Dropbear SSH服务器所需的环境：
- en: '[PRE75]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'When built, this container will start by executing the `entrypoint.sh` script,
    and then the `dropbear` binary. Here''s a sample `entrypoint.sh` that only does
    simple checks for the `USER` and `PASSWORD` environment variable, creates the
    required users on the container, sets some permissions, and finally executes the
    `CMD` instruction from the original Dockerfile:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，该容器将通过执行`entrypoint.sh`脚本启动，然后是`dropbear`二进制文件。以下是一个示例`entrypoint.sh`，它仅对`USER`和`PASSWORD`环境变量进行简单检查，在容器上创建所需的用户，设置一些权限，最后执行原始Dockerfile中的`CMD`指令：
- en: '[PRE76]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'If this container is executed without any arguments, it errors out, thanks
    to the check from the `entrypoint.sh` script:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在没有任何参数的情况下执行此容器，它会报错，这得益于`entrypoint.sh`脚本中的检查：
- en: '[PRE77]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'To properly use this dynamically configured container, use environment variables
    as required:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确使用这个动态配置的容器，请根据需要使用环境变量：
- en: '[PRE78]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now try connecting to this container from another terminal or container with
    proper credentials:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试从另一个终端或容器连接到此容器，并提供正确的凭证：
- en: '[PRE79]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We're logged in to our SSH container!
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经登录到SSH容器了！
- en: Such a dynamic system can be used to give temporary, controlled, and secure
    SSH access to someone needing, for example, shared volume storage access or similar
    usages. Shutting down the container just revokes everything and we're done with
    it.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的动态系统可以用来为需要的人提供临时、受控且安全的SSH访问权限，例如共享卷存储访问或类似用途。关闭容器会撤销所有操作，我们就完成了。
- en: Better security with unprivileged users
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过无特权用户提高安全性
- en: By default, containers execute everything as the `root` user. Granted that containers
    are running in an isolated environment, but still, a publicly facing daemon is
    running as root on a system, and a security breach may give an attacker access
    to this particular container, and maybe root shell access, giving access at least
    to the container's Docker overlay network. Would we like to see this issue combined
    with a 0-day local kernel security breach that would give the attacker access
    to the Docker host? Probably not. Then, maybe we should keep some of the good
    old practices and start by executing our daemon as a user other than root.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，容器会以 `root` 用户身份执行所有操作。虽然容器是在隔离环境中运行的，但仍然，公开面向外部的守护进程是以 root 身份在系统上运行的，如果发生安全漏洞，攻击者可能会获得对该容器的访问权限，甚至是
    root shell 访问权限，从而至少获得容器的 Docker 覆盖网络访问权限。我们是否愿意看到这个问题与一个 0-day 本地内核安全漏洞结合，进而让攻击者获得对
    Docker 主机的访问权限？大概不会。那么，也许我们应该遵循一些古老的最佳实践，从一开始就以非 root 用户身份执行我们的守护进程。
- en: Getting ready
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个配方，您需要以下内容：
- en: A working Docker installation
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个工作中的 Docker 安装
- en: A sample HTTP server binary (sample code included)
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个示例 HTTP 服务器二进制文件（包括示例代码）
- en: How to do it…
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'Let''s take a simple HTTP server that answers on the port `8000` of the container.
    Executed through a container, it would look like this, as seen earlier in this
    book:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个简单的 HTTP 服务器为例，它在容器的 `8000` 端口上提供响应。通过容器执行时，它的样子将是这样的，如本书前面所示：
- en: '[PRE80]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This will work, but things aren''t looking that great security-wise; our daemon
    is, in fact, running as the `root` user, even though it''s running on an unprivileged
    port:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是有效的，但从安全角度来看情况并不理想；我们的守护进程实际上是以 `root` 用户身份运行的，尽管它是在一个非特权端口上运行：
- en: '[PRE81]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This is suboptimal from a security point of view. Containers are real systems,
    so they too can have users. Combined with the `USER` instruction in the Dockerfile,
    we''ll be able to execute commands as an unprivileged user! Here''s how an optimized
    Dockerfile looks, adding a normal user and group for the `hello` user, and then
    executing the `/usr/bin/hello` HTTP server as this new unprivileged user:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来看，这是不理想的。容器是真正的系统，因此它们也可以有用户。结合 Dockerfile 中的 `USER` 指令，我们将能够以非特权用户身份执行命令！这是一个优化过的
    Dockerfile，增加了一个普通的用户和组为 `hello` 用户，然后作为这个新的非特权用户执行 `/usr/bin/hello` HTTP 服务器：
- en: '[PRE82]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Once built and running, the daemon still runs correctly, but as an unprivileged
    user:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建并运行，守护进程仍然能够正常运行，但作为一个非特权用户：
- en: '[PRE83]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We're now building tougher containers!
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正在构建更强大的容器！
- en: Orchestrating with Docker Compose
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 进行编排
- en: Launching multiple containers manually can be a hassle, especially when the
    infrastructure goes increasingly complex. Dependencies, shared variables, and
    common networking can be easily handled with the orchestration tool named Docker
    Compose. In a simply YAML file, we can describe what services are needed to run
    our application (proxy, application, databases, and so on). In this section, we'll
    show how to create a simple LAMP docker-compose file, then we'll show how we can
    iterate from that to build some staging and production specific changes.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 手动启动多个容器可能会很麻烦，尤其是在基础设施日益复杂的情况下。依赖关系、共享变量和公共网络可以通过名为 Docker Compose 的编排工具轻松处理。在一个简单的
    YAML 文件中，我们可以描述运行应用程序所需的服务（代理、应用程序、数据库等）。在本节中，我们将展示如何创建一个简单的 LAMP docker-compose
    文件，然后我们将展示如何从中进行迭代，构建一些适用于暂存和生产的特定更改。
- en: Getting ready
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个配方，您需要以下内容：
- en: A working Docker installation
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个工作中的 Docker 安装
- en: A working Docker Compose installation
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个工作中的 Docker Compose 安装
- en: How to do it…
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'To orchestrate multiple containers together using Docker Compose, let''s start
    with an easy WordPress example. The team at WordPress built a container that auto-configures
    to some extent through environment variables similar to what we saw earlier in
    this chapter. If we just apply the documentation shipped with the WordPress Docker
    container, we end up with the following `docker-compose.yml` at the root of some
    new directory (it can be a Git repository if needed):'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Docker Compose 编排多个容器，我们从一个简单的 WordPress 示例开始。WordPress 团队构建了一个容器，该容器通过类似本章前面所见的环境变量自动配置到一定程度。如果我们仅仅应用随
    WordPress Docker 容器一起发布的文档，我们将得到以下 `docker-compose.yml` 文件，位于某个新目录的根目录中（如果需要，可以是
    Git 仓库）：
- en: '[PRE84]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This has the great advantage to work out of the box; the latest WordPress and
    MariaDB images get downloaded, local HTTP port 80 gets redirected on port 8080
    on the host, and MySQL stays isolated. The WordPress container takes one environment
    variable in this case—the MySQL root password, which should match the environment
    variable from MySQL. We'll see that many more are possible.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个很大的优点，即开箱即用；最新的 WordPress 和 MariaDB 镜像会被下载，本地 HTTP 端口 80 会被重定向到主机的端口 8080，MySQL
    保持隔离。WordPress 容器在这种情况下只需要一个环境变量——MySQL 的 root 密码，它应与 MySQL 的环境变量匹配。我们会看到，实际上还有更多的环境变量可以配置。
- en: 'Executing Docker Compose will automatically create a Docker network and run
    the containers:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 Docker Compose 将自动创建一个 Docker 网络并启动容器：
- en: '[PRE85]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Let''s verify we can connect to the WordPress HTTP server locally, on the redirected
    port `8080`:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证是否能通过本地重定向端口 `8080` 连接到 WordPress HTTP 服务器：
- en: '[PRE86]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'More information can be seen using the `ps` command:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ps` 命令可以查看更多信息：
- en: '[PRE87]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Let''s ensure the password used for the MySQL root password is really the one
    provided by the `docker-compose.yml` file, using the `docker-compose exec` command,
    very similar to the `docker run` command (it takes `docker-compose.yml` names):'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用 `docker-compose exec` 命令来确保 MySQL root 密码使用的确实是 `docker-compose.yml`
    文件中提供的密码，这个命令非常类似于 `docker run` 命令（它接受 `docker-compose.yml` 文件中的名称）：
- en: '[PRE88]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'When we''re done with our initial Docker Compose environment, let''s destroy
    it; the containers and networks will be removed:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成初始的 Docker Compose 环境后，让我们销毁它；容器和网络将被移除：
- en: '[PRE89]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Extending Docker Compose
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展 Docker Compose
- en: 'Now we know the basics, let''s extend the usage a little. We''re not happy
    with the default password and would like to use a better one, so simulate the
    staging environment. Let''s use the overriding feature of Docker Compose for that
    and create a `docker-compose.staging.yml` file that will simply override the concerned
    values:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了基本知识，接下来我们稍微扩展一下使用。我们不满意默认密码，想使用更好的密码，以便模拟一个临时环境。为此，我们将利用 Docker Compose
    的覆盖特性，创建一个 `docker-compose.staging.yml` 文件，简单地覆盖相关的值：
- en: '[PRE90]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The two environment variables `WORDPRESS_DB_PASSWORD` and `MYSQL_ROOT_PASSWORD`
    will be overridden when `docker-compose` is executed with multiple configuration
    files taken in order:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用多个配置文件执行 `docker-compose` 时，`WORDPRESS_DB_PASSWORD` 和 `MYSQL_ROOT_PASSWORD`
    这两个环境变量会被覆盖：
- en: '[PRE91]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Verify that the new password is indeed working for MySQL:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 验证新密码是否在 MySQL 中正常工作：
- en: '[PRE92]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: We're very easily overriding values with simple YAML files!
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们非常容易地通过简单的 YAML 文件来覆盖值！
- en: 'Suppose that we now want to include a reverse proxy to the mix, with a slightly
    earlier version of the Docker image and another MySQL password, to mimic a specific
    situation we have in production. We can use the excellent dynamic Nginx image
    from `jwilder/nginx-proxy` to do this job and add a new *proxy* service, sharing
    port `80` and the local Docker socket as read-only (to dynamically access running
    containers) on a `docker-compose.production.yml` file:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们现在想要在配置中加入反向代理，使用一个稍早版本的 Docker 镜像并更换 MySQL 密码，以模拟我们在生产环境中的特定情况。我们可以使用 `jwilder/nginx-proxy`
    提供的优秀动态 Nginx 镜像来完成这项工作，并在 `docker-compose.production.yml` 文件中添加一个新的 *proxy* 服务，共享端口
    `80` 以及本地 Docker 套接字作为只读（以动态访问运行中的容器）：
- en: '[PRE93]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'This `nginx-proxy` container needs a variable named `VIRTUAL_HOST` to know
    what to answer in case of multiple virtual hosts. Let''s add it as localhost (or
    adapt to your local hostname), along with the better password and the WordPress
    image version:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `nginx-proxy` 容器需要一个名为 `VIRTUAL_HOST` 的变量，以便在有多个虚拟主机的情况下知道该回答什么。我们将其设置为 localhost（或者根据你的本地主机名进行调整），并添加更好的密码以及
    WordPress 镜像版本：
- en: '[PRE94]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Make the password match in the MySQL section as well and we''ll be done with
    our production environment simulation:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 让 MySQL 部分的密码也匹配，我们就完成了生产环境的模拟：
- en: '[PRE95]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Confirm `nginx-proxy` is answering in HTTP/`80` and forwarding a proper HTTP
    answer from the WordPress container:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 确认 `nginx-proxy` 在 HTTP/`80` 上正常响应，并转发来自 WordPress 容器的正确 HTTP 响应：
- en: '[PRE96]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: We've seen how, with only a few lines of YAML, we can easily orchestrate containers,
    how it can be used to handle different cases and environments, and how it can
    also be successfully extended. This is, however, just a small introduction to
    what can be done with Docker Compose—it's quite a powerful tool!
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，仅用几行 YAML 配置就能轻松编排容器，如何处理不同的情况和环境，并且它也能成功扩展。不过，这只是 Docker Compose 可以实现的功能的一个小介绍——它是一个非常强大的工具！
- en: See also
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'Nginx-proxy: [https://github.com/jwilder/nginx-proxy](https://github.com/jwilder/nginx-proxy)'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Nginx-proxy: [https://github.com/jwilder/nginx-proxy](https://github.com/jwilder/nginx-proxy)'
- en: 'WordPress Docker image: [https://hub.docker.com/_/wordpress/](https://hub.docker.com/_/wordpress/)'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WordPress Docker 镜像：[https://hub.docker.com/_/wordpress/](https://hub.docker.com/_/wordpress/)
- en: 'The Docker Compose documentation: [https://docs.docker.com/compose/](https://docs.docker.com/compose/)'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose 文档：[https://docs.docker.com/compose/](https://docs.docker.com/compose/)
- en: Linting a Dockerfile
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lint 检查 Dockerfile
- en: Like any other language, Dockerfiles can and should be linted for updated best
    practices and code quality checks. Docker is no exception to the rule, and good
    practices are always moving, getting updates, and might also be a little different
    between communities. In this section, we'll start with a basic Dockerfile found
    earlier and end up with a fully double-checked linted file.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他任何语言一样，Dockerfile 也可以并且应该进行 lint 检查，以确保最佳实践和代码质量。Docker 也不例外，好的实践总是在不断发展，更新，并且在不同社区之间可能略有不同。在本节中，我们将从之前找到的一个基本
    Dockerfile 开始，最后得到一个完全经过双重检查的 lint 检查文件。
- en: Getting ready
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按此方法进行操作，您需要以下内容：
- en: A working Docker installation
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的 Docker 安装
- en: An AWS account
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 AWS 账户
- en: How to do it…
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Many different linters exist for linting Dockerfiles: Hadolint ([http://hadolint.lukasmartinelli.ch/](http://hadolint.lukasmartinelli.ch/))
    maybe the most used linter, while Project Atomic''s `dockerfile_lint` project
    is perhaps the most complete one ([https://github.com/projectatomic/dockerfile_lint](https://github.com/projectatomic/dockerfile_lint)).'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的 linters 可以用于 lint 检查 Dockerfile：Hadolint（[http://hadolint.lukasmartinelli.ch/](http://hadolint.lukasmartinelli.ch/)）可能是使用最广泛的
    linters，而 Project Atomic 的 `dockerfile_lint` 项目则可能是最完整的一个（[https://github.com/projectatomic/dockerfile_lint](https://github.com/projectatomic/dockerfile_lint)）。
- en: 'Here''s the working Dockerfile from earlier in this book:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书之前提到的工作中的 Dockerfile：
- en: '[PRE97]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Hadolint
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Hadolint
- en: 'Let''s start working with Hadolint, as it''s easy to install (prebuilt binaries
    and Docker images) and use. All rules are explained in Hadolint''s wiki ([https://github.com/lukasmartinelli/hadolint/wiki](https://github.com/lukasmartinelli/hadolint/wiki)),
    and usage is really simple:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用 Hadolint，因为它易于安装（提供预构建的二进制文件和 Docker 镜像）和使用。所有规则都可以在 Hadolint 的 Wiki
    中找到解释（[https://github.com/lukasmartinelli/hadolint/wiki](https://github.com/lukasmartinelli/hadolint/wiki)），而且使用方法非常简单：
- en: '[PRE98]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Alternatively, use the Docker containerized version; it''s probably good in
    CI scripts. Beware of the image size; at the time of writing, the image is 1.7
    GB, while the hadolint binary is less than 20 MB:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，可以使用 Docker 容器化版本；它可能在 CI 脚本中非常有用。请注意镜像的大小；在撰写时，该镜像为 1.7 GB，而 Hadolint 二进制文件小于
    20 MB：
- en: '[PRE99]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Linting Dockerfiles from this chapter, we''ll notice different warnings. Maybe
    some are false positives, or maybe some rules are just not yet updated to the
    latest deprecation notices, such as the following:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始对 Dockerfile 进行 lint 检查，我们会注意到不同的警告。也许有些是误报，或者有些规则还没有更新到最新的废弃通知，例如以下内容：
- en: '[PRE100]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'In fact, this Dockerfile is following Docker 1.13 recommendations, which include
    to no more include a `maintainer` instruction. However, Hadolint is not yet up
    to date for this deprecation change, so execute the following to ignore one or
    more IDs, to still be cool:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这个 Dockerfile 遵循了 Docker 1.13 的推荐做法，其中包括不再包含 `maintainer` 指令。然而，Hadolint
    还没有更新以适应这一废弃的变化，因此执行以下命令以忽略一个或多个 ID，仍然可以保持正常：
- en: '[PRE101]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Dockerfile_lint
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Dockerfile_lint
- en: This project lead by the Project Atomic team ([http://www.projectatomic.io/](http://www.projectatomic.io/))
    is also proposing different checks and strong opinions on how a Dockerfile should
    be written. These propositions are very often good advice, though.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Project Atomic 团队（[http://www.projectatomic.io/](http://www.projectatomic.io/)）主导的这个项目也提出了不同的检查和关于如何编写
    Dockerfile 的强烈意见。这些建议通常都是很好的建议。
- en: 'Execute this to launch `dockerfile_lint` from the official Docker image:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令以从官方 Docker 镜像启动 `dockerfile_lint`：
- en: '[PRE102]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: A certain amount of suggestions will arise (errors, warnings, and info), each
    with a related reference URL to refer to.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 会出现一些建议（错误、警告和信息），每个建议都带有相关的参考 URL 供您参考。
- en: When in doubt, it's often a good move to follow the suggestions and fix the
    code accordingly.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 当有疑问时，通常跟随建议并相应地修复代码是一个不错的选择。
- en: 'At the end of this double linting process, our Dockerfile changed a lot, as
    shown here:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个双重 lint 检查过程结束时，我们的 Dockerfile 改动很大，如下所示：
- en: '[PRE103]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: We added labels to identify the image, versions, and maintainer, and we fixed
    a proper version of the apache2 package. So no bad surprise can happen with an
    untested update (updating the package will need a rebuild of the image), we're
    cleaning the apt cache more precisely, and we're explicitly exposing a port from
    the container.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了标签以识别镜像、版本和维护者，并且我们固定了 apache2 包的正确版本。这样就不会因为未经测试的更新出现意外（更新包需要重新构建镜像），我们更精确地清理了
    apt 缓存，并明确地从容器中暴露了一个端口。
- en: Overall, those changes proposed by the linters helped us a lot in building a
    much better and stronger container. Their role in CI is crucial; include the linters
    in your Jenkins, Circle, or Travis CI jobs!
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，linters 提出的这些更改帮助我们构建了一个更好、更强大的容器。它们在 CI 中的作用至关重要；在你的 Jenkins、Circle 或
    Travis CI 作业中加入 linters！
- en: Deploying a private Docker registry with S3 storage
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署一个带 S3 存储的私有 Docker 注册表
- en: The Docker registry is a central image distribution service. When we *pull*
    or *push* an image, it's from the Docker registry. It can be commercially hosted
    (CoreOS Quay [https://quay.io/](https://quay.io/) is an example, Docker's own
    [https://hub.docker.com/](https://hub.docker.com/) is another), or it can be self-hosted
    (for privacy, speed, bandwidth issues, or company policy). Docker Inc. made it
    simple for us to deploy it; it's extensively documented and packaged. Amongst
    the many deployable features, we'll start by simply deploying a single registry
    ready to be load-balanced, and then we'll switch its backend storage to AWS S3,
    so disk space will never be an issue again.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 注册表是一个中央镜像分发服务。当我们*拉取*或*推送*镜像时，它来自 Docker 注册表。它可以是商业托管的（例如 CoreOS Quay
    [https://quay.io/](https://quay.io/) 和 Docker 自己的 [https://hub.docker.com/](https://hub.docker.com/)），也可以是自托管的（出于隐私、速度、带宽问题或公司政策的考虑）。Docker
    公司让我们轻松部署它；它有详细的文档和打包好的版本。在众多可部署的功能中，我们首先简单地部署一个准备好负载均衡的单一注册表，然后将其后端存储切换为 AWS
    S3，这样磁盘空间再也不是问题。
- en: Getting ready
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To step through this recipe, you will need the following:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照这个配方进行操作，你将需要以下内容：
- en: A working Docker installation
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的 Docker 安装
- en: An AWS account with full S3 access
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有完全 S3 访问权限的 AWS 账户
- en: How to do it…
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: We'll use Docker Compose to work through this recipe. Our objective is to host
    our own private Docker registry, initially using local storage, then an S3 bucket
    for infinite space. The registry will be available on `http://localhost:5000`,
    but feel free to use any other resolvable name or a dedicated server with a locally
    available name.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Docker Compose 来完成这个配方。我们的目标是托管自己的私有 Docker 注册表，最初使用本地存储，然后使用 S3 桶来提供无限的空间。该注册表将通过
    `http://localhost:5000` 访问，但你也可以使用任何其他可解析的名称或具有本地可用名称的专用服务器。
- en: 'To begin with, we need the Docker registry v2 image: `registry:2`. We know
    from the documentation that port `5000` is exposed by the registry server, so
    we need to forward it to our host to use it locally. If we are running multiple
    registries behind a load balancer, it''s safe to share a common secret, let''s
    set it to `s3cr3t`.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要 Docker 注册表 v2 镜像：`registry:2`。根据文档，我们知道注册表服务器会暴露端口 `5000`，所以我们需要将其转发到主机以便本地使用。如果我们在负载均衡器后面运行多个注册表，分享一个通用密钥是安全的，我们将其设置为
    `s3cr3t`。
- en: 'This is what our initial `docker-compose.yml` file looks like:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们初始的 `docker-compose.yml` 文件：
- en: '[PRE104]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'With this simple setup, we already are able to run our own local Docker registry
    server:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个简单的设置，我们已经能够运行我们自己的本地 Docker 注册服务器：
- en: '[PRE105]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'To upload an image to our private registry, the process is to simply tag the
    image with the local registry URL and then push it. Execute the following to tag
    the `ubuntu:16.04` image with `localhost:5000/ubuntu`:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 要将镜像上传到我们的私有注册表，过程就是简单地用本地注册表 URL 标记镜像并推送。执行以下命令将 `ubuntu:16.04` 镜像标记为 `localhost:5000/ubuntu`：
- en: '[PRE106]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Then, to push the image to the local registry, execute this:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要将镜像推送到本地注册表，执行以下操作：
- en: '[PRE107]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: This Docker image is now stored locally and can be reused without accessing
    the public network nor the Docker Hub or similar services.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Docker 镜像现在已存储在本地，可以在不访问公共网络、Docker Hub 或类似服务的情况下重复使用。
- en: Using an S3 backend
  id: totrans-435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 S3 后端
- en: 'An issue with a highly used local Docker registry is disk space management—it''s
    finite. The good news is that the Docker Registry handles easily an S3 backend
    (or Swift if we have an internal OpenStack). For the record, Google Cloud and
    Azure storage are also supported. To enable the S3 backend, only a few variables
    need to be set in the `docker-compose.yml` file: the AWS region to contact, the
    keys, and the bucket name.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 高使用率的本地 Docker 注册表面临的一个问题是磁盘空间管理——它是有限的。好消息是，Docker 注册表可以轻松处理 S3 后端（如果我们有内部的
    OpenStack，也可以使用 Swift）。需要说明的是，Google Cloud 和 Azure 存储也得到支持。要启用 S3 后端，只需在 `docker-compose.yml`
    文件中设置少数几个变量：要联系的 AWS 区域、密钥和桶名称。
- en: '[PRE108]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Destroy (`docker-compose down`) the previous example if you tried it, and start
    this updated one:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试过之前的示例，请先销毁（`docker-compose down`）它，然后启动这个更新后的示例：
- en: '[PRE109]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Now tag again an image locally:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新在本地标记一个镜像：
- en: '[PRE110]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Then, push the image to the local registry:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将镜像推送到本地注册表：
- en: '[PRE111]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Depending on your uplink speed, it will take more or less time for the Registry
    to sync the layers we push with the AWS S3 backend.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的上传速度，注册表同步我们推送的层到 AWS S3 后端所需的时间长短会有所不同。
- en: We now have our own local registry with infinite storage!
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们拥有了自己的本地注册表，具备了无限存储空间！
- en: See also
  id: totrans-446
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'The Docker Registry documentation: [https://docs.docker.com/registry/configuration/](https://docs.docker.com/registry/configuration/)'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 注册表文档：[https://docs.docker.com/registry/configuration/](https://docs.docker.com/registry/configuration/)
