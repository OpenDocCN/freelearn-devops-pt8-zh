- en: Chapter 1. Puppet Language and Style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"Computer language design is just like a stroll in the park. Jurassic
    Park, that is."* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Larry Wall* |'
  prefs: []
  type: TYPE_TB
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a resource to a node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using **Facter** to describe a node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing a package before starting a service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing, configuring, and starting a service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using community **Puppet** style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a manifest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking your manifests with Puppet-lint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using standard naming conventions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using inline templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating over multiple items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing powerful conditional statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using regular expressions in if statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using selectors and case statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the in operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using regular expression substitutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the future parser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll start with the basics of Puppet syntax and show you how
    some of the syntactic sugar in Puppet is used. We'll then move on to how Puppet
    deals with dependencies and how to make Puppet do the work for you.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at how to organize and structure your code into modules following
    community conventions, so that other people will find it easy to read and maintain
    your code. I'll also show you some powerful features of Puppet language, which
    will let you write concise, yet expressive manifests.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a resource to a node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe will introduce the language and show you the basics of writing
    Puppet code. A beginner may wish to reference *Puppet 3: Beginner''s Guide*, *John
    Arundel*, *Packt Publishing* in addition to this section. Puppet code files are
    called manifests; manifests declare resources. A resource in Puppet may be a type,
    class, or node. A type is something like a file or package or anything that has
    a type declared in the language. The current list of standard types is available
    on puppetlabs website at [https://docs.puppetlabs.com/references/latest/type.html](https://docs.puppetlabs.com/references/latest/type.html).
    I find myself referencing this site very often. You may define your own types,
    either using a mechanism, similar to a subroutine, named **defined types**, or
    you can extend the language using a custom type. Types are the heart of the language;
    they describe the things that make up a node (node is the word Puppet uses for
    client computers/devices). Puppet uses resources to describe the state of a node;
    for example, we will declare the following package resource for a node using a
    site manifest (`site.pp`).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a `site.pp` file and place the following code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This manifest will ensure that any node, on which this manifest is applied,
    will install a package called `'httpd'`. The `default` keyword is a wildcard to
    Puppet; it applies anything within the node default definition to any node. When
    Puppet applies the manifest to a node, it uses a **Resource Abstraction Layer**
    (**RAL**) to translate the package type into the package management system of
    the target node. What this means is that we can use the same manifest to install
    the `httpd` package on any system for which Puppet has a **Provider** for the
    package type. Providers are the pieces of code that do the real work of applying
    a manifest. When the previous code is applied to a node running on a YUM-based
    distribution, the YUM provider will be used to install the `httpd` RPM packages.
    When the same code is applied to a node running on an **APT**-based distribution,
    the APT provider will be used to install the `httpd` DEB package (which may not
    exist, most debian-based systems call this package `apache2`; we'll deal with
    this sort of naming problem later).
  prefs: []
  type: TYPE_NORMAL
- en: Using Facter to describe a node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Facter is a separate utility upon which Puppet depends. It is the system used
    by Puppet to gather information about the target system (node); `facter` calls
    the nuggets of information facts. You may run `facter` from the command line to
    obtain real-time information from the system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use `facter` to find the current uptime of the system, the uptime fact:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compare this with the output of the Linux uptime command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When `facter` is installed (as a dependency for puppet), several fact definitions
    are installed by default. You can reference each of these facts by name from the
    command line.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Running `facter` without any arguments causes `facter` to print all the facts
    known about the system. We will see in later chapters that `facter` can be extended
    with your own custom facts. All facts are available for you to use as variables;
    variables are discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Variables in Puppet are marked with a dollar sign ($) character. When using
    variables within a manifest, it is preferred to enclose the variable within braces
    `"${myvariable}"` instead of `"$myvariable"`. All of the facts from `facter` can
    be referenced as top scope variables (we will discuss scope in the next section).
    For example, the **fully qualified domain name** (**FQDN**) of the node may be
    referenced by `"${::fqdn}"`. Variables can only contain alphabetic characters,
    numerals, and the underscore character (`_`). As a matter of style, variables
    should start with an alphabetic character. Never use dashes in variable names.
  prefs: []
  type: TYPE_NORMAL
- en: Scope
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the variable example explained in the *There's more…* section, the fully
    qualified domain name was referred to as `${::fqdn}` rather than `${fqdn}`; the
    double colons are how Puppet differentiates scope. The highest level scope, top
    scope or global, is referred to by two colons (`::`) at the beginning of a variable
    identifier. To reduce namespace collisions, always use fully scoped variable identifiers
    in your manifests. For a Unix user, think of top scope variables as the `/` (root)
    level. You can refer to variables using the double colon syntax similar to how
    you would refer to a directory by its full path. For the developer, you can think
    of top scope variables as global variables; however, unlike global variables,
    you must always refer to them with the double colon notation to guarantee that
    a local variable isn't obscuring the top scope variable.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a package before starting a service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To show how ordering works, we'll create a manifest that installs `httpd` and
    then ensures the `httpd` package service is running.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start by creating a manifest that defines the service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The service definition references a package resource named `httpd`; we now
    need to define that resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, the package will be installed before the service is started.
    Using `require` within the definition of the `httpd` service ensures that the
    package is installed first, regardless of the order within the manifest file.
  prefs: []
  type: TYPE_NORMAL
- en: Capitalization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Capitalization is important in Puppet. In our previous example, we created
    a package named `httpd`. If we wanted to refer to this package later, we would
    capitalize its type (`package`) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To refer to a class, for example, the `something::somewhere` class, which has
    already been included/defined in your manifest, you can reference it with the
    full path as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When you have a defined type, for example the following defined type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding resource may be referenced later as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Knowing how to reference previously defined resources is necessary for the next
    section on metaparameters and ordering.
  prefs: []
  type: TYPE_NORMAL
- en: Learning metaparameters and ordering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the manifests that will be used to define a node are compiled into a catalog.
    A catalog is the code that will be applied to configure a node. It is important
    to remember that manifests are not applied to nodes sequentially. There is no
    inherent order to the application of manifests. With this in mind, in the previous
    `httpd` example, what if we wanted to ensure that the `httpd` process started
    after the `httpd` package was installed?
  prefs: []
  type: TYPE_NORMAL
- en: 'We couldn''t rely on the `httpd` service coming after the `httpd` package in
    the manifests. What we have to do is use metaparameters to tell Puppet the order
    in which we want resources applied to the node. Metaparameters are parameters
    that can be applied to any resource and are not specific to any one resource type.
    They are used for catalog compilation and as hints to Puppet but not to define
    anything about the resource to which they are attached. When dealing with ordering,
    there are four metaparameters used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`before`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`require`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notify`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscribe`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `before` and `require` metaparameters specify a direct ordering; `notify`
    implies `before` and `subscribe` implies `require`. The `notify` metaparameter
    is only applicable to services; what notify does is tell a service to restart
    after the notifying resource has been applied to the node (this is most often
    a package or file resource). In the case of files, once the file is created on
    the node, a notify parameter will restart any services mentioned. The `subscribe`
    metaparameter has the same effect but is defined on the service; the service will
    subscribe to the file.
  prefs: []
  type: TYPE_NORMAL
- en: Trifecta
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The relationship between package and service previously mentioned is an important
    and powerful paradigm of Puppet. Adding one more resource-type file into the fold,
    creates what puppeteers refer to as the **trifecta**. Almost all system administration
    tasks revolve around these three resource types. As a system administrator, you
    install a package, configure the package with files, and then start the service.
  prefs: []
  type: TYPE_NORMAL
- en: '![Trifecta](img/B03643_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Diagram of Trifecta (Files require package for directory, service requires files
    and package)
  prefs: []
  type: TYPE_NORMAL
- en: Idempotency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A key concept of Puppet is that the state of the system when a catalog is applied
    to a node cannot affect the outcome of Puppet run. In other words, at the end
    of Puppet run (if the run was successful), the system will be in a known state
    and any further application of the catalog will result in a system that is in
    the same state. This property of Puppet is known as idempotency. **Idempotency**
    is the property that no matter how many times you do something, it remains in
    the same state as the first time you did it. For instance, if you had a light
    switch and you gave the instruction to turn it on, the light would turn on. If
    you gave the instruction again, the light would remain on.
  prefs: []
  type: TYPE_NORMAL
- en: Installing, configuring, and starting a service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many examples of this pattern online. In our simple example, we will
    create an Apache configuration file under `/etc/httpd/conf.d/cookbook.conf`. The
    `/etc/httpd/conf.d` directory will not exist until the `httpd` package is installed.
    After this file is created, we would want `httpd` to restart to notice the change;
    we can achieve this with a notify parameter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will need the same definitions as our last example; we need the package
    and service installed. We now need two more things. We need the configuration
    file and index page (`index.html`) created. For this, we follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As in the previous example, we ensure the service is running and specify that
    the service requires the `httpd` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then define the package as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we create the `/etc/httpd/conf.d/cookbook.conf` configuration file; the
    `/etc/httpd/conf.d` directory will not exist until the `httpd` package is installed.
    The `require` metaparameter tells Puppet that this file requires the `httpd` package
    to be installed before it is created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then go on to create an `index.html` file for our virtual host in `/var/www/cookbook`.
    This directory won''t exist yet, so we need to create this as well, using the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `require` attribute to the file resources tell Puppet that we need the `/var/www/cookbook`
    directory created before we can create the `index.html` file. The important concept
    to remember is that we cannot assume anything about the target system (node).
    We need to define everything on which the target depends. Anytime you create a
    file in a manifest, you have to ensure that the directory containing that file
    exists. Anytime you specify that a service should be running, you have to ensure
    that the package providing that service is installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, using metaparameters, we can be confident that no matter what
    state the node is in before running Puppet, after Puppet runs, the following will
    be true:'
  prefs: []
  type: TYPE_NORMAL
- en: '`httpd` will be running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `VirtualHost` configuration file will exist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`httpd` will restart and be aware of the `VirtualHost` file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `DocumentRoot` directory will exist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `index.html` file will exist in the `DocumentRoot` directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using community Puppet style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If other people need to read or maintain your manifests, or if you want to share
    code with the community, it's a good idea to follow the existing style conventions
    as closely as possible. These govern such aspects of your code as layout, spacing,
    quoting, alignment, and variable references, and the official puppetlabs recommendations
    on style are available at [http://docs.puppetlabs.com/guides/style_guide.html](http://docs.puppetlabs.com/guides/style_guide.html).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, I'll show you a few of the more important examples and how
    to make sure that your code is style compliant.
  prefs: []
  type: TYPE_NORMAL
- en: Indentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Indent your manifests using two spaces (not tabs), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Quoting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Always quote your resource names, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We cannot do this as follows though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Use single quotes for all strings, except when:'
  prefs: []
  type: TYPE_NORMAL
- en: The string contains variable references such as `"${::fqdn}"`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The string contains character escape sequences such as `"\n"`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Puppet doesn't process variable references or escape sequences unless they're
    inside double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Always quote parameter values that are not reserved words in Puppet. For example,
    the following values are not reserved words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'However, these values are reserved words and therefore not quoted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'False'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is only one thing in Puppet that is false, that is, the word `false`
    without any quotes. The string `"false"` evaluates to `true` and the string `"true"`
    also evaluates to true. Actually, everything besides the literal false evaluates
    to true (when treated as a Boolean):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When this code is run through `puppet apply`, the first two notifies are triggered.
    The final notify is not triggered; it is the only one that evaluates to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Always include curly braces (`{}`) around variable names when referring to
    them in strings, for example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, Puppet's parser has to guess which characters should be a part of
    the variable name and which belong to the surrounding string. Curly braces make
    it explicit.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Always end lines that declare parameters with a comma, even if it is the last
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is allowed by Puppet, and makes it easier if you want to add parameters
    later, or reorder the existing parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'When declaring a resource with a single parameter, make the declaration all
    on one line and with no trailing comma, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Where there is more than one parameter, give each parameter its own line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the code easier to read, line up the parameter arrows in line with
    the longest parameter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The arrows should be aligned per resource, but not across the whole file, otherwise
    it can make it difficult for you to cut and paste code from one file to another.
  prefs: []
  type: TYPE_NORMAL
- en: Symlinks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When declaring file resources which are symlinks, use `ensure => link` and
    set the target attribute, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Creating a manifest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you already have some Puppet code (known as a Puppet manifest), you can skip
    this section and go on to the next. If not, we'll see how to create and apply
    a simple manifest.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create and apply a simple manifest, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install Puppet locally on your machine or create a virtual machine and
    install Puppet on that machine. For YUM-based systems, use [https://yum.puppetlabs.com/](https://yum.puppetlabs.com/)
    and for APT-based systems, use [https://apt.puppetlabs.com/](https://apt.puppetlabs.com/).
    You may also use gem to install Puppet. For our examples, we''ll install Puppet
    using gem on a Debian Wheezy system (hostname: `cookbook`). To use gem, we need
    the `rubygems` package as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, use `gem` to install Puppet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Three gems are installed. Now, with Puppet installed, we can create a directory
    to contain our Puppet code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within your `manifests` directory, create the `site.pp` file with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test your manifest with the `puppet apply` command. This will tell Puppet to
    read the manifest, compare it to the state of the machine, and make any necessary
    changes to that state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To see if Puppet did what we expected (create the `/tmp/hello` file with the
    `Hello, world`! content), run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that creating the file in `/tmp` did not require special permissions. We
    did not run Puppet via `sudo`. Puppet need not be run through `sudo`; there are
    cases where running via an unprivileged user can be useful.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When several people are working on a code base, it''s easy for style inconsistencies
    to creep in. Fortunately, there''s a tool available which can automatically check
    your code for compliance with the style guide: `puppet-lint`. We''ll see how to
    use this in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Checking your manifests with Puppet-lint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The puppetlabs official style guide outlines a number of style conventions
    for Puppet code, some of which we''ve touched on in the preceding section. For
    example, according to the style guide, manifests:'
  prefs: []
  type: TYPE_NORMAL
- en: Must use two-space soft tabs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must not use literal tab characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must not contain trailing white space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should not exceed an 80 character line width
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should align parameter arrows (`=>`) within blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following the style guide will make sure that your Puppet code is easy to read
    and maintain, and if you're planning to release your code to the public, style
    compliance is essential.
  prefs: []
  type: TYPE_NORMAL
- en: The `puppet-lint` tool will automatically check your code against the style
    guide. The next section explains how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s what you need to do to install Puppet-lint:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll install Puppet-lint using the gem provider because the gem version is
    much more up to date than the APT or RPM packages available. Create a `puppet-lint.pp`
    manifest as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run `puppet apply` on the `puppet-lint.pp` manifest, as shown in the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to use Puppet-lint:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose a Puppet manifest file that you want to check with Puppet-lint, and
    run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, Puppet-lint found a number of problems with the manifest file.
    Correct the errors, save the file, and rerun Puppet-lint to check that all is
    well. If successful, you''ll see no output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can find out more about Puppet-lint at [https://github.com/rodjek/puppet-lint](https://github.com/rodjek/puppet-lint).
  prefs: []
  type: TYPE_NORMAL
- en: 'Should you follow Puppet style guide and, by extension, keep your code lint-clean?
    It''s up to you, but here are a couple of things to think about:'
  prefs: []
  type: TYPE_NORMAL
- en: It makes sense to use some style conventions, especially when you're working
    collaboratively on code. Unless you and your colleagues can agree on standards
    for whitespace, tabs, quoting, alignment, and so on, your code will be messy and
    difficult to read or maintain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're choosing a set of style conventions to follow, the logical choice
    would be that issued by puppetlabs and adopted by the community for use in public
    modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Having said that, it''s possible to tell Puppet-lint to ignore certain checks
    if you''ve chosen not to adopt them in your codebase. For example, if you don''t
    want Puppet-lint to warn you about code lines exceeding 80 characters, you can
    run Puppet-lint with the following option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Run `puppet-lint --help` to see the complete list of check configuration commands.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Automatic syntax checking with Git hooks* recipe in [Chapter 2](ch02.html
    "Chapter 2. Puppet Infrastructure"), *Puppet Infrastructure*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Testing your Puppet manifests with rspec-puppet* recipe in [Chapter 9](ch09.html
    "Chapter 9. External Tools and the Puppet Ecosystem"), *External Tools and the
    Puppet Ecosystem*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important things you can do to make your Puppet manifests clearer
    and more maintainable is to organize them into modules.
  prefs: []
  type: TYPE_NORMAL
- en: Modules are self-contained bundles of Puppet code that include all the files
    necessary to implement a thing. Modules may contain flat files, templates, Puppet
    manifests, custom fact declarations, augeas lenses, and custom Puppet types and
    providers.
  prefs: []
  type: TYPE_NORMAL
- en: Separating things into modules makes it easier to reuse and share code; it's
    also the most logical way to organize your manifests. In this example, we'll create
    a module to manage memcached, a memory caching system commonly used with web applications.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following are the steps to create an example module:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use Puppet''s module subcommand to create the directory structure for
    our new module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command creates the module directory and creates some empty files as starting
    points. To use the module, we'll create a symlink to the module name (memcached).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, edit `memcached/manifests/init.pp` and change the class definition at
    the end of the file to the following. Note that `puppet module generate` created
    many lines of comments; in a production module you would want to edit those default
    comments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `modules/thomas-memcached/files` directory and then create a file
    named `memcached.conf` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change your `site.pp` file to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We would like this module to install memcached. We''ll need to run Puppet with
    root privileges, and we''ll use sudo for that. We''ll need Puppet to be able to
    find the module in our home directory; we can specify this on the command line
    when we run Puppet as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether the new service is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we created the module using Puppet's module generate command, we used the
    name `thomas-memcached`. The name before the hyphen is your username or your username
    on Puppet forge (an online repository of modules). Since we want Puppet to be
    able to find the module by the name `memcached`, we make a symbolic link between
    `thomas-memcached` and `memcached`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modules have a specific directory structure. Not all of these directories need
    to be present, but if they are, this is how they should be organized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: All manifest files (those containing Puppet code) live in the manifests directory.
    In our example, the `memcached` class is defined in the `manifests/init.pp` file,
    which will be imported automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `memcached` class, we refer to the `memcached.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `source` parameter tells Puppet to look for the file in:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MODULEPATH/ (/home/thomas/.puppet/modules)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`└memcached/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`└files/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`└memcached.conf`'
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Learn to love modules because they'll make your Puppet life a lot easier. They're
    not complicated, however, practice and experience will help you judge when things
    should be grouped into modules, and how best to arrange your module structure.
    Modules can hold more than manifests and files as we'll see in the next two sections.
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you need to use a template as a part of the module, place it in the module''s
    templates directory and refer to it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Puppet will look for the file in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Facts, functions, types, and providers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modules can also contain custom facts, custom functions, custom types, and providers.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about these, refer to [Chapter 9](ch09.html "Chapter 9. External
    Tools and the Puppet Ecosystem"), *External Tools and the Puppet Ecosystem*.
  prefs: []
  type: TYPE_NORMAL
- en: Third-party modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can download modules provided by other people and use them in your own manifests
    just like the modules you create. For more on this, see Using Public Modules recipe
    in [Chapter 7](ch07.html "Chapter 7. Managing Applications"), *Managing Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: Module organization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more details on how to organize your modules, see puppetlabs website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.puppetlabs.com/puppet/3/reference/modules_fundamentals.html](http://docs.puppetlabs.com/puppet/3/reference/modules_fundamentals.html)'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating custom facts* recipe in [Chapter 9](ch09.html "Chapter 9. External
    Tools and the Puppet Ecosystem"), *External Tools and the Puppet Ecosystem*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using public modules* recipe in [Chapter 7](ch07.html "Chapter 7. Managing
    Applications"), *Managing Applications*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating your own resource types* recipe in [Chapter 9](ch09.html "Chapter 9. External
    Tools and the Puppet Ecosystem"), *External Tools and the Puppet Ecosystem*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating your own providers* recipe in [Chapter 9](ch09.html "Chapter 9. External
    Tools and the Puppet Ecosystem"), *External Tools and the Puppet Ecosystem*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using standard naming conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Choosing appropriate and informative names for your modules and classes will
    be a big help when it comes to maintaining your code. This is even truer if other
    people need to read and work on your manifests.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some tips on how to name things in your manifests:'
  prefs: []
  type: TYPE_NORMAL
- en: Name modules after the software or service they manage, for example, `apache`
    or `haproxy`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name classes within modules (subclasses) after the function or service they
    provide to the module, for example, `apache::vhosts` or `rails::dependencies`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a class within a module disables the service provided by that module, name
    it `disabled`. For example, a class that disables Apache should be named `apache::disabled`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a roles and profiles hierarchy of modules. Each node should have a single
    role consisting of one or more profiles. Each profile module should configure
    a single service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The module that manages users should be named `user`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the user module, declare your virtual users within the class `user::virtual`
    (for more on virtual users and other resources, see the *Using virtual resources*
    recipe in [Chapter 5](ch05.html "Chapter 5. Users and Virtual Resources"), *Users
    and Virtual Resources*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the user module, subclasses for particular groups of users should be
    named after the group, for example, `user::sysadmins` or `user::contractors`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When using Puppet to deploy the config files for different services, name the
    file after the service, but with a suffix indicating what kind of file it is,
    for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Apache init script: `apache.init`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Logrotate config snippet for Rails: `rails.logrotate`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nginx vhost file for mywizzoapp: `mywizzoapp.vhost.nginx`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MySQL config for standalone server: `standalone.mysql`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you need to deploy a different version of a file depending on the operating
    system release, for example, you can use a naming convention like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can have Puppet automatically select the appropriate version as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you need to manage, for example, different Ruby versions, name the class
    after the version it is responsible for, for example, `ruby192` or `ruby186`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Puppet community maintains a set of best practice guidelines for your Puppet
    infrastructure, which includes some hints on naming conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.puppetlabs.com/guides/best_practices.html](http://docs.puppetlabs.com/guides/best_practices.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some people prefer to include multiple classes on a node by using a comma-separated
    list, rather than separate `include` statements, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This is a matter of style, but I prefer to use separate `include` statements,
    one on a line, because it makes it easier to copy and move around class inclusions
    between nodes without having to tidy up the commas and indentation every time.
  prefs: []
  type: TYPE_NORMAL
- en: I mentioned inheritance in a couple of the preceding examples; if you're not
    sure what this is, don't worry, I'll explain this in detail in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using inline templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Templates are a powerful way of using **Embedded Ruby** (**ERB**) to help build
    config files dynamically. You can also use ERB syntax directly without having
    to use a separate file by calling the `inline_template` function. ERB allows you
    to use conditional logic, iterate over arrays, and include variables.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s an example of how to use `inline_template`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pass your Ruby code to `inline_template` within Puppet manifest, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Anything inside the string passed to `inline_template` is executed as if it
    were an ERB template. That is, anything inside the `<%=` and `%>` delimiters will
    be executed as Ruby code, and the rest will be treated as a string.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we use `inline_template` to compute a different hour for this
    cron resource (a scheduled job) for each machine, so that the same job does not
    run at the same time on all machines. For more on this technique, see the *Distributing
    cron jobs efficiently* recipe in [Chapter 6](ch06.html "Chapter 6. Managing Resources
    and Files"), *Managing Resources and Files*.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In ERB code, whether inside a template file or an `inline_template` string,
    you can access your Puppet variables directly by name using an `@` prefix, if
    they are in the current scope or the top scope (facts):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To reference variables in another scope, use `scope.lookupvar`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: You should use inline templates sparingly. If you really need to use some complicated
    logic in your manifest, consider using a custom function instead (see the *Creating
    custom functions* recipe in [Chapter 9](ch09.html "Chapter 9. External Tools and
    the Puppet Ecosystem"), *External Tools and the Puppet Ecosystem*).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using ERB templates* recipe in [Chapter 4](ch04.html "Chapter 4. Working
    with Files and Packages"), *Working with Files and Packages*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using array iteration in templates* recipe in [Chapter 4](ch04.html "Chapter 4. Working
    with Files and Packages"), *Working with Files and Packages*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating over multiple items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Arrays are a powerful feature in Puppet; wherever you want to perform the same
    operation on a list of things, an array may be able to help. You can create an
    array just by putting its content in square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s a common example of how arrays are used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your manifest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run Puppet and note that each package should now be installed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Where Puppet encounters an array as the name of a resource, it creates a resource
    for each element in the array. In the example, a new package resource is created
    for each of the packages in the `$packages` array, with the same parameters (`ensure
    => installed`). This is a very compact way to instantiate many similar resources.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although arrays will take you a long way with Puppet, it''s also useful to
    know about an even more flexible data structure: the hash.'
  prefs: []
  type: TYPE_NORMAL
- en: Using hashes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A hash is like an array, but each of the elements can be stored and looked
    up by name (referred to as the key), for example (`hash.pp`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run Puppet on this, we see the following notify in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Hash values can be anything that you can assign to variables, strings, function
    calls, expressions, and even other hashes or arrays. Hashes are useful to store
    a bunch of information about a particular thing because by accessing each element
    of the hash using a key, we can quickly find the information for which we are
    looking.
  prefs: []
  type: TYPE_NORMAL
- en: Creating arrays with the split function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can declare literal arrays using square brackets, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run Puppet on the preceding code, we see the following notice
    messages in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'However, Puppet can also create arrays for you from strings, using the `split`
    function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `puppet apply` against this new manifest, we see the same messages
    in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `split` takes two arguments: the first argument is the string to
    be split. The second argument is the character to split on; in this example, a
    single space. As Puppet works its way through the string, when it encounters a
    space, it will interpret it as the end of one item and the beginning of the next.
    So, given the string ''`egg beans chips''`, this will be split into three items.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The character to split on can be any character or string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The character can also be a regular expression, for example, a set of alternatives
    separated by a `|` (pipe) character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Writing powerful conditional statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Puppet's `if` statement allows you to change the manifest behavior based on
    the value of a variable or an expression. With it, you can apply different resources
    or parameter values depending on certain facts about the node, for example, the
    operating system, or the memory size.
  prefs: []
  type: TYPE_NORMAL
- en: You can also set variables within the manifest, which can change the behavior
    of included classes. For example, nodes in data center A might need to use different
    DNS servers than nodes in data center B, or you might need to include one set
    of classes for an Ubuntu system, and a different set for other systems.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s an example of a useful conditional statement. Add the following code
    to your manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Puppet treats whatever follows an `if` keyword as an expression and evaluates
    it. If the expression evaluates to true, Puppet will execute the code within the
    curly braces.
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, you can add an else branch, which will be executed if the expression
    evaluates to false.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are some more tips on using `if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Elseif branches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can add further tests using the `elseif` keyword, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Comparisons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can check whether two values are equal using the `==` syntax, as in our
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can check whether they are not equal using `!=`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also compare numeric values using `<` and `>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'To test whether a value is greater (or less) than or equal to another value,
    use `<=` or `>=`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Combining expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can put together the kind of simple expressions described previously into
    more complex logical expressions, using `and`, `or`, and `not`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using the in operator* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using selectors and case statements* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using regular expressions in if statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another kind of expression you can test in `if` statements and other conditionals
    is the regular expression. A regular expression is a powerful way to compare strings
    using pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is one example of using a regular expression in a conditional statement.
    Add the following to your manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Puppet treats the text supplied between the forward slashes as a regular expression,
    specifying the text to be matched. If the match succeeds, the `if` expression
    will be true and so the code between the first set of curly braces will be executed.
    In this example, we used a regular expression because different distributions
    have different ideas on what to call `64bit`; some use `amd64`, while others use
    `x86_64`. The only thing we can count on is the presence of the number 64 within
    the fact. Some facts that have version numbers in them are treated as strings
    to Puppet. For instance, `$::facterversion`. On my test system, this is `2.0.1`,
    but when I try to compare that with `2`, Puppet fails to make the comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wanted instead to do something if the text does not match, use `!~`
    rather than `=~`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regular expressions are very powerful, but can be difficult to understand and
    debug. If you find yourself using a regular expression so complex that you can't
    see at a glance what it does, think about simplifying your design to make it easier.
    However, one particularly useful feature of regular expressions is the ability
    to capture patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can not only match text using a regular expression, but also capture the
    matched text and store it in a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code produces this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**You said ''Puppet is better than manual configuration''. Looks like you''re
    comparing Puppet to manual configuration!**'
  prefs: []
  type: TYPE_NORMAL
- en: The variable `$0` stores the whole matched text (assuming the overall match
    succeeded). If you put brackets around any part of the regular expression, it
    creates a group, and any matched groups will also be stored in variables. The
    first matched group will be `$1`, the second `$2`, and so on, as shown in the
    preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expression syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Puppet''s regular expression syntax is the same as Ruby''s, so resources that
    explain Ruby''s regular expression syntax will also help you with Puppet. You
    can find a good introduction to Ruby''s regular expression syntax at this website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.tutorialspoint.com/ruby/ruby_regular_expressions.htm](http://www.tutorialspoint.com/ruby/ruby_regular_expressions.htm).'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Using regular expression substitutions* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using selectors and case statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although you could write any conditional statement using `if`, Puppet provides
    a couple of extra forms to help you express conditionals more easily: the selector
    and the `case` statement.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some examples of selector and `case` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your manifest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to your manifest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our example demonstrates both the selector and the `case` statement, so let's
    see in detail how each of them works.
  prefs: []
  type: TYPE_NORMAL
- en: Selector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the first example, we used a selector (the `?` operator) to choose a value
    for the `$systemtype` variable depending on the value of `$::operatingsystem`.
    This is similar to the ternary operator in C or Ruby, but instead of choosing
    between two possible values, you can have as many values as you like.
  prefs: []
  type: TYPE_NORMAL
- en: Puppet will compare the value of `$::operatingsystem` to each of the possible
    values we have supplied in Ubuntu, Debian, and so on. These values could be regular
    expressions (for example, for a partial string match, or to use wildcards), but
    in our case, we have just used literal strings.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as it finds a match, the selector expression returns whatever value
    is associated with the matching string. If the value of `$::operatingsystem` is
    Fedora, for example, the selector expression will return the `redhatlike` string
    and this will be assigned to the variable `$systemtype`.
  prefs: []
  type: TYPE_NORMAL
- en: Case statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike selectors, the `case` statement does not return a value. `case` statements
    come in handy when you want to execute different code depending on the value of
    some expression. In our second example, we used the `case` statement to include
    either the `debianlike` or `redhatlike` class, depending on the value of `$::operatingsystem`.
  prefs: []
  type: TYPE_NORMAL
- en: Again, Puppet compares the value of `$::operatingsystem` to a list of potential
    matches. These could be regular expressions or strings, or as in our example,
    comma-separated lists of strings. When it finds a match, the associated code between
    curly braces is executed. So, if the value of `$::operatingsystem` is `Ubuntu`,
    then the code including `debianlike` will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you've got a grip of the basic use of selectors and `case` statements,
    you may find the following tips useful.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As with `if` statements, you can use regular expressions with selectors and
    `case` statements, and you can also capture the values of the matched groups and
    refer to them using `$1`, `$2`, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Defaults
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Both selectors and `case` statements let you specify a default value, which
    is chosen if none of the other options match (the style guide suggests you always
    have a default clause defined):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: When the default action shouldn't normally occur, use the `fail()` function
    to halt the Puppet run.
  prefs: []
  type: TYPE_NORMAL
- en: Using the in operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `in` operator tests whether one string contains another string. Here''s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding expression is true if the `spring` string is a substring of `springfield`,
    which it is. The `in` operator can also test for membership of arrays as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'When `in` is used with a hash, it tests whether the string is a key of the
    hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps will show you how to use the `in` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your manifest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run Puppet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The value of an `in` expression is Boolean (true or false) so you can assign
    it to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Using regular expression substitutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Puppet's `regsubst` function provides an easy way to manipulate text, search
    and replace expressions within strings, or extract patterns from strings. We often
    need to do this with data obtained from a fact, for example, or from external
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we'll see how to use `regsubst` to extract the first three
    octets of an IPv4 address (the network part, assuming it's a `/24` class C address).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to build the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your manifest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run Puppet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `regsubst` function takes at least three parameters: source, pattern, and
    replacement. In our example, we specified the source string as `$::ipaddress`,
    which, on this machine, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'We specify the `pattern` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'We specify the `replacement` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The pattern captures all of the string up to the last period (`\.`) in the
    `\1` variable. We then match on `.*`, which matches everything to the end of the
    string, so when we replace the string at the end with `\1.0`, we end up with only
    the network portion of the IP address, which evaluates to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'We could have got the same result in other ways, of course, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Here, we only match the last octet and replace it with `.0`, which achieves
    the same result without capturing.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `pattern` function can be any regular expression, using the same (Ruby)
    syntax as regular expressions in `if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Importing dynamic information* recipe in [Chapter 3](ch03.html "Chapter 3. Writing
    Better Manifests"), *Writing Better Manifests*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Getting information about the environment* recipe in [Chapter 3](ch03.html
    "Chapter 3. Writing Better Manifests"), *Writing Better Manifests*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using regular expressions in if statements* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the future parser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Puppet language is evolving at the moment; many features that are expected to
    be included in the next major release (4) are available if you enable the future
    parser.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ensure that the `rgen` gem is installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `parser = future` in the `[main]` section of your `puppet.conf`(`/etc/puppet/puppet.conf`
    for open source Puppet as `root,/etc/puppetlabs/puppet/puppet.conf` for Puppet
    `Enterprise, and~/.puppet/puppet.conf` for a non-root user running puppet).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To temporarily test with the future parser, use `--parser=future` on the command
    line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many of the experimental features deal with how code is evaluated, for example,
    in an earlier example we compared the value of the `$::facterversion` fact with
    a number, but the value is treated as a string so the code fails to compile. Using
    the future parser, the value is converted and no error is reported as shown in
    the following command line output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Appending to and concatenating arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can concatenate arrays with the `+` operator or append them with the `<<`
    operator. In the following example, we use the ternary operator to assign a specific
    package name to the `$apache` variable. We then append that value to an array
    using the `<<` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have two arrays, we can use the `+` operator to concatenate the two arrays.
    In this example, we define an array of system administrators (`$sysadmins`) and
    another array of application owners (`$appowners`). We can then concatenate the
    array and use it as an argument to our allowed users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'When we apply this manifest, we see that the two arrays have been joined as
    shown in the following command line output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have two hashes, we can merge them using the same `+` operator we used
    for arrays. Consider our `$interfaces` hash from a previous example; we can add
    another interface to the hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'When we apply this manifest, we see that the route attribute has been merged
    into the hash (your results may differ, the order in which the hash prints is
    unpredictable), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Lambda functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lambda functions are iterators applied to arrays or hashes. You iterate through
    the array or hash and apply an iterator function such as `each`, `map`, `filter`,
    `reduce`, or `slice` to each element of the array or key of the hash. Some of
    the lambda functions return a calculated array or value; others such as `each`
    only return the input array or hash.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda functions such as `map` and `reduce` use temporary variables that are
    thrown away after the lambda has finished. Use of lambda functions is something
    best shown by example. In the next few sections, we will show an example usage
    of each of the lambda functions.
  prefs: []
  type: TYPE_NORMAL
- en: Reduce
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Reduce is used to reduce the array to a single value. This can be used to calculate
    the maximum or minimum of the array, or in this case, the sum of the elements
    of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'This preceding code will compute the sum of the `$count` array and store it
    in the `$sum` variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Filter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Filter is used to filter the array or hash based upon a test within the lambda
    function. For instance to filter our `$count` array as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'When we apply this manifest, we see that only elements 4 and 5 are in the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Map
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Map is used to apply a function to each element of the array. For instance,
    if we wanted (for some unknown reason) to compute the square of all the elements
    of the array, we would use `map` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of applying this manifest is a new array with every element of the
    original array squared (multiplied by itself), as shown in the following command
    line output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Slice
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Slice is useful when you have related values stored in the same array in a
    sequential order. For instance, if we had the destination and port information
    for a firewall in an array, we could split them up into pairs and perform operations
    on those pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'When applied, this manifest will produce the following notices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'To make this a useful example, create a new firewall resource within the block
    of the slice instead of notice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Each
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Each is used to iterate over the elements of the array but lacks the ability
    to capture the results like the other functions. Each is the simplest case where
    you simply wish to do something with each element of the array, as shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, this executes the `notice` for each element of the `$count` array,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Other features
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are other new features of Puppet language available when using the future
    parser. Some increase readability or compactness of code. For more information,
    refer to the documentation on puppetlabs website at [http://docs.puppetlabs.com/puppet/latest/reference/experiments_future.html](http://docs.puppetlabs.com/puppet/latest/reference/experiments_future.html).
  prefs: []
  type: TYPE_NORMAL
