- en: Chapter 1. Puppet Language and Style
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 Puppet 语言与风格
- en: '|   | *"Computer language design is just like a stroll in the park. Jurassic
    Park, that is."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"计算机语言设计就像在公园里散步，只不过是侏罗纪公园。"* |   |'
- en: '|   | --*Larry Wall* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*Larry Wall* |'
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Adding a resource to a node
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向节点添加资源
- en: Using **Facter** to describe a node
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **Facter** 描述节点
- en: Installing a package before starting a service
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在启动服务之前安装包
- en: Installing, configuring, and starting a service
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装、配置并启动服务
- en: Using community **Puppet** style
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用社区 **Puppet** 风格
- en: Creating a manifest
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建清单
- en: Checking your manifests with Puppet-lint
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Puppet-lint 检查你的清单
- en: Using modules
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块
- en: Using standard naming conventions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准命名约定
- en: Using inline templates
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内联模板
- en: Iterating over multiple items
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历多个项
- en: Writing powerful conditional statements
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写强大的条件语句
- en: Using regular expressions in if statements
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 if 语句中使用正则表达式
- en: Using selectors and case statements
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用选择器和案例语句
- en: Using the in operator
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `in` 操作符
- en: Using regular expression substitutions
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式替换
- en: Using the future parser
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用未来解析器
- en: Introduction
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we'll start with the basics of Puppet syntax and show you how
    some of the syntactic sugar in Puppet is used. We'll then move on to how Puppet
    deals with dependencies and how to make Puppet do the work for you.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从 Puppet 语法的基础开始，展示如何使用 Puppet 中的一些语法糖。接着我们将介绍 Puppet 如何处理依赖关系，以及如何让
    Puppet 为你完成工作。
- en: We'll look at how to organize and structure your code into modules following
    community conventions, so that other people will find it easy to read and maintain
    your code. I'll also show you some powerful features of Puppet language, which
    will let you write concise, yet expressive manifests.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何按照社区约定组织和结构化你的代码，将其分成模块，以便其他人能轻松阅读和维护你的代码。我还会展示一些 Puppet 语言的强大功能，这些功能可以让你编写简洁而富有表现力的清单。
- en: Adding a resource to a node
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向节点添加资源
- en: 'This recipe will introduce the language and show you the basics of writing
    Puppet code. A beginner may wish to reference *Puppet 3: Beginner''s Guide*, *John
    Arundel*, *Packt Publishing* in addition to this section. Puppet code files are
    called manifests; manifests declare resources. A resource in Puppet may be a type,
    class, or node. A type is something like a file or package or anything that has
    a type declared in the language. The current list of standard types is available
    on puppetlabs website at [https://docs.puppetlabs.com/references/latest/type.html](https://docs.puppetlabs.com/references/latest/type.html).
    I find myself referencing this site very often. You may define your own types,
    either using a mechanism, similar to a subroutine, named **defined types**, or
    you can extend the language using a custom type. Types are the heart of the language;
    they describe the things that make up a node (node is the word Puppet uses for
    client computers/devices). Puppet uses resources to describe the state of a node;
    for example, we will declare the following package resource for a node using a
    site manifest (`site.pp`).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '本配方将介绍语言并展示如何编写 Puppet 代码的基础。初学者可能希望参考 *Puppet 3: 初学者指南*、*John Arundel*、*Packt
    Publishing*，以补充本节内容。Puppet 代码文件被称为清单；清单声明资源。Puppet 中的资源可以是类型、类或节点。类型类似于文件、包或任何在语言中声明过类型的事物。标准类型的当前列表可以在
    Puppet Labs 网站上找到，地址是 [https://docs.puppetlabs.com/references/latest/type.html](https://docs.puppetlabs.com/references/latest/type.html)。我发现自己经常参考这个网站。你可以定义自己的类型，使用类似于子程序的机制，称为
    **定义类型**，或者你可以使用自定义类型扩展语言。类型是语言的核心；它们描述了组成节点的事物（节点是 Puppet 用来表示客户端计算机/设备的词汇）。Puppet
    使用资源来描述节点的状态；例如，我们将使用站点清单（`site.pp`）为节点声明以下包资源。'
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a `site.pp` file and place the following code in it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `site.pp` 文件，并在其中放置以下代码：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你的账户中下载所有购买的 Packt 书籍的示例代码文件，地址是 [http://www.packtpub.com](http://www.packtpub.com)。如果你从其他地方购买了这本书，你可以访问
    [http://www.packtpub.com/support](http://www.packtpub.com/support) 注册后，文件将直接通过电子邮件发送给你。
- en: How it works...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This manifest will ensure that any node, on which this manifest is applied,
    will install a package called `'httpd'`. The `default` keyword is a wildcard to
    Puppet; it applies anything within the node default definition to any node. When
    Puppet applies the manifest to a node, it uses a **Resource Abstraction Layer**
    (**RAL**) to translate the package type into the package management system of
    the target node. What this means is that we can use the same manifest to install
    the `httpd` package on any system for which Puppet has a **Provider** for the
    package type. Providers are the pieces of code that do the real work of applying
    a manifest. When the previous code is applied to a node running on a YUM-based
    distribution, the YUM provider will be used to install the `httpd` RPM packages.
    When the same code is applied to a node running on an **APT**-based distribution,
    the APT provider will be used to install the `httpd` DEB package (which may not
    exist, most debian-based systems call this package `apache2`; we'll deal with
    this sort of naming problem later).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个清单将确保在应用该清单的任何节点上都会安装一个名为`'httpd'`的包。`default`关键字是Puppet的通配符；它将节点默认定义中的所有内容应用于任何节点。当Puppet将清单应用到一个节点时，它使用**资源抽象层**（**RAL**）将包类型转换为目标节点的包管理系统。这意味着我们可以使用相同的清单在任何为Puppet提供包类型**Provider**的系统上安装`httpd`包。Providers是执行实际应用清单的代码部分。当将之前的代码应用到运行基于YUM的发行版的节点时，将使用YUM提供程序来安装`httpd`的RPM包。当相同的代码应用到运行基于**APT**的发行版的节点时，将使用APT提供程序来安装`httpd`的DEB包（该包可能不存在，大多数基于Debian的系统将该包称为`apache2`；我们稍后会处理这种命名问题）。
- en: Using Facter to describe a node
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Facter描述节点
- en: Facter is a separate utility upon which Puppet depends. It is the system used
    by Puppet to gather information about the target system (node); `facter` calls
    the nuggets of information facts. You may run `facter` from the command line to
    obtain real-time information from the system.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Facter是一个独立的实用程序，Puppet依赖于它。它是Puppet用于收集目标系统（节点）信息的系统；`facter`将这些信息片段称为事实。您可以从命令行运行`facter`以获取系统的实时信息。
- en: How to do it...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Use `facter` to find the current uptime of the system, the uptime fact:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`facter`来查找系统的当前运行时间，运行时间事实：
- en: '[PRE1]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Compare this with the output of the Linux uptime command:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与Linux的uptime命令输出进行比较：
- en: '[PRE2]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When `facter` is installed (as a dependency for puppet), several fact definitions
    are installed by default. You can reference each of these facts by name from the
    command line.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当`facter`安装（作为Puppet的依赖项）时，默认会安装若干事实定义。您可以从命令行通过名称引用这些事实。
- en: There's more...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Running `facter` without any arguments causes `facter` to print all the facts
    known about the system. We will see in later chapters that `facter` can be extended
    with your own custom facts. All facts are available for you to use as variables;
    variables are discussed in the next section.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`facter`而不带任何参数会导致`facter`打印系统已知的所有事实。我们将在后面的章节中看到，`facter`可以通过自定义事实进行扩展。所有事实都可以作为变量供您使用；变量将在下一节中讨论。
- en: Variables
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量
- en: Variables in Puppet are marked with a dollar sign ($) character. When using
    variables within a manifest, it is preferred to enclose the variable within braces
    `"${myvariable}"` instead of `"$myvariable"`. All of the facts from `facter` can
    be referenced as top scope variables (we will discuss scope in the next section).
    For example, the **fully qualified domain name** (**FQDN**) of the node may be
    referenced by `"${::fqdn}"`. Variables can only contain alphabetic characters,
    numerals, and the underscore character (`_`). As a matter of style, variables
    should start with an alphabetic character. Never use dashes in variable names.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet中的变量用美元符号（$）标记。在清单中使用变量时，建议将变量放在大括号`"${myvariable}"`中，而不是`"$myvariable"`。所有来自`facter`的事实都可以作为顶级作用域变量引用（我们将在下一节讨论作用域）。例如，节点的**完全限定域名**（**FQDN**）可以通过`"${::fqdn}"`来引用。变量只能包含字母字符、数字和下划线字符（`_`）。作为一种风格，变量应以字母字符开头。永远不要在变量名中使用连字符。
- en: Scope
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作用域
- en: In the variable example explained in the *There's more…* section, the fully
    qualified domain name was referred to as `${::fqdn}` rather than `${fqdn}`; the
    double colons are how Puppet differentiates scope. The highest level scope, top
    scope or global, is referred to by two colons (`::`) at the beginning of a variable
    identifier. To reduce namespace collisions, always use fully scoped variable identifiers
    in your manifests. For a Unix user, think of top scope variables as the `/` (root)
    level. You can refer to variables using the double colon syntax similar to how
    you would refer to a directory by its full path. For the developer, you can think
    of top scope variables as global variables; however, unlike global variables,
    you must always refer to them with the double colon notation to guarantee that
    a local variable isn't obscuring the top scope variable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *还有更多…* 部分中解释的变量示例中，完全限定的域名被引用为 `${::fqdn}`，而不是 `${fqdn}`；双冒号是 Puppet 区分作用域的方式。最高级别的作用域，即顶级作用域或全局作用域，通过变量标识符前面的两个冒号（`::`）来表示。为了减少命名空间冲突，请始终在清单中使用完全作用域的变量标识符。对于
    Unix 用户来说，顶级作用域变量就像是 `/`（根）级别。你可以使用双冒号语法来引用变量，就像你通过完整路径引用目录一样。对于开发者而言，顶级作用域变量可以看作是全局变量；然而，不同于全局变量，你必须始终使用双冒号符号来引用它们，以确保局部变量不会遮蔽顶级作用域变量。
- en: Installing a package before starting a service
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在启动服务之前安装一个包
- en: To show how ordering works, we'll create a manifest that installs `httpd` and
    then ensures the `httpd` package service is running.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示排序是如何工作的，我们将创建一个清单，首先安装 `httpd`，然后确保 `httpd` 包服务正在运行。
- en: How to do it...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We start by creating a manifest that defines the service:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从创建一个定义服务的清单开始：
- en: '[PRE3]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The service definition references a package resource named `httpd`; we now
    need to define that resource:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务定义引用了一个名为 `httpd` 的包资源；我们现在需要定义这个资源：
- en: '[PRE4]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this example, the package will be installed before the service is started.
    Using `require` within the definition of the `httpd` service ensures that the
    package is installed first, regardless of the order within the manifest file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，包会在服务启动之前安装。通过在 `httpd` 服务的定义中使用 `require`，可以确保包首先安装，无论在清单文件中的顺序如何。
- en: Capitalization
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大小写
- en: 'Capitalization is important in Puppet. In our previous example, we created
    a package named `httpd`. If we wanted to refer to this package later, we would
    capitalize its type (`package`) as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet 中，大小写非常重要。在我们之前的示例中，我们创建了一个名为 `httpd` 的包。如果我们以后想要引用这个包，我们需要将它的类型（`package`）大写，像这样：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To refer to a class, for example, the `something::somewhere` class, which has
    already been included/defined in your manifest, you can reference it with the
    full path as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要引用一个类，例如已经在你的清单中包含/定义的 `something::somewhere` 类，你可以按照以下方式使用完整路径引用它：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When you have a defined type, for example the following defined type:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个定义类型时，例如以下定义的类型：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding resource may be referenced later as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 上述资源稍后可以这样引用：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Knowing how to reference previously defined resources is necessary for the next
    section on metaparameters and ordering.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何引用之前定义的资源对于下一节关于元参数和排序非常重要。
- en: Learning metaparameters and ordering
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习元参数和排序
- en: All the manifests that will be used to define a node are compiled into a catalog.
    A catalog is the code that will be applied to configure a node. It is important
    to remember that manifests are not applied to nodes sequentially. There is no
    inherent order to the application of manifests. With this in mind, in the previous
    `httpd` example, what if we wanted to ensure that the `httpd` process started
    after the `httpd` package was installed?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所有用于定义节点的清单都会编译成一个目录。目录是将应用于配置节点的代码。需要记住的是，清单不会按顺序应用于节点。清单的应用没有固有的顺序。考虑到这一点，在之前的
    `httpd` 示例中，如果我们想确保 `httpd` 进程在 `httpd` 包安装后启动，该怎么办？
- en: 'We couldn''t rely on the `httpd` service coming after the `httpd` package in
    the manifests. What we have to do is use metaparameters to tell Puppet the order
    in which we want resources applied to the node. Metaparameters are parameters
    that can be applied to any resource and are not specific to any one resource type.
    They are used for catalog compilation and as hints to Puppet but not to define
    anything about the resource to which they are attached. When dealing with ordering,
    there are four metaparameters used:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能依赖于 `httpd` 服务在清单中紧跟着 `httpd` 包。我们必须使用元参数来告诉 Puppet 我们希望资源应用到节点的顺序。元参数是可以应用于任何资源的参数，并且不特定于任何一种资源类型。它们用于目录编译，并作为
    Puppet 的提示，但并不定义任何与其附加的资源相关的内容。在处理顺序时，有四个元参数可供使用：
- en: '`before`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`before`'
- en: '`require`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`require`'
- en: '`notify`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notify`'
- en: '`subscribe`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscribe`'
- en: The `before` and `require` metaparameters specify a direct ordering; `notify`
    implies `before` and `subscribe` implies `require`. The `notify` metaparameter
    is only applicable to services; what notify does is tell a service to restart
    after the notifying resource has been applied to the node (this is most often
    a package or file resource). In the case of files, once the file is created on
    the node, a notify parameter will restart any services mentioned. The `subscribe`
    metaparameter has the same effect but is defined on the service; the service will
    subscribe to the file.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`before` 和 `require` 元参数指定了直接的顺序；`notify` 隐含了 `before`，而 `subscribe` 隐含了 `require`。`notify`
    元参数仅适用于服务；`notify` 的作用是告诉服务在通知资源应用到节点后重新启动（这通常是一个包或文件资源）。在文件的情况下，一旦文件在节点上创建，`notify`
    参数会重新启动任何提到的服务。`subscribe` 元参数具有相同的效果，但它是在服务上定义的；服务会订阅该文件。'
- en: Trifecta
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 三重关系
- en: The relationship between package and service previously mentioned is an important
    and powerful paradigm of Puppet. Adding one more resource-type file into the fold,
    creates what puppeteers refer to as the **trifecta**. Almost all system administration
    tasks revolve around these three resource types. As a system administrator, you
    install a package, configure the package with files, and then start the service.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的包与服务之间的关系是 Puppet 的一个重要且强大的范式。再加入一个资源类型文件，便形成了木偶师所说的 **三重关系**。几乎所有系统管理任务都围绕这三种资源类型展开。作为系统管理员，你安装一个包，使用文件配置该包，然后启动服务。
- en: '![Trifecta](img/B03643_01_01.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![三重关系](img/B03643_01_01.jpg)'
- en: Diagram of Trifecta (Files require package for directory, service requires files
    and package)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 三重关系图（文件需要包来创建目录，服务需要文件和包）
- en: Idempotency
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 幂等性
- en: A key concept of Puppet is that the state of the system when a catalog is applied
    to a node cannot affect the outcome of Puppet run. In other words, at the end
    of Puppet run (if the run was successful), the system will be in a known state
    and any further application of the catalog will result in a system that is in
    the same state. This property of Puppet is known as idempotency. **Idempotency**
    is the property that no matter how many times you do something, it remains in
    the same state as the first time you did it. For instance, if you had a light
    switch and you gave the instruction to turn it on, the light would turn on. If
    you gave the instruction again, the light would remain on.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 的一个关键概念是，当目录被应用到节点时，系统的状态不能影响 Puppet 运行的结果。换句话说，在 Puppet 运行结束时（如果运行成功），系统将处于已知状态，且对目录的任何进一步应用将导致系统处于相同的状态。Puppet
    的这一特性称为幂等性。**幂等性** 是指无论你做多少次某事，系统保持与第一次操作相同的状态。例如，如果你有一个灯开关，你指示将其打开，灯会亮。如果你再次给出同样的指令，灯依然保持亮着。
- en: Installing, configuring, and starting a service
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装、配置并启动服务
- en: There are many examples of this pattern online. In our simple example, we will
    create an Apache configuration file under `/etc/httpd/conf.d/cookbook.conf`. The
    `/etc/httpd/conf.d` directory will not exist until the `httpd` package is installed.
    After this file is created, we would want `httpd` to restart to notice the change;
    we can achieve this with a notify parameter.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 网上有很多关于这种模式的例子。在我们简单的例子中，我们将在 `/etc/httpd/conf.d/cookbook.conf` 下创建一个 Apache
    配置文件。 `/etc/httpd/conf.d` 目录在 `httpd` 包安装之前是不存在的。文件创建后，我们希望 `httpd` 重新启动以察觉到更改；我们可以通过
    `notify` 参数实现这一点。
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will need the same definitions as our last example; we need the package
    and service installed. We now need two more things. We need the configuration
    file and index page (`index.html`) created. For this, we follow these steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要和上一个示例相同的定义；我们需要安装包和服务。现在我们需要两个新的要素。我们需要创建配置文件和索引页面（`index.html`）。为此，我们按照以下步骤进行：
- en: 'As in the previous example, we ensure the service is running and specify that
    the service requires the `httpd` package:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与之前的示例一样，我们确保服务正在运行，并指定该服务需要`httpd`包：
- en: '[PRE9]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We then define the package as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们按如下方式定义包：
- en: '[PRE10]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we create the `/etc/httpd/conf.d/cookbook.conf` configuration file; the
    `/etc/httpd/conf.d` directory will not exist until the `httpd` package is installed.
    The `require` metaparameter tells Puppet that this file requires the `httpd` package
    to be installed before it is created:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建`/etc/httpd/conf.d/cookbook.conf`配置文件；`/etc/httpd/conf.d`目录在安装`httpd`包之前是不存在的。`require`元参数告诉Puppet，这个文件需要先安装`httpd`包，才能创建：
- en: '[PRE11]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We then go on to create an `index.html` file for our virtual host in `/var/www/cookbook`.
    This directory won''t exist yet, so we need to create this as well, using the
    following code:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们继续在`/var/www/cookbook`为我们的虚拟主机创建`index.html`文件。这个目录尚未存在，因此我们还需要创建它，使用以下代码：
- en: '[PRE12]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works…
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `require` attribute to the file resources tell Puppet that we need the `/var/www/cookbook`
    directory created before we can create the `index.html` file. The important concept
    to remember is that we cannot assume anything about the target system (node).
    We need to define everything on which the target depends. Anytime you create a
    file in a manifest, you have to ensure that the directory containing that file
    exists. Anytime you specify that a service should be running, you have to ensure
    that the package providing that service is installed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 文件资源的`require`属性告诉Puppet，我们需要先创建`/var/www/cookbook`目录，然后才能创建`index.html`文件。要记住的重要概念是，我们不能假设目标系统（节点）有什么预设条件。我们需要定义目标依赖的所有内容。每当你在清单中创建文件时，你必须确保包含该文件的目录已经存在。每当你指定某个服务应当运行时，你必须确保提供该服务的包已被安装。
- en: 'In this example, using metaparameters, we can be confident that no matter what
    state the node is in before running Puppet, after Puppet runs, the following will
    be true:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，使用元参数，我们可以确保无论节点在运行Puppet之前处于什么状态，Puppet运行后，以下内容将会成立：
- en: '`httpd` will be running'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`httpd`将正在运行。'
- en: The `VirtualHost` configuration file will exist
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VirtualHost`配置文件将存在'
- en: '`httpd` will restart and be aware of the `VirtualHost` file'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`httpd`将重新启动并且意识到`VirtualHost`文件。'
- en: The `DocumentRoot` directory will exist
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DocumentRoot`目录将存在。'
- en: An `index.html` file will exist in the `DocumentRoot` directory
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.html`文件将存在于`DocumentRoot`目录中。'
- en: Using community Puppet style
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用社区Puppet风格
- en: If other people need to read or maintain your manifests, or if you want to share
    code with the community, it's a good idea to follow the existing style conventions
    as closely as possible. These govern such aspects of your code as layout, spacing,
    quoting, alignment, and variable references, and the official puppetlabs recommendations
    on style are available at [http://docs.puppetlabs.com/guides/style_guide.html](http://docs.puppetlabs.com/guides/style_guide.html).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其他人需要阅读或维护你的清单文件，或者你想与社区分享代码，最好尽可能遵循现有的风格约定。这些约定涵盖了代码的布局、空格、引用、对齐和变量引用等方面，Puppet官方的风格推荐可以在[http://docs.puppetlabs.com/guides/style_guide.html](http://docs.puppetlabs.com/guides/style_guide.html)找到。
- en: How to do it…
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: In this section, I'll show you a few of the more important examples and how
    to make sure that your code is style compliant.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我将展示一些更重要的示例，并确保你的代码符合风格要求。
- en: Indentation
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缩进
- en: 'Indent your manifests using two spaces (not tabs), as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个空格（而不是制表符）缩进你的清单文件，如下所示：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Quoting
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用
- en: 'Always quote your resource names, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 始终引用资源名称，如下所示：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We cannot do this as follows though:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不能按以下方式进行：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Use single quotes for all strings, except when:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有字符串，使用单引号，除非：
- en: The string contains variable references such as `"${::fqdn}"`
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串包含像`"${::fqdn}"`这样的变量引用。
- en: The string contains character escape sequences such as `"\n"`
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串包含像`"\n"`这样的字符转义序列。
- en: 'Consider the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下代码：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Puppet doesn't process variable references or escape sequences unless they're
    inside double quotes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet不会处理变量引用或转义序列，除非它们在双引号内。
- en: 'Always quote parameter values that are not reserved words in Puppet. For example,
    the following values are not reserved words:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 始终为那些不是 Puppet 保留字的参数值加上引号。例如，以下值不是保留字：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'However, these values are reserved words and therefore not quoted:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些值是保留字，因此不需要加引号：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'False'
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 假
- en: 'There is only one thing in Puppet that is false, that is, the word `false`
    without any quotes. The string `"false"` evaluates to `true` and the string `"true"`
    also evaluates to true. Actually, everything besides the literal false evaluates
    to true (when treated as a Boolean):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet 中，只有一件事情是假的，即没有引号的 `false`。字符串 `"false"` 评估为 `true`，而字符串 `"true"` 也评估为
    `true`。实际上，除了字面上的 `false`，其他所有东西都会被评估为 `true`（当作为布尔值处理时）：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When this code is run through `puppet apply`, the first two notifies are triggered.
    The final notify is not triggered; it is the only one that evaluates to `false`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过 `puppet apply` 执行此代码时，前两个通知会被触发。最后一个通知不会被触发；它是唯一一个评估为 `false` 的通知。
- en: Variables
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量
- en: 'Always include curly braces (`{}`) around variable names when referring to
    them in strings, for example, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 引用变量名时，始终在字符串中使用大括号（`{}`），例如，按如下方式：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Otherwise, Puppet's parser has to guess which characters should be a part of
    the variable name and which belong to the surrounding string. Curly braces make
    it explicit.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，Puppet 的解析器将不得不猜测哪些字符属于变量名，哪些字符属于周围的字符串。使用大括号可以使其明确。
- en: Parameters
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数
- en: 'Always end lines that declare parameters with a comma, even if it is the last
    parameter:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 声明参数的行结尾始终加上逗号，即使是最后一个参数也不例外：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is allowed by Puppet, and makes it easier if you want to add parameters
    later, or reorder the existing parameters.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 允许使用符号链接，并且如果您以后想添加参数或重新排列现有参数，这样做会更方便。
- en: 'When declaring a resource with a single parameter, make the declaration all
    on one line and with no trailing comma, as shown in the following snippet:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当声明一个只有一个参数的资源时，将整个声明写在一行，并且不要加尾随逗号，如以下代码片段所示：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Where there is more than one parameter, give each parameter its own line:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个参数，将每个参数放在单独一行：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To make the code easier to read, line up the parameter arrows in line with
    the longest parameter, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码更易于阅读，将参数箭头与最长的参数对齐，如下所示：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The arrows should be aligned per resource, but not across the whole file, otherwise
    it can make it difficult for you to cut and paste code from one file to another.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头应按资源对齐，而不是跨整个文件对齐，否则这会使您从一个文件复制并粘贴代码到另一个文件时变得困难。
- en: Symlinks
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 符号链接
- en: 'When declaring file resources which are symlinks, use `ensure => link` and
    set the target attribute, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 声明为符号链接的文件资源时，使用 `ensure => link` 并设置目标属性，如下所示：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Creating a manifest
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建清单
- en: If you already have some Puppet code (known as a Puppet manifest), you can skip
    this section and go on to the next. If not, we'll see how to create and apply
    a simple manifest.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经有一些 Puppet 代码（称为 Puppet 清单），可以跳过此部分并进入下一部分。如果没有，我们将看到如何创建和应用一个简单的清单。
- en: How to do it...
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create and apply a simple manifest, follow these steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并应用简单的清单，请按照以下步骤操作：
- en: 'First, install Puppet locally on your machine or create a virtual machine and
    install Puppet on that machine. For YUM-based systems, use [https://yum.puppetlabs.com/](https://yum.puppetlabs.com/)
    and for APT-based systems, use [https://apt.puppetlabs.com/](https://apt.puppetlabs.com/).
    You may also use gem to install Puppet. For our examples, we''ll install Puppet
    using gem on a Debian Wheezy system (hostname: `cookbook`). To use gem, we need
    the `rubygems` package as follows:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在您的计算机上本地安装 Puppet，或者创建一台虚拟机并在该机器上安装 Puppet。对于基于 YUM 的系统，请使用 [https://yum.puppetlabs.com/](https://yum.puppetlabs.com/)，对于基于
    APT 的系统，请使用 [https://apt.puppetlabs.com/](https://apt.puppetlabs.com/)。您也可以使用
    gem 安装 Puppet。对于我们的示例，我们将在 Debian Wheezy 系统（主机名：`cookbook`）上使用 gem 安装 Puppet。为了使用
    gem，我们需要 `rubygems` 包，如下所示：
- en: '[PRE26]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, use `gem` to install Puppet:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用 `gem` 安装 Puppet：
- en: '[PRE27]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Three gems are installed. Now, with Puppet installed, we can create a directory
    to contain our Puppet code:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装了三个 gem。现在，Puppet 已安装，我们可以创建一个目录来存放我们的 Puppet 代码：
- en: '[PRE28]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Within your `manifests` directory, create the `site.pp` file with the following
    content:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 `manifests` 目录中，创建 `site.pp` 文件，并填入以下内容：
- en: '[PRE29]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Test your manifest with the `puppet apply` command. This will tell Puppet to
    read the manifest, compare it to the state of the machine, and make any necessary
    changes to that state:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `puppet apply` 命令测试您的清单。这将告诉 Puppet 读取清单，比较机器的当前状态，并对该状态进行必要的更改：
- en: '[PRE30]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To see if Puppet did what we expected (create the `/tmp/hello` file with the
    `Hello, world`! content), run the following command:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看Puppet是否按预期操作（创建`/tmp/hello`文件并包含`Hello, world`内容），运行以下命令：
- en: '[PRE31]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that creating the file in `/tmp` did not require special permissions. We
    did not run Puppet via `sudo`. Puppet need not be run through `sudo`; there are
    cases where running via an unprivileged user can be useful.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`/tmp`目录下创建文件不需要特殊权限。我们没有通过`sudo`运行Puppet。Puppet不需要通过`sudo`运行；在某些情况下，通过非特权用户运行可能会很有用。
- en: There's more…
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'When several people are working on a code base, it''s easy for style inconsistencies
    to creep in. Fortunately, there''s a tool available which can automatically check
    your code for compliance with the style guide: `puppet-lint`. We''ll see how to
    use this in the next section.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当多人共同开发一个代码库时，风格不一致的问题很容易出现。幸运的是，有一个工具可以自动检查你的代码是否符合风格指南：`puppet-lint`。我们将在下一节中了解如何使用这个工具。
- en: Checking your manifests with Puppet-lint
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Puppet-lint检查你的清单文件
- en: 'The puppetlabs official style guide outlines a number of style conventions
    for Puppet code, some of which we''ve touched on in the preceding section. For
    example, according to the style guide, manifests:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: puppetlabs官方风格指南列出了多种Puppet代码的风格规范，其中一些我们在前面的小节中已经提到过。例如，根据风格指南，清单文件应该：
- en: Must use two-space soft tabs
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须使用两个空格的软制表符
- en: Must not use literal tab characters
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁止使用字面制表符字符
- en: Must not contain trailing white space
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁止包含多余的空白字符
- en: Should not exceed an 80 character line width
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行宽不应超过80个字符
- en: Should align parameter arrows (`=>`) within blocks
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该在代码块内对齐参数箭头（`=>`）
- en: Following the style guide will make sure that your Puppet code is easy to read
    and maintain, and if you're planning to release your code to the public, style
    compliance is essential.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循风格指南将确保你的Puppet代码易于阅读和维护，如果你打算将代码发布给公众，遵循风格规范是至关重要的。
- en: The `puppet-lint` tool will automatically check your code against the style
    guide. The next section explains how to use it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`puppet-lint`工具将自动检查你的代码是否符合风格指南。下一节将解释如何使用它。'
- en: Getting ready
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Here''s what you need to do to install Puppet-lint:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是安装Puppet-lint所需的步骤：
- en: 'We''ll install Puppet-lint using the gem provider because the gem version is
    much more up to date than the APT or RPM packages available. Create a `puppet-lint.pp`
    manifest as shown in the following code snippet:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过gem提供程序安装Puppet-lint，因为gem版本比APT或RPM包更为更新。创建一个`puppet-lint.pp`清单，如下所示：
- en: '[PRE32]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Run `puppet apply` on the `puppet-lint.pp` manifest, as shown in the following
    command:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`puppet-lint.pp`清单上运行`puppet apply`命令，如下所示：
- en: '[PRE33]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How to do it...
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps to use Puppet-lint:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用Puppet-lint：
- en: 'Choose a Puppet manifest file that you want to check with Puppet-lint, and
    run the following command:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个你想用Puppet-lint检查的Puppet清单文件，然后运行以下命令：
- en: '[PRE34]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you can see, Puppet-lint found a number of problems with the manifest file.
    Correct the errors, save the file, and rerun Puppet-lint to check that all is
    well. If successful, you''ll see no output:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，Puppet-lint发现了清单文件中的一些问题。修正错误，保存文件，然后重新运行Puppet-lint以确保一切正常。如果成功，你将看不到任何输出：
- en: '[PRE35]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There's more...
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: You can find out more about Puppet-lint at [https://github.com/rodjek/puppet-lint](https://github.com/rodjek/puppet-lint).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/rodjek/puppet-lint](https://github.com/rodjek/puppet-lint)了解更多关于Puppet-lint的信息。
- en: 'Should you follow Puppet style guide and, by extension, keep your code lint-clean?
    It''s up to you, but here are a couple of things to think about:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 是否遵循Puppet风格指南，并保持你的代码符合风格规范？这由你决定，但有几点需要考虑：
- en: It makes sense to use some style conventions, especially when you're working
    collaboratively on code. Unless you and your colleagues can agree on standards
    for whitespace, tabs, quoting, alignment, and so on, your code will be messy and
    difficult to read or maintain.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一些风格规范是有意义的，特别是当你与他人合作编写代码时。如果你和同事无法就空格、制表符、引号、对齐等标准达成一致，代码将变得混乱，难以阅读或维护。
- en: If you're choosing a set of style conventions to follow, the logical choice
    would be that issued by puppetlabs and adopted by the community for use in public
    modules.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你选择了要遵循的一套风格规范，最合适的选择就是由puppetlabs发布并被社区采纳用于公共模块的风格规范。
- en: 'Having said that, it''s possible to tell Puppet-lint to ignore certain checks
    if you''ve chosen not to adopt them in your codebase. For example, if you don''t
    want Puppet-lint to warn you about code lines exceeding 80 characters, you can
    run Puppet-lint with the following option:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，如果你选择不在代码库中采纳某些检查，也可以告诉 Puppet-lint 忽略这些检查。例如，如果你不想让 Puppet-lint 警告你关于代码行超过
    80 个字符的事情，你可以使用以下选项运行 Puppet-lint：
- en: '[PRE36]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Run `puppet-lint --help` to see the complete list of check configuration commands.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `puppet-lint --help` 查看完整的检查配置命令列表。
- en: See also
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Automatic syntax checking with Git hooks* recipe in [Chapter 2](ch02.html
    "Chapter 2. Puppet Infrastructure"), *Puppet Infrastructure*
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](ch02.html "第2章。Puppet 基础设施")中的*使用 Git hooks 进行自动语法检查*食谱，*Puppet 基础设施*'
- en: The *Testing your Puppet manifests with rspec-puppet* recipe in [Chapter 9](ch09.html
    "Chapter 9. External Tools and the Puppet Ecosystem"), *External Tools and the
    Puppet Ecosystem*
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第9章](ch09.html "第9章。外部工具与 Puppet 生态系统")中的*使用 rspec-puppet 测试 Puppet 清单*食谱，*外部工具与
    Puppet 生态系统*'
- en: Using modules
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模块
- en: One of the most important things you can do to make your Puppet manifests clearer
    and more maintainable is to organize them into modules.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使 Puppet 清单更清晰、更易维护的最重要的事情之一就是将它们组织成模块。
- en: Modules are self-contained bundles of Puppet code that include all the files
    necessary to implement a thing. Modules may contain flat files, templates, Puppet
    manifests, custom fact declarations, augeas lenses, and custom Puppet types and
    providers.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是自包含的 Puppet 代码包，包含实现某个功能所需的所有文件。模块可以包含普通文件、模板、Puppet 清单、自定义事实声明、augeas 镜头以及自定义
    Puppet 类型和提供程序。
- en: Separating things into modules makes it easier to reuse and share code; it's
    also the most logical way to organize your manifests. In this example, we'll create
    a module to manage memcached, a memory caching system commonly used with web applications.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 将功能分离成模块使得代码更易于重用和共享；这也是组织清单的最合乎逻辑的方式。在这个例子中，我们将创建一个管理 memcached 的模块，memcached
    是一个通常与 Web 应用程序一起使用的内存缓存系统。
- en: How to do it…
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Following are the steps to create an example module:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建示例模块的步骤：
- en: 'We will use Puppet''s module subcommand to create the directory structure for
    our new module:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 Puppet 的模块子命令来为我们的新模块创建目录结构：
- en: '[PRE37]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This command creates the module directory and creates some empty files as starting
    points. To use the module, we'll create a symlink to the module name (memcached).
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令创建模块目录并创建一些空文件作为起点。要使用该模块，我们将创建指向模块名称（memcached）的符号链接。
- en: '[PRE38]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, edit `memcached/manifests/init.pp` and change the class definition at
    the end of the file to the following. Note that `puppet module generate` created
    many lines of comments; in a production module you would want to edit those default
    comments:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编辑 `memcached/manifests/init.pp` 并将文件末尾的类定义更改为以下内容。注意，`puppet module generate`
    创建了许多注释行；在生产环境的模块中，你可能想要编辑这些默认的注释：
- en: '[PRE39]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create the `modules/thomas-memcached/files` directory and then create a file
    named `memcached.conf` with the following contents:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `modules/thomas-memcached/files` 目录，然后创建一个名为 `memcached.conf` 的文件，内容如下：
- en: '[PRE40]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Change your `site.pp` file to the following:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的 `site.pp` 文件更改为以下内容：
- en: '[PRE41]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We would like this module to install memcached. We''ll need to run Puppet with
    root privileges, and we''ll use sudo for that. We''ll need Puppet to be able to
    find the module in our home directory; we can specify this on the command line
    when we run Puppet as shown in the following code snippet:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望这个模块安装 memcached。我们需要以 root 权限运行 Puppet，为此我们将使用 sudo。我们需要确保 Puppet 能在我们的主目录中找到该模块；我们可以在运行
    Puppet 时在命令行中指定这一点，代码片段如下所示：
- en: '[PRE42]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Check whether the new service is running:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查新服务是否正在运行：
- en: '[PRE43]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works…
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When we created the module using Puppet's module generate command, we used the
    name `thomas-memcached`. The name before the hyphen is your username or your username
    on Puppet forge (an online repository of modules). Since we want Puppet to be
    able to find the module by the name `memcached`, we make a symbolic link between
    `thomas-memcached` and `memcached`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 Puppet 的 `module generate` 命令创建模块时，我们使用了名称 `thomas-memcached`。连字符前的名称是你的用户名或你在
    Puppet forge（一个在线模块库）上的用户名。由于我们希望 Puppet 能够通过名称 `memcached` 找到该模块，我们在 `thomas-memcached`
    和 `memcached` 之间创建了一个符号链接。
- en: 'Modules have a specific directory structure. Not all of these directories need
    to be present, but if they are, this is how they should be organized:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 模块有一个特定的目录结构。并不是所有这些目录都需要存在，但如果它们存在，它们应该按如下方式组织：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: All manifest files (those containing Puppet code) live in the manifests directory.
    In our example, the `memcached` class is defined in the `manifests/init.pp` file,
    which will be imported automatically.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 所有清单文件（包含Puppet代码的文件）都位于manifests目录中。在我们的示例中，`memcached`类定义在`manifests/init.pp`文件中，该文件将自动导入。
- en: 'Inside the `memcached` class, we refer to the `memcached.conf` file:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在`memcached`类中，我们引用了`memcached.conf`文件：
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The preceding `source` parameter tells Puppet to look for the file in:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 上述`source`参数告诉Puppet在以下位置查找文件：
- en: '`MODULEPATH/ (/home/thomas/.puppet/modules)`'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`MODULEPATH/ (/home/thomas/.puppet/modules)`'
- en: '`└memcached/`'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`└memcached/`'
- en: '`└files/`'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`└files/`'
- en: '`└memcached.conf`'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`└memcached.conf`'
- en: There's more…
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: Learn to love modules because they'll make your Puppet life a lot easier. They're
    not complicated, however, practice and experience will help you judge when things
    should be grouped into modules, and how best to arrange your module structure.
    Modules can hold more than manifests and files as we'll see in the next two sections.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 学会喜爱模块，因为它们会让你的Puppet使用体验更轻松。它们并不复杂，然而，实践和经验会帮助你判断何时应该将事物组织到模块中，以及如何最好地安排模块结构。正如我们在接下来的两节中所见，模块不仅可以包含清单和文件。
- en: Templates
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板
- en: 'If you need to use a template as a part of the module, place it in the module''s
    templates directory and refer to it as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要将模板作为模块的一部分使用，将其放在模块的templates目录中，并按如下方式引用它：
- en: '[PRE46]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Puppet will look for the file in:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet会在以下位置查找文件：
- en: '[PRE47]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Facts, functions, types, and providers
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事实、函数、类型和提供者
- en: Modules can also contain custom facts, custom functions, custom types, and providers.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 模块还可以包含自定义事实、函数、类型和提供者。
- en: For more information about these, refer to [Chapter 9](ch09.html "Chapter 9. External
    Tools and the Puppet Ecosystem"), *External Tools and the Puppet Ecosystem*.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 有关这些内容的更多信息，请参见[第9章](ch09.html "第9章：外部工具与Puppet生态系统")，*外部工具与Puppet生态系统*。
- en: Third-party modules
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三方模块
- en: You can download modules provided by other people and use them in your own manifests
    just like the modules you create. For more on this, see Using Public Modules recipe
    in [Chapter 7](ch07.html "Chapter 7. Managing Applications"), *Managing Applications*.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以下载其他人提供的模块，并像使用自己创建的模块一样将其应用到自己的清单中。更多内容，请参见[第7章](ch07.html "第7章：管理应用程序")中的《使用公共模块》食谱，*管理应用程序*。
- en: Module organization
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块组织
- en: 'For more details on how to organize your modules, see puppetlabs website:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何组织模块的更多细节，请参见puppetlabs网站：
- en: '[http://docs.puppetlabs.com/puppet/3/reference/modules_fundamentals.html](http://docs.puppetlabs.com/puppet/3/reference/modules_fundamentals.html)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.puppetlabs.com/puppet/3/reference/modules_fundamentals.html](http://docs.puppetlabs.com/puppet/3/reference/modules_fundamentals.html)'
- en: See also
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: The *Creating custom facts* recipe in [Chapter 9](ch09.html "Chapter 9. External
    Tools and the Puppet Ecosystem"), *External Tools and the Puppet Ecosystem*
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第9章](ch09.html "第9章：外部工具与Puppet生态系统")中的*创建自定义事实*食谱，*外部工具与Puppet生态系统*'
- en: The *Using public modules* recipe in [Chapter 7](ch07.html "Chapter 7. Managing
    Applications"), *Managing Applications*
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第7章](ch07.html "第7章：管理应用程序")中的*使用公共模块*食谱，*管理应用程序*'
- en: The *Creating your own resource types* recipe in [Chapter 9](ch09.html "Chapter 9. External
    Tools and the Puppet Ecosystem"), *External Tools and the Puppet Ecosystem*
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第9章](ch09.html "第9章：外部工具与Puppet生态系统")中的*创建你自己的资源类型*食谱，*外部工具与Puppet生态系统*'
- en: The *Creating your own providers* recipe in [Chapter 9](ch09.html "Chapter 9. External
    Tools and the Puppet Ecosystem"), *External Tools and the Puppet Ecosystem*
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第9章](ch09.html "第9章：外部工具与Puppet生态系统")中的*创建你自己的提供者*食谱，*外部工具与Puppet生态系统*'
- en: Using standard naming conventions
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标准命名约定
- en: Choosing appropriate and informative names for your modules and classes will
    be a big help when it comes to maintaining your code. This is even truer if other
    people need to read and work on your manifests.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为模块和类选择适当且富有信息性的名称，在维护代码时会有很大帮助。如果其他人需要阅读并处理你的清单，这一点尤为重要。
- en: How to do it…
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Here are some tips on how to name things in your manifests:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些关于如何命名清单中内容的建议：
- en: Name modules after the software or service they manage, for example, `apache`
    or `haproxy`.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照它们管理的软件或服务来命名模块，例如，`apache`或`haproxy`。
- en: Name classes within modules (subclasses) after the function or service they
    provide to the module, for example, `apache::vhosts` or `rails::dependencies`.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模块内（子类）根据它们为模块提供的功能或服务命名类，例如，`apache::vhosts`或`rails::dependencies`。
- en: If a class within a module disables the service provided by that module, name
    it `disabled`. For example, a class that disables Apache should be named `apache::disabled`.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果模块中的类禁用了该模块提供的服务，则应将其命名为 `disabled`。例如，禁用 Apache 的类应命名为 `apache::disabled`。
- en: Create a roles and profiles hierarchy of modules. Each node should have a single
    role consisting of one or more profiles. Each profile module should configure
    a single service.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个角色和配置文件的模块层次结构。每个节点应具有一个由一个或多个配置文件组成的角色。每个配置文件模块应配置一个单独的服务。
- en: The module that manages users should be named `user`.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管理用户的模块应命名为 `user`。
- en: Within the user module, declare your virtual users within the class `user::virtual`
    (for more on virtual users and other resources, see the *Using virtual resources*
    recipe in [Chapter 5](ch05.html "Chapter 5. Users and Virtual Resources"), *Users
    and Virtual Resources*).
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在用户模块中，将虚拟用户声明在 `user::virtual` 类中（有关虚拟用户和其他资源的更多信息，请参见 [第5章](ch05.html "第5章：用户和虚拟资源")中的
    *使用虚拟资源* 章节）。
- en: Within the user module, subclasses for particular groups of users should be
    named after the group, for example, `user::sysadmins` or `user::contractors`.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在用户模块中，特定用户组的子类应以该组的名称命名，例如 `user::sysadmins` 或 `user::contractors`。
- en: 'When using Puppet to deploy the config files for different services, name the
    file after the service, but with a suffix indicating what kind of file it is,
    for example:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Puppet 部署不同服务的配置文件时，应以服务名称命名文件，但要附加一个后缀，指示文件的类型，例如：
- en: 'Apache init script: `apache.init`'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache 初始化脚本：`apache.init`
- en: 'Logrotate config snippet for Rails: `rails.logrotate`'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rails 的 Logrotate 配置片段：`rails.logrotate`
- en: 'Nginx vhost file for mywizzoapp: `mywizzoapp.vhost.nginx`'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的 mywizzoapp 的 Nginx 虚拟主机文件：`mywizzoapp.vhost.nginx`
- en: 'MySQL config for standalone server: `standalone.mysql`'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立服务器的 MySQL 配置：`standalone.mysql`
- en: 'If you need to deploy a different version of a file depending on the operating
    system release, for example, you can use a naming convention like the following:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你需要根据操作系统版本部署不同版本的文件，例如，你可以使用如下的命名约定：
- en: '[PRE48]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You can have Puppet automatically select the appropriate version as follows:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过以下方式让 Puppet 自动选择适当的版本：
- en: '[PRE49]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If you need to manage, for example, different Ruby versions, name the class
    after the version it is responsible for, for example, `ruby192` or `ruby186`.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你需要管理不同的 Ruby 版本，例如，按版本命名类，如 `ruby192` 或 `ruby186`。
- en: There's more…
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Puppet community maintains a set of best practice guidelines for your Puppet
    infrastructure, which includes some hints on naming conventions:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 社区维护了一套关于 Puppet 基础设施的最佳实践指南，其中包括一些命名约定的提示：
- en: '[http://docs.puppetlabs.com/guides/best_practices.html](http://docs.puppetlabs.com/guides/best_practices.html)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.puppetlabs.com/guides/best_practices.html](http://docs.puppetlabs.com/guides/best_practices.html)'
- en: 'Some people prefer to include multiple classes on a node by using a comma-separated
    list, rather than separate `include` statements, for example:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人更喜欢通过使用逗号分隔的列表而不是单独的 `include` 语句将多个类包含到节点中，例如：
- en: '[PRE50]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This is a matter of style, but I prefer to use separate `include` statements,
    one on a line, because it makes it easier to copy and move around class inclusions
    between nodes without having to tidy up the commas and indentation every time.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种风格问题，但我更喜欢使用单独的 `include` 语句，每行一个，因为这样可以更方便地在节点之间复制和移动类的包含，而无需每次整理逗号和缩进。
- en: I mentioned inheritance in a couple of the preceding examples; if you're not
    sure what this is, don't worry, I'll explain this in detail in the next chapter.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我在前面的几个示例中提到了继承；如果你不确定这是什么意思，别担心，我将在下一章详细解释。
- en: Using inline templates
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内联模板
- en: Templates are a powerful way of using **Embedded Ruby** (**ERB**) to help build
    config files dynamically. You can also use ERB syntax directly without having
    to use a separate file by calling the `inline_template` function. ERB allows you
    to use conditional logic, iterate over arrays, and include variables.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是使用 **嵌入式 Ruby** (**ERB**) 动态构建配置文件的一种强大方式。你也可以通过调用 `inline_template` 函数直接使用
    ERB 语法，而无需使用单独的文件。ERB 允许你使用条件逻辑、遍历数组并包含变量。
- en: How to do it…
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Here''s an example of how to use `inline_template`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用 `inline_template` 的示例：
- en: 'Pass your Ruby code to `inline_template` within Puppet manifest, as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的 Ruby 代码传递给 Puppet 清单中的 `inline_template`，如下所示：
- en: '[PRE51]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How it works…
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Anything inside the string passed to `inline_template` is executed as if it
    were an ERB template. That is, anything inside the `<%=` and `%>` delimiters will
    be executed as Ruby code, and the rest will be treated as a string.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `inline_template` 的字符串中的任何内容都会像 ERB 模板一样执行。也就是说，位于 `<%=` 和 `%>` 分隔符之间的内容会作为
    Ruby 代码执行，其余部分则作为字符串处理。
- en: In this example, we use `inline_template` to compute a different hour for this
    cron resource (a scheduled job) for each machine, so that the same job does not
    run at the same time on all machines. For more on this technique, see the *Distributing
    cron jobs efficiently* recipe in [Chapter 6](ch06.html "Chapter 6. Managing Resources
    and Files"), *Managing Resources and Files*.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用 `inline_template` 为每台机器计算不同的小时数，以便相同的作业不会在所有机器上同时运行。有关此技术的更多信息，请参见[第6章](ch06.html
    "第6章：管理资源和文件")中的 *高效分发 cron 作业* 例子，*管理资源和文件*。
- en: There's more...
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'In ERB code, whether inside a template file or an `inline_template` string,
    you can access your Puppet variables directly by name using an `@` prefix, if
    they are in the current scope or the top scope (facts):'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ERB 代码中，无论是在模板文件内还是 `inline_template` 字符串中，你都可以通过在名称前加 `@` 前缀直接访问 Puppet 变量（如果它们位于当前作用域或顶级作用域（事实）中）：
- en: '[PRE52]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To reference variables in another scope, use `scope.lookupvar`, as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 要引用另一个作用域中的变量，请使用 `scope.lookupvar`，如下所示：
- en: '[PRE53]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You should use inline templates sparingly. If you really need to use some complicated
    logic in your manifest, consider using a custom function instead (see the *Creating
    custom functions* recipe in [Chapter 9](ch09.html "Chapter 9. External Tools and
    the Puppet Ecosystem"), *External Tools and the Puppet Ecosystem*).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该谨慎使用内联模板。如果你确实需要在清单中使用一些复杂的逻辑，考虑使用自定义函数（参见[第9章](ch09.html "第9章：外部工具和 Puppet
    生态系统")中的 *创建自定义函数* 例子，*外部工具和 Puppet 生态系统*）。
- en: See also
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: The *Using ERB templates* recipe in [Chapter 4](ch04.html "Chapter 4. Working
    with Files and Packages"), *Working with Files and Packages*
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章：与文件和包一起工作")中的 *使用 ERB 模板* 例子，*与文件和包一起工作*
- en: The *Using array iteration in templates* recipe in [Chapter 4](ch04.html "Chapter 4. Working
    with Files and Packages"), *Working with Files and Packages*
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章：与文件和包一起工作")中的 *在模板中使用数组迭代* 例子，*与文件和包一起工作*
- en: Iterating over multiple items
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历多个项
- en: 'Arrays are a powerful feature in Puppet; wherever you want to perform the same
    operation on a list of things, an array may be able to help. You can create an
    array just by putting its content in square brackets:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是 Puppet 中的一个强大功能；任何时候你需要对一组事物执行相同操作时，数组都可能派上用场。你只需将内容放入方括号中即可创建一个数组：
- en: '[PRE54]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How to do it…
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'Here''s a common example of how arrays are used:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个常见的数组使用示例：
- en: 'Add the following code to your manifest:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的清单中：
- en: '[PRE55]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Run Puppet and note that each package should now be installed.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Puppet，并注意到每个包现在应该已被安装。
- en: How it works…
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Where Puppet encounters an array as the name of a resource, it creates a resource
    for each element in the array. In the example, a new package resource is created
    for each of the packages in the `$packages` array, with the same parameters (`ensure
    => installed`). This is a very compact way to instantiate many similar resources.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Puppet 遇到数组作为资源的名称时，它会为数组中的每个元素创建一个资源。在这个示例中，会为 `$packages` 数组中的每个包创建一个新的
    package 资源，使用相同的参数（`ensure => installed`）。这是实例化多个相似资源的一种非常简洁的方式。
- en: There's more…
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'Although arrays will take you a long way with Puppet, it''s also useful to
    know about an even more flexible data structure: the hash.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然数组在 Puppet 中可以帮你解决很多问题，但了解一种更灵活的数据结构：哈希，也是非常有用的。
- en: Using hashes
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用哈希
- en: 'A hash is like an array, but each of the elements can be stored and looked
    up by name (referred to as the key), for example (`hash.pp`):'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希类似于数组，但每个元素都可以通过名称（称为键）存储并查找，例如（`hash.pp`）：
- en: '[PRE56]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'When we run Puppet on this, we see the following notify in the output:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在此运行 Puppet 时，输出中会显示以下通知：
- en: '[PRE57]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Hash values can be anything that you can assign to variables, strings, function
    calls, expressions, and even other hashes or arrays. Hashes are useful to store
    a bunch of information about a particular thing because by accessing each element
    of the hash using a key, we can quickly find the information for which we are
    looking.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希值可以是你能够赋值给变量、字符串、函数调用、表达式，甚至是其他哈希或数组的任何内容。哈希非常适合存储关于某一特定事物的大量信息，因为通过使用键来访问哈希的每个元素，我们可以迅速找到我们要寻找的信息。
- en: Creating arrays with the split function
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 split 函数创建数组
- en: 'You can declare literal arrays using square brackets, as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用方括号声明字面数组，如下所示：
- en: '[PRE58]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, when we run Puppet on the preceding code, we see the following notice
    messages in the output:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行 Puppet 对前面的代码时，我们在输出中看到以下通知消息：
- en: '[PRE59]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'However, Puppet can also create arrays for you from strings, using the `split`
    function, as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Puppet 也可以使用 `split` 函数从字符串中为你创建数组，如下所示：
- en: '[PRE60]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Running `puppet apply` against this new manifest, we see the same messages
    in the output:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的清单上运行 `puppet apply`，我们在输出中看到相同的消息：
- en: '[PRE61]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Note that `split` takes two arguments: the first argument is the string to
    be split. The second argument is the character to split on; in this example, a
    single space. As Puppet works its way through the string, when it encounters a
    space, it will interpret it as the end of one item and the beginning of the next.
    So, given the string ''`egg beans chips''`, this will be split into three items.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`split`函数接受两个参数：第一个参数是要分割的字符串。第二个参数是分割的字符；在此示例中是一个空格。当 Puppet 遍历字符串时，当它遇到空格时，会将其解释为一个项的结束和下一个项的开始。因此，给定字符串
    '`egg beans chips`'，它将被分割成三个项。
- en: 'The character to split on can be any character or string:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 用于分割的字符可以是任何字符或字符串：
- en: '[PRE62]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The character can also be a regular expression, for example, a set of alternatives
    separated by a `|` (pipe) character:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 该字符也可以是一个正则表达式，例如，一组由 `|`（管道符）分隔的替代项：
- en: '[PRE63]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Writing powerful conditional statements
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写强大的条件语句
- en: Puppet's `if` statement allows you to change the manifest behavior based on
    the value of a variable or an expression. With it, you can apply different resources
    or parameter values depending on certain facts about the node, for example, the
    operating system, or the memory size.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 的 `if` 语句允许你根据变量或表达式的值改变清单的行为。使用它，你可以根据节点的某些事实（例如操作系统或内存大小）应用不同的资源或参数值。
- en: You can also set variables within the manifest, which can change the behavior
    of included classes. For example, nodes in data center A might need to use different
    DNS servers than nodes in data center B, or you might need to include one set
    of classes for an Ubuntu system, and a different set for other systems.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在清单中设置变量，这些变量可以改变包含类的行为。例如，数据中心 A 中的节点可能需要使用不同的 DNS 服务器，而不是数据中心 B 中的节点，或者你可能需要为
    Ubuntu 系统包含一组类，为其他系统包含另一组类。
- en: How to do it…
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'Here''s an example of a useful conditional statement. Add the following code
    to your manifest:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有用的条件语句示例。将以下代码添加到你的清单中：
- en: '[PRE64]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: How it works…
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Puppet treats whatever follows an `if` keyword as an expression and evaluates
    it. If the expression evaluates to true, Puppet will execute the code within the
    curly braces.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 将 `if` 关键字后面的内容视为一个表达式并进行求值。如果该表达式求值为 true，Puppet 将执行大括号内的代码。
- en: Optionally, you can add an else branch, which will be executed if the expression
    evaluates to false.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，你可以添加一个 else 分支，当表达式求值为 false 时，它将被执行。
- en: There's more…
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: Here are some more tips on using `if` statements.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些使用 `if` 语句的额外技巧。
- en: Elseif branches
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Elseif 分支
- en: 'You can add further tests using the `elseif` keyword, as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `elseif` 关键字添加进一步的测试，如下所示：
- en: '[PRE65]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Comparisons
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较
- en: 'You can check whether two values are equal using the `==` syntax, as in our
    example:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `==` 语法检查两个值是否相等，正如我们示例中的那样：
- en: '[PRE66]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Alternatively, you can check whether they are not equal using `!=`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以检查它们是否不相等，使用 `!=`：
- en: '[PRE67]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You can also compare numeric values using `<` and `>`:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `<` 和 `>` 比较数值：
- en: '[PRE68]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'To test whether a value is greater (or less) than or equal to another value,
    use `<=` or `>=`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试一个值是否大于（或小于）另一个值，使用 `<=` 或 `>=`：
- en: '[PRE69]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Combining expressions
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合表达式
- en: 'You can put together the kind of simple expressions described previously into
    more complex logical expressions, using `and`, `or`, and `not`:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将前面描述的简单表达式组合成更复杂的逻辑表达式，使用 `and`、`or` 和 `not`：
- en: '[PRE70]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: See also
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Using the in operator* recipe in this chapter
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *使用 in 运算符* 配方
- en: The *Using selectors and case statements* recipe in this chapter
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *使用选择器和 case 语句* 配方
- en: Using regular expressions in if statements
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 if 语句中使用正则表达式
- en: Another kind of expression you can test in `if` statements and other conditionals
    is the regular expression. A regular expression is a powerful way to compare strings
    using pattern matching.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在 `if` 语句和其他条件语句中测试正则表达式。正则表达式是一种强大的方式，通过模式匹配来比较字符串。
- en: How to do it…
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'This is one example of using a regular expression in a conditional statement.
    Add the following to your manifest:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在条件语句中使用正则表达式的一个示例。将以下内容添加到你的清单中：
- en: '[PRE71]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: How it works…
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Puppet treats the text supplied between the forward slashes as a regular expression,
    specifying the text to be matched. If the match succeeds, the `if` expression
    will be true and so the code between the first set of curly braces will be executed.
    In this example, we used a regular expression because different distributions
    have different ideas on what to call `64bit`; some use `amd64`, while others use
    `x86_64`. The only thing we can count on is the presence of the number 64 within
    the fact. Some facts that have version numbers in them are treated as strings
    to Puppet. For instance, `$::facterversion`. On my test system, this is `2.0.1`,
    but when I try to compare that with `2`, Puppet fails to make the comparison:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet将斜杠之间的文本视为正则表达式，指定要匹配的文本。如果匹配成功，`if`表达式将为真，因此第一个花括号之间的代码将被执行。在这个例子中，我们使用了正则表达式，因为不同的发行版对`64bit`的命名方式不同；有的使用`amd64`，而有的使用`x86_64`。我们唯一可以依赖的是事实中存在数字64。一些包含版本号的事实会被Puppet视为字符串。例如，`$::facterversion`。在我的测试系统中，它是`2.0.1`，但当我尝试将它与`2`进行比较时，Puppet无法完成比较：
- en: '[PRE72]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'If you wanted instead to do something if the text does not match, use `!~`
    rather than `=~`:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在文本不匹配时执行某些操作，使用`!~`而不是`=~`：
- en: '[PRE73]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: There's more…
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Regular expressions are very powerful, but can be difficult to understand and
    debug. If you find yourself using a regular expression so complex that you can't
    see at a glance what it does, think about simplifying your design to make it easier.
    However, one particularly useful feature of regular expressions is the ability
    to capture patterns.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式非常强大，但可能难以理解和调试。如果你发现自己使用的正则表达式过于复杂，以至于一眼看不出它的作用，可以考虑简化设计，使其更容易理解。然而，正则表达式的一个特别有用的功能是能够捕获模式。
- en: Capturing patterns
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获模式
- en: 'You can not only match text using a regular expression, but also capture the
    matched text and store it in a variable:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以使用正则表达式匹配文本，还可以捕获匹配的文本并将其存储在变量中：
- en: '[PRE74]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The preceding code produces this output:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码会产生以下输出：
- en: '**You said ''Puppet is better than manual configuration''. Looks like you''re
    comparing Puppet to manual configuration!**'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '**你说过“Puppet比手动配置更好”。看起来你正在将Puppet与手动配置进行比较！**'
- en: The variable `$0` stores the whole matched text (assuming the overall match
    succeeded). If you put brackets around any part of the regular expression, it
    creates a group, and any matched groups will also be stored in variables. The
    first matched group will be `$1`, the second `$2`, and so on, as shown in the
    preceding example.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`$0`存储整个匹配的文本（假设整体匹配成功）。如果你在正则表达式的任何部分加上括号，它会创建一个组，任何匹配的组也会存储在变量中。第一个匹配的组将是`$1`，第二个是`$2`，以此类推，如前面的示例所示。
- en: Regular expression syntax
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正则表达式语法
- en: 'Puppet''s regular expression syntax is the same as Ruby''s, so resources that
    explain Ruby''s regular expression syntax will also help you with Puppet. You
    can find a good introduction to Ruby''s regular expression syntax at this website:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet的正则表达式语法与Ruby相同，因此解释Ruby正则表达式语法的资源也将帮助你理解Puppet。你可以在这个网站找到Ruby正则表达式语法的一个很好的介绍：
- en: '[http://www.tutorialspoint.com/ruby/ruby_regular_expressions.htm](http://www.tutorialspoint.com/ruby/ruby_regular_expressions.htm).'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.tutorialspoint.com/ruby/ruby_regular_expressions.htm](http://www.tutorialspoint.com/ruby/ruby_regular_expressions.htm)。'
- en: See also
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: Refer to the *Using regular expression substitutions* recipe in this chapter
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考本章中的*使用正则表达式替换*小节
- en: Using selectors and case statements
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用选择器和`case`语句
- en: 'Although you could write any conditional statement using `if`, Puppet provides
    a couple of extra forms to help you express conditionals more easily: the selector
    and the `case` statement.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以使用`if`编写任何条件语句，但Puppet提供了几种额外的形式，帮助你更容易地表达条件：选择器和`case`语句。
- en: How to do it…
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Here are some examples of selector and `case` statements:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些选择器和`case`语句的示例：
- en: 'Add the following code to your manifest:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的清单中：
- en: '[PRE75]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Add the following code to your manifest:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的清单中：
- en: '[PRE76]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: How it works…
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Our example demonstrates both the selector and the `case` statement, so let's
    see in detail how each of them works.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例同时演示了选择器和`case`语句，接下来我们将详细了解它们是如何工作的。
- en: Selector
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择器
- en: In the first example, we used a selector (the `?` operator) to choose a value
    for the `$systemtype` variable depending on the value of `$::operatingsystem`.
    This is similar to the ternary operator in C or Ruby, but instead of choosing
    between two possible values, you can have as many values as you like.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，我们使用了选择器（`?`操作符）来根据`$::operatingsystem`的值为`$systemtype`变量选择一个值。这类似于C或Ruby中的三元运算符，但你可以根据需要选择任意多个值，而不仅仅是两个可能的值。
- en: Puppet will compare the value of `$::operatingsystem` to each of the possible
    values we have supplied in Ubuntu, Debian, and so on. These values could be regular
    expressions (for example, for a partial string match, or to use wildcards), but
    in our case, we have just used literal strings.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet会将`$::operatingsystem`的值与我们提供的Ubuntu、Debian等可能的值进行比较。这些值可以是正则表达式（例如，用于部分字符串匹配或使用通配符），但在我们的示例中，我们只是使用了字面字符串。
- en: As soon as it finds a match, the selector expression returns whatever value
    is associated with the matching string. If the value of `$::operatingsystem` is
    Fedora, for example, the selector expression will return the `redhatlike` string
    and this will be assigned to the variable `$systemtype`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到匹配项，选择器表达式将返回与匹配字符串相关联的任何值。如果`$::operatingsystem`的值是Fedora，例如，选择器表达式将返回`redhatlike`字符串，并将其赋值给变量`$systemtype`。
- en: Case statement
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Case语句
- en: Unlike selectors, the `case` statement does not return a value. `case` statements
    come in handy when you want to execute different code depending on the value of
    some expression. In our second example, we used the `case` statement to include
    either the `debianlike` or `redhatlike` class, depending on the value of `$::operatingsystem`.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 与选择器不同，`case`语句不返回值。当你想根据某个表达式的值执行不同的代码时，`case`语句非常有用。在我们的第二个示例中，我们使用`case`语句根据`$::operatingsystem`的值包含`debianlike`或`redhatlike`类。
- en: Again, Puppet compares the value of `$::operatingsystem` to a list of potential
    matches. These could be regular expressions or strings, or as in our example,
    comma-separated lists of strings. When it finds a match, the associated code between
    curly braces is executed. So, if the value of `$::operatingsystem` is `Ubuntu`,
    then the code including `debianlike` will be executed.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，Puppet将`$::operatingsystem`的值与一系列潜在的匹配项进行比较。这些匹配项可以是正则表达式或字符串，或者像我们的例子一样，可以是用逗号分隔的字符串列表。当找到匹配项时，大括号中的相关代码会被执行。所以，如果`$::operatingsystem`的值是`Ubuntu`，则包括`debianlike`的代码将会执行。
- en: There's more…
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Once you've got a grip of the basic use of selectors and `case` statements,
    you may find the following tips useful.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你掌握了选择器和`case`语句的基本用法，你可能会发现以下提示很有用。
- en: Regular expressions
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正则表达式
- en: 'As with `if` statements, you can use regular expressions with selectors and
    `case` statements, and you can also capture the values of the matched groups and
    refer to them using `$1`, `$2`, and so on:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 与`if`语句一样，你可以在选择器和`case`语句中使用正则表达式，并且你还可以捕获匹配组的值，并使用`$1`、`$2`等引用它们：
- en: '[PRE77]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Defaults
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认值
- en: 'Both selectors and `case` statements let you specify a default value, which
    is chosen if none of the other options match (the style guide suggests you always
    have a default clause defined):'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器和`case`语句都允许你指定一个默认值，当其他选项都不匹配时，将选择默认值（样式指南建议你始终定义一个默认子句）：
- en: '[PRE78]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The output is as follows:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE79]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: When the default action shouldn't normally occur, use the `fail()` function
    to halt the Puppet run.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 当默认操作通常不应发生时，可以使用`fail()`函数停止Puppet的运行。
- en: Using the in operator
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`in`操作符
- en: 'The `in` operator tests whether one string contains another string. Here''s
    an example:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`操作符测试一个字符串是否包含另一个字符串。这里有一个例子：'
- en: '[PRE80]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The preceding expression is true if the `spring` string is a substring of `springfield`,
    which it is. The `in` operator can also test for membership of arrays as follows:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`spring`字符串是`springfield`的子字符串，则前面的表达式为真，实际上它确实是。`in`操作符也可以测试数组的成员资格，如下所示：
- en: '[PRE81]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'When `in` is used with a hash, it tests whether the string is a key of the
    hash:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 当`in`与哈希一起使用时，它测试字符串是否为哈希的键：
- en: '[PRE82]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: How to do it…
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The following steps will show you how to use the `in` operator:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将展示如何使用`in`操作符：
- en: 'Add the following code to your manifest:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的清单中：
- en: '[PRE83]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Run Puppet:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Puppet：
- en: '[PRE84]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: There's more…
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'The value of an `in` expression is Boolean (true or false) so you can assign
    it to a variable:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`表达式的值是布尔值（真或假），因此你可以将其赋值给一个变量：'
- en: '[PRE85]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Using regular expression substitutions
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正则表达式替换
- en: Puppet's `regsubst` function provides an easy way to manipulate text, search
    and replace expressions within strings, or extract patterns from strings. We often
    need to do this with data obtained from a fact, for example, or from external
    programs.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet的`regsubst`函数提供了一种简便的方式来操作文本、在字符串中搜索和替换表达式，或者从字符串中提取模式。我们通常需要使用从事实中获取的数据，或者从外部程序中获取数据来执行这些操作。
- en: In this example, we'll see how to use `regsubst` to extract the first three
    octets of an IPv4 address (the network part, assuming it's a `/24` class C address).
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将看到如何使用`regsubst`提取IPv4地址的前三个八位字节（假设它是一个`/24`类C地址，即网络部分）。
- en: How to do it…
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何执行……
- en: 'Follow these steps to build the example:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤构建示例：
- en: 'Add the following code to your manifest:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的清单中：
- en: '[PRE86]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Run Puppet:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Puppet：
- en: '[PRE87]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: How it works…
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'The `regsubst` function takes at least three parameters: source, pattern, and
    replacement. In our example, we specified the source string as `$::ipaddress`,
    which, on this machine, is as follows:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`regsubst`函数至少需要三个参数：源、模式和替换。在我们的示例中，我们将源字符串指定为`$::ipaddress`，在这台机器上，它如下所示：'
- en: '[PRE88]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We specify the `pattern` function as follows:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按如下方式指定`pattern`函数：
- en: '[PRE89]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We specify the `replacement` function as follows:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按如下方式指定`replacement`函数：
- en: '[PRE90]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The pattern captures all of the string up to the last period (`\.`) in the
    `\1` variable. We then match on `.*`, which matches everything to the end of the
    string, so when we replace the string at the end with `\1.0`, we end up with only
    the network portion of the IP address, which evaluates to the following:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 模式捕获字符串中的所有内容，直到最后一个句点（`\.`），并将其存储在`\1`变量中。然后我们匹配`.*`，它匹配字符串的所有内容，直到结尾，因此当我们将字符串的结尾替换为`\1.0`时，最终得到的仅是IP地址的网络部分，其值为以下内容：
- en: '[PRE91]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We could have got the same result in other ways, of course, including the following:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以通过其他方式得到相同的结果，包括以下方式：
- en: '[PRE92]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Here, we only match the last octet and replace it with `.0`, which achieves
    the same result without capturing.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只匹配最后一个八位字节，并将其替换为`.0`，这样就可以在不捕获的情况下实现相同的结果。
- en: There's more…
  id: totrans-445
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: The `pattern` function can be any regular expression, using the same (Ruby)
    syntax as regular expressions in `if` statements.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '`pattern`函数可以是任何正则表达式，使用与`if`语句中正则表达式相同的（Ruby）语法。'
- en: See also
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: The *Importing dynamic information* recipe in [Chapter 3](ch03.html "Chapter 3. Writing
    Better Manifests"), *Writing Better Manifests*
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章. 编写更好的清单")中的*导入动态信息*方法，*编写更好的清单*'
- en: The *Getting information about the environment* recipe in [Chapter 3](ch03.html
    "Chapter 3. Writing Better Manifests"), *Writing Better Manifests*
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章. 编写更好的清单")中的*获取环境信息*方法，*编写更好的清单*'
- en: The *Using regular expressions in if statements* recipe in this chapter
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*在 if 语句中使用正则表达式*方法
- en: Using the future parser
  id: totrans-451
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用未来解析器
- en: Puppet language is evolving at the moment; many features that are expected to
    be included in the next major release (4) are available if you enable the future
    parser.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet语言目前正在发展中；许多预期将在下一个主要版本（4）中包含的功能，如果启用未来解析器，已经可以使用。
- en: Getting ready
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Ensure that the `rgen` gem is installed.
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保已安装`rgen` gem。
- en: Set `parser = future` in the `[main]` section of your `puppet.conf`(`/etc/puppet/puppet.conf`
    for open source Puppet as `root,/etc/puppetlabs/puppet/puppet.conf` for Puppet
    `Enterprise, and~/.puppet/puppet.conf` for a non-root user running puppet).
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`puppet.conf`的`[main]`部分中设置`parser = future`（对于开源Puppet，请将其设置为`/etc/puppet/puppet.conf`，对于Puppet
    Enterprise，请设置为`/etc/puppetlabs/puppet/puppet.conf`，对于以非root用户身份运行Puppet的用户，请设置为`~/.puppet/puppet.conf`）。
- en: To temporarily test with the future parser, use `--parser=future` on the command
    line.
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要临时使用未来解析器进行测试，请在命令行中使用`--parser=future`。
- en: How to do it...
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何执行……
- en: 'Many of the experimental features deal with how code is evaluated, for example,
    in an earlier example we compared the value of the `$::facterversion` fact with
    a number, but the value is treated as a string so the code fails to compile. Using
    the future parser, the value is converted and no error is reported as shown in
    the following command line output:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 许多实验性功能处理代码的评估方式，例如，在一个早期示例中，我们将`$::facterversion`事实的值与一个数字进行比较，但由于值被视为字符串，代码无法编译。使用未来解析器时，值会被转换，并且没有报告错误，如以下命令行输出所示：
- en: '[PRE93]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Appending to and concatenating arrays
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向数组添加元素并连接数组
- en: 'You can concatenate arrays with the `+` operator or append them with the `<<`
    operator. In the following example, we use the ternary operator to assign a specific
    package name to the `$apache` variable. We then append that value to an array
    using the `<<` operator:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`+`运算符连接数组，或者使用`<<`运算符将它们附加到数组中。在以下示例中，我们使用三元运算符将特定的包名称分配给`$apache`变量。然后，我们使用`<<`运算符将该值附加到数组中：
- en: '[PRE94]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'If we have two arrays, we can use the `+` operator to concatenate the two arrays.
    In this example, we define an array of system administrators (`$sysadmins`) and
    another array of application owners (`$appowners`). We can then concatenate the
    array and use it as an argument to our allowed users:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有两个数组，我们可以使用`+`运算符将这两个数组连接起来。在这个示例中，我们定义了一个系统管理员数组（`$sysadmins`）和另一个应用程序所有者数组（`$appowners`）。然后，我们可以将这两个数组连接起来，并作为允许用户的参数：
- en: '[PRE95]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'When we apply this manifest, we see that the two arrays have been joined as
    shown in the following command line output:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们应用这个清单时，我们看到这两个数组已经合并，如下所示的命令行输出：
- en: '[PRE96]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'If we have two hashes, we can merge them using the same `+` operator we used
    for arrays. Consider our `$interfaces` hash from a previous example; we can add
    another interface to the hash:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有两个哈希表，我们可以使用与数组相同的`+`运算符将它们合并。考虑我们之前示例中的`$interfaces`哈希表，我们可以向哈希表中添加另一个接口：
- en: '[PRE97]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'When we apply this manifest, we see that the route attribute has been merged
    into the hash (your results may differ, the order in which the hash prints is
    unpredictable), as follows:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们应用这个清单时，我们看到路由属性已合并到哈希表中（您的结果可能不同，哈希表打印的顺序是不可预测的），如下所示：
- en: '[PRE98]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Lambda functions
  id: totrans-471
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Lambda 函数
- en: Lambda functions are iterators applied to arrays or hashes. You iterate through
    the array or hash and apply an iterator function such as `each`, `map`, `filter`,
    `reduce`, or `slice` to each element of the array or key of the hash. Some of
    the lambda functions return a calculated array or value; others such as `each`
    only return the input array or hash.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 函数是应用于数组或哈希表的迭代器。你会遍历数组或哈希表，并对数组的每个元素或哈希表的每个键应用如`each`、`map`、`filter`、`reduce`、`slice`等迭代函数。一些
    Lambda 函数会返回计算后的数组或值；而如`each`之类的函数只会返回输入的数组或哈希表。
- en: Lambda functions such as `map` and `reduce` use temporary variables that are
    thrown away after the lambda has finished. Use of lambda functions is something
    best shown by example. In the next few sections, we will show an example usage
    of each of the lambda functions.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 像`map`和`reduce`这样的 Lambda 函数使用临时变量，这些变量在 Lambda 函数完成后会被丢弃。Lambda 函数的使用最好通过示例来展示。在接下来的几个章节中，我们将展示每个
    Lambda 函数的示例用法。
- en: Reduce
  id: totrans-474
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缩减
- en: 'Reduce is used to reduce the array to a single value. This can be used to calculate
    the maximum or minimum of the array, or in this case, the sum of the elements
    of the array:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 缩减用于将数组缩减为单一值。它可以用来计算数组的最大值或最小值，或者在这种情况下，计算数组元素的总和：
- en: '[PRE99]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'This preceding code will compute the sum of the `$count` array and store it
    in the `$sum` variable, as follows:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会计算`$count`数组的总和，并将其存储在`$sum`变量中，如下所示：
- en: '[PRE100]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Filter
  id: totrans-479
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 过滤器
- en: 'Filter is used to filter the array or hash based upon a test within the lambda
    function. For instance to filter our `$count` array as follows:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器用于基于 Lambda 函数中的测试来过滤数组或哈希表。例如，以下是如何过滤我们的`$count`数组：
- en: '[PRE101]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'When we apply this manifest, we see that only elements 4 and 5 are in the result:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们应用这个清单时，我们看到结果中只有第4和第5个元素：
- en: '[PRE102]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Map
  id: totrans-484
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 映射
- en: 'Map is used to apply a function to each element of the array. For instance,
    if we wanted (for some unknown reason) to compute the square of all the elements
    of the array, we would use `map` as follows:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 映射用于对数组的每个元素应用一个函数。例如，如果我们想（出于某些未知的原因）计算数组中所有元素的平方，我们会按如下方式使用`map`：
- en: '[PRE103]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The result of applying this manifest is a new array with every element of the
    original array squared (multiplied by itself), as shown in the following command
    line output:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 应用这个清单的结果是一个新数组，其中原数组的每个元素都被平方（自乘），如下所示的命令行输出：
- en: '[PRE104]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Slice
  id: totrans-489
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 切片
- en: 'Slice is useful when you have related values stored in the same array in a
    sequential order. For instance, if we had the destination and port information
    for a firewall in an array, we could split them up into pairs and perform operations
    on those pairs:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有相关的值按顺序存储在同一个数组中时，切片非常有用。例如，如果我们有防火墙的目的地和端口信息存储在一个数组中，我们可以将它们拆分成一对对的值，并对这些对进行操作：
- en: '[PRE105]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'When applied, this manifest will produce the following notices:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 应用后，这个清单会生成以下通知：
- en: '[PRE106]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'To make this a useful example, create a new firewall resource within the block
    of the slice instead of notice:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个例子更具实用性，请在切片块内创建一个新的防火墙资源，而不是使用`notice`：
- en: '[PRE107]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Each
  id: totrans-496
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Each
- en: 'Each is used to iterate over the elements of the array but lacks the ability
    to capture the results like the other functions. Each is the simplest case where
    you simply wish to do something with each element of the array, as shown in the
    following code snippet:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '`Each`用于遍历数组的元素，但不像其他函数那样具有捕获结果的能力。`Each`是最简单的情况，通常用于对数组中的每个元素执行某些操作，如以下代码片段所示：'
- en: '[PRE108]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'As expected, this executes the `notice` for each element of the `$count` array,
    as follows:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期所示，它对`$count`数组中的每个元素执行`notice`，如下所示：
- en: '[PRE109]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Other features
  id: totrans-501
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 其他特性
- en: There are other new features of Puppet language available when using the future
    parser. Some increase readability or compactness of code. For more information,
    refer to the documentation on puppetlabs website at [http://docs.puppetlabs.com/puppet/latest/reference/experiments_future.html](http://docs.puppetlabs.com/puppet/latest/reference/experiments_future.html).
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用未来解析器时，Puppet语言还有其他新特性。一些特性提高了代码的可读性或紧凑性。欲了解更多信息，请参考Puppetlabs网站上的文档：[http://docs.puppetlabs.com/puppet/latest/reference/experiments_future.html](http://docs.puppetlabs.com/puppet/latest/reference/experiments_future.html)。
