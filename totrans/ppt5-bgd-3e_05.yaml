- en: Chapter 5. Variables, expressions, and facts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章：变量、表达式和事实
- en: '|   | *It is impossible to begin to learn that which one thinks one already
    knows.* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *无法开始学习自己认为已经掌握的知识。* |   |'
- en: '|   | --*Epictetus* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*埃皮克泰图斯* |'
- en: In this chapter, you will learn about Puppet variables and data types, expressions,
    and conditional statements. You will also learn how Puppet manifests can get data
    about the node using Facter, find out which are the most important standard facts,
    and see how to create your own external facts. Finally, you will use Puppet's
    `each` function to iterate over arrays and hashes, including Facter data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习 Puppet 变量和数据类型、表达式以及条件语句。你还将学习如何使用 Facter 获取有关节点的数据，了解最重要的标准事实，并查看如何创建你自己的外部事实。最后，你将使用
    Puppet 的 `each` 函数迭代数组和哈希，包括 Facter 数据。
- en: '![Variables, expressions, and facts](img/B08880_05_01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![变量、表达式和事实](img/B08880_05_01.jpg)'
- en: Introducing variables
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入变量
- en: 'A **variable** in Puppet is simply a way of giving a name to a particular value,
    which we could then use wherever we would use the literal value (`variable_string.pp`):'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet 中，**变量**仅仅是给特定值命名的一种方式，这样我们就可以在需要使用字面值的地方使用该变量（`variable_string.pp`）：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The dollar sign (`$`) tells Puppet that what follows is a variable name. Variable
    names must begin with a lowercase letter or an underscore, though the rest of
    the name can also contain uppercase letters or numbers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 美元符号（`$`）告诉 Puppet 后面跟的是变量名。变量名必须以小写字母或下划线开头，尽管变量名的其余部分也可以包含大写字母或数字。
- en: 'A variable can contain different types of data; one such type is a **String**
    (like `php7.0-cli`), but Puppet variables can also contain **Number** or **Boolean**
    values (`true` or `false`). Here are a few examples (`variable_simple.pp`):'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以包含不同类型的数据；其中一种类型是**字符串**（如 `php7.0-cli`），但 Puppet 变量也可以包含**数字**或**布尔**值（`true`
    或 `false`）。以下是一些示例（`variable_simple.pp`）：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using Booleans
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用布尔值
- en: 'Strings and numbers are straightforward, but Puppet also has a special data
    type to represent true or false values, which we call **Boolean** values, after
    the logician George Boole. We have already encountered some Boolean values in
    Puppet resource attributes (`service.pp`):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串和数字是直观的，但 Puppet 还有一种特殊的数据类型来表示真假值，我们称之为**布尔**值，取名自逻辑学家乔治·布尔。我们在 Puppet 资源属性中已经遇到了一些布尔值（`service.pp`）：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The only allowed values for Boolean variables are the literal values `true`
    and `false`, but Boolean variables can also hold the values of conditional expressions
    (expressions whose value is `true` or `false`), which we'll explore later in this
    chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔变量唯一允许的值是字面值 `true` 和 `false`，但是布尔变量也可以持有条件表达式的值（值为 `true` 或 `false` 的表达式），我们将在本章稍后探讨。
- en: Tip
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You might be wondering what type the value `running` is in the previous example.
    It's actually a string, but a special, unquoted kind of string called a **bare
    word**. Although it would be exactly the same to Puppet if you used a normal quoted
    string `'running'` here, it's considered good style to use bare words for attribute
    values which can only be one of a small number of words (for example, the `ensure`
    attribute on services can only take the values `running` or `stopped`). By contrast,
    `true` is not a bare word but a Boolean value, and it is not interchangeable with
    the string `'true'`. Always use the unquoted literal values `true` or `false`
    for Boolean values.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道在之前的示例中，`running` 的值是什么类型。实际上，它是一个字符串，但它是一个特殊的、未加引号的字符串，称为**裸字**。虽然如果在这里使用正常的加引号字符串
    `'running'` 对 Puppet 来说是完全一样的，但对于只能是少数几个词之一的属性值（例如，服务的 `ensure` 属性只能取值 `running`
    或 `stopped`），使用裸字被认为是良好的风格。相比之下，`true` 不是裸字，而是布尔值，并且不能与字符串 `'true'` 互换。布尔值应始终使用未加引号的字面量值
    `true` 或 `false`。
- en: Interpolating variables in strings
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在字符串中插值变量
- en: 'It''s no good being able to store something in a variable if you can''t get
    it out again, and one of the most common ways to use a variable''s value is to
    **interpolate** it in a string. When you do this, Puppet inserts the current value
    of the variable into the contents of the string, replacing the name of the variable.
    String interpolation looks like this (`string_interpolation.pp`):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法再将变量中的内容取出来，那么将某些内容存储在变量中也没什么用。最常见的使用变量值的方式之一就是将其**插值**到字符串中。当你这样做时，Puppet
    会将变量的当前值插入到字符串内容中，替换掉变量的名称。字符串插值看起来像这样（`string_interpolation.pp`）：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When you apply this manifest, the following output is printed:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你应用此清单时，以下输出将被打印：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To interpolate (that is, to insert the value of) a variable in a string, prefix
    its name with a `$` character and surround it with curly braces (`{}`). This tells
    Puppet to replace the variable's name with its value in the string.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要在字符串中插入（即插值）变量的值，可以在变量名之前加上 `$` 符号，并用大括号（`{}`）将其括起来。这告诉 Puppet 用变量的值替换字符串中的变量名。
- en: Tip
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We sneaked a new Puppet function, `notice()`, into the previous example. It
    has no effect on the system, but it prints out the value of its argument. This
    can be very useful for troubleshooting problems or finding out what the value
    of a variable is at a given point in your manifest.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的示例中悄悄添加了一个新的 Puppet 函数`notice()`。它对系统没有影响，但会打印出其参数的值。这在故障排除或查看在清单中的某个特定时刻变量的值时非常有用。
- en: Creating arrays
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数组
- en: 'A variable can also hold more than one value. An **Array** is an ordered sequence
    of values, each of which can be of any type. The following example creates an
    array of **Integer** values (`variable_array.pp`):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 变量也可以包含多个值。**数组**是值的有序序列，每个值可以是任何类型。以下示例创建了一个 **整数** 类型的数组（`variable_array.pp`）：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can refer to any individual element of an array by giving its index number
    in square brackets, where the first element is index `[0]`, the second is `[1]`,
    and so on. (If you find this confusing, you're not alone, but it may help to think
    of the index as representing an offset from the beginning of the array. Naturally,
    then, the offset of the first element is 0.)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在方括号中给出索引号来引用数组的任何单个元素，其中第一个元素的索引是`[0]`，第二个是`[1]`，依此类推。（如果你觉得这很混乱，你并不孤单，但可以试着将索引看作是数组起始位置的偏移量。自然地，第一项的偏移量是0。）
- en: Declaring arrays of resources
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明资源数组
- en: 'You already know that in Puppet resource declarations, the title of the resource
    is usually a string, such as the path to a file or the name of a package. You
    might as well ask, "What happens if you supply an array of strings as the title
    of a resource instead of a single string? Does Puppet create multiple resources,
    one for each element in the array?" Let''s try an experiment where we do exactly
    that with an array of package names and see what happens (`resource_array.pp`):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道，在 Puppet 资源声明中，资源的标题通常是一个字符串，比如文件的路径或软件包的名称。你可能会问：“如果你为资源提供一个字符串数组作为标题，而不是单个字符串，会发生什么呢？Puppet
    会为数组中的每个元素创建多个资源吗？”让我们尝试一个实验，正好用一个包含软件包名称的数组来做这个实验，看看会发生什么（`resource_array.pp`）：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If our intuition is right, applying the previous manifest should give us a
    package resource for each package listed in the `$dependencies` array, and each
    one should be installed. Here''s what happens when the manifest is applied:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的直觉是对的，应用之前的清单应该会为 `$dependencies` 数组中列出的每个软件包创建一个软件包资源，并且每个软件包都会被安装。以下是应用清单时发生的情况：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Giving an array of strings as the title of a resource results in Puppet creating
    multiple resources, all identical except for the title. You can do this not just
    with packages, but also with files, users, or, in fact, any type of resource.
    We'll see some more sophisticated ways of creating resources from data in [Chapter
    6](ch06.html "Chapter 6. Managing data with Hiera"), *Managing data with Hiera*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个字符串数组作为资源的标题会导致 Puppet 创建多个资源，除了标题不同之外，其他都相同。你不仅可以对软件包这么做，还可以对文件、用户，或者任何类型的资源这么做。在[第6章](ch06.html
    "第6章：使用 Hiera 管理数据")，*使用 Hiera 管理数据*中，我们将看到一些更复杂的从数据创建资源的方式。
- en: Tip
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Why did we run `sudo apt-get update` before applying the manifest? This is the
    Ubuntu command to update the system's local package catalog from the upstream
    servers. It's always a good idea to run this before installing any package to
    make sure you're installing the latest version. In your production Puppet code,
    of course, you can run this via an `exec` resource.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们在应用清单之前运行了`sudo apt-get update`？这是 Ubuntu 命令，用于从上游服务器更新系统的本地软件包目录。在安装任何软件包之前运行此命令是一个好主意，以确保你安装的是最新版本。当然，在你的生产
    Puppet 代码中，你可以通过 `exec` 资源来运行它。
- en: Understanding hashes
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解哈希
- en: 'A **hash**, also known as a dictionary in some programming languages, is like
    an array, but instead of just being a sequence of values, each value has a name
    (`variable_hash.pp`):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈希**，在某些编程语言中也被称为字典，类似于数组，但不同于仅仅是值的序列，每个值都有一个名称（`variable_hash.pp`）：'
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The name for each value is known as the **key**. In the previous example, the
    keys of this hash are `john`, `rabiah`, `abigail`, `melina`, and `sumiko`. To
    look up the value of a given key, you put the key in square brackets after the
    hash name: `$heights[''john'']`.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 每个值的名称被称为**键**。在前面的示例中，这个哈希的键是`john`、`rabiah`、`abigail`、`melina`和`sumiko`。要查找给定键的值，你可以在哈希名称后面用方括号括住键：`$heights['john']`。
- en: Tip
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Puppet style note**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**Puppet风格说明**'
- en: Did you spot the trailing comma on the last hash key-value pair and the last
    element of the array in the previous example? Although the comma isn't strictly
    required, it's good style to add one. The reason is that it's very common to want
    to add another item to an array or hash, and if your last item already has a trailing
    comma, you won't have to remember to add one when extending the list.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到前面示例中最后一个哈希键值对和数组最后一个元素后的逗号？尽管逗号不是严格要求的，但添加逗号是一种良好的编码风格。原因是当你需要向数组或哈希中添加新项时，如果最后一个项已经有逗号，就不用记得在扩展列表时再添加一个逗号。
- en: Setting resource attributes from a hash
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从哈希中设置资源属性
- en: 'You might have noticed that a hash looks a lot like the attributes of a resource:
    it''s a one-to-one mapping between names and values. Wouldn''t it be convenient
    if, when declaring resources, we could just specify a hash containing all the
    attributes and their values? As it happens, you can do just that (`hash_attributes.pp`):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，哈希看起来非常像资源的属性：它是名称和值之间的一对一映射。如果在声明资源时，我们可以直接指定一个包含所有属性及其值的哈希，那该有多方便？事实证明，你可以这样做（`hash_attributes.pp`）：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `*` character, cheerfully named the **attribute splat operator**, tells
    Puppet to treat the specified hash as a list of attribute-value pairs to apply
    to the resource. This is exactly equivalent to specifying the same attributes
    directly, as in the following example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`*`字符，欢快地被称为**属性拆分运算符**，告诉Puppet将指定的哈希视为要应用于资源的属性值对列表。这完全等同于直接指定相同的属性，如以下示例所示：'
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Introducing expressions
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入表达式
- en: 'Variables are not the only things in Puppet that have a value. Expressions
    also have a value. The simplest expressions are just literal values:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 变量不是Puppet中唯一具有值的事物。表达式也有值。最简单的表达式只是字面值：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can combine numeric values with arithmetic operators, such as `+`, `-`,
    `*`, and `/`, to create **arithmetic** **expressions**, which have a numeric value,
    and you can use these to have Puppet do calculations (`expression_numeric.pp`):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将数字值与算术运算符（如`+`、`-`、`*`和`/`）结合起来，创建**算术** **表达式**，它们有一个数值，并且可以用来让Puppet进行计算（`expression_numeric.pp`）：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The most useful expressions, though, are which that evaluate to `true` or `false`,
    known as **Boolean expressions**. The following is a set of examples of Boolean
    expressions, all of which evaluate to `true` (`expression_boolean.pp`):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最有用的表达式是那些计算结果为`true`或`false`的表达式，这些被称为**布尔表达式**。以下是一些布尔表达式的例子，它们的结果都为`true`（`expression_boolean.pp`）：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Meeting Puppet's comparison operators
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认识Puppet的比较运算符
- en: 'All the operators in the Boolean expressions shown in the previous example
    are known as **comparison operators**, because they compare two values. The result
    is either `true` or `false`. These are the comparison operators Puppet provides:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，所有布尔表达式中的运算符被称为**比较运算符**，因为它们用来比较两个值。结果是`true`或`false`。以下是Puppet提供的比较运算符：
- en: '`==` and `!=` (equal, not equal)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`==` 和 `!=`（等于，不等于）'
- en: '`>`, `>=`, `<`, and `<=` (greater than, greater than or equal to, less than,
    less than or equal to)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>`、`>=`、`<`和`<=`（大于、大于或等于、小于、小于或等于）'
- en: '`A in B` (`A` is a substring of `B`, `A` is an element of the array `B`, or
    `A` is a key of the hash `B`)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A in B`（`A`是`B`的子字符串，`A`是数组`B`的元素，或`A`是哈希`B`的键）'
- en: '`A =~ B` (`A` is matched by the regular expression `B`, or `A` is a value of
    data type `B`. For example, the expression `''hello'' =~ String` is `true`, because
    the value `''hello''` is of type String.)'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A =~ B`（`A`被正则表达式`B`匹配，或`A`是数据类型`B`的值。例如，表达式`''hello'' =~ String`为`true`，因为值`''hello''`的类型是String。）'
- en: Introducing regular expressions
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入正则表达式
- en: 'The `=~` operator tries to match a given value against a **regular expression**.
    A regular expression (*regular* in the sense of constituting a pattern or a rule)
    is a special kind of expression which specifies a set of strings. For example,
    the regular expression `/a+/` describes the set of all strings that contain one
    or more consecutive `a`s: `a`, `aa`, `aaa`, and so on, as well as all strings
    which contain such a sequence among other characters. The slash characters `//`
    delimit a regular expression in Puppet.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`=~`操作符尝试将给定值与**正则表达式**进行匹配。正则表达式（在这里是指构成模式或规则的“常规”表达式）是一种特殊类型的表达式，用于指定一组字符串。例如，正则表达式`/a+/`描述了包含一个或多个连续`a`字符的所有字符串：`a`、`aa`、`aaa`，依此类推，以及包含这样的字符序列的其他字符字符串。正则表达式在Puppet中由斜杠字符`//`限定。'
- en: When we say a regular expression **matches** a value, we mean the value is one
    of the set of strings specified by the regular expression. The regular expression
    `/a+/` would match the string `aaa` or the string `Aaaaargh!`, for example.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说正则表达式**匹配**某个值时，我们指的是该值是正则表达式指定的一组字符串中的一个。例如，正则表达式`/a+/`将匹配字符串`aaa`或字符串`Aaaaargh!`。
- en: 'The following example shows some regular expressions that match the string
    `foo` (`regex.pp`):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了一些正则表达式，它们匹配字符串`foo`（`regex.pp`）：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Regular expressions are more-or-less a standard language for expressing string
    patterns. It''s a complicated and powerful language, which really deserves a book
    of its own (and there are several), but suffice it to say for now that Puppet''s
    regular expression syntax is the same as that used in the Ruby language. You can
    read more about it in the Ruby documentation at:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式或多或少是用于表达字符串模式的标准语言。它是一种复杂而强大的语言，确实值得一本书来深入探讨（也确实有几本书），但暂时可以简单了解，Puppet的正则表达式语法与Ruby语言使用的语法相同。你可以在Ruby文档中了解更多信息：
- en: '[http://ruby-doc.org/core/Regexp.html](http://ruby-doc.org/core/Regexp.html)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://ruby-doc.org/core/Regexp.html](http://ruby-doc.org/core/Regexp.html)'
- en: Using conditional expressions
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用条件表达式
- en: Boolean expressions, like those in the previous example, are useful because
    we can use them to make choices in the Puppet manifest. We can apply certain resources
    only if a given condition is met, or we can assign an attribute one value or another,
    depending on whether some expression is true. An expression used in this way is
    called a **conditional expression**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔表达式，如前面示例中的那些，十分有用，因为我们可以利用它们在Puppet清单中做出选择。只有在满足某个条件时，我们才会应用特定的资源，或者我们可以根据某个表达式是否为真来给某个属性赋予不同的值。以这种方式使用的表达式称为**条件表达式**。
- en: Making decisions with if statements
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`if`语句做决策
- en: 'The most common use of a conditional expression is in an `if` statement. The
    following example shows how to use `if` to decide whether to apply a resource
    (`if.pp`):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 条件表达式最常见的用法是在`if`语句中。以下示例演示了如何使用`if`来决定是否应用资源（`if.pp`）：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can see that the value of the Boolean variable `$install_perl` governs
    whether or not the `perl` package is installed. If `$install_perl` is `true`,
    Puppet will apply the following resource:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，布尔变量`$install_perl`的值决定了是否安装`perl`包。如果`$install_perl`为`true`，Puppet将应用以下资源：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If, on the other hand, `$install_perl` is `false`, the resource applied will
    be:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果`$install_perl`为`false`，应用的资源将是：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can use `if` statements to control the application of any number of resources
    or, indeed, any part of your Puppet manifest. You can leave out the `else` clause
    if you like; in that case, when the value of the conditional expression is `false`,
    Puppet will do nothing.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`if`语句来控制任何数量资源的应用，甚至控制Puppet清单的任何部分。如果你愿意，可以省略`else`子句；在这种情况下，当条件表达式的值为`false`时，Puppet将不做任何操作。
- en: Choosing options with case statements
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`case`语句选择选项
- en: 'The `if` statement allows you to take a yes/no decision based on the value
    of a Boolean expression. But if you need to make a choice among more than two
    options, you can use a `case` statement instead (`case.pp`):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句允许你根据布尔表达式的值做出是/否决策。但是，如果你需要在多个选项中做选择，可以使用`case`语句代替（`case.pp`）：'
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In a `case` statement, Puppet compares the value of the expression to each of
    the cases listed in order. If it finds a match, the corresponding resources are
    applied. The special case called `default` always matches, and you can use it
    to make sure that Puppet will do the right thing even if none of the other cases
    match.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在`case`语句中，Puppet会将表达式的值与按顺序列出的每个情况进行比较。如果找到匹配项，则会应用相应的资源。名为`default`的特殊情况始终匹配，你可以使用它确保即使其他情况都不匹配，Puppet也能做出正确的操作。
- en: Finding out facts
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找事实
- en: It's very common for Puppet manifests to need to know something about the system
    they're running on, for example, its hostname, IP address, or operating system
    version. Puppet's built-in mechanism for getting system information is called
    **Facter**, and each piece of information provided by Facter is known as a **fact**.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet清单中很常见的需求是需要了解它们运行的系统的一些信息，例如其主机名、IP地址或操作系统版本。Puppet获取系统信息的内置机制叫做**Facter**，Facter提供的每一条信息被称为**事实**。
- en: Using the facts hash
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用事实哈希
- en: 'You can access Facter facts in your manifest using the **facts hash**. This
    is a Puppet variable called `$facts` which is available everywhere in the manifest,
    and to get a particular fact, you supply the name of the fact you want as the
    key (`facts_hash.pp`):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在清单中使用**facts哈希**来访问Facter事实。这是一个Puppet变量`$facts`，在清单中的任何地方都可以使用，若要获取某个特定的事实，只需提供该事实的键名（`facts_hash.pp`）：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: On the Vagrant box, or any Linux system, this will return the value `Linux`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vagrant盒子中，或者任何Linux系统中，这将返回值`Linux`。
- en: 'In older versions of Puppet, each fact was a distinct global variable, like
    this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在较旧版本的Puppet中，每个事实都是一个独立的全局变量，如下所示：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You will still see this style of fact reference in some Puppet code, though
    it is now deprecated and will eventually stop working, so you should always use
    the $facts hash instead.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然会在一些Puppet代码中看到这种事实引用风格，尽管它现在已被弃用，并最终会停止工作，所以你应该始终使用$facts哈希。
- en: Running the facter command
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行facter命令
- en: 'You can also use the `facter` command to see the value of particular facts,
    or just see what facts are available. For example, running `facter os` on the
    command line will show you the hash of available OS-related facts:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`facter`命令查看某些特定事实的值，或仅查看哪些事实是可用的。例如，在命令行中运行`facter os`将显示可用的与操作系统相关的事实的哈希：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can also use the `puppet facts` command to see what facts will be available
    to Puppet manifests. This will also include any custom facts defined by third-party
    Puppet modules (see [Chapter 7](ch07.html "Chapter 7. Mastering modules"), *Mastering
    modules*, for more information about this).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`puppet facts`命令来查看哪些事实将对Puppet清单可用。这还会包括由第三方Puppet模块定义的任何自定义事实（有关更多信息，请参阅[第7章](ch07.html
    "第7章：精通模块")，*精通模块*）。
- en: Accessing hashes of facts
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问事实的哈希
- en: As in the previous example, many facts actually return a hash of values, rather
    than a single value. The value of the `$facts['os']` fact is a hash with the keys
    `architecture`, `distro`, `family`, `hardware`, `name`, `release`, and `selinux`.
    Some of those are also hashes; it's hashes all the way down!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的例子所示，许多事实实际上返回的是一个值的哈希，而不是单一的值。`$facts['os']`事实的值是一个哈希，其中包含`architecture`、`distro`、`family`、`hardware`、`name`、`release`和`selinux`等键。其中一些也是哈希；一切都是哈希！
- en: 'As you know, to access a particular value in a hash, you specify the key name
    in square brackets. To access a value inside a hash, you add another key name
    in square brackets after the first, as in the following example (`facts_architecture.pp`):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，要访问哈希中的特定值，你需要在方括号中指定键名。要访问哈希内部的值，你需要在第一个键名后加上另一个键名，如下例所示（`facts_architecture.pp`）：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can keep on appending more keys to get more and more specific information
    (`facts_distro_codename.pp`):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以继续附加更多的键来获得越来越具体的信息（`facts_distro_codename.pp`）：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Key fact**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键事实**'
- en: 'The operating system major release is a very handy fact and one you''ll probably
    use often:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统的主要版本是一个非常有用的事实，你可能会经常用到它：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Referencing facts in expressions
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在表达式中引用事实
- en: 'Just as with ordinary variables or values, you can use facts in expressions,
    including conditional expressions (`fact_if.pp`):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 就像普通变量或值一样，你可以在表达式中使用事实，包括条件表达式（`fact_if.pp`）：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Although conditional expressions based on facts can be useful, an even better
    way of making decisions based on facts in your manifests is to use Hiera, which
    we'll cover in the next chapter. For example, if you find yourself writing an
    `if` or `case` statement which chooses different resources depending on the operating
    system version, consider using a Hiera query instead.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然基于事实的条件表达式可能很有用，但在清单中基于事实做出决策的更好方法是使用Hiera，我们将在下一章中介绍。例如，如果发现自己编写了根据操作系统版本选择不同资源的`if`或`case`语句，请考虑改用Hiera查询。
- en: Using memory facts
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内存事实
- en: Another useful set of facts is that relating to the **system memory**. You can
    find out the total physical memory available, and the amount of memory currently
    used, as well as the same figures for swap memory.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的事实集是与**系统内存**相关的事实。您可以查看可用的总物理内存，当前使用的内存量，以及交换内存的相同数字。
- en: 'One common use for this is to configure applications dynamically based on the
    amount of system memory. For example, the MySQL parameter `innodb_buffer_pool_size`
    specifies the amount of memory allocated to database query cache and indexes,
    and it should generally be set as high as possible ("*as large a value as practical,
    leaving enough memory for other processes on the node to run without excessive
    paging*", according to the documentation). So you might decide to set this to
    three-quarters of total memory (for example), using a fact and an arithmetic expression,
    as in the following snippet (`fact_memory.pp`):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 其一常见用途是根据系统内存量动态配置应用程序。例如，MySQL参数`innodb_buffer_pool_size`指定为数据库查询缓存和索引分配的内存量，通常应尽可能设置得高（根据文档，"*尽可能大的值，留下足够的内存供节点上的其他进程运行而不过度分页*"）。因此，您可以决定将其设置为总内存的四分之三（例如），使用事实和算术表达式，如以下片段（`fact_memory.pp`）所示：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Key fact**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键事实**'
- en: 'The total system memory fact will help you calculate configuration parameters
    which vary as a fraction of memory:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 总系统内存事实将帮助您计算随内存分数变化的配置参数：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Discovering networking facts
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发现网络事实
- en: 'Most applications use the network, so you''ll find Facter''s network-related
    facts very useful for anything to do with network configuration. The most commonly
    used facts are the system hostname, fully qualified domain name (FQDN), and IP
    address (`fact_networking.pp`):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序使用网络，因此对于任何涉及网络配置的事情，您会发现Facter的网络相关事实非常有用。最常用的事实是系统主机名、完全合格的域名（FQDN）和IP地址（`fact_networking.pp`）：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Key fact**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键事实**'
- en: 'The system hostname is something you''ll need to refer to often in your manifests:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 系统主机名是您在清单中经常需要引用的内容：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Providing external facts
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供外部事实
- en: While the built-in facts available to Puppet provide a lot of important information,
    you can make the `$facts` hash even more useful by extending it with your own
    facts, known as **external facts**. For example, if nodes are located in different
    cloud providers, each of which requires a slightly different networking setup,
    you could create a custom fact called `cloud` to document this. You can then use
    this fact in manifests to make decisions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Puppet提供的内置事实提供了大量重要信息，但通过添加自定义事实（称为**外部事实**），您可以使`$facts`哈希表变得更加有用。例如，如果节点位于不同的云提供商中，每个提供商都需要稍有不同的网络设置，您可以创建一个名为`cloud`的自定义事实来记录这一点。然后，您可以在清单中使用此事实来做出决策。
- en: 'Puppet looks for external facts in the `/opt/puppetlabs/facter/facts.d/` directory.
    Try creating a file in that directory called `facts.txt` with the following contents
    (`fact_external.txt`):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet在`/opt/puppetlabs/facter/facts.d/`目录中查找外部事实。尝试在该目录中创建一个名为`facts.txt`的文件，并包含以下内容（`fact_external.txt`）：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'A quick way to do this is to run the following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 快速实现此目标的方法是运行以下命令：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `cloud` fact is now available in your manifests. You can check that the
    fact is working by running the following command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的清单中包含了`cloud`事实。您可以通过运行以下命令来检查该事实是否有效：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To use the fact in your manifest, query the `$facts` hash just as you would
    for a built-in fact (`fact_cloud.pp`):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的清单中使用该事实，请像使用内置事实（`fact_cloud.pp`）一样查询`$facts`哈希表：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can put as many facts in a single text file as you like, or you can have
    each fact in a separate file: it doesn''t make any difference. Puppet will read
    all the files in the `facts.d/` directory and extract all the `key=value` pairs
    from each one.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在单个文本文件中放置尽可能多的事实，或者您可以在单独的文件中放置每个事实：这没有任何区别。 Puppet将读取`facts.d/`目录中的所有文件，并从每个文件中提取所有`key=value`对。
- en: Text files work well for simple facts (those that return a single value). If
    your external facts need to return structured data (arrays or hashes, for example),
    you can use a YAML or JSON file instead to do this. We'll be learning more about
    YAML in the next chapter, but for now, if you need to build structured external
    facts, consult the Puppet documentation for details.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 文本文件适用于简单的事实（那些返回单一值的事实）。如果您的外部事实需要返回结构化数据（例如数组或哈希），您可以改用 YAML 或 JSON 文件来实现这一点。我们将在下一章学习更多关于
    YAML 的内容，但现在，如果您需要构建结构化的外部事实，请参考 Puppet 文档了解详细信息。
- en: It's common to set up external facts like this at build time, perhaps as part
    of an automated bootstrap script (see [Chapter 12](ch12.html "Chapter 12. Putting
    it all together"), *Putting it all together*, for more about the bootstrap process).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建时设置外部事实是很常见的，也许是自动引导脚本的一部分（有关引导过程的更多信息，请参见 [第12章](ch12.html "第12章. 综合应用")，*综合应用*）。
- en: Creating executable facts
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建可执行事实
- en: External facts are not limited to static text files. They can also be the output
    of scripts or programs. For example, you could write a script that calls a web
    service to get some data, and the result would be the value of the fact. These
    are known as **executable facts**.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 外部事实不仅限于静态文本文件。它们也可以是脚本或程序的输出。例如，您可以编写一个脚本，调用 web 服务以获取某些数据，结果将是事实的值。这些被称为**可执行事实**。
- en: 'Executable facts live in the same directory as other external facts (`/opt/puppetlabs/facter/facts.d/)`,
    but they are distinguished by having the execute bit set on their files (recall
    that files on Unix-like systems each have a set of bits indicating their read,
    write, and execute permissions) and they also can''t be named with `.txt`, `.yaml`,
    or `.json` extensions. Let''s build an executable fact which simply returns the
    current date, as an example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行事实与其他外部事实位于同一目录（`/opt/puppetlabs/facter/facts.d/`），但是它们通过在文件上设置可执行位来区分（请记住，类
    Unix 系统上的文件都有一组位，指示其读、写和执行权限），并且它们不能使用 `.txt`、`.yaml` 或 `.json` 后缀命名。让我们构建一个简单的可执行事实，返回当前日期作为示例：
- en: 'Run the following command to copy the executable fact example into the external
    fact directory:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令将可执行事实示例复制到外部事实目录中：
- en: '[PRE34]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Set the execute bit on the file with the following command:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令为文件设置可执行位：
- en: '[PRE35]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now test the fact:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在测试该事实：
- en: '[PRE36]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here is the script which generates this output (`date.sh`):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是生成该输出的脚本（`date.sh`）：
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that the script has to output `date=` before the actual date value. This
    is because Facter expects executable facts to output a list of `key=value` pairs
    (just one such pair, in this case). The `key` is the name of the fact (`date`),
    and the `value` is whatever is returned by `` `date +%F` `` (the current date
    in ISO 8601 format). You should use ISO 8601 format (`YYYY-MM-DD`) whenever you
    need to represent dates, by the way, because it's not only the international standard
    date format, but it is also unambiguous and sorts alphabetically.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，脚本必须在实际日期值之前输出`date=`。这是因为 Facter 期望可执行的事实输出一个`key=value`对的列表（在这种情况下只有一个对）。`key`是事实的名称（`date`），`value`是通过``
    `date +%F` ``返回的内容（ISO 8601 格式的当前日期）。顺便提一下，任何需要表示日期时都应该使用 ISO 8601 格式（`YYYY-MM-DD`），因为它不仅是国际标准日期格式，而且清晰、无歧义，并且按字母顺序排序。
- en: As you can see, executable facts are quite powerful because they can return
    any information which can be generated by a program (the program could make network
    requests or database queries, for example). However, you should use executable
    facts with care, as Puppet has to evaluate *all* external facts on the node every
    time it runs, which means running every script in `/opt/puppetlabs/facter/facts.d`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，可执行事实非常强大，因为它们可以返回程序可以生成的任何信息（例如，程序可以进行网络请求或数据库查询）。然而，您应该小心使用可执行事实，因为 Puppet
    必须在每次运行时评估节点上的*所有*外部事实，这意味着它会运行 `/opt/puppetlabs/facter/facts.d` 目录中的每个脚本。
- en: Tip
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you don't need the information from an executable fact to be regenerated
    every time Puppet runs, consider running the script from a cron job at longer
    intervals and having it write output to a static text file in the facts directory
    instead.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不需要每次 Puppet 运行时重新生成可执行事实的信息，考虑从 cron 作业中定期运行脚本，并让它将输出写入事实目录中的静态文本文件。
- en: Iterating over arrays
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历数组
- en: 'Iteration (doing something repeatedly) is a useful technique in your Puppet
    manifests to avoid lots of duplicated code. For example, consider the following
    manifest, which creates several files with identical properties (`iteration_simple.pp`):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代（反复做某事）是 Puppet 清单中一个有用的技巧，可以避免大量重复的代码。例如，考虑以下清单，它创建了多个具有相同属性的文件（`iteration_simple.pp`）：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can see that each of these resources is identical, except for the task
    number: `task1`, `task2`, and `task3`. Clearly, this is a lot of typing and should
    you later decide to change the properties of these scripts (for example, moving
    them to a different directory), you''ll have to find and change each one in the
    manifest. For three resources, this is already annoying, but for thirty or a hundred
    resources it''s completely impractical. We need a better solution.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这些资源每个都是相同的，除了任务编号：`task1`、`task2` 和 `task3`。显然，这样大量的输入是繁琐的，如果你稍后决定修改这些脚本的属性（例如，将它们移动到不同的目录），你需要在清单中找到并修改每一个。对于三个资源来说，这已经很麻烦了，但如果是三十个或者一百个资源，那简直无法忍受。我们需要更好的解决方案。
- en: Using the each function
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 each 函数
- en: 'Puppet provides the `each` function to help with just this kind of situation.
    The `each` function takes an array and applies a block of Puppet code to each
    element of the array. Here''s the same example we saw previously, only this time
    using an array and the `each` function (`iteration_each.pp`):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 提供了 `each` 函数来帮助处理这种情况。`each` 函数接收一个数组，并将一段 Puppet 代码应用于数组中的每个元素。这里是我们之前看到的相同示例，只不过这次使用了数组和
    `each` 函数（`iteration_each.pp`）：
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now this looks more like a computer program! We have a **loop**, created by
    the `each` function. The loop goes round and round, creating a new `file` resource
    for each element of the `$tasks` array. Let''s look at a schematic version of
    an `each` loop:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这看起来更像是一个计算机程序！我们有了一个由 `each` 函数创建的 **循环**。这个循环一次又一次地运行，为每个 `$tasks` 数组中的元素创建一个新的
    `file` 资源。让我们看一下 `each` 循环的示意图：
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following list describes the components of the `each` loop:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表描述了 `each` 循环的组成部分：
- en: '`ARRAY` can be any Puppet array variable or literal value (it could even be
    a call to Hiera that returns an array). In the previous example, we used `$tasks`
    as the array.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ARRAY` 可以是任何 Puppet 数组变量或字面量值（甚至可以是返回数组的 Hiera 调用）。在之前的示例中，我们使用了 `$tasks`
    作为数组。'
- en: '`ELEMENT` is the name of a variable which will hold, each time round the loop,
    the value of the current element in the array. In the previous example, we decided
    to name this variable `$task`, although we could have called it anything.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ELEMENT` 是一个变量的名称，每次循环时它将保存数组中当前元素的值。在之前的示例中，我们决定将此变量命名为 `$task`，尽管我们本可以取任何名字。'
- en: '`BLOCK` is a section of Puppet code. This could consist of a function call,
    resource declarations, include statements, conditional statements: anything which
    you can put in a Puppet manifest, you can also put inside a loop block. In the
    previous example, the only thing in the block was the `file` resource, which creates
    `/usr/local/bin/$task`.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BLOCK` 是一段 Puppet 代码。这可以是一个函数调用、资源声明、包含语句、条件语句：你可以在 Puppet 清单中写入的任何内容，也可以放在循环块内。在之前的示例中，块中唯一的内容是
    `file` 资源，它创建了 `/usr/local/bin/$task`。'
- en: Iterating over hashes
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代哈希
- en: 'The `each` function works not only on arrays, but also on hashes. When iterating
    over a hash, the loop takes two `ELEMENT` parameters: the first is the hash key,
    and the second is the value. The following example shows how to use `each` to
    iterate over a hash resulting from a Facter query (`iteration_hash.pp`):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`each` 函数不仅适用于数组，也适用于哈希。当迭代哈希时，循环需要两个 `ELEMENT` 参数：第一个是哈希的键，第二个是哈希的值。以下示例展示了如何使用
    `each` 来迭代一个由 Facter 查询返回的哈希（`iteration_hash.pp`）：'
- en: '[PRE41]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The list of interfaces returned by `$facts[''networking''][''interfaces'']`
    is a hash, where the key is the name of the interface (for example, `lo0` for
    the local loopback interfaces) and the value is a hash of the interface''s attributes
    (including the IP address, netmask, and so on). Applying the manifest in the previous
    example gives this result (on my Vagrant box):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`$facts[''networking''][''interfaces'']` 返回的接口列表是一个哈希，其中键是接口的名称（例如，`lo0` 是本地回环接口的名称），值是接口属性的哈希（包括
    IP 地址、子网掩码等）。应用之前示例中的清单会产生如下结果（在我的 Vagrant 虚拟机上）：'
- en: '[PRE42]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we''ve gained an understanding of how Puppet''s variable and
    data type system works, including the basic data types: Strings, Numbers, Booleans,
    Arrays, and Hashes. We''ve seen how to interpolate variables in strings and how
    to quickly create sets of similar resources using an array of resource names.
    We''ve learned how to set common attributes for resources using a hash of attribute-value
    pairs and the attribute splat operator.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了 Puppet 的变量和数据类型系统如何工作，包括基本数据类型：字符串、数字、布尔值、数组和哈希。我们学习了如何在字符串中插入变量，以及如何通过资源名称数组快速创建一组相似的资源。我们还学会了如何通过属性-值对的哈希设置资源的常见属性，并使用属性展开操作符。
- en: We've seen how to use variables and values in expressions, including arithmetic
    expressions, and explored the range of Puppet's comparison operators to generate
    Boolean expressions. We've used conditional expressions to build `if…else` and
    `case` statements and had a brief introduction to regular expressions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了如何在表达式中使用变量和值，包括算术表达式，并探讨了 Puppet 比较操作符的范围，以生成布尔表达式。我们使用条件表达式构建 `if…else`
    和 `case` 语句，并简要介绍了正则表达式。
- en: We've learned how Puppet's Facter subsystem supplies information about the node
    via the facts hash and how to use facts in our own manifests and in expressions.
    We've pointed out some key facts, including the operating system release, the
    system memory capacity, and the system hostname. We've seen how to create custom
    external facts, such as a `cloud` fact, and how to dynamically generate fact information
    using executable facts.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了 Puppet 的 Facter 子系统如何通过 facts 哈希提供关于节点的信息，以及如何在自己的清单和表达式中使用 facts。我们指出了一些关键的
    facts，包括操作系统版本、系统内存容量和系统主机名。我们还了解了如何创建自定义外部 facts，例如 `cloud` fact，以及如何使用可执行的 facts
    动态生成 fact 信息。
- en: Finally, we've learned about iteration in Puppet using the `each` function and
    how to create multiple resources based on data from arrays or hashes, including
    Facter queries.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们了解了如何使用 Puppet 中的 `each` 函数进行迭代，并基于数组或哈希中的数据（包括 Facter 查询）创建多个资源。
- en: In the next chapter, we'll stay with the topic of data and explore Puppet's
    powerful Hiera database. We'll see what problems Hiera solves, look at how to
    set up and query Hiera, how to write data sources, how to create Puppet resources
    directly from Hiera data, and also how to use Hiera encryption to manage secret
    data.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续讨论数据话题，探索 Puppet 强大的 Hiera 数据库。我们将看到 Hiera 解决了哪些问题，学习如何设置和查询 Hiera，如何编写数据源，如何直接从
    Hiera 数据创建 Puppet 资源，以及如何使用 Hiera 加密来管理敏感数据。
