<html><head></head><body><div class="chapter" title="Chapter&#xA0;12.&#xA0;Putting it all together"><div class="titlepage"><div><div><h1 class="title"><a id="ch12"/>Chapter 12. Putting it all together</h1></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><span class="emphasis"><em>Manhood is patience. Mastery is nine times patience.</em></span></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<span class="attribution"><span class="emphasis"><em>Ursula K. Le Guin, 'A Wizard of Earthsea'</em></span></span></td></tr></table></div><p>In this chapter, we will apply ideas from all the previous chapters to see what a complete, working Puppet infrastructure looks like, using a demonstration repo which illustrates all the principles explained in this book. You can use it as the basis of your own Puppet codebase, adapting and expanding it as needed.</p><div class="mediaobject"><img src="graphics/8880_12_01.jpg" alt="Putting it all together"/></div><div class="section" title="Getting the demo repo"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec68"/>Getting the demo repo</h1></div></div></div><p>The demo repo is <a id="id579" class="indexterm"/>available on GitHub, and you can clone it in the same way as for the example repo for this book by running this command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>git clone -b production https://github.com/bitfield/control-repo-3</strong></span>
</pre></div><p>It contains everything you'll need to manage nodes with Puppet:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">User accounts and SSH keys</li><li class="listitem" style="list-style-type: disc">SSH and <code class="literal">sudoers</code> config</li><li class="listitem" style="list-style-type: disc">Time zone and NTP settings</li><li class="listitem" style="list-style-type: disc">Hiera data</li><li class="listitem" style="list-style-type: disc">Automatic Puppet update and apply scripts</li><li class="listitem" style="list-style-type: disc">Bootstrap script for new nodes</li></ul></div><p>It also includes a Vagrantfile so you can try out the repo on a Vagrant virtual machine.</p><div class="section" title="Copying the repo"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec203"/>Copying the repo</h2></div></div></div><p>If you are going to use the <a id="id580" class="indexterm"/>demo repo as the basis for your own Puppet repo, you need to make a copy of it so that you can edit and maintain it yourself.</p><p>You can do this in two ways. One is to <span class="emphasis"><em>fork</em></span> the repo to your own GitHub account. To do this, log in to GitHub and browse to the demo repo URL:</p><p>
<a class="ulink" href="https://github.com/bitfield/control-repo-3.git">https://github.com/bitfield/control-repo-3.git</a>
</p><p>Look for the <span class="strong"><strong>Fork</strong></span> button at the top right of the page and click it. This will create a new repo under your account that will contain all the code and history from the demo repo.</p><p>Alternatively, you can follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new repo in your GitHub account (name it <code class="literal">puppet</code>, <code class="literal">control-repo</code>, or whatever you prefer).</li><li class="listitem">Make a note of the repo URL.</li><li class="listitem">Clone the demo repo to your personal machine:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>git clone -b production https://github.com/bitfield/control-repo-3</strong></span>
<span class="strong"><strong>cd control-repo-3</strong></span>
</pre></div></li><li class="listitem">Rename the original repository remote (so you can get updates in future):<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>git remote rename origin upstream</strong></span>
</pre></div></li><li class="listitem">Add your new repo as the <code class="literal">origin</code> remote (using the URL for your repo you noted earlier):<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>git remote add origin YOUR_GIT_URL</strong></span>
</pre></div></li><li class="listitem">Push to the new remote:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>git push origin production</strong></span>
</pre></div></li></ol></div><p>Your repo now contains a <a id="id581" class="indexterm"/>complete copy of the demo repo, which you can edit and customize just as you like.</p><p>As the original repo is updated in the future, you will be able to pull these changes into your own version. To get changes from upstream, run the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>git fetch upstream</strong></span>
<span class="strong"><strong>git rebase upstream/production</strong></span>
</pre></div></div></div></div>
<div class="section" title="Understanding the demo repo"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec69"/>Understanding the demo repo</h1></div></div></div><p>It's now time to see how all the <a id="id582" class="indexterm"/>ideas from the previous chapters fit together. It should be helpful for you to see how a complete Puppet infrastructure works, and you can also use this repo as a basis for your own projects. We'll see how you can do that later in the chapter, but first, a word or two about the overall structure of the repo.</p><div class="section" title="The control repo"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec204"/>The control repo</h2></div></div></div><p>A <span class="strong"><strong>control repo</strong></span> is a <a id="id583" class="indexterm"/>Puppet codebase which contains no modules, or only site-specific <a id="id584" class="indexterm"/>modules, and it's a good way to organize your Puppet code.</p><p>In <a class="link" href="ch07.html" title="Chapter 7. Mastering modules">Chapter 7</a>, <span class="emphasis"><em>Mastering modules</em></span> we learned about using the <code class="literal">r10k</code> tool to manage modules with a Puppetfile. The Puppetfile specifies which modules we use, with their exact versions, and their sources (usually Puppet Forge, but they can also come from remote Git repos).</p><p>Therefore, our Puppet repo needs to contain only a Puppetfile, along with our Hiera data, and the <code class="literal">role</code> and <code class="literal">profile</code> modules.</p></div><div class="section" title="Module management"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec205"/>Module management</h2></div></div></div><p>Because <code class="literal">r10k</code> expects to <a id="id585" class="indexterm"/>manage everything in the <code class="literal">modules/</code> directory using the Puppetfile, our <span class="strong"><strong>site-specific modules</strong></span> are kept in a separate directory in the control repo named <code class="literal">site-modules/</code>.</p><p>To enable this, we need to add the following setting to the <code class="literal">environment.conf</code> file:</p><div class="informalexample"><pre class="programlisting">modulepath = "modules:site-modules:$basemodulepath"</pre></div><p>This adds <code class="literal">site-modules/</code> to the list of places Puppet will look for modules.</p><p>As detailed in <a class="link" href="ch07.html" title="Chapter 7. Mastering modules">Chapter 7</a>, <span class="emphasis"><em>Mastering modules</em></span>, we will be using <code class="literal">r10k</code> and a Puppetfile to manage all third-party modules. Accordingly, there is no <code class="literal">modules/</code> directory in the demo repo: <code class="literal">r10k</code> will create this when it installs the required modules.</p><p>Here's the Puppetfile with the list of modules we need for the initial repo. Of course, as you adapt the repo to your own needs, you'll be adding more modules to this list (<code class="literal">Puppetfile</code>):</p><div class="informalexample"><pre class="programlisting">forge "http://forge.puppetlabs.com"

# Modules from the Puppet Forge
mod 'puppetlabs/accounts', '1.1.0'
mod 'puppetlabs/ntp', '6.2.0'
mod 'puppetlabs/stdlib', '4.19.0'
mod 'saz/sudo', '4.2.0'
mod 'saz/timezone', '3.5.0'
mod 'stm/debconf', '2.0.0'</pre></div><p>We'll see how these modules are used in the following sections.</p><p>Every so often, use the <code class="literal">generate-puppetfile</code> tool to automatically update your module versions and dependencies (see <a class="link" href="ch07.html" title="Chapter 7. Mastering modules">Chapter 7</a>, <span class="emphasis"><em>Mastering modules</em></span> for more about this). Run the following command in the repo directory:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>generate-puppetfile -p Puppetfile</strong></span>
</pre></div><p>Copy and paste the output back into your Puppetfile, replacing the existing <code class="literal">mod</code> statements.</p></div><div class="section" title="Classes"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec206"/>Classes</h2></div></div></div><p>As you may recall <a id="id586" class="indexterm"/>from <a class="link" href="ch08.html" title="Chapter 8. Classes, roles, and profiles">Chapter 8</a>, <span class="emphasis"><em>Classes, roles, and profiles</em></span>, we use Hiera <a id="id587" class="indexterm"/>data to determine which classes and resources should be applied to the node. The common classes are listed in <code class="literal">common.yaml</code>, and there is a per-node data file for the <code class="literal">demo</code> node which includes the <code class="literal">role::demo</code> class. These classes are included by the following line in <code class="literal">manifests/site.pp</code>:</p><div class="informalexample"><pre class="programlisting">include(lookup('classes', Array[String], 'unique'))</pre></div></div><div class="section" title="Roles"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec207"/>Roles</h2></div></div></div><p>
<span class="strong"><strong>Role classes</strong></span> identify by <a id="id588" class="indexterm"/>name what the function of the node is, and define what <a id="id589" class="indexterm"/>profile classes should be included (see <a class="link" href="ch08.html" title="Chapter 8. Classes, roles, and profiles">Chapter 8</a>, <span class="emphasis"><em>Classes, roles, and profiles</em></span> for more about this).</p><p>It's common practice to keep your role classes in a <code class="literal">role</code> module, and as this is a site-specific module, it's filed under <code class="literal">site-modules/</code>.</p><p>Here's the <code class="literal">role::demo</code> role manifest (<code class="literal">site-modules/role/manifests/demo.pp</code>):</p><div class="informalexample"><pre class="programlisting"># Be the demo node
class role::demo {
  include profile::common
}</pre></div></div><div class="section" title="Profiles"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec208"/>Profiles</h2></div></div></div><p>A <span class="strong"><strong>profile class</strong></span> identifies by <a id="id590" class="indexterm"/>name some specific piece of software or functionality <a id="id591" class="indexterm"/>required for a role, and declares the necessary resources to manage it (refer to <a class="link" href="ch08.html" title="Chapter 8. Classes, roles, and profiles">Chapter 8</a>, <span class="emphasis"><em>Classes, roles, and profiles</em></span> for a more detailed explanation of profiles).</p><p>Often, there are profiles which are common to all nodes: our user accounts, for example, and a few others. It's logical to keep these in the <code class="literal">common.yaml</code> Hiera data file, so that these profiles will be included by all nodes.</p><p>Here are the classes included in <code class="literal">common.yaml</code>:</p><div class="informalexample"><pre class="programlisting">classes:
- profile::ntp
- profile::puppet
- profile::ssh
- profile::sudoers
- profile::timezone
- profile::users</pre></div><p>We'll see what each of these profiles do in the following sections.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip59"/>Tip</h3><p>In the Hiera data, classes are listed in alphabetical order: this can be helpful when you have many classes included, and can make it easier to see whether or not a given class is already in the list. When you add new classes, make sure you keep the list in alphabetical order.</p></div></div></div><div class="section" title="Users and access control"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec209"/>Users and access control</h2></div></div></div><p>The <code class="literal">puppetlabs/accounts</code> <a id="id592" class="indexterm"/>module provides a standard way to handle user accounts with the <code class="literal">accounts::user</code> class. Accordingly, we will use this to manage our users in the <code class="literal">profile::users</code> class.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>If you prefer to manage user accounts directly in Puppet using the <code class="literal">user</code> and <code class="literal">ssh_authorized_key</code> resources, see <a class="link" href="ch04.html" title="Chapter 4. Understanding Puppet resources">Chapter 4</a>, <span class="emphasis"><em>Understanding Puppet resources</em></span> for more information.</p></div></div><p>You could just list the required users as literal resources in your Puppet manifest, of course. But instead let's take the data-driven approach described in <a class="link" href="ch06.html" title="Chapter 6. Managing data with Hiera">Chapter 6</a>, <span class="emphasis"><em>Managing data with Hiera</em></span>, and define our users with Hiera data.</p><p>This is what the data structure looks like (<code class="literal">data/common.yaml</code>):</p><div class="informalexample"><pre class="programlisting">
users:
  'john':
    comment: 'John Arundel'
    uid: '1010'
    sshkeys:
      - 'ssh-rsa AAAA ...'
  'bridget':
    comment: 'Bridget X. Zample'
    uid: '1011'
    sshkeys:
      - 'ssh-rsa AAAA ...'</pre></div><p>Here's the code in the <code class="literal">users</code> profile to read the data and create the corresponding <code class="literal">accounts::user</code> resources (<code class="literal">site-modules/profile/manifests/users.pp</code>):</p><div class="informalexample"><pre class="programlisting"># Set up users
class profile::users {
  lookup('users', Hash, 'hash').each | String $username, Hash $attrs | {
    accounts::user { $username:
      * =&gt; $attrs,
    }
  }
}</pre></div><p>As you can see, we fetch all the user data into a single <code class="literal">$users</code> hash with a call to <code class="literal">lookup()</code>. We iterate over the hash, declaring an <code class="literal">accounts::user</code> resource for each user, whose attributes are loaded from the hash data.</p><p>Note that when using the <code class="literal">accounts::user</code> resource, the <code class="literal">sshkeys</code> attribute must contain an array of authorized <a id="id593" class="indexterm"/>SSH public keys for the user.</p></div><div class="section" title="SSH configuration"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec210"/>SSH configuration</h2></div></div></div><p>It's good security <a id="id594" class="indexterm"/>practice to restrict SSH logins to a set of named users, using the <code class="literal">AllowUsers</code> directive in <code class="literal">/etc/ssh/sshd_config</code>. We used a Puppet template to <a id="id595" class="indexterm"/>build this config file in <a class="link" href="ch09.html" title="Chapter 9. Managing files with templates">Chapter 9</a>, <span class="emphasis"><em>Managing files with templates</em></span>. In that example, we got the list of allowed users from Hiera, and we will do the same here.</p><p>Here's the template for the <code class="literal">sshd_config</code> file (<code class="literal">site-modules/profile/templates/ssh/sshd_config.epp</code>):</p><div class="informalexample"><pre class="programlisting">&lt;%- | Array[String] $allow_users | -%&gt;
# File is managed by Puppet

AcceptEnv LANG LC_*
ChallengeResponseAuthentication no
GSSAPIAuthentication no
PermitRootLogin no
PrintMotd no
Subsystem sftp internal-sftp
AllowUsers &lt;%= join($allow_users, ' ') %&gt;
UseDNS no
UsePAM yes
X11Forwarding yes</pre></div><p>We declare that the template takes an <code class="literal">$allow_users</code> parameter which is an Array of String values. Because the <code class="literal">AllowUsers</code> parameter in <code class="literal">sshd_config</code> expects a space-separated list of users, we call the <code class="literal">join()</code> function from the standard library to create this list from the Puppet array (see <a class="link" href="ch07.html" title="Chapter 7. Mastering modules">Chapter 7</a>, <span class="emphasis"><em>Mastering modules</em></span>, for more about this and other standard library functions).</p><p>Here's the relevant Hiera data (<code class="literal">data/common.yaml</code>):</p><div class="informalexample"><pre class="programlisting">
allow_users:
  - 'john'
  - 'bridget'
  - 'ubuntu'</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip60"/>Tip</h3><p>We could have just constructed the list from the <code class="literal">$users</code> hash, which contains all known users, but we don't necessarily want everyone on that list to be able to log in to every node. Conversely, we may need to allow logins for some accounts which are not managed by Puppet. An example is the <code class="literal">ubuntu</code> account, which is required by Vagrant in order to manage the VM properly. If you're not using Vagrant boxes, you can remove the <code class="literal">ubuntu</code> user from this list.</p></div></div><p>The code to read this <a id="id596" class="indexterm"/>Hiera data and populate the template is as follows (<code class="literal">site-modules/profile/manifests/ssh.pp</code>):</p><div class="informalexample"><pre class="programlisting"># Manage sshd config
class profile::ssh {
  ensure_packages(['openssh-server'])

  file { '/etc/ssh/sshd_config':
    content =&gt; epp('profile/ssh/sshd_config.epp', {
      'allow_users' =&gt; lookup('allow_users', Array[String], 
        'unique'),
    }),
    notify  =&gt; Service['ssh'],
  }

  service { 'ssh':
    ensure =&gt; running,
    enable =&gt; true,
  }
}</pre></div><p>This is a package-file-service pattern, which you may remember from <a class="link" href="ch02.html" title="Chapter 2. Creating your first manifests">Chapter 2</a>, <span class="emphasis"><em>Creating your first manifests</em></span>.</p><p>First, we install the <code class="literal">openssh-server</code> package (this is usually already installed, but it's good style to declare the package anyway, since we rely on it for what follows).</p><p>Next, we manage the <code class="literal">/etc/ssh/sshd_config</code> file with a template, which we populate using Hiera data from a call to <code class="literal">lookup('allow_users', Array[String], 'unique')</code>. This file notifies the <code class="literal">ssh</code> service whenever it changes.</p><p>Finally, we declare the <code class="literal">ssh</code> service and specify that it should be running and enabled at boot time.</p></div><div class="section" title="Sudoers configuration"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec211"/>Sudoers configuration</h2></div></div></div><p>The <code class="literal">sudo</code> command is <a id="id597" class="indexterm"/>the standard Unix mechanism for <a id="id598" class="indexterm"/>controlling <span class="strong"><strong>user privileges</strong></span>. It's usually used to allow normal users to run commands with the privileges of the <code class="literal">root</code> user.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip61"/>Tip</h3><p>Using <code class="literal">sudo</code> is preferable to allowing people to log in and run a shell as <code class="literal">root</code>, and <code class="literal">sudo</code> also audits and records which user ran which commands. You can also specify very fine-grained permissions, such as allowing a user to run only a certain command as <code class="literal">root</code>, but no others.</p></div></div><p>The most popular Forge module for managing <code class="literal">sudo</code> permissions is <code class="literal">saz/sudo</code>, and that's what we'll use here. Here's the Hiera data listing the users with <code class="literal">sudo</code> access (<code class="literal">data/common.yaml</code>):</p><div class="informalexample"><pre class="programlisting">
sudoers:
  - 'john'
  - 'bridget'
  - 'ubuntu'</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip62"/>Tip</h3><p>If you're not using Vagrant, you can remove the <code class="literal">ubuntu</code> user from this list.</p></div></div><p>Here's the <code class="literal">profile</code> class which reads the data (<code class="literal">site-modules/profile/manifests/sudoers.pp</code>):</p><div class="informalexample"><pre class="programlisting"># Manage user privileges
class profile::sudoers {
  sudo::conf { 'secure_path':
    content  =&gt; 'Defaults      secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/puppetlabs/puppet/bin:/opt/puppetlabs/bin"',
    priority =&gt; 0,
  }
  $sudoers = lookup('sudoers', Array[String], 'unique', [])
  $sudoers.each | String $user | {
    sudo::conf { $user:
      content  =&gt; "${user} ALL=(ALL) NOPASSWD: ALL",
      priority =&gt; 10,
    }
  }
}</pre></div><p>This allows us to run commands like <code class="literal">sudo</code> puppet, as a normal user. That's what this part of the manifest does:</p><div class="informalexample"><pre class="programlisting">  sudo::conf { 'secure_path':
    content  =&gt; 'Defaults      secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/puppetlabs/puppet/bin:/opt/puppetlabs/bin"',
    priority =&gt; 0,
  }</pre></div><p>The <code class="literal">sudo::conf</code> resource, provided by the <code class="literal">saz/sudo</code> module, allows us to write arbitrary <code class="literal">sudoers</code> config as a string: in this case, setting the <code class="literal">secure_path</code> variable.</p><p>The remainder of the profile is concerned with configuring passwordless <code class="literal">sudo</code> privileges for each user named in the <a id="id599" class="indexterm"/>Hiera array <code class="literal">sudoers</code>. As usual, we get the array from Hiera and proceed to iterate over it with <code class="literal">each</code>, creating a <code class="literal">sudo::conf</code> resource for each named user.</p></div><div class="section" title="Time zone and clock synchronization"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec212"/>Time zone and clock synchronization</h2></div></div></div><p>There is a <a id="id600" class="indexterm"/>handy Forge module for managing server time zones: <code class="literal">saz/timezone</code>. Here's our <code class="literal">timezone</code> profile which uses that module to set all nodes to UTC (<code class="literal">site-modules/profile/manifests/timezone.pp</code>):</p><div class="informalexample"><pre class="programlisting"># Set the time zone for all nodes
class profile::timezone {
  class { 'timezone':
    timezone =&gt; 'Etc/UTC',
  }
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip63"/>Tip</h3><p>It may seem tempting to set the node's time zone to your own local time zone, instead of UTC. However, this idea doesn't scale. When you have nodes in multiple time zones, or all over the world, they will all be in different time zones, this will lead to very confusing results when you try to compare timestamps from different log files. Always set the node's time zone to UTC, and then you'll never be confused (at least, not about that).</p></div></div><p>Similarly, we want to make sure that the clocks on all our nodes are synchronized, not only with each other, but with the global time standard as a whole. We will be using the <code class="literal">puppetlabs/ntp</code> module for this, and here is the relevant profile (<code class="literal">site-modules/profile/manifests/ntp.pp</code>):</p><div class="informalexample"><pre class="programlisting"># Synchronize with NTP
class profile::ntp {
  include ::ntp
}</pre></div><p>As it happens, there's no special configuration to do for NTP (though you could, if you wanted, specify a <a id="id601" class="indexterm"/>list of time servers to contact, for example).</p></div><div class="section" title="Puppet configuration"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec213"/>Puppet configuration</h2></div></div></div><p>We need to <a id="id602" class="indexterm"/>configure a regular cron job which pulls any updates from the Git repo and runs Puppet to apply the updated manifest.</p><p>The <code class="literal">profile::puppet</code> class sets this up (<code class="literal">site-modules/profile/manifests/puppet.pp</code>):</p><div class="informalexample"><pre class="programlisting"># Set up Puppet config and cron run
class profile::puppet {
  service { ['puppet', 'mcollective', 'pxp-agent']:
    ensure =&gt; stopped, # Puppet runs from cron
    enable =&gt; false,
  }

  cron { 'run-puppet':
    ensure  =&gt; present,
    command =&gt; '/usr/local/bin/run-puppet',
    minute  =&gt; '*/10',
    hour    =&gt; '*',
  }

  file { '/usr/local/bin/run-puppet':
    source =&gt; 'puppet:///modules/profile/puppet/run-puppet.sh',
    mode   =&gt; '0755',
  }

  file { '/usr/local/bin/papply':
    source =&gt; 'puppet:///modules/profile/puppet/papply.sh',
    mode   =&gt; '0755',
  }
}</pre></div><p>There are a fair number of resources in this profile, so let's look at each of them in turn.</p><p>First, we stop and disable some of the services started by the Puppet package, which we won't need:</p><div class="informalexample"><pre class="programlisting">  service { ['puppet', 'mcollective', 'pxp-agent']:
    ensure =&gt; stopped, # Puppet runs from cron
    enable =&gt; false,
  }</pre></div><p>Next follows the cron job which carries out the regular Git updates and Puppet runs. The <code class="literal">run-puppet</code> script looks like this (<code class="literal">site-modules/profile/files/run-puppet.s</code>h):</p><div class="informalexample"><pre class="programlisting">#!/bin/bash
cd /etc/puppetlabs/code/environments/production &amp;&amp; git pull
/opt/puppetlabs/puppet/bin/r10k puppetfile install
/opt/puppetlabs/bin/puppet apply --environment production manifests/</pre></div><p>Here's the <code class="literal">cron</code> <a id="id603" class="indexterm"/>resource which runs the script:</p><div class="informalexample"><pre class="programlisting">  cron { 'run-puppet':
    ensure  =&gt; present,
    command =&gt; '/usr/local/bin/run-puppet',
    minute  =&gt; '*/10',
    hour    =&gt; '*',
  }</pre></div><p>The job is set to run every 10 minutes, but you can adjust this if you need to.</p><p>This looks very much like the <code class="literal">run-puppet</code> script you may recall from <a class="link" href="ch03.html" title="Chapter 3. Managing your Puppet code with Git">Chapter 3</a>, <span class="emphasis"><em>Managing your Puppet code with Git</em></span>. The only difference is the extra step to run <code class="literal">r10k puppetfile install</code> (in case you added any new external modules in to the Puppetfile) and the addition of the <code class="literal">--environment</code> switch to <code class="literal">puppet apply</code>.</p><p>The next resource in <code class="literal">profile::puppet</code> deploys a convenience script named <code class="literal">papply</code>, which saves you from having to type the whole <code class="literal">puppet apply</code> command manually (<code class="literal">site-modules/profile/files/papply.sh</code>):</p><div class="informalexample"><pre class="programlisting">#!/bin/bash
environment=${PUPPET_ENV:-production}
/opt/puppetlabs/puppet/bin/r10k puppetfile install
/opt/puppetlabs/bin/puppet apply --environment ${environment} --strict=warning /etc/puppetlabs/code/environments/${environment}/manifests/ $*</pre></div><p>Just running <code class="literal">papply</code> from the command line will apply Puppet immediately, without pulling any Git changes.</p><p>If you want to test Puppet changes from a different environment (for example, if you have a staging branch checked out at <code class="literal">/etc/puppetlabs/code/environments/staging</code>), you can control this with the <code class="literal">PUPPET_ENV</code> variable, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>PUPPET_ENV=staging papply</strong></span>
</pre></div><p>Note that <code class="literal">papply</code> passes its command-line arguments on to Puppet (with <code class="literal">$*</code>), so you can add any arguments supported by the <code class="literal">puppet apply</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>papply --noop --show_diff</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip64"/>Tip</h3><p>We also supply the flag <code class="literal">--strict=warning</code> to the <code class="literal">puppet apply</code> command, which will cause Puppet to alert you if any potentially problematic code is encountered (such as referencing a variable which has not yet been defined). If you want Puppet to be really strict, set <code class="literal">--strict=error</code> instead, which will prevent the manifest being applied until all such problems are fixed.</p></div></div></div></div>
<div class="section" title="The bootstrap process"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec70"/>The bootstrap process</h1></div></div></div><p>In order to prepare a <a id="id604" class="indexterm"/>new node for Puppet management using the demo repo, we need to do a number of things:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Install Puppet</li><li class="listitem" style="list-style-type: disc">Clone the Git repo</li><li class="listitem" style="list-style-type: disc">Run Puppet for the first time</li></ul></div><p>In <a class="link" href="ch03.html" title="Chapter 3. Managing your Puppet code with Git">Chapter 3</a>, <span class="emphasis"><em>Managing your Puppet code with Git</em></span>, we performed these steps manually, but the demo repo automates this process (usually known as <span class="strong"><strong>bootstrap</strong></span>). Here is the bootstrap script (<code class="literal">scripts/bootstrap.sh</code>):</p><div class="informalexample"><pre class="programlisting">#!/bin/bash
PUPPET_REPO=$1
HOSTNAME=$2
BRANCH=$3
if [ "$#" -ne 3 ]; then
  echo "Usage: $0 PUPPET_REPO HOSTNAME BRANCH"
  exit 1
fi
hostname ${HOSTNAME}
echo ${HOSTNAME} &gt;/etc/hostname
source /etc/lsb-release
apt-key adv --fetch-keys http://apt.puppetlabs.com/DEB-GPG-KEY-puppet
wget http://apt.puppetlabs.com/puppetlabs-release-${DISTRIB_CODENAME}.deb
dpkg -i puppetlabs-release-${DISTRIB_CODENAME}.deb
apt-get update
apt-get -y install git puppet-agent
cd /etc/puppetlabs/code/environments
mv production production.orig
git clone ${PUPPET_REPO} production
cd production
git checkout ${BRANCH}
/opt/puppetlabs/puppet/bin/gem install r10k --no-rdoc --no-ri
/opt/puppetlabs/puppet/bin/r10k puppetfile install --verbose
/opt/puppetlabs/bin/puppet apply --environment=production /etc/puppetlabs/code/environments/production/manifests/</pre></div><p>It expects to be run with three arguments (we'll see how this is done in a moment): <code class="literal">PUPPET_REPO</code>, the Git URL for the Puppet repo to clone, <code class="literal">HOSTNAME</code>, the desired hostname for the node, and <code class="literal">BRANCH</code>, the branch of the Puppet repo to use.</p><p>First, the script sets the specified hostname:</p><div class="informalexample"><pre class="programlisting">hostname ${HOSTNAME}
echo ${HOSTNAME} &gt;/etc/hostname</pre></div><p>Next, it looks at the <code class="literal">/etc/lsb-release</code> file to find out the version of Ubuntu installed.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip65"/>Tip</h3><p>This script is <a id="id605" class="indexterm"/>Ubuntu-specific, but you can easily modify it to work with a different Linux distribution if you need to.</p></div></div><p>The appropriate Puppet Labs APT repository package is downloaded with <code class="literal">wget</code> and installed. Then the <code class="literal">puppet-agent</code> package is installed along with <code class="literal">git</code>:</p><div class="informalexample"><pre class="programlisting">source /etc/lsb-release
apt-key adv --fetch-keys http://apt.puppetlabs.com/DEB-GPG-KEY-puppet
wget http://apt.puppetlabs.com/puppetlabs-release-${DISTRIB_CODENAME}.deb
dpkg -i puppetlabs-release-${DISTRIB_CODENAME}.deb
apt-get update &amp;&amp; apt-get -y install git puppet-agent</pre></div><p>The next step in the bootstrap process is to clone the Git repo into the place where Puppet expects to find its manifests:</p><div class="informalexample"><pre class="programlisting">cd /etc/puppetlabs/code/environments
mv production production.orig
git clone ${PUPPET_REPO} production
cd production
git checkout ${BRANCH}</pre></div><p>Next, we install <code class="literal">r10k</code> (in Puppet's gem context, using the Puppet-specific <code class="literal">gem</code> command) and run <code class="literal">r10k puppetfile install</code>, to install all the required modules listed in the <code class="literal">Puppetfile</code>:</p><div class="informalexample"><pre class="programlisting">/opt/puppetlabs/puppet/bin/gem install r10k --no-rdoc --no-ri
/opt/puppetlabs/puppet/bin/r10k puppetfile install --verbose</pre></div><p>Now we can run Puppet for the first time, which will configure everything else we need:</p><div class="informalexample"><pre class="programlisting">/opt/puppetlabs/bin/puppet apply --environment=production /etc/puppetlabs/code/environments/production/manifests/</pre></div><p>Of course, in order to run this script on the target node, we have to copy it there first. This step is performed by the <code class="literal">puppify</code> script (<code class="literal">scripts/puppify</code>):</p><div class="informalexample"><pre class="programlisting">#!/bin/bash
PUPPET_REPO=https://github.com/bitfield/control-repo-3.git
IDENTITY="-i /Users/john/.ssh/pbg.pem"
if [ "$#" -lt 2 ]; then
  cat &lt;&lt;USAGE
Usage: $0 TARGET HOSTNAME [BRANCH]
Install Puppet on the node TARGET (IP address or DNS name) and run
the bootstrap process. Set the hostname to HOSTNAME, and optionally use
the control repo branch BRANCH.
USAGE
  exit 1
fi
TARGET=$1
HOSTNAME=${2}
BRANCH=${3:-production}
OPTIONS="-oStrictHostKeyChecking=no"
echo -n "Copying bootstrap script... "
scp ${IDENTITY} ${OPTIONS} $(dirname $0)/bootstrap.sh ubuntu@${TARGET}:/tmp
echo "done."
echo -n "Bootstrapping... "
ssh ${IDENTITY} ${OPTIONS} ubuntu@${TARGET} "sudo bash /tmp/bootstrap.sh ${PUPPET_REPO} ${HOSTNAME} ${BRANCH}"
echo "done."</pre></div><p>First, the script sets the URL of the Git repo to clone (you'll need to change this to your own URL when you adapt the demo repo for your own use):</p><div class="informalexample"><pre class="programlisting">PUPPET_REPO=https://github.com/bitfield/control-repo-3.git</pre></div><p>Next, we specify the key file used to connect to the target node via SSH (again, modify this to use your own key):</p><div class="informalexample"><pre class="programlisting">IDENTITY="-i /Users/john/.ssh/pbg.pem"</pre></div><p>After the usage message and processing the command-line arguments, the script proceeds to copy the <code class="literal">bootstrap.sh</code> file to the target node:</p><div class="informalexample"><pre class="programlisting">scp ${IDENTITY} ${OPTIONS} $(dirname $0)/bootstrap.sh ubuntu@${TARGET}:/tmp</pre></div><p>The final step is to <a id="id606" class="indexterm"/>run the bootstrap script on the node, passing it the required command-line arguments:</p><div class="informalexample"><pre class="programlisting">ssh ${IDENTITY} ${OPTIONS} ubuntu@${TARGET} "sudo bash /tmp/bootstrap.sh ${PUPPET_REPO} ${HOSTNAME} ${BRANCH}"</pre></div></div>
<div class="section" title="Adapting the repo for your own use"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec71"/>Adapting the repo for your own use</h1></div></div></div><p>You will need to <a id="id607" class="indexterm"/>change some of the data and settings in the demo repo to be able to use it yourself. To get you started, here is a table showing which files to change and what information you'll need to supply, with more detailed explanations in the following sections:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>File</p>
</th><th style="text-align: left" valign="bottom">
<p>What to change</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">data/common.yaml</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">users</code>: Users and SSH keys common to all nodes</p>
<p>
<code class="literal">allow_users</code>: Users allowed to log in to all nodes</p>
<p>
<code class="literal">sudoers</code>: Users allowed to use <code class="literal">sudo</code> on all nodes</p>
<p>
<code class="literal">classes</code>: Classes included by all nodes</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">data/nodes/[NODE NAME].yaml</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">users</code>: Users and SSH keys that only exist on this node</p>
<p>
<code class="literal">allow_users</code>: Users allowed to log in to only this node</p>
<p>
<code class="literal">sudoers</code>: Users allowed to use <code class="literal">sudo</code> on only this node</p>
<p>
<code class="literal">classes</code>: Classes included only by this node</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">site-modules/role/manifests/</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Role classes for your nodes (include <code class="literal">profile::common</code> in each one)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">scripts/puppify</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">PUPPET_REPO</code>: Git URL of your Puppet repo</p>
<p>
<code class="literal">IDENTITY</code>: Path to the SSH key for initial bootstrap of nodes, if you need one</p>
</td></tr></tbody></table></div><div class="section" title="Configuring users"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec214"/>Configuring users</h2></div></div></div><p>As we saw earlier <a id="id608" class="indexterm"/>in this chapter, the user accounts managed by Puppet are configured from Hiera data. Edit the <code class="literal">data/common.yaml</code> file, which looks like this:</p><div class="informalexample"><pre class="programlisting">
users:
  'john':
    comment: 'John Arundel'
    uid: '1010'
    sshkeys:
      - 'ssh-rsa AAAA... john@susie'
...</pre></div><p>Replace the existing users with the user accounts you want to create on nodes (at first it may just be one account, for yourself). Add any SSH keys you want to use with them to the <code class="literal">sshkeys</code> array.</p><p>The list of allowed users on each node is controlled by the <code class="literal">allow_users</code> array. Replace the users listed there with your own users.</p><p>The list of users with <code class="literal">sudo</code> privileges is controlled by the <code class="literal">sudoers</code> array. Replace the users listed there with those of your own users which you want to have root privileges.</p></div><div class="section" title="Adding per-node data files and role classes"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec215"/>Adding per-node data files and role classes</h2></div></div></div><p>Per-node Hiera <a id="id609" class="indexterm"/>data, including classes, is kept in the <code class="literal">data/nodes/</code> directory. When you add a new node, add a data file for it named <code class="literal">data/nodes/NODE_NAME.yaml</code>, replacing <code class="literal">NODE_NAME</code> with the node's hostname.</p><p>Include role classes <a id="id610" class="indexterm"/>suitable to the node (see <a class="link" href="ch08.html" title="Chapter 8. Classes, roles, and profiles">Chapter 8</a>, <span class="emphasis"><em>Classes, roles, and profiles</em></span> for more information about this). If you don't specify any classes in the per-node file, the node will just include the classes listed in <code class="literal">common.yaml</code>. This will be enough to set your node up with your SSH account and key, and validate that the bootstrap process works properly. Later, you can start adding role classes to the per-node file to get actual work done.</p><p>Add your role classes to the <code class="literal">site-modules/role/manifests/</code> directory, along the lines of <code class="literal">role::demo</code>.</p><p>If there are users which you only need on a specific node, and you don't want them to exist on all the nodes, list them under <code class="literal">users</code> in the per-node data file. If they need to log in via SSH, add them to <code class="literal">allow_users</code> too. Similarly, if you need a user to have <code class="literal">sudo</code> rights only on this node, list them under <code class="literal">sudoers</code> in the per-node data file.</p></div><div class="section" title="Modifying the bootstrap credentials"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec216"/>Modifying the bootstrap credentials</h2></div></div></div><p>In the <code class="literal">scripts/puppify</code> file, edit the <code class="literal">PUPPET_REPO</code> setting to the URL of your own Git repo. If you need <a id="id611" class="indexterm"/>an SSH key to connect to the target node (for example, if you're using Amazon EC2, in which case you'll have a <code class="literal">.pem</code> file containing your key which you downloaded from the AWS console), add its location to the <code class="literal">IDENTITY</code> variable.</p></div></div>
<div class="section" title="Bootstrapping a new node"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec72"/>Bootstrapping a new node</h1></div></div></div><p>If you'd like to try <a id="id612" class="indexterm"/>out the demo repo on a Vagrant box, there is a suitable Vagrantfile included within the repo directory.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>If you don't have Vagrant installed, follow the instructions in the <span class="emphasis"><em>Installing VirtualBox and Vagrant</em></span> section of <a class="link" href="ch01.html" title="Chapter 1. Getting started with Puppet">Chapter 1</a>, <span class="emphasis"><em>Getting Started with Puppet</em></span> first.</p></div></div><div class="section" title="Bootstrapping a Vagrant VM"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec217"/>Bootstrapping a Vagrant VM</h2></div></div></div><p>Run the following <a id="id613" class="indexterm"/>command in the repo directory to start your Vagrant VM:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scripts/start_vagrant.sh</strong></span>
</pre></div></div><div class="section" title="Bootstrapping physical or cloud nodes"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec218"/>Bootstrapping physical or cloud nodes</h2></div></div></div><p>Alternatively, you can <a id="id614" class="indexterm"/>bootstrap a physical or cloud node using the repo. All you will need is the IP address or DNS name of the target node.</p><p>Run the following command from the Puppet repo, replacing <code class="literal">TARGET_SERVER</code> with the address or name of the node, and <code class="literal">HOSTNAME</code> with the hostname that you want to set (for example <code class="literal">demo</code>):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scripts/puppify TARGET_SERVER HOSTNAME</strong></span>
</pre></div><p>You will see some output related to copying the bootstrap script, installing the Puppet package, cloning the repo, installing the Forge modules, and running Puppet for the first time. Once this is completed, the node should be ready, and you can try logging in to it using your own SSH account.</p></div><div class="section" title="Using other distributions and providers"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec219"/>Using other distributions and providers</h2></div></div></div><p>The <code class="literal">puppify</code> <a id="id615" class="indexterm"/>and <code class="literal">bootstrap</code> scripts included with the demo repo will work for an Ubuntu node on Amazon EC2, but you can modify them to work with any Linux distribution or server provider.</p><p>For example, if you're using a <a id="id616" class="indexterm"/>
<span class="strong"><strong>Google Compute Engine</strong></span> (<span class="strong"><strong>GCE</strong></span>) instance, you can edit the <code class="literal">puppify</code> script to replace the <code class="literal">ssh</code> command with <code class="literal">gcloud compute ssh</code>. If you're using a Digital Ocean droplet, you can add your SSH key to the droplet when you provision it via the web interface, and you can modify the <code class="literal">puppify</code> script to log in as the <code class="literal">root</code> user instead of <code class="literal">ubuntu</code>.</p><p>If you're managing nodes on several different platforms, you may find it more convenient to use a customized <code class="literal">puppify</code> script for each one, naming them (for example) <code class="literal">puppify_ec2</code>, <code class="literal">puppify_linode</code>, and so on.</p><p>If you're not using Ubuntu or Debian, you may need to make some changes to the <code class="literal">bootstrap.sh</code> script. For example, if you're using Red Hat Linux or CentOS, you'll need to have the script install Puppet via <code class="literal">yum</code> instead of <code class="literal">apt</code>. Again, if you're managing nodes on multiple OS distributions, you may need to maintain a custom bootstrap script for each one.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec73"/>Summary</h1></div></div></div><p>In this chapter we've introduced the example control repo and seen how to download it. We've explained the control repo pattern, and how it works with <code class="literal">r10k</code> and the Puppetfile to manage third-party and local modules. We've learned how to fork the repo and pull changes from upstream.</p><p>We've looked at the example role and profile classes, and seen how Puppet can use Hiera data to configure user accounts, SSH keys, allowed users, and <code class="literal">sudoers</code> privileges. We've covered the use of Forge modules to manage time zone setting and NTP synchronization. Additionally, we've explored the resources and scripts necessary to control automatic Puppet updates and runs.</p><p>The demo repo contains bootstrap scripts to help you put a freshly-provisioned node under Puppet control, and we've examined how these scripts work in detail.</p><p>Finally, we've learned how to adapt the demo repo for your own site, and outlined how to add your own users and access settings, and your own common profiles, and per-node role classes. We 've seen how to plug in your own information to the bootstrap scripts and how to use them to bootstrap a new node.</p></div>
<div class="section" title="The beginning"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec74"/>The beginning</h1></div></div></div><p>I hope you've enjoyed this book and have learned something useful from it; I certainly learned a lot from writing it. However, there's only so much you can learn from books. As Proust wrote, "We don't receive wisdom; we must discover it for ourselves after a journey that no one can take for us or spare us."</p><p>It's good to have a friend point us in the right direction and come with us a little way for moral support, but then we need to walk on by ourselves. I hope that this book will be the beginning of your journey, not the end.</p><p>The world-famous classical guitarist John Williams was once asked how long it took him to learn to play the guitar. "I'm still learning," he said.</p></div></body></html>