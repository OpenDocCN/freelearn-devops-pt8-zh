- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How Not to Use IaC and Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Infrastructure as Code** (**IaC**) tools such as Terraform have revolutionized
    the way we manage cloud infrastructure, offering powerful capabilities for automating
    the deployment and configuration of complex environments. However, despite the
    benefits, there are still many situations where IaC and Terraform can be misused
    or overused, leading to inefficiencies, errors, and security vulnerabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll explore some basic Terraform commands, then compare Terraform
    and CloudFormation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover these main topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Terraform architecture and workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To compare with the others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terraform architecture and workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make the most of Terraform and use it effectively to manage your cloud infrastructure,
    it’s important to have a good understanding of its architecture and workflow.
    Terraform follows a declarative approach to infrastructure management, where you
    describe the desired state of your infrastructure using configuration files, and
    it takes care of provisioning and configuring the necessary resources to achieve
    that state.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll explore the key components of Terraform’s architecture
    and workflow, and provide a high-level overview of how Terraform works to manage
    infrastructure on cloud platforms such as AWS, Azure, and Google Cloud. Understanding
    these concepts will help you write more effective Terraform code and troubleshoot
    issues more easily.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Terraform is a tool that allows developers to describe the infrastructure and
    run it in any environment. Terraform has many use cases, such as building a whole
    data center or just a single server or resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Terraform – multi-cloud](img/B18198_02_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Terraform – multi-cloud
  prefs: []
  type: TYPE_NORMAL
- en: Terraform is a powerful infrastructure management tool that enables safe and
    efficient building, modification, and versioning of infrastructure. It is capable
    of managing both local and remote infrastructure, making it an ideal choice for
    distributed teams collaborating on a project from different geographical locations.
    With Terraform, teams can easily work together on complex infrastructure projects,
    regardless of their physical location, while ensuring that the infrastructure
    remains consistent and up to date.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Terraform architecture is quite simple; it is composed of just four components:'
  prefs: []
  type: TYPE_NORMAL
- en: Providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The modules are used to define the infrastructure and its components. The providers
    are responsible for how these modules should be executed in different environments.
    Resources are what we need to build our infrastructure, and templates are used
    to describe them easily. The following diagram outlines the technical flow for
    Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Terraform technical flow](img/B18198_02_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Terraform technical flow
  prefs: []
  type: TYPE_NORMAL
- en: Providers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Terraform providers are essentially plugins that Terraform installs to interact
    with remote systems, such as Azure, AWS, Google Cloud, VMware, and a lot of other
    vendors’ devices.
  prefs: []
  type: TYPE_NORMAL
- en: To interact with various cloud providers, SaaS providers, and other APIs, Terraform
    relies on plugins known as providers. These providers serve as the interface between
    Terraform and the target infrastructure, allowing Terraform to manage the desired
    resources. By leveraging a rich ecosystem of providers, Terraform enables users
    to manage infrastructure resources across multiple platforms using a unified,
    consistent syntax and workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform uses providers to provision resources, which describe one or more
    infrastructure objects such as virtual networks and compute instances. Each provider
    on the Terraform Registry has documentation detailing available resources and
    their configuration options.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven’t used any Terraform provider within your script, you won’t be
    able to manage or create any infrastructure. You can define more than one provider
    in your Terraform code.
  prefs: []
  type: TYPE_NORMAL
- en: If you are working with Terraform modules, then you need to declare the Terraform
    providers in your root module while the child modules inherit the provider configuration
    from the root module. Terraform providers follow their own release cadence and
    version number syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Terraform, a module is essentially a collection of Terraform template files
    that reside in a single directory. Even the most basic configuration consisting
    of just one directory with one or more `.tf` files is considered a **module**.
    When executing Terraform commands directly from such a directory, it’s referred
    to as the **root module**. By organizing infrastructure configurations into modules,
    users can encapsulate related resources and easily reuse them across different
    projects. This modularity enables teams to create scalable and maintainable infrastructure
    code, resulting in faster development and easier maintenance over time. The following
    shows a sample folder structure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Sample folder structure](img/B18198_02_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Sample folder structure
  prefs: []
  type: TYPE_NORMAL
- en: In Terraform, commands operate solely on the template files located in one specific
    directory, typically the current working directory. However, by utilizing module
    blocks in your templates, you can invoke modules residing in other directories.
    Whenever Terraform encounters a module block, it processes the configuration files
    for that module.
  prefs: []
  type: TYPE_NORMAL
- en: When a template calls a module, the module is considered a “child module” of
    that template. Modules can be sourced either locally or remotely. Terraform supports
    multiple remote sources, such as the Terraform Registry, various version control
    systems, HTTP URLs, and private module registries in Terraform Cloud or Terraform
    Enterprise. By leveraging remote modules, teams can more easily share and collaborate
    on infrastructure configurations.
  prefs: []
  type: TYPE_NORMAL
- en: There are over 10,000 modules published in the public Terraform Registry ready
    to use at [https://registry.terraform.io/browse/modules](https://registry.terraform.io/browse/modules),
    and you can start to use them to provision infrastructure right away.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go over the benefits of using modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Organize configuration**: Terraform offers modules as a means to simplify
    the organization and comprehension of your infrastructure configuration. This
    approach offers a more user-friendly experience, where users are not required
    to learn all of Terraform’s features, but instead can focus on the specific features
    they need. Infrastructure can be complex, and even relatively simple deployments
    may require hundreds or thousands of lines of code. By leveraging modules, you
    can logically group related configuration elements into discrete components, making
    it easier to manage and modify your infrastructure over time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encapsulate configuration**: Modules offer the additional advantage of encapsulating
    configuration into distinct, logical components. This encapsulation can help avoid
    unintended consequences, such as inadvertently modifying other infrastructure
    while attempting to change a single component, and also minimize the likelihood
    of simple errors, such as inadvertently assigning the same name to different resources.
    By keeping related configuration elements organized within their own modules,
    users can more easily understand and modify their infrastructure in a controlled
    and systematic manner, reducing the risk of unexpected errors and making it simpler
    to implement changes over time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reuse configuration**: Creating infrastructure configurations from scratch
    can be a time-intensive and error-prone process. By utilizing modules, however,
    users can save time, enforce governance, and minimize costly errors by reusing
    pre-existing configurations authored by themselves, their colleagues, or other
    members of the Terraform community who have made modules publicly available. Additionally,
    modules can be shared within teams or published publicly, offering users the ability
    to benefit from the expertise of others and distribute their own work to others
    who may find it useful. Ultimately, leveraging modules can help users work more
    efficiently and effectively, making it easier to implement and maintain infrastructure
    configurations over time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Provide consistency and ensure best practices**: In addition to facilitating
    efficient configuration development, modules also promote consistency across infrastructure
    configurations. Consistency is essential for comprehending complex configurations
    and ensures that best practices are applied uniformly across all configurations.
    For example, cloud providers offer numerous options for configuring object storage
    services such as Amazon S3 buckets. Improperly secured object storage has led
    to several critical security incidents, and due to the complexity of configuring
    these services, misconfiguration can occur easily.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Self-service**: Modules simplify the usage of your configuration by other
    teams. The Terraform Registry enables other teams to locate and utilize your approved
    and published Terraform modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Leveraging modules can enhance the governance of your resources**: For instance,
    modules can be utilized to define the configuration of your organization’s public
    website buckets, as well as separate modules for private buckets that serve logging
    applications. Furthermore, modules facilitate updates to resource configurations
    by allowing you to modify a configuration in one location, which can then be applied
    to all instances where the module is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Terraform uses resource blocks to manage various kinds of infrastructure, such
    as virtual networks, compute instances, and higher-level components including
    DNS records. These resource blocks map to one or more infrastructure objects within
    your Terraform configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, each Terraform provider has several distinct resources that correspond
    to the relevant APIs for managing a given infrastructure type. Resource declarations
    can include several advanced features, although only a limited subset is necessary
    for initial use. With advanced syntax features, such as single resource declarations
    that generate multiple similar remote objects, users can familiarize themselves
    with and confirm all the features of a resource provider’s documentation pages
    in the Terraform Registry.
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Terraform templates provide a way to create resources in the desired format
    on the target cloud providers or systems.
  prefs: []
  type: TYPE_NORMAL
- en: A Terraform template is a collection of files that define the desired state
    of your infrastructure to be achieved. They include different configuration files,
    such as variables, resources, and modules. You can keep a single file or multiple
    files under a directory, depending on your needs and personal choice.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered the components of the architecture, let’s look at the
    workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Terraform’s workflows consist of five fundamental steps:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.4 – Terraform’s \uFEFFworkflow](img/B18198_02_4.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Terraform’s workflow
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps involve the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Write**: This step involves creating modifications to the code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Init**: At this stage, you initialize your code and download the requirements
    specified in your code, such as providers.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Plan**: In this step, you review and predict the changes and determine whether
    to accept them.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Apply**: This is where you accept the changes and implement them on real
    infrastructure.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Destroy**: This final step involves destroying all the infrastructure you’ve
    created.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Details and actions vary between workflows. Let’s look at all the steps of the
    workflow in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Write
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To begin with, author your Terraform configuration just like you would write
    code in your preferred editor. It is standard practice to store your work in a
    version-controlled repository, even when working individually.
  prefs: []
  type: TYPE_NORMAL
- en: Init
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `terraform init` command initializes the working directory where Terraform
    configuration files are located. It is recommended to execute this command as
    the first step after creating a new Terraform configuration or cloning an existing
    one from version control.
  prefs: []
  type: TYPE_NORMAL
- en: Executing this command multiple times is safe. `terraform init` carries out
    several initialization processes that prepare the current working directory for
    Terraform use. While subsequent runs may produce errors, the command will not
    delete your existing configuration or state.
  prefs: []
  type: TYPE_NORMAL
- en: Most providers are available as Terraform plugins. When executing the command,
    Terraform scans the configuration for direct and indirect references to providers
    and attempts to install the corresponding plugins. The program automatically discovers,
    downloads, and installs appropriate provider plugins that are published in either
    the public registry or a third-party provider’s registry.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform stores information about the chosen providers in the dependency lock
    file after a successful installation. To ensure that Terraform selects the same
    provider versions when you run `terraform init` in the future, commit this file
    to your version control system.
  prefs: []
  type: TYPE_NORMAL
- en: The `terraform init` command can be used for various purposes, such as plugin
    installation, child module installation, and backend initialization.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Terraform initialization output](img/B18198_02_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Terraform initialization output
  prefs: []
  type: TYPE_NORMAL
- en: Plan
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `terraform plan` command generates an execution plan that enables you to
    preview the infrastructure modifications Terraform intends to make. Once a plan
    is generated, Terraform performs the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Reads the current state of existing remote objects to verify that the state
    is current
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compares the current state to the previous state, noting any discrepancies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suggests a set of actions that, if implemented, should ensure that the remote
    objects align with the configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `terraform plan` command itself does not implement the predicted modifications.
    Instead, it is intended for use before applying or sharing your changes with your
    team to verify that the proposed changes align with your expectations. If Terraform
    detects no resource changes, the `terraform plan` command indicates that no changes
    are required for the actual infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – terraform plan output](img/B18198_02_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – terraform plan output
  prefs: []
  type: TYPE_NORMAL
- en: Apply
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To execute the actions suggested by Terraform plan, use the `terraform apply`
    command. The simplest approach is to execute `terraform apply` without any arguments,
    which automatically generates a new execution plan (similar to running `terraform
    plan`) and asks for approval before executing the proposed actions.
  prefs: []
  type: TYPE_NORMAL
- en: Unless explicitly directed to skip approval, `terraform apply` prompts the user
    for confirmation before making any changes to the corresponding infrastructure
    provider’s API.
  prefs: []
  type: TYPE_NORMAL
- en: If no changes are detected in the configuration files compared to the current
    Terraform state, no modifications will be made to the infrastructure. Since Terraform
    is a declarative language, the `terraform apply` command can be executed multiple
    times safely.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.7 – \uFEFFterraform apply command](img/B18198_02_7.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – terraform apply command
  prefs: []
  type: TYPE_NORMAL
- en: Destroy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use the `terraform destroy` command to easily destroy all remote objects
    managed by a specific Terraform configuration. You should not destroy objects
    that last for a long time in a production environment, but sometimes Terraform
    is used to handle short-lived infrastructure for development purposes, where `terraform
    destroy` can helpfully remove all temporary objects when you don’t need them anymore.
  prefs: []
  type: TYPE_NORMAL
- en: The `terraform destroy` command should be used with caution and is not a command
    you would execute regularly. However, it is frequently used in non-production
    environments, where cleanup tasks are necessary for many proof-of-concept tests.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.8 – \uFEFFterraform destroy command](img/B18198_02_8.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – terraform destroy command
  prefs: []
  type: TYPE_NORMAL
- en: In summary, Terraform provides a set of commands to facilitate the creation,
    modification, and deletion of infrastructure resources. The `terraform init` command
    initializes the working directory where the Terraform configuration files are
    located. `terraform plan` generates an execution plan to preview the changes to
    be made to the infrastructure, while `terraform apply` executes the suggested
    changes after receiving user confirmation. Finally, `terraform destroy` destroys
    all remote objects managed by the configuration. With these commands, Terraform
    provides a powerful, flexible, and efficient toolset for managing IaC. Let’s compare
    other IaC tools to Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: To Compare with the Other IaC Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Terraform’s flexible abstraction of resources and providers allows it to represent
    a wide range of infrastructure components, from physical hardware and virtual
    machines to email and DNS providers. This versatility makes Terraform capable
    of addressing various issues.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform can manage virtually any cloud or virtual environment, including AWS,
    Microsoft Azure, and Google Cloud Platform, among others.
  prefs: []
  type: TYPE_NORMAL
- en: While this chapter focuses on using Terraform to manage AWS infrastructure,
    it is essential to note that Terraform is not exclusive to only cloud platforms.
    It can manage a single application or an entire data center.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform versus CloudFormation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to **IaC** tools for cloud-based resources, two of the most popular
    choices are Terraform and AWS CloudFormation. While both tools aim to provide
    a reliable, efficient, and safe way to manage cloud infrastructure, they differ
    in their approach and implementation. Terraform is an open source tool that offers
    a flexible and extensible language for creating and managing infrastructure. In
    contrast, CloudFormation is an **AWS** proprietary tool that uses JSON or YAML
    templates to define infrastructure resources. This section will compare and contrast
    the features and capabilities of Terraform and CloudFormation, to help you make
    an informed decision on which tool best suits your infrastructure management needs.
  prefs: []
  type: TYPE_NORMAL
- en: What is AWS CloudFormation?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CloudFormation is a service provided by **AWS** that simplifies the management
    of a collection of AWS resources, including provisioning and updating them as
    necessary. With CloudFormation, you can create, update, and delete stacks in response
    to changes in your application environment. This AWS-managed service also offers
    a straightforward approach to creating reusable templates that enable you to deploy
    cost-effective applications.
  prefs: []
  type: TYPE_NORMAL
- en: CloudFormation allows you to design and provision AWS and third-party resources
    for your cloud environment using a configuration format known as templates. These
    templates, written in either JSON or YAML format, allow for the reusability and
    scalability of infrastructure, making it easier to manage large-scale cloud environments.
    The following diagram illustrates how Amazon CloudFormation serves as the central
    orchestrator for various AWS services.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – AWS CloudFormation](img/B18198_02_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – AWS CloudFormation
  prefs: []
  type: TYPE_NORMAL
- en: Comparison and differences between Terraform and CloudFormation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Scope**: On the coverage side, CloudFormation is very powerful because it
    is developed and supported directly by AWS, but Terraform has a great community
    that always works at a fast pace to ensure new resources, and features are implemented
    for providers quickly.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Type**: CloudFormation is a managed service by AWS, but Terraform has a CLI
    tool that can run from your workstation, a server, or a CI/CD system (such as
    Jenkins, GitHub Actions, etc.) or Terraform Cloud (a SaaS automation solution
    from HashiCorp).'
  prefs: []
  type: TYPE_NORMAL
- en: '**License and support**: CloudFormation is a native AWS service, and AWS Support
    plans cover it as well. Terraform is an enterprise product and an open source
    project. HashiCorp offers 24/7 support, but at the same time, the huge Terraform
    community and provider developers are always helpful.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax**/**language**: CloudFormation supports both JSON and YAML formats.
    Terraform uses **HashiCorp Configuration Language** (**HCL**), which is human-readable
    as well as machine-friendly.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Architecture**: CloudFormation is an AWS-managed service to which you send/upload
    your templates for provisioning; on the other hand, Terraform is a decentralized
    system with which you can provision infrastructure from any workstation or server.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modularization**: In CloudFormation, nested stacks and cross-stack references
    can be used to achieve modularization, while Terraform is capable of creating
    reusable and reproducible modules.'
  prefs: []
  type: TYPE_NORMAL
- en: '**User experience**/**ease of use**: In contrast to CloudFormation, which is
    limited to AWS services, Terraform spans multiple cloud service providers such
    as AWS, Azure, and Google Cloud Platform, among others. This flexibility allows
    Terraform to provide a unified approach to managing cloud infrastructure across
    multiple providers, making it a popular choice for organizations that use more
    than one cloud provider.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Life cycle and state management**: CloudFormation stores the state and manages
    it with the use of stacks. Terraform stores the state on disk in JSON format and
    allows you to use a remote state system, such as an AWS S3 bucket, that gives
    you the capability of tracking versions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Import from existing infrastructure**: It is possible to import resources
    into CloudFormation, but only a few resources are supported. It is possible to
    import all resources into Terraform state, but it does not generate configuration
    in the process; you need to handle that. But there are third-party tools that
    can generate configuration, too.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Verification steps**: CloudFormation uses change sets to verify the required
    changes. Terraform has a powerful plan for identifying changes and allows you
    to verify your changes to existing infrastructure before applying them.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rolling updates and rollbacks**: CloudFormation automatically rolls back
    to the last working state. Terraform has no feature for rolling updates or rollbacks,
    but you can build a rollback system using a CI/CD system.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multi-cloud management**: CloudFormation is AWS-only, but Terraform supports
    multiple cloud providers and many more services.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Compliance integration**: CloudFormation is built by AWS, so compliance is
    already assured, but for Terraform, you need to implement third-party tools yourself
    to achieve compliance.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deployment type**: CloudFormation has a built-in CI/CD system that takes
    care of everything concerning deployment and rollbacks. Terraform can be deployed
    from any system, but you need to build your CI/CD workflow or adopt a service
    that can fill the gaps.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Drift detection**: Both tools have drift detection by default.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cost**: Using AWS CloudFormation does not incur any additional charges beyond
    the cost of the AWS resources that are created, such as Amazon EC2 instances or
    Elastic Load Balancing load balancers. In contrast, Terraform is an open source
    project that can be used free of charge. However, to obtain enterprise-level features
    such as CI/CD automation and state management, you may need to consider using
    additional services and systems provided by HashiCorp or third-party service providers.
    These additional services may come with their own costs.'
  prefs: []
  type: TYPE_NORMAL
- en: Terraform or CloudFormation – which should I choose?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The debate between Terraform and CloudFormation is ongoing and ultimately, the
    decision of which tool to use will depend on your personal preferences and requirements.
    Both tools offer unique benefits and features, so it’s important to evaluate which
    one aligns best with your organization’s goals and cloud infrastructure needs.
  prefs: []
  type: TYPE_NORMAL
- en: CloudFormation is a more fitting choice when your whole infrastructure relies
    on AWS and you have no intention of integrating a multi-cloud setup in the future.
    For newcomers to AWS services, the native AWS provided integration support can
    be quite advantageous. As it’s developed by AWS, CloudFormation enjoys quicker
    AWS-centric updates. It operates on JSON and YAML, thereby bypassing any potential
    learning hurdles associated with HCL.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, Terraform shines when there’s usage (even potential future
    usage) of multi-cloud resources and faster operation is desired. Its module-based
    design promotes the creation of repeatable templates, accelerating the configuration
    process. Additionally, Terraform provides a broader range of functions not found
    in CloudFormation, which is beneficial for quicker resource provisioning.
  prefs: []
  type: TYPE_NORMAL
- en: What is best for you ultimately depends on your requirements. You should assess
    your application’s infrastructure strategy, security and compliance requirements,
    and cloud adoption strategy to make a final decision.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter provided an overview of Terraform and its architecture and workflow,
    as well as a comparison between Terraform and CloudFormation. Terraform is a popular
    IaC tool that allows for safe and efficient management of infrastructure across
    multiple cloud providers. It relies on plugins called providers to interact with
    cloud providers, SaaS providers, and other APIs. Terraform uses modules to organize
    and encapsulate configurations into logical components, making it easier to navigate
    and understand complex configurations. Using modules can also provide consistency
    in your configurations and make them easier for other teams to use. Terraform
    uses resource blocks to manage infrastructure objects in your configuration, with
    most providers having several different resources that map to the appropriate
    APIs to manage that infrastructure type. The workflow of Terraform consists of
    five key steps: **Write**, **Init**, **Plan**, **Apply**, and **Destroy**.'
  prefs: []
  type: TYPE_NORMAL
- en: The chapter also compared Terraform to AWS CloudFormation, which is limited
    to AWS services, whereas Terraform can span multiple cloud service providers.
    While CloudFormation simplifies the process of managing the life cycle of AWS
    resources and provides a simple way to create reusable templates, Terraform’s
    flexibility allows for a unified approach to managing cloud infrastructure across
    multiple providers.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, the decision of whether to use Terraform or CloudFormation will
    depend on personal preference and requirements. Both tools offer unique benefits
    and features that can help organizations efficiently manage their cloud infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapter, we will delve into various key aspects of working with
    Terraform. Let’s start coding our first Terraform template.
  prefs: []
  type: TYPE_NORMAL
