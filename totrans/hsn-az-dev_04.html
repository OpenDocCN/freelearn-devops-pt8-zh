<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Distributed Applications and Microservices with Service Fabric</h1>
                </header>
            
            <article>
                
<p><strong>Service Fabric</strong> (<strong>SF</strong>) is a platform for distributed applications that greatly simplifies developing and deploying applications that are scalable and reliable. It's one of the best solutions for developing cloud-native apps and lets users focus on developing <span>rather</span> than on maintaining infrastructure and connections between particular components. It's a next-generation platform that is actively developed by Microsoft and has received much attention recently.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Microservice architecture and how to use it in the cloud with SF</li>
<li>Basic concepts of SF, such as services or actors</li>
<li>Communicating between services in SF</li>
<li style="font-weight: 400">Managing clusters in SF and securing them</li>
<li>Monitoring services in SF and how to diagnose them</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To perform exercises in this chapter, you will need the following:</p>
<ul>
<li>Visual Studio 2017 with <strong>Azure development</strong> and <strong>ASP.NET</strong> and <strong>web development</strong><span><span> workloads</span></span></li>
<li>Microsoft Azure SF SDK (<a href="http://www.microsoft.com/web/handlers/webpi.ashx?command=getinstallerredirect&amp;appid=MicrosoftAzure-ServiceFabric-CoreSDK">http://www.microsoft.com/web/handlers/webpi.ashx?command=getinstallerredirect&amp;appid=MicrosoftAzure-ServiceFabric-CoreSDK</a>)</li>
<li>Node.js (<a href="https://nodejs.org/en/">https://nodejs.org/en/</a>)</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding microservices</h1>
                </header>
            
            <article>
                
<p>Probably you have heard about an architecture called <strong>microservices</strong>. There is no single definition that we could quote here, so the main purpose of this chapter will be to acquire a better insight into what we can call a microservice and how to develop an application in such a manner. This directly connects to SF, which is one of the biggest and most advanced services in Azure. If you aim at building a modular, loosely-coupled, and modern application, this particular cloud component is designed for you.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Monolith versus microservices</h1>
                </header>
            
            <article>
                
<p>We will start our journey with microservices by comparing them with a traditional application, which is composed of multiple layers serving different purposes:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/3755b0bf-a1ea-4aad-8984-19b4653f85cb.png" style="width:9.00em;height:13.92em;" width="144" height="222"/></div>
<p>As you can see, we define such services as monolithic, where the whole code base is deployed as one application. This one application has multiple responsibilities:</p>
<ul>
<li>Serving the UI</li>
<li>Running business logic</li>
<li>Running additional processes (such as jobs)</li>
</ul>
<p>We can also look at it differently—as a single module that handles features from different domains. Let's consider an e-shop, where we have the following:</p>
<ul>
<li>Payment logic</li>
<li>Basket logic</li>
<li>Order processing logic</li>
<li>Discounts logic</li>
<li>Many, many more different domains</li>
</ul>
<p>Now the question arises—should our application run such logic in one instance or should we divide it into multiple independent modules, which have different lifetimes, run differently, and can be developed individually? Maybe we would <span>also </span>like to scale them separately depending on current workload or business requirements. The choice always depends on the requirements your application will have to face. However, if you would like to give try microservices, SF is the way to go, especially if you aim at using cloud-native components.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Microservice approach</h1>
                </header>
            
            <article>
                
<p>You may wonder whether the microservice architecture is one you would like to choose and work with. In this section, I would like to focus on specific features this approach provides and how you can address them when writing an application and, in the end, using SF.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using different languages and frameworks</h1>
                </header>
            
            <article>
                
<p>Sometimes, we would like to address different problems resolved by our application by using different programming languages or tools. Maybe it is a good idea to write mainly in C# or Java and deliver more advanced features such as domain-specific calculations using a dedicated language. Maybe we have multiple teams working on different features and each one would like to use a different framework.</p>
<p>Maybe the whole work is so globally distributed that dividing it into multiple smaller packages (and finally services) is the way to go. All of these problems are possible to solve using a single application but, on a bigger scale, such an approach could become cumbersome and insufficient. By leveraging the capabilities of <span>SF</span> in Azure, we can organize multiple applications (containing multiple services each) as a single platform, which can be managed from one place and deployed individually, saving time and money.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Scaling and updating services individually</h1>
                </header>
            
            <article>
                
<p>We have just talked about deploying each service individually. Thanks to such an approach, you do not have to push the whole code base at once. I am sure you have had at least one project that was so big that the whole process of delivering it to the production environment was difficult to automate and took really long to finish. In such a scenario, dividing the project into smaller modules can also be beneficial let's say that, in the last month, only one team delivered a new feature; you do not have to go through all your platform tests. What is more, if something is not right after deployment in a part of the system you have not modified, you do not have to bring in another team to investigate the problem. This confers the following advantages:</p>
<ul>
<li>The process of delivering a business value is shorter and simpler<span>,</span> and hence less vulnerable to mistakes</li>
<li>You can focus on a particular module and changes in it often do not affect other modules</li>
</ul>
<p>There is one more interesting feature of the microservices architecture—you can scale each component separately. This means that if, for example, there is a module responsible for processing payments and you have just had a big discount in your online shop, resulting in a rapid growth of incoming orders, you do not have to worry that they overwhelm it. What you can do in such a situation is simply scale it out, so you can process each order in parallel using as many instances of your module as you currently need. Later in this chapter, you will learn how you can achieve such scalability in SF using different approaches depending on the actual structure of your application. The following diagram describes the difference between scaling microservices and monolith application—while the former gives you the possibility to scale up each service individually, the latter has to be scaled as a single entity:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/b70e27f1-7128-4a45-9123-bdbfaa8d4ef5.png" style="width:34.75em;height:23.50em;" width="588" height="397"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using well-designed interfaces and protocols</h1>
                </header>
            
            <article>
                
<p>You may ask, If we divide our application into, for instance, several smaller modules, how can we now ensure that communication between them will be smooth, seamless, and with the smallest latency possible? To satisfy such requirements, one has to refer to multiple communication patterns described by patterns for service-oriented architectures, which in fact are the very foundation of microservices. In general, you have to leverage well-known protocols such as HTTP or TCP, which are widely used in the IT industry and are understood by thousands of APIs, devices, and frameworks. Of course, you could think about designing a custom protocol or standard—while initially, it might be a good idea, sooner or later it may become an obstacle to expanding your application because it's not compatible with newer services. What is more, it is important to use popular serialization methods such as XML, JSON, or any binary format that is easily available and well documented. By following such guides, you can be sure that your microservice architecture will be easy to extend and integrate with.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Dealing with state</h1>
                </header>
            
            <article>
                
<p>Nearly every application has some kind of state (of course, one can develop a stateless service, which does not have to store <span>a state</span> anywhere and just performs an action/returns a result; we will cover such services later in this chapter).</p>
<p>This state has to be managed and shared; in monolithic application handling, it is pretty straightforward and obvious—we have, for instance, a database, which holds all information from multiple parts of our system. In general, it is stored in one place (of course it can be scaled and shared, but we do not manage such features on our own), so we do not have to worry that we update it only partially (and if we do, there are always transactions). Of course, the state does not have to be stored in a database—we can use any kind of storage that holds data.</p>
<p>When using microservices, it turns out that each individual service has its own state and manages it independently. Problems arise where we have to query data from different modules or store data in more than one <span>form of storage</span>. To overcome such problems, one can use patterns such as eventual consistency. In SF, you can choose whether a state should be externalized or co-located. Additionally, SF takes care of making it highly available and durable.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Diagnosing and monitoring microservices</h1>
                </header>
            
            <article>
                
<p>While <span>the process of monitoring </span>traditional applications is pretty straightforward and simple, when you have tens or hundreds of smaller services, making it right is not that obvious. This has also other implications such as: What is the actual impact if one module goes down? When you have a monolith, you are immediately aware of any issues as your application simply stops working properly. With microservices, you may find it difficult to react in time if your monitoring does not cover all areas of your system. In SF, you have multiple levels of monitoring, which you can define as follows:</p>
<ul>
<li><strong>Application monitoring</strong>: This tracks how your application is used.</li>
<li><strong>Cluster monitoring</strong>: This allows you to monitor the whole SF cluster, so you can verify whether the whole service performs as expected.</li>
<li><strong>Performance monitoring</strong>: Sometimes, it is hard to understand how your application behaves if you do not monitor its performance. In SF, it is easier to track resource utilization and predict possible issues.</li>
<li><strong>Health monitoring</strong>: When working with microservices, it is crucial to know whether particular modules are healthy or not. In SF, you can leverage the Health API or health reports available in <span>SF</span> Explorer to gain a better insight into the current status of your application.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Containers, services, and actors in SF</h1>
                </header>
            
            <article>
                
<p>To start with SF, we will cover three main topics, which allow you to divide an application logically and physically:</p>
<ul>
<li><strong>Containers</strong>: Small, deployable components that are isolated from each other and enable you to virtualize the underlying operating system</li>
<li><strong>Reliable services</strong>: One of the programming models available in SD for writing and managing stateful and stateless services</li>
<li><strong>Reliable a</strong><strong>ctors</strong>: Another programming model on top of Reliable services</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Containers</h1>
                </header>
            
            <article>
                
<p>For now, SF supports two types of container:</p>
<ul>
<li><strong>Docker </strong>on Linux</li>
<li><strong>Windows Server </strong>containers on Windows Server 2016</li>
</ul>
<p>When working with containers in SF, you can use any programming language or framework (as you probably expected), but the most important thing related to such a model is the fact that you do not have to stick to built-in programming models (Reliable actors and Reliable services). What is more, this approach is very similar to running so-called <strong>guest executables</strong>, where you deploy an existing executable to SF.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a cluster</h1>
                </header>
            
            <article>
                
<p>Before we start with containers, we will need to create an SF cluster. To do so, go to Azure Portal and click <span class="packt_screen">+ Create a resource</span>. Search for <kbd>Service Fabric Cluster</kbd> and click <span class="packt_screen">Create</span>. You will see a familiar screen, where you have to fill multiple fields with your cluster configuration. In SF, the process of creation is divided into four different steps, which we will cover one by one.</p>
<p>On the very first screen, you will have to enter basic information regarding the cluster:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/4566481e-7e38-41ba-9496-d09745398369.png" style="width:39.17em;height:38.42em;" width="619" height="608"/></div>
<p>There is one field that probably requires a little bit of clarification, namely, <span class="packt_screen">Operating system</span>. As mentioned in the beginning of this chapter, SF supports both Windows and Linux containers, which you can select here. The choice affects both the pricing and available <span>features</span>, so you have to be sure which OS you're using.</p>
<p>Once you are satisfied with the setup, you can proceed to the next screen:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/f63ee24d-2611-4248-b7cc-016f6e794c8c.png" width="933" height="572"/></div>
<p>Now we begin with the actual cluster configuration. The first thing you have to do is select <span class="packt_screen">Node type count</span>. To select the correct version, you have to understand what this actually means. This property defines the following:</p>
<ul>
<li>Virtual machine (VM) sizes</li>
<li>The number of VMs</li>
<li>Properties of VMs</li>
</ul>
<p>So, to cut a long story short—if you need two different types of machine (because, for instance, you have a lightweight frontend and heavy backend), you will choose two different node types. </p>
<div class="packt_tip">Remember that you can always add or remove a node after cluster creation, but you will always need to have at least one.</div>
<p>On the <span class="packt_screen">Node type configuration</span><strong> </strong>blade, you will have to choose the size of virtual machines and their capacity and select a name for the node. You can also configure advanced options but, as we are just starting with SF, I would not recommend changing anything there.</p>
<div class="packt_infobox">Using fewer than five virtual machines initially designates a cluster as a test cluster. The reason why SF requires you to run five or more VMs is to make sure that your solution is more resilient to <span>simultaneous failures. You still can use a test cluster to run production workloads, but it is not recommended.</span></div>
<p>Now click <span class="packt_screen">OK </span>to proceed. The last but one screen allows you to configure the security features of your cluster:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/5a461416-515c-4e6f-ad5a-403141143d53.png" width="1195" height="397"/></div>
<p>You can choose either the <span class="packt_screen">Basic </span>or <span class="packt_screen">Custom </span>configuration type—the difference between them is that, when using <span class="packt_screen">Basic</span>,<span class="packt_screen"> </span>a certificate will be created for you and, when choosing <span class="packt_screen">Custom</span>,<span class="packt_screen"> </span>you can enter certificate information on your own. Additionally, SF will require you to select a key vault (or create a new one) to store a certificate. </p>
<div class="packt_infobox">We will not cover Azure key vaults in this book. If you would like to know more about this service, please take a look at the documentation—<a href="https://docs.microsoft.com/en-us/azure/key-vault/">https://docs.microsoft.com/en-us/azure/key-vault/</a></div>
<p>When everything is set and ready, you can click <span class="packt_screen">OK, </span>and you will see the final screen with a summary of the configuration of your cluster. Validate all of the information displayed there and, if you are ready to create the cluster, click on <span class="packt_screen">Create</span>. When you go to the resource group you selected while creating the cluster, you should see a similar setup to mine:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/43a7b959-18bd-466d-99c9-459d5bebdc49.png" width="890" height="295"/></div>
<p>As you can see, it contains many different services already:</p>
<ul>
<li><strong>Virtual machine scale set</strong>: <span>To make sure you can easily scale out, SF uses</span> the VMs scale set t<span>o automate the whole process</span></li>
<li><strong>Service Fabric </strong><strong>cluster</strong>: T<span>he actual </span>SF servi<span>ce</span></li>
<li><strong>Load balancer</strong>:<span> To distribute the load between your machines</span></li>
<li><strong>Public IP address</strong>:<span> So your application is available publicly</span></li>
<li><strong>Storage account</strong>:<span> For storing data</span></li>
<li><strong>Virtual network</strong>: To <span>secure and ease communication between machines, </span>SF utilizes Azure Virtual Network to <span>couple machines in</span> the VMs scale set</li>
</ul>
<p>Now that we have a cluster configured and running, we can proceed to deploy the Docker container.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Deploying a container</h1>
                </header>
            
            <article>
                
<p>To use Docker images in SF, we will need a registry in Azure Container Registry. You can go back to <a href="51d6dd91-dc4f-4c18-af05-e6ddc1b552fc.xhtml">Chapter 3</a>, <span><em>Deploying Web Applications as Containers</em>, </span>where I described in detail how to work with ACR and Docker.</p>
<p>Now we will try to deploy a simple Python application—to start, we will need Dockerfile,<span> of course</span>:</p>
<pre>FROM python:2.7-slim<br/>WORKDIR /app<br/>ADD . /app<br/>RUN pip install -r requirements.txt<br/>EXPOSE 80<br/>ENV NAME World<br/>CMD ["python", "app.py"]</pre>
<p>Additionally, let's create a Python application, which will display simple text:</p>
<pre>from flask import Flask<br/><br/>app = Flask(__name__)<br/><br/>@app.route("/")<br/>def hello():<br/><br/>    return 'This is my first Service Fabric app!'<br/><br/>if __name__ == "__main__":<br/>    app.run(host='0.0.0.0', port=80)</pre>
<p>Now, run the <kbd>docker build</kbd> command:</p>
<pre>docker build -t handsonservicefabricapp .</pre>
<p>We will be able to test and run it locally by typing the following:</p>
<pre>docker run -d -p 4000:80 --name handsonsf handsonservicefabricapp</pre>
<p>As you can see, all is working correctly—we can proceed by pushing an image and deploying it:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/a760e192-3e6a-4ea1-a7cf-ad93d14f14da.png" style="width:18.17em;height:7.83em;" width="258" height="111"/></div>
<p>To push a container image, you will need of course a registry for it. If you want to use Azure Container Registry, please refer to the previous chapter for detailed instructions.</p>
<p>For now, you will need three Docker<strong> </strong>commands:</p>
<ul>
<li><kbd>docker login</kbd>: To authenticate in ACR</li>
<li><kbd>docker tag</kbd><strong>:</strong> To create an alias of an image and put it in the correct namespace</li>
<li><kbd>docker push</kbd>: To deploy an image to the registry</li>
</ul>
<p>The following is the full syntax:</p>
<pre>docker login handsonazureregistry.azurecr.io -u {USERNAME} -p {PASSWORD}<br/>docker tag handsonservicefabricapp handsonazureregistry.azurecr.io/sf/handsonservicefabricapp<br/>docker push handsonazureregistry.azurecr.io/sf/handsonservicefabricapp</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Packaging a service</h1>
                </header>
            
            <article>
                
<p>To package our service, we will use Yeoman with the <span>SF</span><span> Yeoma</span><span>n container generator</span><span>. To do so, you have to install them—in your command line, execute the following two commands:</span></p>
<pre><strong>npm install -g yo</strong><br/><strong>npm install -g generator-azuresfcontainer</strong></pre>
<p>We will need one more thing—because the container image will be fetched from ACR, we have to configure its credentials in <kbd>ApplicationManifest.xml</kbd>.<strong> </strong>While the username can be traditionally found on the <span class="packt_screen">Overview </span>blade of Container Registry, to find a password you have to run these two commands:</p>
<pre><strong>az acr login --name {REGISTRY_NAME}</strong><br/><strong>az acr credential show -n {REGISTRY_NAME} --query passwords[0].value</strong></pre>
<p>Now, we will need to update the manifest generated by Yeoman so it uses our credentials:</p>
<pre>&lt;ServiceManifestImport&gt;<br/>  &lt;ServiceManifestRef ServiceManifestName="HandsOnServicePkg" ServiceManifestVersion="1.0.0" /&gt;<br/>  &lt;Policies&gt;<br/>    &lt;ContainerHostPolicies CodePackageRef="Code"&gt;<br/>      &lt;PortBinding ContainerPort="80" EndpointRef="HandsOnServiceEndpoint"/&gt;<br/>      &lt;RepositoryCredentials AccountName="{LOGIN}" Password="{PASSWORD}" PasswordEncrypted="false"/&gt;<br/>    &lt;/ContainerHostPolicies&gt;<br/>  &lt;/Policies&gt;<br/>&lt;/ServiceManifestImport&gt;</pre>
<p>Now, log in to your cluster using the following command:</p>
<pre><strong>sfctl cluster select --endpoint https://{ENDPOINT}:19000 --pem {CERTIFICATE}.pem --no-verify</strong></pre>
<p>Finally, just run the <kbd>install.ps1</kbd><strong> </strong>file Yeoman generated and wait a moment—your application image should be deployed to the SF cluster in the cloud and fully working.</p>
<div class="packt_tip">To get a certificate, you can download it from the <span class="packt_screen">Certificates </span>blade in key vault.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Reliable services</h1>
                </header>
            
            <article>
                
<p>In this section, we will try to create both stateless and stateful services using SF. This time, we will use Visual Studio to create a C# application and deploy it to our cluster. You can also start with Reliable services<strong> </strong>on Linux, but this will not be covered in this book. Refer to the <em>Further reading</em><strong> </strong>section for links to the appropriate documentation. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a SF application</h1>
                </header>
            
            <article>
                
<p>When you open a Visual Studio instance, go to <span class="packt_screen">File</span> | <span class="packt_screen">New Project</span>. In the new window search for <span class="packt_screen">Visual C#</span> | <span class="packt_screen">Cloud </span>templates; you should be able to find the <span class="packt_screen">Service Fabric Application </span>option:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/bc14a362-7565-4abe-92b3-053f7f823991.png" width="933" height="290"/></div>
<div class="packt_infobox">If you cannot find this option, make sure you have installed the <span>SF</span> SDK.</div>
<p>On the next screen, you will see many different options, most of which we will discuss later. For now, select <span class="packt_screen">Stateless Service</span><strong> </strong>and click <span class="packt_screen">OK</span>:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/13a5a698-e9a3-4ffe-a318-6542987ed80b.png" width="784" height="312"/></div>
<p>After a moment you should be able to see that a <span>stateless service </span>template has been built with SF. You can now press <em>F5</em><strong> </strong>to see how it works with all the default values:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/b393b48b-2c84-4a90-8a87-383bfbda32a5.png" width="747" height="313"/></div>
<div class="packt_tip">If you have trouble starting your local SF instance, make sure you have started Visual Studio as an administrator.</div>
<p>As you can see, each second a message—<kbd>Working-{N}</kbd>—is published. Take a look at the <kbd>RunAsync()</kbd><strong> </strong>method:</p>
<pre>protected override async Task RunAsync(CancellationToken cancellationToken)<br/>{<br/>  long iterations = 0;<br/><br/>  while (true)<br/>  {<br/>    cancellationToken.ThrowIfCancellationRequested();<br/><br/>    ServiceEventSource.Current.ServiceMessage(this.Context, "Working-{0}", ++iterations);<br/><br/>    await Task.Delay(TimeSpan.FromSeconds(1), cancellationToken);<br/>  }<br/>}</pre>
<p>You will see that it is the source of those messages. In fact, it is the starting point of your service, which is called when it starts. It also accepts one parameter, <kbd>cancellationToken</kbd>, which is here to inform you about any of the following:</p>
<ul>
<li><span>There was a fatal error in your code and the service is currently in the invalid state</span></li>
<li>There was a hardware outage in a cluster</li>
<li>There is an ongoing upgrade</li>
<li>The current instance of service is no longer required</li>
</ul>
<div class="packt_tip">Remember to honor that <kbd>RunAsync()</kbd><strong> </strong>should return a task. The system will wait until the service finishes executing, so always try to do it as quickly as possible if you discover that cancellation was requested.</div>
<p>Let's now try to add also a stateful service—to do so, add a new <span class="packt_screen">Service Fabric Application</span><strong> </strong>project to the solution, but this time select <span class="packt_screen">Stateful Service</span>:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/262514e8-d2e8-4967-8b99-4a5cd0bc75b8.png" style="width:50.58em;height:18.75em;" width="788" height="292"/></div>
<p>If you compare the stateless <kbd>RunAsync()</kbd><strong> </strong>with the stateful one, you will see many differences:</p>
<pre>protected override async Task RunAsync(CancellationToken cancellationToken)<br/>{<br/>  var myDictionary = await this.StateManager.GetOrAddAsync&lt;IReliableDictionary&lt;string, long&gt;&gt;("myDictionary");<br/><br/>  while (true)<br/>  {<br/>    cancellationToken.ThrowIfCancellationRequested();<br/><br/>    using (var tx = this.StateManager.CreateTransaction())<br/>    {<br/>      var result = await myDictionary.TryGetValueAsync(tx, "Counter");<br/><br/>      ServiceEventSource.Current.ServiceMessage(this.Context, "Current Counter Value: {0}",<br/>        result.HasValue ? result.Value.ToString() : "Value does not exist.");<br/><br/>      await myDictionary.AddOrUpdateAsync(tx, "Counter", 0, (key, value) =&gt; ++value);<br/><br/>      // If an exception is thrown before calling CommitAsync, the transaction aborts, all changes are</pre>
<pre>      // discarded, and nothing is saved to the secondary replicas.<br/>      await tx.CommitAsync();<br/>    }<br/><br/>    await Task.Delay(TimeSpan.FromSeconds(1), cancellationToken);<br/>  }<br/>}</pre>
<p>The most important one is a direct reference to state—in a stateful service, we have the state manager, which enables you to query state and execute actions within transactions. Here, in the previous example, we fetch a dictionary of the <kbd>IReliableDictionary&lt;&gt;</kbd> type from it—it is a reliable collection that stores data and replicates it to other machines. In fact, it is the same dictionary as, for example, <kbd>IDictionary&lt;&gt;</kbd>, but this time operations on a collection are asynchronous because data has to be persisted on disk.</p>
<div class="packt_tip">Remember that everything you store in the state manager has to be serializable. </div>
<p>When you start your application, you will see that both services are running at the same time:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/2ad502eb-f52e-4249-bc9f-43ec34221e3c.png" style="width:33.83em;height:20.83em;" width="476" height="293"/></div>
<p>Now we would like to publish our simple application to Azure to see whether it really works.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Deploying an application to the cloud</h1>
                </header>
            
            <article>
                
<p>If you take a look, you will see that our solution contains now three projects:</p>
<ul>
<li>Stateless service</li>
<li>Stateful service</li>
<li>SF project</li>
</ul>
<p>Now right-click on the SF project and click the <span class="packt_screen">Publish...</span><strong> </strong>option:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/90bb0bc6-4fe0-474a-8df8-6d9fbccd3faf.png" width="250" height="188"/></div>
<p>On the new screen, you can configure things such as <span class="packt_screen">Target profile</span><strong> </strong>or <span class="packt_screen">Application Parameters File</span>, but the most interesting one is <span class="packt_screen">Connection Endpoint</span>, which is empty now. In fact, you cannot proceed without selecting one option, so let's open the drop-down menu and see our options. Among the available options, you will have the following:</p>
<ul>
<li><span class="packt_screen">Local cluster</span></li>
<li><span class="packt_screen">Create New Cluster</span></li>
<li><span class="packt_screen">Use Trial Cluster</span></li>
<li><span class="packt_screen">Refresh</span></li>
</ul>
<p>While the local/new cluster option is self-explanatory, you might wonder what the <span class="packt_screen">Trial</span> option is. When you select it, you will be given an option to sign-in to so-called <strong>party clusters</strong>. These are free-of-charge SF clusters, which you can use to play with this service a little bit and learn how it works. You do not need a subscription, but after an hour the cluster will be taken down. Because we are learning about services in Azure <span>in this book, </span>I will not use that option, but feel free to utilize it later if you decide you want to know much more about SF than this short chapter was able to provide.</p>
<p>When you select the <span class="packt_screen">Create New Cluster</span><strong> </strong>option, a new screen will appear with the whole SF cluster configuration. It is very similar to the one you can see in the portal—it has the same sections, such as <span class="packt_screen">Cluster</span>, <span class="packt_screen">Certificate</span>, and <span class="packt_screen">VM Detail</span>. </p>
<div class="packt_infobox">Creating an SF cluster from Visual Studio has one downside—you do not know what the recommended values are and have no direct reference to the documentation. </div>
<p>The following shows my configuration from the first tab:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/acaa76fb-9dfb-4b6d-95cc-85e366621bfa.png" style="width:42.00em;height:28.42em;" width="625" height="423"/></div>
<p>As you can see, I set the <span class="packt_screen">Number of nodes</span> to <kbd>1</kbd>—this is because I am not planning to deploy a production workload and do not need two different characteristics of virtual machines as both my services are more or less the same. When you click <span class="packt_screen">Next</span>, you will see the second tab, where you will specify a certificate password. A certificate will be automatically created and imported if you leave the <span class="packt_screen">Import certificate</span><strong> </strong>option checked:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/c888da57-7ae9-46d4-8cc4-fc7effb6f4db.png" style="width:40.00em;height:27.25em;" width="624" height="425"/></div>
<div class="packt_infobox">Certificates in SF are a way to secure both node-to-node and client-to-node communication. These are X.509 certificates and, what is more, it is important to keep at least one valid—failing to do so can even make the cluster stop functioning.</div>
<p>The next tab is <span class="packt_screen">VM Detail</span>, where you can specify details of machines running your cluster. After providing a <span class="packt_screen">User name</span> and <span class="packt_screen">Password</span>, you have to choose which operating system will be used to run <span>SF</span> and the size of each VM. After entering all the required information, you can click on <span class="packt_screen">Create</span>:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/0f419abf-58e7-443f-ada4-3f1ec783431e.png" style="width:43.42em;height:29.33em;" width="625" height="422"/></div>
<p>Deploying an SF cluster can take a while so be patient. Once it is finished, you can take a look at it in Azure Portal to see that all parts of the whole ecosystem are deployed. However, when you enter the SF cluster in Azure, you will see that it has both <kbd>0</kbd> applications and <kbd>0</kbd> nodes attached. This is because we just created it without deploying anything. This is why we have to go back to Visual Studio and click <span class="packt_screen">Publish </span>once more, this time selecting a cluster we just created:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/cbcd32d1-0685-40f9-af53-2e855db9362c.png" style="width:45.58em;height:31.17em;" width="619" height="423"/> </div>
<p>Now, let's go to Azure and explore our application. On the <span class="packt_screen">Overview </span>blade of our <span>SF</span> instance, there is the <span class="packt_screen">Explorer </span>button:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/86aee828-8e92-4f0e-95e8-a7abc002d786.png" style="width:37.00em;height:14.17em;" width="509" height="195"/></div>
<p>When you click on it, new windows will open in your browser and you will be asked to select a certificate, which will be used to secure a connection. Remember to select the one you created and exported during SF cluster creation. After accepting it, you should be able to see <span class="packt_screen">Service Fabric Explorer</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/3fadbcd5-d990-4d20-8a73-ea9314d2fe13.png" width="1504" height="739"/></div>
<p>Congratulations—you have just created your very first microservice architecture using SF!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Reliable actors</h1>
                </header>
            
            <article>
                
<p>In the previous section, we created an application that is made up of two services—a stateful and stateless one. In SF, there are many different frameworks to build your system—another one is Reliable actors. It is designed for creating a platform of distributed services that can work concurrently and independently—because each actor is isolated, an issue with one instance does not affect others working at the same moment. You may wonder when to choose <span class="packt_screen">Reliable services</span> and when the best option is <span class="packt_screen">Reliable Actors</span>? The rule of thumb could be defined as follows:</p>
<ul>
<li>If you require to divide your work among multiple <span>workers</span> (such as hundreds or thousands), choose <span class="packt_screen">Reliable Actors</span></li>
<li>If you want to isolate your work and expect a single-threaded environment for simplicity, choose <span class="packt_screen"><span class="packt_screen">Reliable Actors</span></span></li>
<li>If your business domain expects work to be performed in the transaction, choose <span class="packt_screen">Reliable Services</span></li>
<li>If your service has to be reliable and highly available, choose <span class="packt_screen">Reliable Services</span></li>
</ul>
<p>Of course, the aforementioned reasons do not cover all possible scenarios, but you should be able to understand the difference by now. In general, you cannot expect that actors will be very durable as the idea is to spawn new ones and forward the workload to them instead of ensuring that they can work indefinitely.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a project with actors</h1>
                </header>
            
            <article>
                
<p>We will start our journey with Reliable actors by creating a brand new project in Visual Studio—for this, click on <span class="packt_screen">File</span> | <span class="packt_screen">New project</span><strong> </strong>and once more select an SF template. On the <span class="packt_screen">New Service Fabric Service</span><strong> </strong>screen, select the <span class="packt_screen">Actor Service</span><strong> </strong>template and click <span class="packt_screen">OK</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/e7f8d6c5-6fe8-4e26-95d2-28458cf6c95d.png" style="width:55.25em;height:41.42em;" width="780" height="585"/></div>
<p class="mce-root"/>
<p>After your project is initialized, you will see that it is a bit different from the one for Reliable services—what is most important is that it now contains the <kbd>.Interfaces</kbd><strong> </strong>project, which for now contains only one file with the following content:</p>
<pre>[assembly: FabricTransportActorRemotingProvider(RemotingListener = RemotingListener.V2Listener, RemotingClient = RemotingClient.V2Client)]<br/>namespace ReliableActor.Interfaces<br/>{<br/>    /// &lt;summary&gt;<br/>    /// This interface defines the methods exposed by an actor.<br/>    /// Clients use this interface to interact with the actor that implements it.<br/>    /// &lt;/summary&gt;<br/>    public interface IReliableActor : IActor<br/>    {<br/>        /// &lt;summary&gt;<br/>        /// TODO: Replace with your own actor method.<br/>        /// &lt;/summary&gt;<br/>        /// &lt;returns&gt;&lt;/returns&gt;<br/>        Task&lt;int&gt; GetCountAsync(CancellationToken cancellationToken);<br/><br/>        /// &lt;summary&gt;<br/>        /// TODO: Replace with your own actor method.<br/>        /// &lt;/summary&gt;<br/>        /// &lt;param name="count"&gt;&lt;/param&gt;<br/>        /// &lt;returns&gt;&lt;/returns&gt;<br/>        Task SetCountAsync(int count, CancellationToken cancellationToken);<br/>    }<br/>}</pre>
<p>It will act as our communication point between the actor and its clients. You may think of it as a contracts aggregator. Now, check the main actor project (in my case it is <kbd>ReliableActor</kbd>)—you will find there the current implementation of the previous interface. The following is the current code:</p>
<pre>namespace ReliableActor<br/>{<br/>    [StatePersistence(StatePersistence.Persisted)]<br/>    internal class ReliableActor : Actor, IReliableActor<br/>    {<br/>        public ReliableActor(ActorService actorService, ActorId actorId) <br/>            : base(actorService, actorId)<br/>        {<br/>        }<br/><br/>        protected override Task OnActivateAsync()<br/>        {<br/>            ActorEventSource.Current.ActorMessage(this, "Actor activated.");<br/>            return this.StateManager.TryAddStateAsync("count", 0);<br/>        }<br/><br/>        Task&lt;int&gt; IReliableActor.GetCountAsync(CancellationToken cancellationToken)<br/>        {<br/>            return this.StateManager.GetStateAsync&lt;int&gt;("count", cancellationToken);<br/>        }<br/><br/>        Task IReliableActor.SetCountAsync(int count, CancellationToken cancellationToken)<br/>        {<br/>            return this.StateManager.AddOrUpdateStateAsync("count", count, (key, value) =&gt; count &gt; value ? count : value, cancellationToken);<br/>        }<br/>    }<br/>}</pre>
<p>Each actor implementation is decorated with the <kbd>[StatePersistence]</kbd><strong> </strong>attribute. It has three different options:</p>
<ul>
<li><span class="packt_screen">Persisted</span>: Here the state is persisted to disk and replicated to replicas (three or more). It is the most durable option and prevents you from losing it even during a complete cluster failure.</li>
<li><span class="packt_screen">Volatile</span>: Instead of persisting a state to disk, it is only replicated and held in memory on three or more replicas. This is the less durable option, similar to holding your data only in RAM memory, which will be lost once power is lost.</li>
<li><span class="packt_screen">None</span>: If you do not need to persist in your state, you can use this option.</li>
</ul>
<p>There is no best option here—it all depends on the requirements of your actors. Please note one more thing<span>—</span>an actor itself is not limited to some kind of "hard" contract<span>; </span>you define the code all by yourself and SF will do its best to replicate it, persist state (if needed), and scale out to meet your demands. Currently, we have only a worker<span>—</span>we also need a client to test our service.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating an actor's client</h1>
                </header>
            
            <article>
                
<p>To create a client, we will use the most traditional <span class="packt_screen">Console Application</span>.<strong> </strong>Once more, click on <span class="packt_screen">File</span> | <span class="packt_screen">New project </span>and search for it or just right-click on the solution and click on <span class="packt_screen">Add</span> | <span class="packt_screen">New project</span>. You will have to add two more things before we write some code:</p>
<ul>
<li>Add a reference to our <kbd>.Interfaces</kbd><strong> </strong>project as we have to know which methods we would like to call</li>
<li>Install the <kbd>Microsoft.ServiceFabric.Actors</kbd> package</li>
</ul>
<p>We will write a simple application that calls our actor, fetches the current count value, and updates it. The following shows my example code:</p>
<pre>using System;<br/>using System.Threading;<br/>using System.Threading.Tasks;<br/>using Microsoft.ServiceFabric.Actors;<br/>using Microsoft.ServiceFabric.Actors.Client;<br/>using ReliableActor.Interfaces;<br/><br/>namespace ReliableActor.Client<br/>{<br/>    class Program<br/>    {<br/>        static void Main()<br/>        {<br/>            MainAsync().GetAwaiter().GetResult();<br/>        }<br/><br/>        static async Task MainAsync()<br/>        {<br/>            IReliableActor actor = ActorProxy.Create&lt;IReliableActor&gt;(ActorId.CreateRandom(), new Uri("fabric:/ReliableActors/ReliableActorService"));<br/>            while (true)<br/>            {<br/>                var count = await actor.GetCountAsync(CancellationToken.None);<br/>                Console.Write($"Current count is: {count}\r\n");<br/>                await actor.SetCountAsync(++count, CancellationToken.None);<br/><br/>                Thread.Sleep(1000);<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p>As you can see, I am doing three things:</p>
<ul>
<li>I am getting a reference to my actor service by using the <kbd>fabric</kbd> protocol and a specific interface I created</li>
<li>To obtain the count value, I am calling the <kbd>GetCountAsync()</kbd><strong> </strong>method on my reference</li>
<li>I am updating state by calling <kbd>SetCountAsync()</kbd></li>
</ul>
<p>The following shows the result of running both actor and client:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/d2912129-005c-4c3a-b185-0498b5e4826a.png" style="width:15.58em;height:11.25em;" width="241" height="174"/></div>
<p>Great—all works as expected. You may wonder how actor instances are distributed in the SF cluster and how we achieve the distribution of hundreds of instances of them. Well, it is all handled by SF runtime by partitioning instances and attaching them to different nodes on a cluster. Thanks to that, you can expect that the workload will be balanced—what is more, you can reference an actor by its ID (as opposed to the presented method, <kbd>ActorId.CreateRandom()</kbd>), but it is not always recommended as you have to ensure you are not overloading one actor.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Communication between services</h1>
                </header>
            
            <article>
                
<p>You currently know how to work with SF using Reliable services and Reliable actors. The next important topic refers to communication between each instance of a service. As we discussed at the beginning of this chapter, the best option when building your microservices is to create a platform that will be agnostic when it comes to choosing what is the best way to communicate and accept incoming requests. In SF, you do not have a single way to exchange messages—instead you are provided with a complete framework to do it your way. In this section, we will focus on building a simple communication channel for your services.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a communication channel</h1>
                </header>
            
            <article>
                
<p>To create a channel, you will need to implement the following interface:</p>
<pre>public interface ICommunicationListener<br/>{<br/>    Task&lt;string&gt; OpenAsync(CancellationToken cancellationToken);<br/>    Task CloseAsync(CancellationToken cancellationToken);<br/>    void Abort();<br/>}</pre>
<p>As you can see, there is no information regarding technology or the framework used—it is up to you. We will try to open the HTTP protocol in our service. Since we cannot cover all types of service in this book, we will focus on the stateless service. If you open the project from the section about it, in the main file of your service, you can find the following method:</p>
<pre>protected override IEnumerable&lt;ServiceInstanceListener&gt; CreateServiceInstanceListeners()<br/>{<br/>  return new ServiceInstanceListener[0];<br/>}</pre>
<p>Currently, it returns an empty array—we would have to provide a custom implementation of <kbd>ServiceInstanceListener</kbd><strong> </strong>and add it here. While it is, of course, possible to do so, it would take too much time to describe it in detail; instead, we use a NuGet package, which has the correct implementation of such a listener and is built using ASP.NET Core.</p>
<div class="packt_infobox">Currently, it is possible to use Http Sys or Kestrel to resolve communication. Feel free to experiment as those technologies differ a little and are always a substitute for each other (for example, Http Sys is currently not designed for stateful services).</div>
<p>For this exercise, please install the following package: <kbd>Microsoft.ServiceFabric.AspNetCore. HttpSys</kbd>. Once you have it, you can modify the <kbd>CreateServiceInstanceListeners()</kbd><strong> </strong>method as follows:</p>
<pre>protected override IEnumerable&lt;ServiceInstanceListener&gt; CreateServiceInstanceListeners()<br/>{<br/>  return new[]<br/>  {<br/>    new ServiceInstanceListener(serviceContext =&gt;<br/>      new HttpSysCommunicationListener(serviceContext, "ServiceEndpoint", (url, listener) =&gt;<br/>        new WebHostBuilder()<br/>          .UseHttpSys()<br/>          .ConfigureServices(<br/>            services =&gt; services<br/>              .AddSingleton&lt;StatelessServiceContext&gt;(serviceContext))<br/>          .UseContentRoot(Directory.GetCurrentDirectory())<br/>          .UseServiceFabricIntegration(listener, ServiceFabricIntegrationOptions.None)<br/>          .UseStartup&lt;Startup&gt;()<br/>          .UseUrls(url)<br/>          .Build()))<br/>  };<br/>}</pre>
<p>As you can see, it provided the full implementation of a listener and a pipeline for handling a request. You will also need to implement the <kbd>Startup</kbd> class, which will handle communication:</p>
<pre>public class Startup<br/>{<br/>  public Startup(IHostingEnvironment env)<br/>  {<br/>  }<br/><br/>  public Startup(IApplicationBuilder appenv, IHostingEnvironment env, ILoggerFactory loggerFactory)<br/>  {<br/>  }<br/><br/>  public void ConfigureServices(IServiceCollection services)<br/>  {<br/>  }<br/><br/>  public void Configure(IApplicationBuilder app)<br/>  {<br/>    app.Run(context =&gt; {<br/>      return context.Response.WriteAsync("Hello From Service Fabric!");<br/>    });<br/>  }<br/>}</pre>
<p>This may look familiar to you as this is a simple ASP.NET Core stack, which you would implement in the same manner, creating a web application not hosted in SF. Only one thing remains for now—we have to modify <kbd>ServiceManifest.xml</kbd> and specify that our endpoint is exposed by a service:</p>
<pre>&lt;Resources&gt;<br/>  &lt;Endpoints&gt;<br/>    &lt;Endpoint Name="ServiceEndpoint" Protocol="http" Port="80" /&gt;<br/>  &lt;/Endpoints&gt;<br/>&lt;/Resources&gt;</pre>
<div class="packt_infobox">Remember that the endpoint name must match the one you defined in your code.</div>
<p>Now, when you run your application, you should be able to call it by using the exposed endpoint, which can be found in <span class="packt_screen">Service Fabric Explorer</span>:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/78fbe318-6fe3-4a32-9784-b3d07b56a62e.png" width="1035" height="510"/></div>
<p>The following is the result of calling my service from the Postman application:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/7deca25b-2c8a-436e-8b28-33cd7059e0c2.png" style="width:32.50em;height:25.58em;" width="439" height="346"/></div>
<p>Now the question is: What you can do with such a feature? In fact, there are many possibilities—you can exchange messages between services, you can query a service for the status of a task currently performed, or you can change a state so a different path will be chosen when running a workload. This is a very powerful functionality and, in addition to <span>all of the advantages</span> that SF brings to distributed systems, you can be sure that your communication is reliable and fully under your control.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Clusters in SF</h1>
                </header>
            
            <article>
                
<p>We have talked about clusters in SF, but how can you really understand such a concept in that service? You probably remember that, during the creation of a cluster, we had to choose both node types and their characteristics—the number of VMs and their type. If you choose to have three nodes with five machines in each one, you will end up with a cluster of fifteen machines in total. SF automatically balances it, so if you are changing its size, all services will be redeployed to achieve maximum utilization. In this chapter, we will talk a little about security, available features, and scalability.</p>
<p>The following is a conceptual diagram of a cluster organization:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/7cb6390b-610a-4fd4-8d3a-ddfbb6a44ae0.png" style="width:28.25em;height:28.17em;" width="521" height="519"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cluster security</h1>
                </header>
            
            <article>
                
<p>If you go back to the creation of a cluster, you will notice that we always had to create or import a certificate—without it, there was no way to proceed. You have to remember that it is your responsibility to secure your environment and prevent unauthorized access. As the documentation states, it is impossible to create an insecure cluster—this is, of course, true. However, if you expose your endpoint (especially in production workloads) publicly, there is always the possibility that somebody will figure it out and start abusing it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Node-to-node security</h1>
                </header>
            
            <article>
                
<p>Let's assume that you have three different nodes for different types of workload:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/40fd6dd9-2024-4d7f-b431-b4b048ec93bf.png" style="width:23.83em;height:22.00em;" width="423" height="388"/> </div>
<p>Those nodes could be exposed (or not exposed) to the external network. Now, you may wonder how SF ensures that communication is handled in a secure manner. In fact, there are two possibilities:</p>
<ul>
<li><strong>Certificate security</strong>: In such a scenario, a client (node) attaches credentials to each request and signs a message with the private key</li>
<li><strong>Windows security</strong>: Based on the Kerberos protocol</li>
</ul>
<p>The final solution depends on your actual needs.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Client-to-node security</h1>
                </header>
            
            <article>
                
<p>Besides communicating within a cluster, you may need to allow authorized users to exchange messages with individual nodes. In fact, this is cover by similar security options as <strong>node-to-node </strong>security—here you can choose between certificates and <strong>Active Directory</strong> (<strong>AD</strong>) security. What is the advantage of using AD in that scenario? There is one very important aspect—in most cases, you do not want to share certificates with your client (this could also<span> be</span> cumbersome with a large number of them). AD security can be set in the ARM template by providing additional options:</p>
<pre>"azureActiveDirectory": {<br/>  "tenantId": "&lt;guid&gt;",<br/>  "clusterApplication": "&lt;guid&gt;",<br/>  "clientApplication": "&lt;guid&gt;"<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Scaling</h1>
                </header>
            
            <article>
                
<p>Scaling is one of the most important features of SF as the microservices architecture is all about being able to scale out when you need and preserving a stable environment while doing so. In most cases, you will need to scale horizontally (<span>by </span>getting more machines running your workloads) but, of course, it is also possible to scale vertically (so more powerful machines become available and, in some scenarios, it is a better option than scaling out). In general, the answer to whether you need to scale out or up depends on the work your code needs to do:</p>
<ul>
<li>If your work can be parallelized, choose to scale out</li>
<li>If your work performs many calculations and is I/O-heavy and such actions cannot be distributed, choose to scale out</li>
</ul>
<p>What is more, each node type in SF is a separate VM scale set. That means that you can scale your nodes independently, according to your needs. This is a very important feature—you probably would not appreciate, if only one part of your system requires more computing power, having to update the whole cluster. </p>
<div class="packt_tip">In SF, each node has specific requirements when it comes to scaling, as it is important to keep the correct number of nodes running production workloads. Details can be found in the documentation; you can find a link to it in the <em>Further reading</em><strong> </strong>section at the end of this chapter.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Scaling a cluster up or down</h1>
                </header>
            
            <article>
                
<p>In general, it is not recommended to scale a cluster up or down, as it is a dangerous operation (especially if you would like to change the VM SKU of the primary node). If you wonder why, please consider the following operation—you are about to scale down a node. This is an infrastructure operation, which requires changing available hardware for your application. If you do not monitor and orchestrate all operations correctly, you may end up with your stateful services losing data (for example, you temporarily lost access to a database) and even stateless services may become unstable. In fact, to scale up or down in a secure fashion, you should first create a new node type, and then gradually reduce the instance count of the old one, so SF is able to distribute the workload correctly before the old node is shut down.</p>
<div class="packt_infobox">The SF documentation states that it is highly inadvisable to change the SKU of VMs running a primary node. However, it is, of course, possible when done carefully; <span>you can find a link to instructions in the </span><em>Further reading</em><strong> </strong><span>section at the end of this chapter.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Monitoring and diagnostics</h1>
                </header>
            
            <article>
                
<p>In the final section of this chapter, we will cover some topics regarding monitoring and diagnosing your services in SF. As you probably remember, I noted such features as one of the most important in microservices, as you have to always be able to tell how each one works and perform the needed action (such as scale out, restart, or kill an instance) if required. In SF, there are a few levels of monitoring that we will briefly describe here.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Application monitoring</h1>
                </header>
            
            <article>
                
<p>In most cases, you want to monitor how your application works, what the user traffic is, and how your services communicate with each other. While you are able to bring your own framework, you can also leverage <strong>Application Insights</strong> (<strong>AI</strong>) integration—this will ensure that you are getting all necessary logs and available diagnostic messages. You can set up AI integration while creating a cluster for SF:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/f8f11568-683e-4857-ad31-91652b7aadb9.png" style="width:17.83em;height:33.17em;" width="306" height="567"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cluster monitoring</h1>
                </header>
            
            <article>
                
<p>While working, your cluster emits a variety of events, which map to one particular entity within it:</p>
<ul>
<li>Cluster</li>
<li>Application</li>
<li>Service</li>
<li>Partition</li>
<li>Replica</li>
<li>Container</li>
</ul>
<p>You can query these events by leveraging the <kbd>EventStore</kbd> service available in SF. It is possible to correlate them, so you can find out how one entity impacts others. The following is the example request to the API returning events from a specific time range:</p>
<pre>http://{CLUSTER}:19080/EventsStore/Cluster/Events?api-version=6.2-preview&amp;StartTimeUtc=2018-04-03T18:00:00Z&amp;EndTimeUtc=2018-07-04T18:00:00Z</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Health monitoring</h1>
                </header>
            
            <article>
                
<p>Besides monitoring your application and cluster, you will also want to check how a particular service is working. To check its health, SF introduces <span class="packt_screen">Service Fabric Explorer</span>, which you can access to verify the health of the following:</p>
<ul>
<li>Node</li>
<li>Application</li>
<li>Service</li>
<li>Partition</li>
<li>Replica</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p>You can access the Explorer both locally and in the cloud. It presents a nice UI, which displays a lot of useful information that you can use to determine the current status of the whole system, notice possible problems, and get the necessary details to investigate an issue further:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/87d148c2-b6e6-40c0-b69c-35f50d14693a.png" width="1507" height="742"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we only took a brief look at SF and the microservices built with this Azure component. You have learned the basic concepts of SF, such as Reliable services and Reliable actors, and how to implement a communication protocol to exchange messages between services and clients. Remember that building an application based on microservices is not a trivial task and requires sticking to many important rules to avoid problems with dealing with state, monitoring, or scaling. Use SF as a framework for building distributed applications, which takes care of ensuring that they are reliable and highly available.</p>
<p>Last but not least: do not be discouraged if you have problems with SF or feel overwhelmed by its multiple options and configurations—this particular service has a pretty difficult learning curve, but after reading this whole chapter, you should be able to start writing your very own services <span>without problems</span>.</p>
<p class="mce-root"/>
<p>In <a href="51d6dd91-dc4f-4c18-af05-e6ddc1b552fc.xhtml" target="_blank">Chapter 3</a>, <span><em>Deploying Web Applications as Containers</em>, </span>you will learn about another PaaS service available in Azure: Azure Search, which lets you start using your own search engine to index and query stored documents.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is the difference between Reliable services and Reliable actors?</li>
<li>What is the difference between stateless and stateful services?</li>
<li>What <span>one has to be implemented to introduce its </span>very own communication channel in SF?</li>
<li>What is node type in SF?</li>
<li>Can you scale (up/out) node types individually?</li>
<li>Can you select a VM SKU when creating a cluster?</li>
<li>What are the two types of node security in SF?</li>
<li>What is the difference between cluster, application, service, partition, and replica?</li>
<li>Why does SF advocate creating a node with at least five VMs?</li>
<li>What is the reliability tier in SF?</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li><a href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-technical-overview">https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-technical-overview</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-cluster-creation-via-arm">https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-cluster-creation-via-arm</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-cluster-scaling">https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-cluster-scaling</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-diagnostics-event-generation-operational">https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-diagnostics-event-generation-operational</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-work-with-reliable-collections">https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-work-with-reliable-collections</a></li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>