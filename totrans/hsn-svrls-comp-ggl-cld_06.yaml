- en: Developing Cloud Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will deliver an overview of Google Cloud Functions. It will
    provide you with a good understanding of the what, why, and how of Google Cloud
    Functions. Knowing the basis for any technology and its use case will assist with
    integration and application in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this outcome, we will again build an application throughout the chapter
    to illustrate some critical aspects of Cloud Functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Google Cloud Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing with the Functions Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the Cloud Functions workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the HTTP protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, to complete the exercises, you will require a Google Cloud
    project or a Qwiklabs account.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code files of this chapter in the GitHub repository for the
    book under the `ch04` subdirectory at [https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch04](https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch04).
  prefs: []
  type: TYPE_NORMAL
- en: While you are going through code snippets in the book, you will notice that,
    in a few instances, a few lines from the code/outputs have been removed and replaced
    with ellipses (`...`). The use of ellipses is to show only relevant code/output.
    The complete code is available on GitHub at the preceding link.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Google Cloud Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The description of Cloud Functions on Google Cloud indicates an event-driven
    serverless compute platform. What this means is that functions are triggered either
    by HTTP endpoints or via a background service (for example, Google Cloud Storage
    or Cloud Pub/Sub and other sources within Google Cloud). Operationally, Cloud
    Functions are *single-use* pieces of code that are quick to deploy and provide
    the *glue* between multiple services. The exciting aspect of Cloud Functions is
    that they can be stitched together quite easily in the same way a traditional
    application would be. It is entirely feasible to create a couple of HTTP endpoint
    functions that link through to a Cloud Pub/Sub backend, and by keeping your service
    simple, the build can quickly complete.
  prefs: []
  type: TYPE_NORMAL
- en: While the default setting for functions is public, authentication can be enabled
    for features to secure the environment in which they operate. Cloud Functions
    are executed using a service account and are, therefore, configurable via Google
    Cloud **Identity and Access Management** (**IAM**). It is important to note that
    functions do not share memory space, which means an isolated context for each
    instance executed.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, it is essential to note that functions are stateless in nature;
    they are therefore not expected to persist information within the Cloud Function.
  prefs: []
  type: TYPE_NORMAL
- en: The exception to this is scenario is something like persisting a database connection
    that should be stored globally in code. Doing this means the next Cloud Function
    invocation doesn't need to introduce any additional latency retrieving the connection
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Further to this, the following properties are central to the DNA of Cloud Functions:'
  prefs: []
  type: TYPE_NORMAL
- en: They operate in a secure operation context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They don't share memory across functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No state is maintained.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Cloud Functions provides an excellent way to execute single-purpose
    Cloud Functions without needing to spend a lifetime coding an application. Further
    use cases exist and are denoted in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As developers have become more exposed to cloud infrastructure, an exciting
    outcome is the evolution of lightweight functions. Consider the applications you
    use daily and how they have matured over time. How many of these now feature an
    HTTP endpoint that can be used independently from the application? What would
    happen if everything became an API; how cool would that be? Situations such as
    these are analogous to the processing of logs in which records were held internally
    in a proprietary format. Then someone had the bright idea to export application
    data to a centralized solution to capture information. A tipping point occurred,
    and we all adopted this typical pattern as the de-facto mechanism for the management
    of logging.
  prefs: []
  type: TYPE_NORMAL
- en: Back to Cloud Functions – consider how much more convenient it is to develop
    an application when you have standard solutions and patterns that can easily integrate
    with your resolution. Also, consider the level of design required upfront to ensure
    that an application retains a degree of compatibility. Working with a protocol
    such as HTTP provides a very well-understood interface that is recognized by a
    wide range of people. Having a typical frame of reference provides an excellent
    method of moving the industry forward, and HTTP provides just the vehicle for
    adoption and propagation of the development of abstracted interfaces. So, we'll
    reflect on the types of use cases that Cloud Functions are most appropriate for
    over the next couple of sections.
  prefs: []
  type: TYPE_NORMAL
- en: Processing with backend services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Backend serverless compute is triggered by services such as Cloud Pub/Sub and
    Cloud Storage. The scope of these services is made more interesting by the prospect
    of being able to integrate different Google Cloud services with your Cloud Functions.
  prefs: []
  type: TYPE_NORMAL
- en: We already know that we can use Cloud Functions for many scenarios. As outlined
    previously in the use case introduction, serverless backend processing is an excellent
    use case for this solution. In this situation, the Cloud Function design addresses
    a request to provide specific information. This request presents a particular
    signature of the service that encapsulates the information necessary to complete
    processing some arbitrary data. At the outset of this processing, the function
    responds to indicate it has completed the assigned activity. The response can
    note success or failure; however, in terms of the service, its life cycle is complete,
    and it will fade out of existence.
  prefs: []
  type: TYPE_NORMAL
- en: Processing with real-time data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another scenario that sits well with serverless compute is that of real-time
    data processing. In this situation, Cloud Functions' on-demand provisioning enables
    them to meet processing requirements for a service designed against minimal latency.
    As we discussed earlier in the book, it may be useful to understand several attributes
    before the development of a solution. The ability to quickly provision infrastructure
    in a short amount of time is a significant factor for solutions requiring real-time
    processing. Cloud Functions support a startup time of less than 2.5 seconds for
    memory allocations of less than 1,024 MB and this can be highly beneficial where
    an application requires immediate processing. As many systems move from batch
    to near real-time processing, the adoption of these types of capabilities will
    become more prevalent. Accordingly, it is therefore increasingly important to
    understand how to adapt and incorporate these patterns in the services designed.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond the example scenarios laid out in the preceding section, many other use
    cases exist. Working with Cloud Functions minimizes the work needed to integrate
    your code and removes the obligation to provide the associated infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: To use Cloud Functions requires very little in the way of additional knowledge
    of the backend architecture. In truth, as long as you are comfortable in one of
    the language runtimes, you can be up and running very quickly. Having said that,
    we should take the time to explain what is happening in the background and how
    you can go about extending this to meet your needs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we move on to cover the Functions Framework. One thing
    Google Cloud is keen to ensure is that developers get an excellent experience.
    To achieve this typically means allowing them to work in their existing environment.
    So how about being able to work locally but being still able to deploy code to
    a cloud environment?
  prefs: []
  type: TYPE_NORMAL
- en: Developing with the Functions Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, please take a moment to consider the benefit of the Functions
    Framework we have been discussing – the various options available on Google Cloud,
    meaning we can run code in different environments. As a platform that prides itself
    as being developer-centric, allowing engineers to pick up and use their code in
    different contexts is highly advantageous.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Functions Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Functions Framework is an open source project that enables you to build
    your functions in multiple environments, for example, locally. As with any magic
    trick, the beauty is not understanding the mechanics of the illusion, but with
    how it makes you feel. In this instance, let's pull back the curtains to see how
    this particular trick is done and also what it means in terms of Cloud Functions.
  prefs: []
  type: TYPE_NORMAL
- en: So why do we need something like this? Well, working in a local, often highly
    customized environment provides a friendly comfort zone for developers. The context
    you are working in will be familiar, and the tools, locations, and access can
    all easily be checked and validated. There is an inherent comfort associated with
    working in this way. Moving to the cloud removes some of those psychological comforts
    from the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having the ability to work locally, despite being counter to the end objective
    of running code in the cloud, is something folks want to do. Being able to work
    across a variety of environments using Cloud Functions leads us to the Functions
    Framework. The framework is a lightweight dependency that allows developers to
    run simple interfaces in a range of settings, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Cloud Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud Run and Cloud Run for Anthos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knative environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building on the **Functions as a Service** (**FaaS**) platform for Google Cloud,
    the availability of this framework provides a simple mechanism to achieve portability
    across multiple environments. To incorporate the code is as simple as adding the
    relevant package to your project. In the next section, we will walk through a
    simple example to demonstrate its usage in a project. In the following case, we
    create a basic Node application to process some web-based information.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an application locally with the Functions Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most developers prefer the local experience of working within a development
    environment. The Functions Framework provides Cloud Functions developers with
    the ability to continue to use this local work environment and propagate their
    code to the cloud in a seamless manner:'
  prefs: []
  type: TYPE_NORMAL
- en: First, create a directory for the example code to be built and initialize the
    environment. In my example, I have created a directory named `functions-framework`
    and will be using this to develop my code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is important to note that in my local environment I am using Node v10+, as
    this is a requirement to use the Functions Framework. Also, I have npm v6.9.0
    installed on my testing machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the Node version on your environment, run the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Using an editor, create a file named `index.js` and add the following content
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a template `package.json` file, run `npm init` from the command line.
    Edit the content as necessary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the above code extract, I have the bare minimum added to
    my file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, install the `functions-framework` package. My assumption here is that
    this is not already present on your local machine. To install this package, you
    will use `npm` to get the necessary package information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this command has been completed, you will see that the `package.json`
    file has been updated to include reference to the Function Framework under the
    `dependencies` category, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now our environment is ready to build functions, so let's make a really simple
    application to test our environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our new code, we need to tell the application to run a script when the
    application is run. In the existing `package.json`, add the following reference
    to the code to call the Functions Framework and pass a `target` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Great job; we now have our `index.js` and `package.json` ready to use the Functions
    Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Run the application locally using the standard calling method `npm start` from
    the command line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that, in our example environment, the running application is bound to
    port `8080` over the HTTP protocol. Open your browser and access this URL, `http://localhost:8080`,
    to see the output from your application as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1d5b8844-041a-4d42-aeb7-49a8ae0e0417.png)'
  prefs: []
  type: TYPE_IMG
- en: Building code to run locally on a development machine is trivial using this
    framework. However, how would this scenario differ if we wanted to deploy to the
    cloud? In the next section, we look at how to deploy code to the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an application to the cloud with the Functions Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When migrating our local application to a cloud environment, surprisingly, there
    is little that we need to do in terms of preparation. In this example, I will
    assume you have already installed and initialized the Google Cloud SDK to enable
    you to connect and provision resources on Google Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of clarity, I will create another function that says something
    slightly different; however, you can use the same Cloud Function defined in the
    code created previously:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `index.js` file, create a second function named `helloWorldCloud`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Give this new function the attributes as defined previously; however, we will
    use a different message to illustrate that a different function is called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Save the new content for the application and test to ensure it continues to
    work as per the previous run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `npm start` from the command line. Remember, the only thing we have changed
    in this iteration is the code base.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running the `npm start` command allows us to browse to `localhost:8080` and
    see the message from our application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/430a00ce-56fb-4e0f-a933-d5abc49b098c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we want to run our code base in the Cloud by deploying the Cloud Function.
    For this instance, we rely on the Cloud SDK to get our code running in a Google
    Cloud project. Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To confirm that the information created from the source uploaded successfully,
    take a look at the running Cloud Function source code. Here, we can see it includes
    the same source code that has been archived and uploaded to Google Cloud. However
    the resulting display is showing the message specifically relating to our new
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1cd48c72-8399-4654-9c2d-55a2a12b9f18.png)'
  prefs: []
  type: TYPE_IMG
- en: At this point, we now know how to deploy code to our local environment and also
    to a Google Cloud project using Cloud Functions. But what exactly are Cloud Functions
    for and what can it do? In the next section, we go into some further details on
    the relative benefits and use cases for this service.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Cloud Functions workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, it seems like Cloud Functions are pretty useful, and together with the Functions
    Framework, it would appear to be a match made in heaven. Besides, the overall
    approach seems very extensible, and working with other products and services within
    Google Cloud seems greatly simplified. So, if you are already in *team Google
    Cloud*, using Cloud Functions is a no-brainer.
  prefs: []
  type: TYPE_NORMAL
- en: For those of you who are not in *team Google Cloud* or may be sitting on the
    fence, there is more to this story. Serverless is a general term that has taken
    some critical feedback over the years. For most folks, serverless relates to the
    lack of requirement-driven infrastructure management when deploying code. For
    others, it means, services being available immediately and being capable of achieving
    sizing appropriate to the needs of the application used, with the ability to self-heal.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your perspective, Cloud Functions may or may not meet your needs.
    The main concern that people highlight is the time taken to deploy code. *Why
    isn't the function available immediately?*, *Why is the memory constrained?*,
    and so on – *When I use provider X, the services are available immediately, the
    memory isn't constrained, and they serve tea and cakes for every deployment!*
  prefs: []
  type: TYPE_NORMAL
- en: So before we go into the details on Cloud Functions, it feels like a good time
    to bring up what is happening behind the scenes as we deploy our code to the cloud.
    Google has laid out an excellent architecture in terms of mapping out the leading
    products regarding capability for a data processing pipeline. The data life cycle
    is useful from an architecture perspective as it outlines the produce available
    to render specific aspects of your pipeline. In terms of the common topics of
    ingestion, storage, processing, and analytics, this approach provides an exciting
    way to break down the component architecture.
  prefs: []
  type: TYPE_NORMAL
- en: So how do you create a function? Let's examine this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud Function properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed earlier, Cloud Functions provides support for several runtimes
    on Google Cloud, including Node.js, Python, Go, Java, and Ruby. Getting started
    with Cloud Functions is as easy as accessing the Google Cloud console and selecting
    the most appropriate runtime. Each runtime includes template code that presents
    the blueprint for a primary Cloud Function plus all the ancillary system code
    necessary to get an example up and running in no time.
  prefs: []
  type: TYPE_NORMAL
- en: A key consideration for code is how much time an algorithm will take to process
    and how much this matters. For example, if the algorithm is part of the UX, then
    any delay in processing will likely be noticeable to the end user. Asynchronous
    code permits long-lived processing actions to be offloaded from the main thread
    and executed in the background. Taking this action is key to maintaining performance
    across the application space as it provides the ability to delineate between resources
    requiring fast or slow responses.
  prefs: []
  type: TYPE_NORMAL
- en: Besides, as you are now aware, functions are generally stateless applications
    that should not persist any information. As a general rule, this means that the
    service utilizes a short life-cycle in which data processes and the task comes
    to an end. To minimize potential latency reduce long-lived request and response
    cycles, by using asynchronous calls within code.
  prefs: []
  type: TYPE_NORMAL
- en: For stateful applications, the need to maintain information presents an issue
    in terms of the potential latency associated with the persistence of data. It
    should be clear that anything requiring the read/write cycle outside of memory
    will introduce some level of delay. Trying to minimize this delay presents an
    interesting design problem that ultimately depends on what you want to give up
    and to what degree you want to move away from the performance, loose coupling,
    data design, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call a function, the event notification mechanism on Google Cloud is a trigger.
    The trigger is an important consideration when starting out developing a Cloud
    Function. Design of a function does require some thought to determine what pieces
    are needed to deliver a suitable model. As an event-driven architecture, there
    are some options available, as indicated in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Trigger** | **Event** | **Destination** |'
  prefs: []
  type: TYPE_TB
- en: '| HTTP | HTTP | URL |'
  prefs: []
  type: TYPE_TB
- en: '| Cloud Pub/Sub | Topic |  |'
  prefs: []
  type: TYPE_TB
- en: '| Cloud Storage |'
  prefs: []
  type: TYPE_TB
- en: Finalize/create
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Archive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Bucket |'
  prefs: []
  type: TYPE_TB
- en: '| Cloud Firestore |'
  prefs: []
  type: TYPE_TB
- en: Write
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '| Google Analytics for Firebase | Log | Log Event Name |'
  prefs: []
  type: TYPE_TB
- en: '| Firebase Authentication |'
  prefs: []
  type: TYPE_TB
- en: Create
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '| Firebase Realtime Database |'
  prefs: []
  type: TYPE_TB
- en: Write
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Database |'
  prefs: []
  type: TYPE_TB
- en: '| Firebase Remote Config | `remoteconfig.update` |  |'
  prefs: []
  type: TYPE_TB
- en: In addition to the runtime, there are also additional properties included when
    commencing creating a Cloud Function. Memory allocation is an essential consideration
    as the expectation is that the processing performed exists in-memory. Cloud Functions
    provide memory allocation from 128 KB to 2 GB that can be adjusted by the developer
    based on the requirement of the application developed.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving onto the more general options, it's worth having a brief overview
    of authentication and how this relates to Cloud Functions.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The default authentication for Cloud Functions represents public access; that
    is, it can be accessed by anyone, anywhere. From the Cloud Functions configuration
    screen, select Allow unauthenticated invocations to create a publically exposed
    endpoint. The `allUsers` IAM setting provides public access assignment to the
    service account associated with the Cloud Function. An invocation of a function
    relies on the association of a service account. A service account is a particular
    account used for non-interactive access, as in the entrance is for another computer
    rather than a human. The user account is assigned role permission, and this is
    bound to the service. By default, Cloud Functions binds an `allUser` permission,
    but alterations before and after the creation of a function are possible.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the initial function designation allows adjustment through IAM settings.
    This approach brings Cloud Functions into line with other services on Google Cloud.
    Later in this book, Cloud Functions security will be discussed, and it will cover
    the configuration of service accounts concerning Cloud Functions to limit privilege.
  prefs: []
  type: TYPE_NORMAL
- en: For now, let's move on to the options available regarding accessing the source
    versions for a function.
  prefs: []
  type: TYPE_NORMAL
- en: Source control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Working with source code presents many challenges. Thankfully, Cloud Functions
    provides several options to integrate source code. The Cloud Functions source
    code can be accessed from the sources such as those outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inline editor**: Create and amend the function code in the Google Cloud Console.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ZIP upload**: Upload a local ZIP file to an intermediary staging Cloud Storage
    bucket.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ZIP from Cloud Storage**: Use an existing ZIP file located in a Cloud Storage
    bucket.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloud Source repository**: Use source version control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a quick bout of development, the inline editor can be quite useful; however,
    it will probably make more sense to use one of the many other options when writing
    more intricate code. In most instances, you can continue to use your favorite
    editor and upload code with whichever method meets your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to upload source code takes us nicely onto the next topic, that
    is, selecting a language runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Working with different runtime languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the next few paragraphs, we will outline the baseline functions using
    Node, Python, and Go, and discuss the high-level differences between the various
    runtime languages.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our discussion begins with Node.js (v10). In this template code, we can see
    that the actual function consists of a couple of lines of code. In terms of Node.js,
    the exact flavor is Express.js. Express.js is a concise framework that works in
    conjunction with Node.js to enhance functionality through additions such as routing
    middleware and HTML rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the following example code, we can see a function definition based
    on `exports.helloWorld`. The `exports` keyword indicates the function executes
    (that is, exposed as a callable function) once deployed. Note also that the service
    to be exported takes two parameters mapped to the HTTP request and response values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default Google Cloud Function written in Node.js is illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The body of the function examines the request made to determine the addition
    of a query message or message body.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the Express.js documentation tells us a bit more about the access
    requirement for the message assignment statement. For a GET message, we understand
    that a query can pass additional data to the function.
  prefs: []
  type: TYPE_NORMAL
- en: If not, the default message of `Hello World` will be returned in the message
    variable. Next, `res.status` is set to the value of 200 and the message variable
    added to the response. Remember from the previous discussion on HTTP response
    codes that a 200 represents a successful transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The current revision of Python supported on Google Cloud is version 3.7\. From
    the example code, what we do not see is that the Flask package handles HTTP communication.
    At first glance, there is undoubtedly a lot more code present than in the example
    for Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we define our function and can see an immediate difference in the
    naming convention. In Python, we have named our service `hello_world`, which is
    different from the sample Node.js template. Feel free to change the name to be
    consistent, but it does not ultimately matter. Ensure you use the correct name
    for the function to execute, as this can be a frustrating error to fix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the body of the function, we can see a call to return a JSON object. Similar
    to the Node.js Cloud Function, we check the argument for the message to indicate
    if we are to override the default message. To cover the bases, we again ensure
    this example works for both GET and POST messages. Finally, if the user has not
    added a message in the required format, we return the default message of `Hello
    World!`.
  prefs: []
  type: TYPE_NORMAL
- en: Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go is currently supported on Google Cloud for version 1.11+. As you would expect,
    the revision compatibility is maintained as each version is released, so the recommendation
    is to maintain compatibility with newer versions.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example code, we import some packages to enable our application
    to perform the necessary access to HTTP and JSON. The function signature remains
    the same with request and response arguments, both used as an entry point to the
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the body of the function, our code will default to a standard message if
    the program does not provide one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Working with Cloud Functions, we see that irrespective of the runtime language
    chosen, many of the properties are shared nonetheless. In terms of languages,
    we also observed the different forms of example code used for Node, Python, and
    Go.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of coding our functions, looking for design patterns will help us to
    avoid reinventing the wheel. We know a bit more about the available language runtimes
    and have seen an example of the boilerplate code associated with each one. To
    test the function, we would need a triggering event, and, in the next section,
    we will discuss an approach to this situation.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the runtime triggering event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test the function, we can craft some data with which to confirm the success
    criteria of our service. Again, Cloud Functions can assist with this task by allowing
    the entry of JSON data to be passed directly to the function at runtime in the
    testing window:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical URL for a cloud function will resemble syntax of the following link.
    Hitting the endpoint will access the default information associated with the Cloud
    Function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For the template code, we can supplant a new message by adding some additional
    information to the URL, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `req.query` property returns an object with information,
    in this case, a message to be displayed in place of the default `Hello World!`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you go ahead and run this function without entering any additional parameters,
    a message of `Hello World` will be displayed and a response code of `200` generated.
    Triggering the event in this way is similar to accessing the function URL directly,
    in that no additional information will be incorporated into the query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **Message** | **Triggering Event** | **Output** | **Response return code**
    |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `{}` | `Hello World!` | `200` |'
  prefs: []
  type: TYPE_TB
- en: Alternatively, by adding some parameters to the triggering event, we can output
    a specific string when running the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **Message** | **Triggering Event** | **Output** | **Response return code**
    |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `{"message":"Yo Gabba Gabba!"}` | `Yo Gabba Gabba!` | `200` |'
  prefs: []
  type: TYPE_TB
- en: In the preceding example shown, the triggering event has a JSON string added.
    In this instance, the output to the function changes to display the string entered
    earlier. As before, the return code generated is `200`.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to test an application is fundamental to any developer workflow.
    However, it is just as essential to be able to reference the logs and application-specific
    information for monitoring purposes. To achieve this on Google Cloud, we use Stackdriver.
  prefs: []
  type: TYPE_NORMAL
- en: Stackdriver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each time traffic reaches the endpoint, information relating to the Cloud Function
    will be captured automatically in Stackdriver. If you are not familiar with Stackdriver,
    it is a centralized logging and monitoring system for Google Cloud. We will discuss
    Stackdriver in greater depth later in the book in [Chapter 10](5a03622d-8dae-4385-a141-7b04988f5672.xhtml),
    *Cloud Run Labs*; however, for the time being, it is essential to know that this
    is where to access real-time information for a function. To search for function
    execution, use a filter in Stackdriver, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Field** | **Example content** |'
  prefs: []
  type: TYPE_TB
- en: '| `resource.type` | `cloud_function` |'
  prefs: []
  type: TYPE_TB
- en: '| `resource.labels.function_name` | `function-1` |'
  prefs: []
  type: TYPE_TB
- en: '| `resource.labels.region` | `us-central1` |'
  prefs: []
  type: TYPE_TB
- en: '| `labels.execution_id` | `4ubpvdgz7c8w` |'
  prefs: []
  type: TYPE_TB
- en: The determining factor for which runtime language to use will largely depend
    on your personal experience. I have used Node.js throughout this book as it is
    very accessible. The interface is straightforward and efficient and doesn't take
    too much head-scratching to understand the code. Of course, you may have your
    personal favorite, and, hopefully, similar packages are available in those runtime
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the boilerplate code is the beginning of your journey, so do not
    be afraid to experiment with different approaches and techniques. In the next
    section, we provide an overview of the HTTP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the HTTP protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the context of our discussion on Cloud Functions, it is essential to consider
    how the HTTP protocol works—learning the necessary foundation of the API to enable
    communication between request and response.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP verbs, such as GET, PUT, POST, DELETE, and so on, provide the basis for
    the HTTP protocol to perform its various functions. The design of the contract
    is one that has generally stood the test of time as more advanced use cases have
    been more prevalent over time. Typically running over TCP, the protocol requires
    a reliable medium on which to transmit messages—utilizing a contract such as TCP
    establishes some level of resilience for the data transmission and acknowledgment
    when performing machine-to-machine communication. In terms of commonality, GET
    and POST represent the most common methods used for applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we provide a quick overview of these methods to understand
    their use.
  prefs: []
  type: TYPE_NORMAL
- en: Defining GET/POST methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Accessing a web page typically uses the GET method to gather content stored
    on remote servers. Whenever you are surfing the internet and looking at the contents
    of various websites, the HTTP GET method is used to achieve this. The GET method
    is, at its most basic, an idempotent retrieval mechanism for HTTP. Think about
    the GET method as a simple retrieval mechanism, that is, *get this information
    from the remote server*. Sending this command to a remote server tells it to provide
    a message response.
  prefs: []
  type: TYPE_NORMAL
- en: The GET method also allows query information to be sent to the remote server;
    however, this information is displayed as part of the URL. The message payload
    is typically served as a stream of bytes, after which the remote server will close
    the open TCP connection indicating the completion of the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: When working with web pages, in addition to retrieving information from a website
    using the GET method, there is also the POST method. The POST method provides
    the ability to supply additional information as part of the query sent to the
    remote server. In contrast to the GET method, there is no exposure via the URL
    of query information, and the request made is non-idempotent. These attributes
    make the POST method more useful for incorporating information that should not
    disclose content via the URL and is susceptible to change. A typical use for this
    type of arrangement is web forms, in which field values are sent as part of the
    HTTP request query.
  prefs: []
  type: TYPE_NORMAL
- en: Once the request/response cycle has completed, a status code indicating the
    status of the transaction is returned. In the next topic, an overview of HTTP
    codes outlines the general categories.
  prefs: []
  type: TYPE_NORMAL
- en: Unmasking HTTP response codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An HTTP response's three-digit response code indicates the success of the communication
    performed. These response codes are vital to ensure the smooth running of any
    HTTP-based application server.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have ever needed to configure or maintain a web server, the following
    information will undoubtedly be very familiar to you:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Return Value** | **Type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| 1xx | Information | An informational response code indicating the request
    was understood. |'
  prefs: []
  type: TYPE_TB
- en: '| 2xx | Success | The more common method of confirming the success of the request
    is by returning this status code. |'
  prefs: []
  type: TYPE_TB
- en: '| 3xx | Redirect | Redirection associated with the client request; typically
    no user interaction is required as a redirect is automatically enacted to complete
    the action. |'
  prefs: []
  type: TYPE_TB
- en: '| 4xx | Client Error | A request-based error that indicates something was wrong
    with the information sent from the client to the server. |'
  prefs: []
  type: TYPE_TB
- en: '| 5xx | Server Error | An error relating to the response from the server-side
    communication has occurred, meaning the request could not be fulfilled. |'
  prefs: []
  type: TYPE_TB
- en: The full list of HTTP status code is maintained by the **Internet Assigned Numbers
    Authority** (**IANA**). The broad categories associated with the HTTP status code
    ensure that most situations are catered for when working in this area.
  prefs: []
  type: TYPE_NORMAL
- en: Another area that may be of use in extending your understanding is how to work
    across domains with web content. In the next section, we'll look at a concise
    overview of cross-origin resource sharing.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Cross-Origin Resource Sharing (CORS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enabling CORS in the HTTP header enables a range of actions to be performed
    across domains. The addition of this provides an extra capability beyond that
    of traditional single-domain, client-to-server information exchange. As you would
    expect of the client, their responsibility is to initiate a request that includes
    indicating the method and header requirements. From a server perspective, the
    range of header properties is more numerous, allowing the achievement of a richer
    set of functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'An application may not always be in a situation where execution takes place
    in the same domain. For these types of situations, there is CORS, and this provides
    the ability to enable communication across domains:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Client** | **Server** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Origin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access-Control-Request-Method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access-Control-Request-Headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Access-Control-Allow-Origin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access-Control-Allow-Credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access-Control-Expose-Headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access-Control-Max-Age
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access-Control-Allow-Methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access-Control-Allow-Headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we outlined the event-driven triggers associated with Cloud Functions.
    Looking at the options, it's clear that these triggers are capable of meeting
    many of the use cases related to building systems. Thinking of events and triggers
    like *glue* or *lego* pieces is a good metaphor for the use of these components.
    When it comes to building new components or designing a serverless application,
    it is often surprising how easy it is to use these building blocks together. But
    it doesn't stop there – imagine extending beyond Google Cloud to other cloud providers
    and using their services. Serverless provides a real and exciting disruption to
    the existing design and application development process. Single-use functions
    focused on delivering a clean interface with defined inputs and outputs make for
    a more efficient delivery and maintenance experience.
  prefs: []
  type: TYPE_NORMAL
- en: Working through each of the options, we discussed how each could be used to
    significant effect when building a serverless application. To achieve this, an
    adaptive type of architecture requires more than Cloud Functions, for example,
    when incorporating authentication (via Firebase), proxy access (via Cloud Endpoints),
    or temporary storage (via Google Cloud Storage). Working with best practices and
    combining different approaches isn't a one-size-fits-all affair, and you have
    the ability to utilize both open source and commercial software seamlessly, moving
    beyond the serverless platform and looking out to the broader aspects of your
    system. While serverless provides a simple method of achieving scale, introducing
    network scale in other aspects of your portfolio will still require careful planning.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we walked through a broad overview of Cloud Functions and where
    it sits within the Google Cloud Serverless portfolio. Also, we looked at a few
    tangential aspects that are relevant to the use of FaaS, such as HTTP2 and the
    data life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: By exploring the runtimes and observing the associated code throughout the chapter,
    we are now aware of how to structure Cloud Functions in multiple languages. We
    also are aware of how to test and resolve issues by incorporating monitoring and
    logging into our development workflow. As you will know, Google provides a full
    array of tools and services to get you to the point where you can quickly develop
    a **minimum viable product** (**MVP**).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover some more examples in greater depth. Building
    an application provides an excellent way to learn the critical elements of a serverless
    application environment.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What port does Cloud Functions run on?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What trigger is used by Cloud Pub/Sub?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What runtime languages are supported by Google Cloud Functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the HTTP response code for success?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the HTTP response code for a client-side error?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the HTTP response code for a server-side error?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of CORS?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is CORS enabled?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Introduction to HTTP/2**: [https://developers.google.com/web/fundamentals/performance/http2](https://developers.google.com/web/fundamentals/performance/http2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP/2 for load balancing with Ingress**: [https://cloud.google.com/kubernetes-engine/docs/how-to/ingress-http2](https://cloud.google.com/kubernetes-engine/docs/how-to/ingress-http2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions Framework**: [https://cloud.google.com/functions/docs/functions-framework](https://cloud.google.com/functions/docs/functions-framework)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
