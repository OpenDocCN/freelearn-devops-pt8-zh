["```\n$ docker info --format=\"{{ .DockerRootDir }}\"\n/var/lib/docker\n```", "```\n$ docker container create --name test alpine\nf7536c408182698af04f53f032ea693f1623985ae12ab0525f7fb4119c8850d9\n$ docker container inspect test --format=\"{{ .Config.Cmd }}\"\n[/bin/sh]\n$ docker container ls\nCONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES\n```", "```\n$ docker container rm test\ntest\n$ docker container inspect test --format=\"{{ .Config.Cmd }}\"\nError: No such container: test\n```", "```\n$ docker network list\nNETWORK ID     NAME      DRIVER    SCOPE\n490f99141fa4   bridge    bridge    local\nb984f74311fa   host      host      local\n25c30b67b7cd   none      null      local\n```", "```\n$  docker container create --name one alpine sleep INF\n116220a54ee1da127a4b2b56974884b349de573a4ed27e2647b1e780543374f9\n$ docker container inspect one --format='{{ .NetworkSettings.IPAddress }}'\n```", "```\n$ docker container start one\none\n$ docker container inspect one --format='{{ .NetworkSettings.IPAddress }}'\n172.17.0.2\n```", "```\n$ docker network inspect bridge --format='{{ .IPAM }}'\n{default map[] [{172.17.0.0/16  172.17.0.1 map[]}]}\n```", "```\n$ docker container ls\nCONTAINER ID   IMAGE     COMMAND       CREATED          STATUS         PORTS     NAMES\n116220a54ee1   alpine    \"sleep INF\"   12 minutes ago   Up 8 minutes             one\n$ docker container run -ti alpine ping -c 3 172.17.0.2\nPING 172.17.0.2 (172.17.0.2): 56 data bytes\n64 bytes from 172.17.0.2: seq=0 ttl=64 time=1.148 ms\n64 bytes from 172.17.0.2: seq=1 ttl=64 time=0.163 ms\n64 bytes from 172.17.0.2: seq=2 ttl=64 time=0.165 ms\n--- 172.17.0.2 ping statistics ---\n3 packets transmitted, 3 packets received, 0% packet loss\nround-trip min/avg/max = 0.163/0.492/1.148 ms\n```", "```\n$ docker network create --subnet 192.168.30.0/24 mynetwork\n43ee9a8bde09de1882c91638ae7605e67bab0857c0b1ee9fe785c2d5e5c9c3a7\n$ docker network inspect mynetwork --format='{{ .IPAM }}'\n{default map[] [{192.168.30.0/24   map[]}]}\n$ docker run --detach  --name forty \\\n--network=mynetwork alpine sleep INF\n3aac157b4fd859605ef22641ea5cc7e8b37f2216f0075d92a36fc7f62056e2da\n$ docker container ls\nCONTAINER ID   IMAGE     COMMAND       CREATED          STATUS         PORTS     NAMES\n3aac157b4fd8   alpine    \"sleep INF\"   10 seconds ago   Up 8 seconds             forty\n116220a54ee1   alpine    \"sleep INF\"   2 hours ago      Up 2 hours               one\n```", "```\n$ docker run  --rm --network=mynetwork alpine ping \\\n-c 1 forty\nPING forty (192.168.30.2): 56 data bytes\n64 bytes from 192.168.30.2: seq=0 ttl=64 time=0.222 ms\n --- forty ping statistics ---\n1 packets transmitted, 1 packets received, 0% packet loss\nround-trip min/avg/max = 0.222/0.222/0.222 ms\n```", "```\n$ docker run  --rm --network=mynetwork alpine ping \\\n-c 1 one\nping: bad address 'one'\n```", "```\n$ docker container inspect one \\\n--format='{{ .NetworkSettings.IPAddress }}'\n172.17.0.2\n$ docker run  --rm --network=mynetwork alpine ping -c 1 172.17.0.2\nPING 172.17.0.2 (172.17.0.2): 56 data bytes\n--- 172.17.0.2 ping statistics ---\n1 packets transmitted, 0 packets received, 100% packet loss\n```", "```\n$ docker network connect mynetwork one\n```", "```\n$ docker exec -ti one ip address show|grep inet\n    inet 127.0.0.1/8 scope host lo\n    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0\n    inet 192.168.30.3/24 brd 192.168.30.255 scope global eth1\n```", "```\n$ docker exec -ti one ping -c 1 forty\nPING forty (192.168.30.2): 56 data bytes\n64 bytes from 192.168.30.2: seq=0 ttl=64 time=0.199 ms\n --- forty ping statistics ---\n1 packets transmitted, 1 packets received, 0% packet loss\nround-trip min/avg/max = 0.199/0.199/0.199 ms\n```", "```\n    $ docker pull postgres:alpine -q\n    docker.io/library/postgres:alpine\n    $ docker image inspect postgres:alpine \\\n    --format=\"{{ .Config.Volumes }}\"\n    map[/var/lib/postgresql/data:{}]\n    $ docker run -d -P postgres:alpine\n    27f008dea3f834f85c8b8674e8e30d4b4fc6c643df5080c62a14b63b5651401f\n    $ docker container inspect 27f008dea3 \\\n    --format=\"{{ .Mounts }}\"\n    [{volume 343e58f19c66d664e92a512ca2e8bb201d8787bc62bb9835d5b2d5ba46584fe2 /var/lib/docker/volumes/343e58f19c66d664e92a512ca2e8bb201d8787bc62bb9835d5b2d5ba46584fe2/_data /var/lib/postgresql/data local  true }]\n    frjaraur@sirius:~$ docker volume ls\n    DRIVER    VOLUME NAME\n    docker volume create to create them or just include a volume name when we run a container. If this volume already exists, the container runtime will attach it to the container, and if isn’t already present, it will be created. Container runtimes allow us to extend their volumes’ functionality by using different plugins; this will allow us to use NFS, for example. Let’s run the previous example using a defined volume; we will use DATA as the name for this new volume:\n\n    ```", "```\n\n    ```", "```\n$ docker container run --name test alpine touch /tmp/TESTFILE\n$ docker container diff test\nC /tmp\nA /tmp/TESTFILE\n```", "```\n$ docker system df\nTYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE\nImages          5         4         1.564GB   11.1MB (0%)\nContainers      17        0         729.3MB   729.3MB (100%)\nLocal Volumes   2         2         0B        0B\nBuild Cache     13        0         1.094GB   1.094GB\n```", "```\n$ docker system df --verbose\nImages space usage:\n REPOSITORY               TAG             IMAGE ID       CREATED       SIZE      SHARED SIZE   UNIQUE SIZE   CONTAINERS\nlocalhost:32768/trivy    custom-0.38.2   bdde1846d546   2 weeks ago   1.3GB     7.05MB        1.293GB       4\nContainers space usage:\nCONTAINER ID   IMAGE                                 COMMAND                  LOCAL VOLUMES   SIZE      CREATED        STATUS                       NAMES\ndf967027f21a   alpine                                \"touch /tmp/TESTFILE\"    0               0B        47 hours ago   Exited (0) 47 hours ago      test\nLocal Volumes space usage:\nVOLUME NAME                                                        LINKS     SIZE\nDATA                                                               1         0B\n343e58f19c66d664e92a512ca2e8bb201d8787bc62bb9835d5b2d5ba46584fe2   1         0B\n Build cache usage: 1.094GB\n CACHE ID       CACHE TYPE     SIZE      CREATED       LAST USED     USAGE     SHARED\nlipx4a3h7x8j   regular        4.05MB    2 weeks ago   2 weeks ago   2         true\n```", "```\nREPOSITORY               TAG             IMAGE ID       CREATED       SIZE      SHARED SIZE   UNIQUE SIZE   CONTAINERS\nlocalhost:32768/trivy    custom-0.38.2   bdde1846d546   2 weeks ago   1.3GB     7.05MB        1.293GB       4\nlocalhost:32768/alpine   0.3             a043ba94e082   2 weeks ago   11.1MB    7.05MB        4.049MB       0\nregistry                 2.8.1           0d153fadf70b   6 weeks ago   24.15MB   0B            24.15MB       1\npostgres                 alpine          6a35e2c987a6   6 weeks ago   243.1MB   7.05MB        236MB         2\nalpine                   latest          b2aa39c304c2   6 weeks ago   7.05MB    7.05MB        0B            10\n```", "```\n737aa47334e2   localhost:32768/trivy:custom-0.38.2   \"trivy image python:…\"   0               365MB     2 weeks ago    Exited (0) 2 weeks ago       infallible_mirzakhani\nf077c99cb082   localhost:32768/trivy:custom-0.38.2   \"trivy image python:…\"   0               365MB     2 weeks ago    Exited (0) 2 weeks ago       sharp_kowalevski\n```", "```\n$ docker system prune\nWARNING! This will remove:\n  - all stopped containers\n  - all networks not used by at least one container\n  - all dangling images\n  - all dangling build cache\n Are you sure you want to continue? [y/N] y\nDeleted Containers:\ndf967027f21a15e473d236a9c30fa95d5104a8a180a91c3ca9e0e117bdeb6400\n...\nDeleted Networks:\ntest1\n...\nDeleted build cache objects:\n1cmmyj0xgul6e37qdrwjijrhf\n...\n Total reclaimed space: 1.823GB\n```", "```\n   {\n      \"log-driver\": \"json-file\",\n      \"log-opts\": {\n            \"max-size\": \"20m\",\n            \"max-file\": \"10\",\n        }\n   }\n```", "```\n$ docker run \\\n      --log-driver local --log-opt max-size=10m \\\n      alpine echo hello world\n```", "```\n    $ docker container run -d --name one alpine sleep INF\n    one is running, we will run a second one directly with the ping command. We will use one as the name to test the default bridge network DNS’s existence:\n\n    ```", "```\n\n    ```", "```\n    $ docker container inspect one \\\n    --format=\"{{ .NetworkSettings.IPAddress }}\"\n    two can reach container one:\n\n    ```", "```\n\n    As expected, both containers see each other because they are running in the default bridge network. Let’s remove the reference container so that we can test this again using a custom network:\n\n    ```", "```\n    $ docker network create testnet\n    582fe354cf843270a84f8d034ca9e152ac4bffe47949ce5399820e81fb0ba555\n    $ docker network inspect testnet --format=\"{{ .IPAM.Config }}\"\n    [{172.18.0.0/16  172.18.0.1 map[]}]\n    ```", "```\n    $ docker container run -d --net testnet --name one alpine sleep INF\n    027469ad503329300c5df6019cfe72982af1203e0ccf7174fc7d0e242b7999aa\n    ```", "```\n\n    ```", "```\n$ docker network inspect testnet \\\n--format=\"{{ .Containers }}\"\nping command with the first container’s name as the target:\n\n```", "```\n    $ docker container run -d --net testnet \\\n    --name webserver nginx:alpine\n    docker container ls or docker ps:\n\n    ```", "```\n    $ docker container exec -ti one /bin/sh\n    / # ps -ef\n    PID   USER     TIME  COMMAND\n        1 root      0:00 sleep INF\n        7 root      0:00 /bin/sh\n       26 root      0:00 ps -ef\n    / # apk add --update --no-cache curl\n    fetch https://dl-cdn.alpinelinux.org/alpine/v3.17/main/x86_64/APKINDEX.tar.gz\n    ...\n    OK: 9 MiB in 20 packages\n    / # curl webserver -I\n    HTTP/1.1 200 OK\n    ...\n    ```", "```\n    / # hostname\n    027469ad5033\n    webserver container because we are going to modify its main page by using a bind mount volume:\n\n    ```", "```\n    $ mkdir $(pwd)/data\n    webserver container again, but this time, we will add the created directory as a volume so that we can include our index.xhtml file:\n\n    ```", "```\n    $ docker container exec -ti one curl webserver\n    webserver container using the same volume, we will obtain the same result because this directory provides persistency for static content:\n\n    ```", "```\n    $ echo \"My webserver 2\" >data/index.xhtml\n    $ docker container exec -ti one curl webserver2\n    My webserver 2\n    ```", "```\n\n    ```", "```\n\n    ```", "```\n\n    ```", "```\n\n    ```", "```\n    $ docker container rm -fv webserver2\n    -fv argument to force-remove the container (stop it if it was running) and the associated volumes (in this case, we used a bind mount, which will never be removed by the container runtime, so don’t worry about this type of mount). Let’s also launch our web server by using the extended mount definition just to understand its usage:\n\n    ```", "```\n\n    ```", "```\n    $ docker container run -d --net testnet -v WWWROOT:/usr/share/nginx/html --name webserver nginx:alpine\n    fb59d6cf6e81dfd43b063204f5fd4cdbbbc6661cd4166bcbcc58c633fee26e86\n    $ docker container exec -ti one curl webserver\n    <!DOCTYPE html>\n    <html>\n    <head>\n    <title>Welcome to nginx!</title>\n    …\n    <h1>Welcome to nginx!</h1>\n    $ docker cp data/index.xhtml webserver:/usr/share/nginx/html\n    ```", "```\n    $ docker container exec -ti one curl webserver\n    My webserver 2\n    ```", "```\n$ docker rm -f webserver webserver2\n```", "```\n    $ docker container run -d \\\n    --net testnet -P -v WWWROOT:/usr/share/nginx/html \\\n    --name webserver nginx:alpine\n    dc658849d9c34ec05394a3d1f41377334261283092400e0a0de4ae98582238a7\n    $ docker ps\n    CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS                   NAMES\n    dc658849d9c3   nginx:alpine   \"/docker-entrypoint.…\"   14 seconds ago   Up 12 seconds   0.0.0.0:32768->80/tcp   webserver\n    32768 and 61000.\n    ```", "```\n    $ curl 127.0.0.1:32768\n    host network.As we already have `curl` installed on one container, we can use `commit` for these changes to prepare a new image for running new containers with `curl`:\n\n    ```", "```\n\n    ```", "```\n    $ docker container run -d --net host \\\n    --name two myalpine sleep INF\n    inspect, we will notice that no IP addresses will be associated with the container via the container runtime. Instead, all the host’s network interfaces will be attached to the containers:\n\n    ```", "```\n\n    ```", "```\n    $ docker container exec -ti two curl webserver -I\n    curl: (6) Could not resolve host: webserver\n    ```", "```\n    $ docker container inspect webserver --format=\"{{ .NetworkSettings.Networks.testnet.IPAddress }}\"\n    172.18.0.3\n    $ docker container exec -ti two curl 172.18.0.3\n    My webserver 2\n    ```", "```\n    $ cat <<EOF|docker build -q -t stress -\n    FROM alpine:latest\n    RUN apk add --update --no-cache stress-ng\n    EOF\n    stress-ng works by using just one worker process and a maximum memory capacity of 1,024 MB:\n\n    ```", "```\n    $ docker stats --no-stream\n    CONTAINER ID   NAME      CPU %     MEM USAGE / LIMIT     MEM %     NET I/O     BLOCK I/O   PIDS\n    docker stats to retrieve the statistics continuously:\n\n    ```", "```\n    $ docker container kill stress\n    stress\n    $ docker run -d --name stress-limited  \\\n    --memory 128M stress stress-ng --vm-bytes 1024M  \\\n    --fork 1 -m 1\n    stats action again continuously (to show the output in this book, we executed it using --no-stream a few times) and we can verify that although stress-ng runs a process with 1,024 MB, the container never uses that amount of memory:\n\n    ```", "```\n\n    Wait a few seconds and execute it again:\n\n    ```", "```\n\n    As we expected, the memory usage is limited. You can verify what happened by reviewing the current host’s system log. The container runtime uses cgroups to limit the container’s use of resources and the kernel launched the OOM-Killer feature to kill the processes that were consuming more memory than expected:\n\n    ```", "```\n\n    ```", "```\n\n    ```", "```\n\n    ```", "```\n    $ docker container rm --force stress-limited\n    stress-limited\n    ```", "```\n    $ docker container run -d --publish 8080:80 \\\n    --name webserver nginx:alpine\n    cbcd52a7ca480606c081edc63a59df5b6a237bb2891a4f4bb2ae68f9882fd0b3\n    $ docker container ls\n    CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS         PORTS                  NAMES\n    8080:\n\n    ```", "```\n\n    ```", "```\n    $ docker logs webserver\n    /docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration\n    ...\n    2023/03/31 19:26:57 [notice] 1#1: start worker process 33\n    --tail 2 (this will show only the last two lines of the container’s logs):\n\n    ```", "```\n    # forward request and error logs to docker log collector\n        && ln -sf /dev/stdout /var/log/nginx/access.log \\\n        && ln -sf /dev/stderr /var/log/nginx/error.log \\\n    ```", "```\n\n    ```", "```\n    $ docker exec -ti webserver id\n    root should always be preferred, so let’s remove this container and create a new safer one (without root):\n\n    ```", "```\n    $ docker container run -d --publish 8080:80 \\\n    --name webserver  --user 1000 nginx:alpine\n    root user:\n\n    ```", "```\n    $ docker search nginxinc\n    NAME                                         DESCRIPTION                                     STARS OFFICIAL   AUTOMATED\n    nginxinc/nginx-unprivileged                  Unprivileged NGINX Dockerfiles                  90\n    ...\n    ```", "```\n\n    ```", "```\n\n    ```", "```\n    $ docker image pull nginxinc/nginx-unprivileged:alpine-slim -q\n    docker inspect to do so:\n\n    ```", "```\n    $ docker container run -d --publish 8080:8080 --name webserver nginxinc/nginx-unprivileged:alpine-slim\n    369307cbd5e8b74330b220947ec41d4f263ebfe7727efddae3efbcc3a1610e5e\n    $ docker container ps\n    CONTAINER ID   IMAGE                                     COMMAND                  CREATED          STATUS          PORTS                    NAMES\n    369307cbd5e8   nginxinc/nginx-unprivileged:alpine-slim   \"/docker-entrypoint.…\"   15 seconds ago   Up 13 seconds   0.0.0.0:8080->8080/tcp   webserver\n    ```", "```\n\n    ```", "```\n    $ curl 0.0.0.0:8080  -I\n    HTTP/1.1 200 OK\n    ...\n     $ docker logs --tail 2 webserver\n    2023/04/01 11:40:29 [notice] 1#1: start worker process 32\n    172.17.0.1 - - [01/Apr/2023:11:41:36 +0000] \"HEAD / HTTP/1.1\" 200 0 \"-\" \"curl/7.81.0\" \"-\"\n    ```", "```\n    $ docker exec webserver id\n    uid=101(nginx) gid=101(nginx) groups=101(nginx)\n    ```", "```\n    $ docker ps -q|xargs docker kill\n    6f883a19a8f1\n    3e37afe57357\n    -q argument is used to only show the containers’ IDs. Then, we piped the result using the xargs command to docker kill. This combination kills all the running containers.\n    ```", "```\n    $ docker system prune --all --volumes\n    WARNING! This will remove:\n      - all stopped containers\n      - all networks not used by at least one container\n      - all volumes not used by at least one container\n      - all images without at least one container associated to them\n      - all build cache\n     Are you sure you want to continue? [y/N] y\n    ...\n    docker system df:\n\n    ```", "```\n\n    ```", "```\n\n```"]