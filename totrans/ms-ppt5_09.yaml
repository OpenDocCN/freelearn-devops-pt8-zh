- en: Exported Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exported resources provide a way for a system to declare a resource, but not
    necessarily realize it. They are designed to allow nodes to publish information
    about themselves to a central database (PuppetDB), so that another node can collect
    the Puppet resource and realize it on the system. Exported resources primarily
    provide a way to create an infrastructure that is aware of other infrastructures
    in your environment. They provide the most value for an infrastructure that must
    eventually converge with information from an infrastructure that has been dynamically
    created by an automated process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Virtual and exported resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Virtual and exported resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand exported resources, it first helps to understand virtual resources.
    Virtual resources declare a state that could be made available, but will not be
    enforced until declared with the `realize` function. These resources are designed
    to allow you to prepublish a resource, but only enforce it if other conditions
    are met. Virtual resources help overcome the single declaration challenge that
    can emerge in Puppet code if you have multiple manifests that need to generate
    the same resource—you may need to include more than one of these manifests on
    a single node. If multiple modules need to manage the same file, consider virtualizing
    the resource, and making that resource available from multiple modules.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common use example of virtual resources is the use of special access administrative
    users. With a robust security policy, you may not want any single user having
    administrative access to all systems in an infrastructure. You'd then want to
    declare the administrative user as a virtual resource and allow profiles to realize
    those users where appropriate. In the following example, I'll add myself to a
    Linux system as an administrative user, and then realize the resource in multiple
    manifests, not causing resource conflict but allowing me to  place myself surgically
    on the appropriate systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, I need to declare myself and possibly other users as a virtual resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'I want to use the `realize` function in multiple profiles to call the user
    object from the catalog, and ensure it is on the system. Notice the use of the
    capital letter in the reference: `User[''rrussellyates'']`. This object already
    exists in the catalog, so I''m calling an object that already exists. I''ll want
    to make sure that I include the manifest this is declared in so that the virtual
    user is already in the catalog and realized by the profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, my production-level application requires two manifests that call me as
    an administrative user. Because this is a virtual resource that has only been
    declared once, both manifests can call the user independently or together without
    conflict:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll then apply this role to our node, using our `site.pp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this on our system, this administrative user will be realized with
    no duplicate resource declaration errors, even though the user is realized in
    both profiles. We can successfully call this user from multiple places, without
    resource conflicts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not all virtual resources are independent from each other. Sometimes, we want
    to generate a collection of resources that we can realize together as a group.
    Puppet provides a metaparameter called a tag that allows us to categorize resources
    together. Tags allow us to run a subset of Puppet code using `puppet agent -t
    --tags <tag>`. They provide a user-specific marking of a resource in order to
    build a collection of similar objects. Tags are an array, so you can apply more
    than one tag to a resource, but still call them separately. Virtual resources
    with tags can be called with a resource collector, sometimes called the *spaceship
    operator*. The simple format for calling resources by a tag is `Resource <| |>`.
    Inside of the two pipes, you can search the catalog for any parameter or metaparameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using tags, we could call that administrative user with `User <| tag ==
    ''monitoring_admin'' |>`. This allows us to bundle resources and call them as
    a group, rather than as an individual pocket. Let''s take the preceding example
    and expand it to use a tag-based system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ve tagged `chuck` as a member of monitoring support, Jason as a member
    of infrastructure administrators, and myself as a member of both teams. My manifest
    would then call users of a group, rather than the users individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After we change our profile to use both tags, the two additional users will
    be added: `jsouthgate` and `chuck`. The administrative user `russellyates` was
    already on the system, so he was not created again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Exported resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Virtual resources allow us to stage resources to be used by the node they were
    created on. Expanding on this, exported resources allow a node to create a virtual
    resource and share it with other nodes in the infrastructure. Exported resources
    are a useful way to design automated systems that need information from other
    automated systems. In implementation, you can think of an exported resource as
    virtualized and announced. The resource is not realized on the system (although
    it could be), and it is instead shared with the rest of the infrastructure. This
    allows us to build systems that manage things based on knowing the states of other
    nodes in the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declaring an exported resource is done in the same way as a virtual resource,
    except we use two `@` symbols instead of one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Although we wouldn''t want to use this particular example, we could realize
    this resource on the local system using file `<| |>` and receive just the local
    resource. By adding an additional set of brackets, `<<| |>>`, our infrastructure
    would take this file as described by every node in the infrastructure. The following
    example shows how to retrieve our resources from an exported catalog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll add this profile to our `site.pp` outside of a node definition so that
    it is utilized by all nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the agent, we will see a file being placed in `/tmp` for each node
    in the infrastructure.  For each node that checks into the master, all other nodes
    will also gain a new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Exported resources are collected out of the storage of catalogs last reported
    to PuppetDB. If a node has a change in the catalog, and the exported resource
    is no longer available in the last run, it will not be available for resource
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to take note of with exported resources: Your node that realizes
    these resources will *eventually* converge to the intended state of the infrastructure.
    Until a node reports this resource to the Puppet Master, your node will be unaware
    of the existence of the node. Let''s use a scenario where you have a new node
    that you''ve classified with an external resource in the catalog. Until that node
    checks into the master for the first time, that resource will not populate into
    PuppetDB. Even after it checks into PuppetDB, the node realizing the resource
    must also run another `puppet agent run`. This means that, on a node that has
    just run Puppet with the default timer of 30 minutes, it may take 30 minutes to
    report its exported resource to the Puppet Master. Then, your node collecting
    these resources may take up to another 30 minutes to check in with the master
    and receive these changes. Exported resources are not immediate, but your infrastructure
    will eventually converge around the new information provided to PuppetDB.'
  prefs: []
  type: TYPE_NORMAL
- en: The built-in default for a Puppet agent is a 30-minute timer to check in with
    the Puppet Master. If you have a simply configured machine that should find this
    information faster, such as a load balancer, consider having it check into the
    master more often. A load balancer that checks in every 5 minutes should report
    the node as online shortly after its initial configuration via Puppet.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Exported resources are best used delicately within an infrastructure. We''ll
    go over a few use cases, and talk about similar applications that may use this
    information as we go. We''ll use Forge modules where they make sense, but we''ll
    also build some custom exported resources so that a functional sample is available.
    In this section, we''ll be discussing a few examples of exported resources:'
  prefs: []
  type: TYPE_NORMAL
- en: A dynamic `/etc/hosts` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a node to an `haproxy` load balancer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an external database on a database server for an application server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom configuration files using the `concat` and `File_line` Puppet resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hosts file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This first sample is easy to understand and interpret, but definitely should
    not be used in place of a true **Domain Name Server** (**DNS**). A few years ago,
    I had a customer that was using a public cloud, but it had been acquired by a
    very large company, which had a team dedicated to managing corporate DNS. The
    turnaround for a DNS record was often 4 days, while many of the applications they
    launched had a lifetime of only a few days before being replaced with a new node.
    The solution had some issues for resolution if node networking information changed
    for a period of time, but it was an effective short-term solution until the policies
    around DNS were relaxed for the customer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we''ll use a single profile that exports the FQDN
    and IP address of every system classified by `profile::etchosts`, which is to
    be consumed and actioned on by every node (including the originator) in the environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If we wanted to ensure that we only collect host entries for hosts in the same
    Puppet environment, we can simply change our manifest to read `Host <<| tag ==
    'shoddy_dns'` and `environment == $environment |>>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This manifest contains both the exported resource and the resource collection
    call. Any node we include this on will both report its host record and retrieve
    all host records (including its own). Because we want to apply this code to all
    nodes in our infrastructure, we will place it outside of any node definition in
    `site.pp`, causing it to apply to all nodes in the infrastructure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run our agent, we retrieve each host entry individually and place it
    in `/etc/hosts`. In the following example, I run this catalog against my Puppet
    Master. The Puppet Master retrieves each host entry found in PuppetDB and places
    it in `/etc/hosts`. The nodes reported are `haproxy`, `appserver`, and `mysql`.
    These nodes will be used for the rest of the examples in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As noted previously, this should not be seen as a replacement for a true DNS.
    It is a simple and functional sample of how to build and use a Puppet exported
    resource.
  prefs: []
  type: TYPE_NORMAL
- en: Load balancing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A load balancer is a common system that uses the exported resources pattern
    in Puppet. Load balancers are used to forward traffic across multiple nodes, providing
    both high availability through redundancy and performance via horizontal scaling.
    Load balancers like HAProxy also allow for the design of applications that forward
    a user to data centers more local to them for performance.
  prefs: []
  type: TYPE_NORMAL
- en: The load balancer itself will receive a traditional configuration, while every
    member of the balancer will export a resource to be consumed by the load balancer.
    The load balancer then uses each entry from each exported resource to build a
    combined configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: The following sample uses `puppetlabs-haproxy` (for more information visit [https://forge.puppet.com/puppetlabs/haproxy](https://forge.puppet.com/puppetlabs/haproxy)) from
    the Puppet Forge. HAProxy is a free and open source load balancer that can be
    used without a license at home. There are other modules available for a few other
    load balancers on the Forge, and users are free to create their own custom modules
    for solutions in the Enterprise.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll need to create two profiles to support this use case: one for the load
    balancer and one for the balancer member. The balancer member profile is a simple
    exported resource that declares the listener service it will use, and reports
    its hostname, IP address, and available ports to the HAProxy. The `loadbalancer`
    profile will configure a very simple default `loadbalancer`, a listening service
    to provide forwarding on, and most importantly collect all configurations from
    exported resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll want then to place these profiles on two separate hosts. In the following
    example, I''m placing the `balancermember` profile on the `appserver`, and the
    `loadbalancer` profile on the `haproxy`. We''ll continue expanding on our `site.pp`
    from before, adding code as we go along:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following sample, the load balancer had already been configured as a
    load balancer but had no balancer members to forward to. The `appserver` had also
    completed a run and reported its exported `haproxy` configuration to PuppetDB.
    Finally, the HAProxy server collects and realizes that resource and places it
    as a line in its configuration files, enabling the forwarding of traffic to the
    `appserver` from the `haproxy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This module uses a `Concat` fragment to build an entire file. If a node does
    not report their `haproxy::balancermember` exported resource on a run, it will
    be removed from the `loadbalancer` realizing these resources on the next run.
  prefs: []
  type: TYPE_NORMAL
- en: When a user requests port `80` (`http`) or port `443` (`https`) from the HAProxy
    server, it will automatically retrieve and forward traffic from our `appserver`.
    If we had multiple app servers, it would even split the load between the two,
    allowing for horizontal scaling.
  prefs: []
  type: TYPE_NORMAL
- en: Database connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many applications require databases to store information between sessions.
    In many large organizations, it is common to centralize these databases and point
    applications to them externally. The following example will consist of two profiles:
    one for the database and one for the application seeking to use the database.'
  prefs: []
  type: TYPE_NORMAL
- en: The following sample uses `puppetlabs-mysql` from the Puppet Forge. MySQL is
    a free and open source SQL database that can be used without a license at home.
    There are other modules available for other databases, such as SQL Server, OracleDB,
    Kafka, and MongoDB. These modules can be used in a familiar fashion to provide
    exported resources to an external database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the `appserver::database` profile provides a very
    simple installation of MySQL. It also retrieves all `mysql::db` resources tagged
    `ourapp`, and realizes them on the central server. The `appserver` profile accepts
    a parameter for the password that could be supplied via `hiera` or encrypted using
    `eyaml`. Using this password, it will export a database resource to be collected
    and realized on the database server. Other configurations could be made to an
    application on this server to ensure it uses the database provided by this exported
    resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll go ahead and insert these profiles into the node definition for our
    `appserver` and a new node definition for `mysql`. This configuration will ensure
    that our `appserver` has a relevant database on the `mysql` server, and that its
    application is forwarded properly through the `haproxy`. Notice the passing of
    the password on the `appserver` node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When applied to a previously configured database server, with a freshly exported
    resource from our `appserver`, a new database, database user, and set of permissions
    has been created on the DB Server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: One flaw with this system is the up to 30-minute gap between the `appserver`
    being launched and the database being realized on the system. In the next chapter,
    we'll also be discussing application orchestration, which helps solve this problem
    by linking nodes together and orchestrating the agent runs. If you have time to
    let the infrastructure converge, this exported resource can work for databases
    and applications alone.
  prefs: []
  type: TYPE_NORMAL
- en: Concat, file lines, and you!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous samples relied on existing resources such as the host, or existing
    forge modules such as `haproxy` and `mysql`. In some cases, we'll need to build
    custom configuration files on systems using exported resources. We'll go over
    samples using both `concat` and `file_line`. `concat` to declare the entire contents
    of a file, using a list of ordered strings. File line is part of `puppetlabs-stdlib`
    (for more information visit [https://forge.puppet.com/puppetlabs/stdlib](https://forge.puppet.com/puppetlabs/stdlib))
    and it places lines that are not present into an existing file, and can also be
    used to match an existing line using `regex`.
  prefs: []
  type: TYPE_NORMAL
- en: Concat – the hammer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll be building a file called `/tmp/hammer.conf` that is comprised of a header
    section and a variable number of sections provided by exported resources. This
    class was designed to be used on all machines in an infrastructure, but could
    easily be turned into a single server configuration file by splitting the exported
    resource into a separate profile from the `concat` resource and the header `concat::fragment`.
  prefs: []
  type: TYPE_NORMAL
- en: The following sample uses `puppetlabs-concat` from the Puppet Forge.(For more
    information visit [https://forge.puppet.com/puppetlabs/concat](https://forge.puppet.com/puppetlabs/concat)). The
    `concat` module allows us to declare a file, made from pieces or fragments, and
    order the creation of a single file on a system. This allows us to define one
    or more headers and footers, while leaving room for dynamic lines to be added
    into the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we''re building a manifest that builds `hammer.conf`.
    The `concat` resource gives each fragment a location to build on. The hammer time
    `concat::fragment` is used to manage the header, as noted by order `01` in the
    parameters. Each machine will export a `concat` fragment detailing an FQDN, IP
    address, operating system, and version as a line in the file in order to simulate
    a global configuration file or inventory file. Finally, each machine will realize
    all of these exported fragments using the resource collector for `concat` fragments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll add `files::hammer` outside of any node definitions so that this inventory
    file is created on all of the machines in our infrastructure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When this is run on our `mysql` node as the final node in the infrastructure,
    `/tmp/hammer.conf` is created and contains Facter facts provided by each node
    in the infrastructure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Most configuration files should be built this way, and be holistically managed
    by Puppet. In a case where the entirety of a file is not managed, we can use `file_line`
    provided by `stdlib` in its place.
  prefs: []
  type: TYPE_NORMAL
- en: file_line – the scalpel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this exercise, we'll be using a Puppet file resource to build a file, but
    only if it's not already present in the system. Then, we'll use file lines to
    insert values we want into the file, which are collected from exported resources
    across all systems.
  prefs: []
  type: TYPE_NORMAL
- en: The following sample uses `puppetlabs-stdlib` (for more information visit [https://forge.puppet.com/puppetlabs/stdlib](https://forge.puppet.com/puppetlabs/stdlib)) from
    the Puppet Forge. `stdlib` contains a large number of functions to use in manifests,
    as well as the resource `file_line`.  `file_line` allows a line to be individually
    managed inside of a file, and can also be used to provide regex matching when
    you want to use it as a find-and-replace to the unmanaged file. If targeting INI
    files, consider using `puppetlabs-inifile` instead.(For more information visit 
    [https://forge.puppet.com/puppetlabs/inifile](https://forge.puppet.com/puppetlabs/inifile)).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will first build a file called `/tmp/scalpel.conf`. We''ll
    ensure that this file is present and has ownership by root. We will set the replace
    flag to alert Puppet not to replace the content of this file if it''s already
    present on the system, ensuring that any content already found in this file is
    not overwritten. A default will be provided by the content line if the file is
    not currently on the system. We''ll then build an exported `file_line` to simulate
    a line of configuration with a match statement to ensure that we replace misconfigured
    lines rather than create new ones. Finally, we''ll realize all of these resources
    on every node that this is classified on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The scalpel configuration file is designed to be used on each machine in the
    infrastructure, so it is also placed outside of a node definition in the `site.pp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, our node picks up the configuration change, and creates the file.
    Notice that the file is created, and then the file lines are inserted thanks to
    the require parameter we used in our exported `file_line` resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike our `concat` example, this file remains editable outside of Puppet,
    except for the individual lines managed by the manifest. In the following sample,
    I''ve edited the file to have comments at the top and changed the `haproxy`''s
    virtual setting to false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When the agent is run again, the `haproxy` line is corrected, but our comments
    stay at the top of the file. Users could even add their own configuration lines
    to this file, and as long as that configuration is not reported by Puppet exported
    resources, it would remain in the configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This methodology does allow for a lot of configuration drift in an infrastructure.
    If your team is acting to provide controlled self-service resources, this is an
    effective way to allow your customers to modify configuration files, except for
    settings specifically managed by your infrastructure team.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about virtual and exported resources. Virtual resources
    allow us to describe what a resource should be, and realize it under other conditions.
    Exported resources allow us to announce our virtual resources to other nodes in
    the infrastructure by using PuppetDB. We examined writing a virtual resource for
    administrative users and placed a file in `/tmp` for all other nodes in our infrastructure
    using exported resources. We then explored using exported resources to create
    an `/etc/hosts` file, a load balancer, a database, and an example of building
    a custom configuration file with `concat` and `file_line`.
  prefs: []
  type: TYPE_NORMAL
- en: When we applied these exported resources across our systems, we noticed that
    the main limitation of these resources is timing. Our infrastructure will eventually
    converge, but it does not happen in an orchestrated and timely fashion. Our next
    chapter will be on application orchestration, which allows us to tie a multitier
    application together and orchestrate the order Puppet runs in on those nodes.
  prefs: []
  type: TYPE_NORMAL
