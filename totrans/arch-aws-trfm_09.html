<html><head></head><body>
<div id="_idContainer037">
<h1 class="chapter-number" id="_idParaDest-170"><a id="_idTextAnchor169"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-171"><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.2.1">Deploying Containers in AWS with Terraform</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In recent years, containerization has become an increasingly popular method for deploying and managing applications in the cloud. </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">Amazon Web Services</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">AWS</span></strong><span class="koboSpan" id="kobo.7.1">) offers a range of containerization services, including Amazon </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">Elastic Container Registry</span></strong><span class="koboSpan" id="kobo.9.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.10.1">ECR</span></strong><span class="koboSpan" id="kobo.11.1">), Amazon </span><strong class="bold"><span class="koboSpan" id="kobo.12.1">Elastic Container Service</span></strong><span class="koboSpan" id="kobo.13.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.14.1">ECS</span></strong><span class="koboSpan" id="kobo.15.1">), and Amazon </span><strong class="bold"><span class="koboSpan" id="kobo.16.1">Elastic Kubernetes Service</span></strong><span class="koboSpan" id="kobo.17.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.18.1">EKS</span></strong><span class="koboSpan" id="kobo.19.1">). </span><span class="koboSpan" id="kobo.19.2">In this chapter, you will learn how to use Terraform to deploy containers in AWS, from selecting and designing the appropriate infrastructure to developing and deploying your </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">container infrastructure.</span></span></p>
<p><span class="koboSpan" id="kobo.21.1">Get ready to dive into the world of containerization and learn how to deploy containers in AWS using Terraform with the </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.23.1">What </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">are containers?</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.25.1">AWS containers</span></span></li>
<li><span class="koboSpan" id="kobo.26.1">How to utilize Terraform </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">for containers</span></span></li>
<li><span class="koboSpan" id="kobo.28.1">How to use Terraform for AWS </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">container resources</span></span></li>
</ul>
<h1 id="_idParaDest-172"><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.30.1">What are containers?</span></h1>
<p><span class="koboSpan" id="kobo.31.1">Containers are a type of</span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.32.1"> virtualization technology that allows developers to package up an application and its dependencies into a single container, which can be easily moved between different environments. </span><span class="koboSpan" id="kobo.32.2">Containers provide a consistent environment for the application to run in, regardless of the underlying infrastructure. </span><span class="koboSpan" id="kobo.32.3">They are lightweight and efficient, as they share the host operating system kernel and do not require a full </span><strong class="bold"><span class="koboSpan" id="kobo.33.1">virtual machine</span></strong><span class="koboSpan" id="kobo.34.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.35.1">VM</span></strong><span class="koboSpan" id="kobo.36.1">). </span><span class="koboSpan" id="kobo.36.2">Popular containerization platforms include Docker </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">and Kubernetes.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">Containers offer a more lightweight and efficient alternative to VMs. </span><span class="koboSpan" id="kobo.38.2">In essence, a container is a self-contained, portable, and executable package that contains all the necessary components to run specific software, such as the code, runtime, libraries, environment variables, and configuration files. </span><span class="koboSpan" id="kobo.38.3">Because containers provide a consistent environment for the application to run in, they are well suited for use in various environments, including </span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.39.1">development, testing, </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">and production.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">Containers are built on top of a container engine, such as Docker or </span><strong class="bold"><span class="koboSpan" id="kobo.42.1">Linux Containers</span></strong><span class="koboSpan" id="kobo.43.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.44.1">LXC</span></strong><span class="koboSpan" id="kobo.45.1">). </span><span class="koboSpan" id="kobo.45.2">These engines provide an </span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.46.1">abstraction layer on top of the host operating system and manage the container’s resources, such as CPU, memory, and storage. </span><span class="koboSpan" id="kobo.46.2">Containers can be run on a single host or can be orchestrated across multiple hosts using container orchestration platforms such as Kubernetes, Amazon EKS, Amazon ECS, or </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">Docker Swarm.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">Containers are also highly portable, so they can be easily moved between different environments, such as from a developer’s laptop to a test environment and then to production. </span><span class="koboSpan" id="kobo.48.2">This makes it easier to manage the entire application life cycle and ensures consistency across different stages </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">of development.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">In summary, containers are a way to package software in a format that can run consistently across different environments. </span><span class="koboSpan" id="kobo.50.2">They are lightweight, efficient, and easy to manage, making them a popular choice for modern application development </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">and deployment.</span></span></p>
<h2 id="_idParaDest-173"><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.52.1">Containers in AWS</span></h2>
<p><span class="koboSpan" id="kobo.53.1">In AWS, containers refer to </span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.54.1">a way of packaging and deploying applications as container images. </span><span class="koboSpan" id="kobo.54.2">These container images can be run on AWS services such as Amazon ECS and </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">Amazon EKS.</span></span></p>
<p><span class="koboSpan" id="kobo.56.1">Amazon ECS is a fully managed container orchestration service that makes it easy to run, scale, and secure containerized applications. </span><span class="koboSpan" id="kobo.56.2">With ECS, you can run containers on a cluster of Amazon </span><strong class="bold"><span class="koboSpan" id="kobo.57.1">Elastic Compute Cloud</span></strong><span class="koboSpan" id="kobo.58.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.59.1">EC2</span></strong><span class="koboSpan" id="kobo.60.1">) instances, and it </span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.61.1">automatically handles tasks such as scaling, load balancing, and health monitoring. </span><span class="koboSpan" id="kobo.61.2">ECS also integrates with other</span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.62.1"> AWS services such as </span><strong class="bold"><span class="koboSpan" id="kobo.63.1">Elastic Load Balancing</span></strong><span class="koboSpan" id="kobo.64.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.65.1">ELB</span></strong><span class="koboSpan" id="kobo.66.1">), Amazon </span><strong class="bold"><span class="koboSpan" id="kobo.67.1">Relational Database Service</span></strong><span class="koboSpan" id="kobo.68.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.69.1">RDS</span></strong><span class="koboSpan" id="kobo.70.1">), and Amazon </span><strong class="bold"><span class="koboSpan" id="kobo.71.1">Simple Storage </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.72.1">Service</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.73.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.74.1">S3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.76.1">Amazon EKS is a managed service that makes it easy to deploy, scale, and operate containerized applications using Kubernetes. </span><span class="koboSpan" id="kobo.76.2">EKS automates the provisioning and management of the Kubernetes control plane and worker nodes, so you can focus on building and running your applications. </span><span class="koboSpan" id="kobo.76.3">EKS also integrates with other AWS services, such as ELB and Amazon RDS, to provide a fully managed Kubernetes experience </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">on AWS.</span></span></p>
<p><span class="koboSpan" id="kobo.78.1">AWS also offers other services that can be used in conjunction with containers, such as Amazon ECR for storing and managing container images, and AWS Fargate for running containers without the need to manage the </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">underlying infrastructure.</span></span></p>
<p><span class="koboSpan" id="kobo.80.1">In summary, in AWS, containers</span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.81.1"> refer to containerized applications that can be run and managed on AWS services such as ECS and EKS, and other related services such as ECR and Fargate that provide a fully managed container orchestration service, allowing developers to focus on building and running their applications without worrying about the </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">underlying infrastructure.</span></span></p>
<h2 id="_idParaDest-174"><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.83.1">The reasons for using containers</span></h2>
<p><span class="koboSpan" id="kobo.84.1">There are several reasons why developers and organizations </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">use containers:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.86.1">Portability</span></strong><span class="koboSpan" id="kobo.87.1">: Containers</span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.88.1"> provide a consistent environment for an application to run in, regardless of the underlying infrastructure. </span><span class="koboSpan" id="kobo.88.2">This makes them highly portable, so they can be easily moved between different environments such as development, testing, </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">and production.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.90.1">Isolation</span></strong><span class="koboSpan" id="kobo.91.1">: Containers provide isolation between different applications running on the same host, which helps to prevent conflicts and ensures that each application has the resources </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">it needs.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.93.1">Scalability</span></strong><span class="koboSpan" id="kobo.94.1">: Containers can be easily scaled up or down to meet changing demands, allowing for more efficient use </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">of resources.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.96.1">Cost-effective</span></strong><span class="koboSpan" id="kobo.97.1">: Containers are lightweight and share the host operating system kernel, so they are more efficient than full VMs. </span><span class="koboSpan" id="kobo.97.2">This means that you can run more containers on a single host, which can help to </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">reduce costs.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.99.1">Automation</span></strong><span class="koboSpan" id="kobo.100.1">: Containers can be easily automated and orchestrated using tools such as Kubernetes and Docker, making it easier to manage the entire application </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">life cycle.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.102.1">Efficiency</span></strong><span class="koboSpan" id="kobo.103.1">: Containers can be built and deployed faster, leading to faster development </span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.104.1">cycles and faster </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.105.1">time-to-market</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.106.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.107.1">TTM</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">).</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.109.1">Security</span></strong><span class="koboSpan" id="kobo.110.1">: Containers provide an additional layer of security by isolating the application from the host operating system and other applications running on the </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">same host.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.112.1">Microservices</span></strong><span class="koboSpan" id="kobo.113.1">: Containers can be used to deploy microservices-based architectures, which can make it easier to build and maintain </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">complex applications.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.115.1">Flexibility</span></strong><span class="koboSpan" id="kobo.116.1">: Containers can</span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.117.1"> be used with a variety of platforms and technologies, such as Linux, Windows, and cloud providers, making them a flexible choice for different types of applications </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">and environments.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.119.1">Versioning</span></strong><span class="koboSpan" id="kobo.120.1">: Containers can be versioned, making it easy to roll back to a previous version of an application </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">if necessary.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.122.1">Testability</span></strong><span class="koboSpan" id="kobo.123.1">: Containers make it easy to test applications in different environments, as the entire application and its dependencies are packaged together in </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">a container.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.125.1">Continuous integration and deployment</span></strong><span class="koboSpan" id="kobo.126.1">: Containers can be integrated with </span><strong class="bold"><span class="koboSpan" id="kobo.127.1">Continuous Integration and Continuous Deployment</span></strong><span class="koboSpan" id="kobo.128.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.129.1">CI/CD</span></strong><span class="koboSpan" id="kobo.130.1">) pipelines, allowing for automated </span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.131.1">building, testing, and deployment </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">of applications.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.133.1">Hybrid and multi-cloud</span></strong><span class="koboSpan" id="kobo.134.1">: Containers can be used to deploy and run applications across multiple cloud providers, allowing for greater flexibility and choice when it comes to </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">cloud infrastructure.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.136.1">Serverless</span></strong><span class="koboSpan" id="kobo.137.1">: Containers can be used in conjunction with serverless platforms such as AWS Lambda, Azure Functions, and Google Cloud Functions, to create highly scalable, </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">event-driven applications.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.139.1">In summary, containers provide a consistent and isolated environment, helping to ensure that an application will run the same way across different environments and making it easy to move the application between different environments. </span><span class="koboSpan" id="kobo.139.2">They are lightweight, easy to automate and scale, cost-effective, efficient, and provide additional security. </span><span class="koboSpan" id="kobo.139.3">They are also a good fit for </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">microservices-based architectures.</span></span></p>
<h2 id="_idParaDest-175"><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.141.1">How to containerize applications</span></h2>
<p><span class="koboSpan" id="kobo.142.1">There are several steps involved in containerizing </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">an application:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.144.1">Package the application and its dependencies</span></strong><span class="koboSpan" id="kobo.145.1">: The first step is to package the application and its dependencies into a single container. </span><span class="koboSpan" id="kobo.145.2">This typically involves creating a </span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.146.1">container image, which includes the application code, runtime, libraries, environment variables, and </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">config files.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.148.1">Define the container’s environment</span></strong><span class="koboSpan" id="kobo.149.1">: The next step is to define the container’s environment, including the operating system and runtime that the application will run on. </span><span class="koboSpan" id="kobo.149.2">This is done by creating a Dockerfile, which specifies the base image to use, any additional software to install, and any </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">configuration settings.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.151.1">Build the container image</span></strong><span class="koboSpan" id="kobo.152.1">: Once the Dockerfile is defined, the container image can be built using a tool such as Docker. </span><span class="koboSpan" id="kobo.152.2">This creates a lightweight, standalone, executable package that includes everything needed to run </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">the application.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.154.1">Push the container image to a registry</span></strong><span class="koboSpan" id="kobo.155.1">: After the container image is built, it can be pushed to a container registry, such as Docker Hub or Amazon ECR, where it can be easily shared and distributed to </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">different environments.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.157.1">Deploy the container</span></strong><span class="koboSpan" id="kobo.158.1">: The final step is to deploy the container to a container orchestration platform, such as Kubernetes or Amazon ECS, where it can be easily scaled </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">and managed.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.160.1">Test the containerized application</span></strong><span class="koboSpan" id="kobo.161.1">: Before deploying the containerized application to production, it’s important to test it in a non-production environment to make sure it works as expected. </span><span class="koboSpan" id="kobo.161.2">This can be done by running the container image on a test cluster or on a developer’s local machine. </span><span class="koboSpan" id="kobo.161.3">This step can help identify and fix any issues before the application is deployed </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">to production.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.163.1">Optimize the container image</span></strong><span class="koboSpan" id="kobo.164.1">: It’s important to optimize the container image to minimize the size and reduce the number of layers. </span><span class="koboSpan" id="kobo.164.2">This can be done by using multi-stage builds, removing unnecessary files and packages, and using smaller </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">base images.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.166.1">Monitor and update the containerized application</span></strong><span class="koboSpan" id="kobo.167.1">: Once the containerized application is</span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.168.1"> deployed, it’s important to monitor it to ensure it’s running smoothly and to identify any potential issues. </span><span class="koboSpan" id="kobo.168.2">Regular updates and security patches should be applied to the containerized application and </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">its dependencies.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.170.1">Consider security best practices</span></strong><span class="koboSpan" id="kobo.171.1">: Security should always be considered when containerizing an application. </span><span class="koboSpan" id="kobo.171.2">Best practices include running containers with the least privilege, using a container registry with built-in security features, and regularly updating the container images and the </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">host system.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.173.1">In summary, containerizing an application is a multi-step process that involves packaging the application and its dependencies into a container image, defining the container’s environment, building the image, pushing it to a registry, deploying it to a container orchestration platform, testing it, optimizing the image, monitoring and updating the application, and considering security </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">best practices.</span></span></p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.175.1">AWS containers</span></h1>
<p><span class="koboSpan" id="kobo.176.1">In AWS, containers refer to a</span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.177.1"> way of packaging and deploying applications as container images. </span><span class="koboSpan" id="kobo.177.2">These container images can be run on AWS services such as Amazon ECS and </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">Amazon EKS.</span></span></p>
<p><span class="koboSpan" id="kobo.179.1">Amazon ECS and Amazon EKS are explained in the </span><em class="italic"><span class="koboSpan" id="kobo.180.1">Containers in AWS</span></em><span class="koboSpan" id="kobo.181.1"> section, so we won’t repeat </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">them here.</span></span></p>
<p><span class="koboSpan" id="kobo.183.1">AWS Fargate is a serverless compute engine for containers that allows you to run containers without having to provision and manage the underlying infrastructure. </span><span class="koboSpan" id="kobo.183.2">With Fargate, you only pay for the resources that your containers use, and there is no need to manage the underlying </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">EC2 instances.</span></span></p>
<p><span class="koboSpan" id="kobo.185.1">Amazon ECR is a fully managed container registry service that makes it easy to store, manage, and deploy container images. </span><span class="koboSpan" id="kobo.185.2">ECR is integrated with other AWS services such as ECS and EKS, making it easy to store and retrieve container images for use in </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">those services.</span></span></p>
<p><span class="koboSpan" id="kobo.187.1">AWS App Runner is a fully managed service that makes it easy to build, test, and deploy containerized applications quickly. </span><span class="koboSpan" id="kobo.187.2">It automates the building, testing, and deployment of containerized applications, allowing developers to focus on </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">writing code.</span></span></p>
<p><span class="koboSpan" id="kobo.189.1">AWS Elastic Beanstalk is a fully managed service that makes it easy to deploy, run, and scale web applications and services. </span><span class="koboSpan" id="kobo.189.2">Elastic Beanstalk supports multiple platforms, including Java, .NET, PHP, Node.js, Python, Ruby, and Go, and it also supports deploying applications as </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">Docker containers.</span></span></p>
<p><span class="koboSpan" id="kobo.191.1">AWS Lambda is a</span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.192.1"> serverless compute service that allows you to run code without provisioning or managing servers. </span><span class="koboSpan" id="kobo.192.2">It automatically scales your applications in response to incoming requests, and you only pay for the compute time that you consume. </span><span class="koboSpan" id="kobo.192.3">AWS Lambda with container support allows developers to package their application code and dependencies together in a container and deploy it as a function. </span><span class="koboSpan" id="kobo.192.4">This enables developers to take advantage of the benefits of containers such as consistent runtime environments and the ability to run their applications in </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">different environments.</span></span></p>
<p><span class="koboSpan" id="kobo.194.1">In summary, AWS offers a range of services that can be used to deploy and manage containerized applications, including Amazon ECS, Amazon EKS, AWS Fargate, Amazon ECR, and AWS App Runner. </span><span class="koboSpan" id="kobo.194.2">These services provide an easy way to deploy, run, and manage containerized applications, integrate with other AWS services, and automate various aspects of the application life </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">cycle management.</span></span></p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.196.1">How to choose the best containerization platform in AWS</span></h2>
<p><span class="koboSpan" id="kobo.197.1">Choosing the best</span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.198.1"> containerization platform in AWS will depend on the specific requirements of your application and use case. </span><span class="koboSpan" id="kobo.198.2">Here are some factors to consider when making </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">your decision:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.200.1">Microservices versus monolithic</span></strong><span class="koboSpan" id="kobo.201.1">: If your </span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.202.1">application is built using a microservices-based architecture, then ECS or EKS would be a good choice, as they are designed to handle the scaling and orchestration of multiple services. </span><span class="koboSpan" id="kobo.202.2">If your application is a monolithic application, then Fargate or App Runner may be a </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">better fit.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.204.1">Scale</span></strong><span class="koboSpan" id="kobo.205.1">: Consider the scale of your application and the resources it requires. </span><span class="koboSpan" id="kobo.205.2">ECS and EKS are both highly scalable and can handle large numbers of containers and services. </span><span class="koboSpan" id="kobo.205.3">Fargate is also scalable, but it is more suited for running small to </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">medium-sized applications.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.207.1">Existing infrastructure</span></strong><span class="koboSpan" id="kobo.208.1">: If you already have an existing infrastructure in place, it may be more cost-effective to use ECS or EKS, as they can integrate with your </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">existing resources.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.210.1">Cost</span></strong><span class="koboSpan" id="kobo.211.1">: Consider the cost of running your application on each platform. </span><span class="koboSpan" id="kobo.211.2">ECS and EKS may be more expensive than Fargate, as they require the provisioning and management of </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">underlying</span></span><span class="No-Break"><a id="_idIndexMarker440"/></span><span class="No-Break"><span class="koboSpan" id="kobo.213.1"> infrastructure.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.214.1">Functionality</span></strong><span class="koboSpan" id="kobo.215.1">: Consider the functionality that you need for your application. </span><span class="koboSpan" id="kobo.215.2">ECS and EKS provide more advanced features for deploying, scaling, and managing containerized applications, while Fargate is more suited for running </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">individual containers.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.217.1">Team experience</span></strong><span class="koboSpan" id="kobo.218.1">: Consider the experience of your team with the different platforms. </span><span class="koboSpan" id="kobo.218.2">If your team has experience with Kubernetes, EKS might be a better fit; if it has experience with AWS native services, ECS or Fargate might be </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">more appropriate.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.220.1">Each platform has its own set of features and capabilities, and the choice of which platform to use will depend on the specific requirements of your application and use case. </span><span class="koboSpan" id="kobo.220.2">ECS and EKS are more suited for microservices-based architectures, while Fargate and App Runner are more suited for running individual containers. </span><span class="koboSpan" id="kobo.220.3">AWS Lambda is more suited for running function-based workloads, and Elastic Beanstalk is more suited for deploying web applications </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">and services.</span></span></p>
<p><span class="koboSpan" id="kobo.222.1">Ultimately, the best containerization platform for your application will depend on the specific requirements of your use case. </span><span class="koboSpan" id="kobo.222.2">It is important to evaluate each platform based on the factors that are most important to your application, such as scalability, cost, and functionality. </span><span class="koboSpan" id="kobo.222.3">It may also be beneficial to test different platforms in a non-production environment to determine which one works best for your application before making a </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">final decision.</span></span></p>
<p><span class="koboSpan" id="kobo.224.1">Additionally, it’s worth considering the level of flexibility and control you want over the infrastructure and the level of automation you want to achieve. </span><span class="koboSpan" id="kobo.224.2">ECS and EKS provide more control and flexibility over the infrastructure, while Fargate and App Runner provide </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">more automation.</span></span></p>
<p><span class="koboSpan" id="kobo.226.1">In general, it’s recommended to start with the simplest option that meets your needs and gradually add complexity as needed. </span><span class="koboSpan" id="kobo.226.2">AWS Lambda, for instance, is a good starting point for function-based </span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.227.1">workloads, Elastic Beanstalk for web-based applications, Fargate for small to medium-sized applications, and ECS or EKS for complex </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">microservices-based architectures.</span></span></p>
<p><span class="koboSpan" id="kobo.229.1">It’s also important to note that AWS provides a variety of services that can be used in conjunction with the containerization platform, such as ECR for storing and managing container images, and AWS App Mesh for service </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">mesh management.</span></span></p>
<h1 id="_idParaDest-178"><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.231.1">How to utilize Terraform for containers</span></h1>
<p><span class="koboSpan" id="kobo.232.1">Terraform provides a </span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.233.1">powerful platform for managing and deploying container infrastructure on AWS. </span><span class="koboSpan" id="kobo.233.2">With Terraform, you can easily create and manage resources such as ECR, ECS, and EKS. </span><span class="koboSpan" id="kobo.233.3">This section will cover the basics of how to utilize Terraform for containers, including selecting and designing container infrastructure with Terraform, and how to develop and deploy container infrastructure </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">using Terraform.</span></span></p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.235.1">Deploying containers with Terraform</span></h2>
<p><span class="koboSpan" id="kobo.236.1">Terraform is a tool that </span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.237.1">allows you to define, provision, and manage infrastructure as code. </span><span class="koboSpan" id="kobo.237.2">To design a container using Terraform, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">docker_container</span></strong><span class="koboSpan" id="kobo.239.1"> resource to create, configure, and manage </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">a container.</span></span></p>
<p><span class="koboSpan" id="kobo.241.1">Here is an example of how to use Terraform to create </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">a container:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.243.1">
resource "docker_container" "example" {
  name  = "example-container"
  image = "nginx:latest"
  ports {
    internal = 80
    external = 8080
  }
  environment {
    EXAMPLE_VAR = "example value"
  }
  volumes {
    container_path = "/var/www/html"
    host_path = "./data"
    read_only = true
  }
}</span></pre> <p><span class="koboSpan" id="kobo.244.1">This example creates a container named </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">"example-container"</span></strong><span class="koboSpan" id="kobo.246.1"> using the latest version of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">nginx</span></strong><span class="koboSpan" id="kobo.248.1"> image, maps port </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">80</span></strong><span class="koboSpan" id="kobo.250.1"> inside the container to port </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">8080</span></strong><span class="koboSpan" id="kobo.252.1"> on the host, and sets an environment </span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.253.1">variable named </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">EXAMPLE_VAR</span></strong><span class="koboSpan" id="kobo.255.1"> with a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">"example value"</span></strong><span class="koboSpan" id="kobo.257.1">. </span><span class="koboSpan" id="kobo.257.2">The container also creates a volume that maps the </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">/var/www/html</span></strong><span class="koboSpan" id="kobo.259.1"> path inside the container to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">./data</span></strong><span class="koboSpan" id="kobo.261.1"> path on the host, with </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">read-only access.</span></span></p>
<p><span class="koboSpan" id="kobo.263.1">You can also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">docker_image</span></strong><span class="koboSpan" id="kobo.265.1"> resource to create, manage, and configure a container image, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">docker_network</span></strong><span class="koboSpan" id="kobo.267.1"> resource to create, manage, and configure </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">container networks.</span></span></p>
<p><span class="koboSpan" id="kobo.269.1">Here is an example of how to use Terraform to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">container image:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.271.1">
resource "docker_image" "example" {
  name = "example-image"
  build {
    context = "./example-image"
    dockerfile = "Dockerfile"
  }
}</span></pre> <p><span class="koboSpan" id="kobo.272.1">This example creates a container image named </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">"example-image"</span></strong><span class="koboSpan" id="kobo.274.1"> using the Dockerfile in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">"./</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">example-image"</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.277.1"> directory.</span></span></p>
<p><span class="koboSpan" id="kobo.278.1">Here is an example of how to use Terraform to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">container network:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.280.1">
resource "docker_network" "example" {
  name = "example-network"
  driver = "bridge"
}</span></pre> <p><span class="koboSpan" id="kobo.281.1">This example creates a</span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.282.1"> container network named </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">"example-network"</span></strong><span class="koboSpan" id="kobo.284.1"> with a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">bridge</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.286.1"> driver.</span></span></p>
<p><span class="koboSpan" id="kobo.287.1">By using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">docker_container</span></strong><span class="koboSpan" id="kobo.289.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">docker_image</span></strong><span class="koboSpan" id="kobo.291.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">docker_network</span></strong><span class="koboSpan" id="kobo.293.1"> resources, you can use Terraform to create, manage, and configure containers, container images, and container networks in a repeatable and </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">automated way.</span></span></p>
<p><span class="koboSpan" id="kobo.295.1">Terraform also supports other providers besides Docker, such as AWS ECS, ECR, and EKS, </span><strong class="bold"><span class="koboSpan" id="kobo.296.1">Azure Container Instance</span></strong><span class="koboSpan" id="kobo.297.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.298.1">ACI</span></strong><span class="koboSpan" id="kobo.299.1">), and </span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.300.1">Google Container Engine, which provides more specific resources and data sources that are tailored to those </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">specific providers.</span></span></p>
<h1 id="_idParaDest-180"><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.302.1">How to use Terraform for AWS container resources</span></h1>
<p><span class="koboSpan" id="kobo.303.1">There are several ways to deploy </span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.304.1">containers in AWS, depending on your specific requirements and use case. </span><span class="koboSpan" id="kobo.304.2">Here are the general steps to deploy a container </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">in AWS:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.306.1">Build and push your container image to a container registry such as Amazon ECR or any other public or </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">private registry</span></span></li>
<li><span class="koboSpan" id="kobo.308.1">Choose a container orchestration platform such as Amazon ECS, Amazon EKS, AWS Fargate, AWS Lambda, AWS Elastic Beanstalk, or AWS </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">App Runner</span></span></li>
<li><span class="koboSpan" id="kobo.310.1">Create a task definition or Pod definition that describes the container image and its configurations, such as environment variables, ports, </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">and volumes</span></span></li>
<li><span class="koboSpan" id="kobo.312.1">Create a service or deployment that uses the task definition or Pod definition to launch one or more</span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.313.1"> instances of </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">the container</span></span></li>
<li><span class="koboSpan" id="kobo.315.1">Optionally, configure scaling, load balancing, and monitoring for your </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">containerized application</span></span></li>
<li><span class="koboSpan" id="kobo.317.1">Optionally, you can use services such as Terraform or AWS CloudFormation to automate the deployment and management of your </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">container infrastructure</span></span></li>
<li><span class="koboSpan" id="kobo.319.1">Test your application and monitor its performance to make sure it’s working </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">as expected</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.321.1">It’s worth noting that each of the container orchestration platforms that AWS provides has its own set of management consoles, APIs, and CLIs that you can use to deploy, manage, and scale your </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">containerized applications.</span></span></p>
<p><span class="koboSpan" id="kobo.323.1">After building container images to push container images to ECR, we can utilize Terraform to create </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">ECR repositories.</span></span></p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.325.1">How to deploy AWS ECR with Terraform</span></h2>
<p><span class="koboSpan" id="kobo.326.1">Amazon ECR is a fully managed container registry service that makes it easy to store, manage, and deploy container</span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.327.1"> images. </span><span class="koboSpan" id="kobo.327.2">To use Terraform to manage ECR resources and to deploy an Amazon ECR repository, you can use the AWS provider for Terraform, which provides a set of resources and data sources specific to ECR. </span><span class="koboSpan" id="kobo.327.3">Here are the general steps to deploy an ECR repository </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">using Terraform:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.329.1">Install and configure the AWS provider for Terraform in your </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">local environment</span></span></li>
<li><span class="koboSpan" id="kobo.331.1">Create a new Terraform configuration file and specify the AWS provider and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">aws_ecr_repository</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.333.1"> resource</span></span></li>
<li><span class="koboSpan" id="kobo.334.1">Define the properties of the ECR repository, such as the repository name, in the </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">resource configuration</span></span></li>
<li><span class="koboSpan" id="kobo.336.1">Run </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">terraform init</span></strong><span class="koboSpan" id="kobo.338.1"> to initialize the Terraform environment and download the necessary </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">provider plugins</span></span></li>
<li><span class="koboSpan" id="kobo.340.1">Run </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">terraform plan</span></strong><span class="koboSpan" id="kobo.342.1"> to preview the changes that will be made to </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">your infrastructure</span></span></li>
<li><span class="koboSpan" id="kobo.344.1">Run </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">terraform apply</span></strong><span class="koboSpan" id="kobo.346.1"> to create an ECR repository in your </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">AWS account</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.348.1">Here is an example of</span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.349.1"> how to use Terraform to create an </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">ECR repository:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.351.1">
provider "aws" {
  region = "us-west-2"
}
resource "aws_ecr_repository" "example" {
  name = "example-repository"
}</span></pre> <p><span class="koboSpan" id="kobo.352.1">This example creates an ECR repository named </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">"example-repository"</span></strong><span class="koboSpan" id="kobo.354.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">"</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">us-west-2"</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.357.1"> region.</span></span></p>
<p><span class="koboSpan" id="kobo.358.1">You can also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">aws_ecr_lifecycle_policy</span></strong><span class="koboSpan" id="kobo.360.1"> resource to manage the life cycle policies for an ECR repository and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">aws_ecr_image</span></strong><span class="koboSpan" id="kobo.362.1"> resource to manage the images stored in an ECR repository </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">using Terraform.</span></span></p>
<p><span class="koboSpan" id="kobo.364.1">Here is an example of </span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.365.1">how to use Terraform to create a life cycle policy for an </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">ECR repository:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.367.1">
resource "aws_ecr_lifecycle_policy" "example" {
  repository = aws_ecr_repository.example.name
  policy = &lt;&lt;EOF
  {
    "rules": [
      {
        "rulePriority": 1,
        "description": "Expire images older than 30 days",
        "selection": {
          "tagStatus": "untagged",
          "countType": "sinceImagePushed",
          "countUnit": "days",
          "countNumber": 30
        },
        "action": {
          "type": "expire"
        }
      }
    ]
  }
  EOF
}</span></pre> <p><span class="koboSpan" id="kobo.368.1">This example creates a life cycle policy for the ECR repository specified by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">aws_ecr_repository.example.name</span></strong><span class="koboSpan" id="kobo.370.1"> reference. </span><span class="koboSpan" id="kobo.370.2">This policy expires images that are older than 30 days and have no tag associated </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">with them.</span></span></p>
<p><span class="koboSpan" id="kobo.372.1">It’s important to note that</span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.373.1"> this is a simple example of a life cycle policy. </span><span class="koboSpan" id="kobo.373.2">You can use the full set of options that an AWS ECR life cycle policy provides to create more complex policies, such as image tagging rules, image scanning rules, and </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.375.1">You can also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">terraform plan</span></strong><span class="koboSpan" id="kobo.377.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">terraform apply</span></strong><span class="koboSpan" id="kobo.379.1"> commands to preview and apply the changes made to the </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">repository policy.</span></span></p>
<p><span class="koboSpan" id="kobo.381.1">Here is an example of how </span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.382.1">to use Terraform to create an image in an </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">ECR repository:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.384.1">
resource "aws_ecr_image" "example" {
  repository = aws_ecr_repository.example.name
  image_tag = "latest"
  image_digest = "${data.aws_ecr_image.example.image_digest}"
}
data "aws_ecr_image" "example" {
  repository = aws_ecr_repository.example.name
  image_tag = "latest"
}</span></pre> <p><span class="koboSpan" id="kobo.385.1">This example creates an image in an ECR repository specified by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">aws_ecr_repository.example.name</span></strong><span class="koboSpan" id="kobo.387.1"> reference. </span><span class="koboSpan" id="kobo.387.2">The image is tagged with </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">"latest"</span></strong><span class="koboSpan" id="kobo.389.1"> and the digest of the image is obtained from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">aws_ecr_image</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.391.1">data source.</span></span></p>
<p><span class="koboSpan" id="kobo.392.1">You can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">aws_ecr_image</span></strong><span class="koboSpan" id="kobo.394.1"> resource to push and pull images to and from an ECR repository, as well as to manage images stored in an </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">ECR repository.</span></span></p>
<p><span class="koboSpan" id="kobo.396.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">aws_ecr_image</span></strong><span class="koboSpan" id="kobo.398.1"> resource also allows you to specify image details such as the image tag, image digest, image manifest, and image </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">scanned status.</span></span></p>
<p><span class="koboSpan" id="kobo.400.1">It’s important to note that the</span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.401.1"> preceding example is a simple example of creating an image in an ECR repository. </span><span class="koboSpan" id="kobo.401.2">You can use the full set of options that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">aws_ecr_image</span></strong><span class="koboSpan" id="kobo.403.1"> resource provides to create and manage images in your </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">ECR repository.</span></span></p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.405.1">Deploying container images to AWS container platforms with Terraform</span></h2>
<p><span class="koboSpan" id="kobo.406.1">In this section, we will explore how to deploy container images to AWS container platforms using Terraform. </span><span class="koboSpan" id="kobo.406.2">By </span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.407.1">utilizing Terraform, we can simplify the process of managing container infrastructure and automate the deployment of containerized applications on AWS. </span><span class="koboSpan" id="kobo.407.2">We will discuss the use of AWS container services such as ECR, ECS, and EKS and how to deploy container images to these services </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">using Terraform.</span></span></p>
<h3><span class="koboSpan" id="kobo.409.1">Deploying to AWS ECS</span></h3>
<p><span class="koboSpan" id="kobo.410.1">To deploy container images to Amazon ECS using Terraform, you can use the AWS provider for Terraform, which</span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.411.1"> provides a set of resources and data</span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.412.1"> sources specific to ECS. </span><span class="koboSpan" id="kobo.412.2">Here are the general steps to deploy an ECS container </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">using Terraform:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.414.1">Install and configure the AWS provider for Terraform in your </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">local environment.</span></span></li>
<li><span class="koboSpan" id="kobo.416.1">Create a new Terraform configuration file and specify the AWS provider and the necessary ECS resources such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">aws_ecs_task_definition</span></strong><span class="koboSpan" id="kobo.418.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">aws_ecs_service</span></strong><span class="koboSpan" id="kobo.420.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">aws_ecs_cluster</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.424.1">Define the properties of the container, such as the container image, container name, port mappings, and environment variables, in the task </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">definition resource.</span></span></li>
<li><span class="koboSpan" id="kobo.426.1">Create a service resource that references the task definition, and configure the desired number of task replicas and the load balancer settings </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">if applicable.</span></span></li>
<li><span class="koboSpan" id="kobo.428.1">Create a cluster resource if it doesn’t exist, and reference it in the task definition and </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">service resources.</span></span></li>
<li><span class="koboSpan" id="kobo.430.1">Run </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">terraform init</span></strong><span class="koboSpan" id="kobo.432.1"> to initialize the Terraform environment and download the necessary </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">provider plugins.</span></span></li>
<li><span class="koboSpan" id="kobo.434.1">Run </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">terraform plan</span></strong><span class="koboSpan" id="kobo.436.1"> to preview the changes that will be made to </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">your infrastructure.</span></span></li>
<li><span class="koboSpan" id="kobo.438.1">Run </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">terraform apply</span></strong><span class="koboSpan" id="kobo.440.1"> to create the ECS service and deploy the container to your cluster in your </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">AWS account.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.442.1">Here is an example of </span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.443.1">how to use Terraform to deploy a</span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.444.1"> container </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">to ECS:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.446.1">
resource "aws_ecs_task_definition" "example" {
  family = "example-task-definition"
  container_definitions = &lt;&lt;DEFINITION
[
  {
    "name": "example-container",
    "image": "example-image:latest",
    "portMappings": [
      {
        "containerPort": 80,
        "hostPort": 80
      }
    ],
    "memory": 512,
    "cpu": 256
  }
]
DEFINITION
}
resource "aws_ecs_service" "example" {
  name            = "example-service"
  task_definition = aws_ecs_task_definition.example.arn
  cluster         = aws_ecs_cluster.example.id
  desired_count   = 2
}
resource "aws_ecs_cluster" "example" {
  name = "example-cluster"
}</span></pre> <p><span class="koboSpan" id="kobo.447.1">This example creates an ECS task definition, service, and cluster using Terraform. </span><span class="koboSpan" id="kobo.447.2">The task definition defines the container image, container name, port mappings, and memory and CPU requirements. </span><span class="koboSpan" id="kobo.447.3">The service references the task definition and creates two replicas of the</span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.448.1"> container in the specified </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">ECS cluster.</span></span></p>
<p><span class="koboSpan" id="kobo.450.1">You can also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">aws_elbv2_listener</span></strong><span class="koboSpan" id="kobo.452.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">aws_elbv2_target_group</span></strong><span class="koboSpan" id="kobo.454.1"> resources to configure a load balancer and register the ECS service as a </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">target group.</span></span></p>
<p><span class="koboSpan" id="kobo.456.1">It’s worth noting that this is a simple example of deploying an ECS container using Terraform. </span><span class="koboSpan" id="kobo.456.2">You can use</span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.457.1"> the full set of options that the ECS resources provide to create and manage more complex ECS environments, such as auto scaling, rolling updates, and integration with other AWS services such as CloudWatch, CloudTrail, </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">and more.</span></span></p>
<p><span class="koboSpan" id="kobo.459.1">You can also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">terraform plan</span></strong><span class="koboSpan" id="kobo.461.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">terraform apply</span></strong><span class="koboSpan" id="kobo.463.1"> commands to preview and apply the changes made to the </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">ECS environment.</span></span></p>
<h3><span class="koboSpan" id="kobo.465.1">Deploying to AWS EKS</span></h3>
<p><span class="koboSpan" id="kobo.466.1">There are two steps for </span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.467.1">deploying applications to AWS EKS, as </span><a id="_idIndexMarker463"/><span class="No-Break"><span class="koboSpan" id="kobo.468.1">detailed next.</span></span></p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.469.1">Creating an AWS EKS cluster with Terraform</span></h2>
<p><span class="koboSpan" id="kobo.470.1">To create an Amazon EKS cluster using Terraform, you can use the AWS provider for Terraform, which provides a</span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.471.1"> set of resources and data sources specific to EKS. </span><span class="koboSpan" id="kobo.471.2">Here are the general steps to create an EKS cluster </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">using Terraform:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.473.1">Install and configure the AWS provider for Terraform in your </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">local environment.</span></span></li>
<li><span class="koboSpan" id="kobo.475.1">Create a new Terraform configuration file and specify the AWS provider and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">aws_eks_cluster</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.477.1"> resource.</span></span></li>
<li><span class="koboSpan" id="kobo.478.1">Define the properties of the EKS cluster, such as the cluster name, Kubernetes version, and VPC settings, in the </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">resource configuration.</span></span></li>
<li><span class="koboSpan" id="kobo.480.1">Optionally, create an </span><strong class="bold"><span class="koboSpan" id="kobo.481.1">Identity and Access Management</span></strong><span class="koboSpan" id="kobo.482.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.483.1">IAM</span></strong><span class="koboSpan" id="kobo.484.1">) role and policy for the cluster, and associate them with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">aws_eks_cluster</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.486.1"> resource.</span></span></li>
<li><span class="koboSpan" id="kobo.487.1">Optionally, create a configuration file for </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">kubeconfig</span></strong><span class="koboSpan" id="kobo.489.1"> to use </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">the cluster.</span></span></li>
<li><span class="koboSpan" id="kobo.491.1">Run </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">terraform init</span></strong><span class="koboSpan" id="kobo.493.1"> to initialize the Terraform environment and download the necessary </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">provider plugins.</span></span></li>
<li><span class="koboSpan" id="kobo.495.1">Run </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">terraform plan</span></strong><span class="koboSpan" id="kobo.497.1"> to preview the changes that will be made to </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">your infrastructure.</span></span></li>
<li><span class="koboSpan" id="kobo.499.1">Run </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">terraform apply</span></strong><span class="koboSpan" id="kobo.501.1"> to create the EKS cluster in your </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">AWS account.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.503.1">Here is an example of how to use Terraform to create an </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">EKS cluster:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.505.1">
resource "aws_eks_cluster" "example" {
  name     = "example-cluster"
  role_arn = aws_iam_role.example.arn
  version  = "1.20"
  vpc_config {
    security_group_ids = [aws_security_group.example.id]
    subnet_ids         = [aws_subnet.example.*.id]
  }
}
resource "aws_iam_role" "example" {
  name = "example-role"
  assume_role_policy = &lt;&lt;EOF
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Service": "eks.amazonaws.com"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}
EOF
}
resource "aws_iam_role_policy" "example" {
  name = "example-policy"
  role = aws_iam_role.example.id
  policy = &lt;&lt;EOF
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "ec2:Describe*",
       "iam:PassRole",
"eks:"
],
"Resource": ""
}
]
}
EOF
}
resource "aws_security_group" "example" {
name = "example-security-group"
description = "Controls access to the EKS cluster"
}
resource "aws_subnet" "example" {
count = 2
vpc_id = aws_vpc.example.id
cidr_block = "10.0.${count.index}.0/24"
availability_zone = "us-west-2a"
map_public_ip_on_launch = true
}</span></pre> <p><span class="koboSpan" id="kobo.506.1">This example creates an EKS cluster with the specified name and Kubernetes version and associates it with the specified IAM role and </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">security group.</span></span></p>
<p><span class="koboSpan" id="kobo.508.1">It also creates two subnets in the specified Availability Zone for worker nodes to </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">launch into.</span></span></p>
<p><span class="koboSpan" id="kobo.510.1">It’s worth noting that this is a simple example of creating an EKS cluster using Terraform. </span><span class="koboSpan" id="kobo.510.2">You can use the full set of options that the EKS resources provide to create and manage more complex EKS </span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.511.1">environments, such as scaling, monitoring, and integration with other AWS services such as CloudWatch, CloudTrail, </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">and more.</span></span></p>
<p><span class="koboSpan" id="kobo.513.1">You can also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">terraform plan</span></strong><span class="koboSpan" id="kobo.515.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">terraform apply</span></strong><span class="koboSpan" id="kobo.517.1"> commands to preview and apply the changes made to the </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">EKS environment.</span></span></p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.519.1">Deploying an application to an AWS EKS cluster with Terraform</span></h2>
<p><span class="koboSpan" id="kobo.520.1">To deploy container images to</span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.521.1"> Amazon EKS using Terraform, you can use the Kubernetes provider for Terraform, which provides a set of resources and data sources specific to EKS. </span><span class="koboSpan" id="kobo.521.2">Here are the general steps to deploy a Kubernetes Pod </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">using Terraform:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.523.1">Install and configure the Kubernetes provider for Terraform in your </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">local environment.</span></span></li>
<li><span class="koboSpan" id="kobo.525.1">Create a new Terraform configuration file and specify the Kubernetes provider and the necessary resources such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">kubernetes_namespace</span></strong><span class="koboSpan" id="kobo.527.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">kubernetes_deployment</span></strong><span class="koboSpan" id="kobo.529.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">kubernetes_service</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.533.1">Define the properties of the Pod, such as the container image, container name, container ports, and environment variables, in the </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">deployment resource.</span></span></li>
<li><span class="koboSpan" id="kobo.535.1">Create a service resource that references the deployment, and configure the load balancer settings </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">if applicable.</span></span></li>
<li><span class="koboSpan" id="kobo.537.1">Create a namespace resource if it doesn’t exist, and reference it in the deployment and </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">service resources.</span></span></li>
<li><span class="koboSpan" id="kobo.539.1">Run </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">terraform init</span></strong><span class="koboSpan" id="kobo.541.1"> to initialize the Terraform environment and download the necessary </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">provider plugins.</span></span></li>
<li><span class="koboSpan" id="kobo.543.1">Run </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">terraform plan</span></strong><span class="koboSpan" id="kobo.545.1"> to</span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.546.1"> preview the changes that will be made to </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">your infrastructure.</span></span></li>
<li><span class="koboSpan" id="kobo.548.1">Run </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">terraform apply</span></strong><span class="koboSpan" id="kobo.550.1"> to create the Kubernetes deployment and service, and deploy the Pod to your </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">EKS cluster.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.552.1">Here is an example of how to use Terraform to deploy a Pod </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">to EKS:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.554.1">
resource "kubernetes_namespace" "example" {
  metadata {
    name = "example-namespace"
  }
}
resource "kubernetes_deployment" "example" {
metadata {
name = "example-deployment"
namespace = kubernetes_namespace.example.metadata.0.name
}
spec {
replicas = 2
template {
  metadata {
    labels = {
      app = "example"
    }
  }
  spec {
    container {
      name  = "example"
      image = "example-image:latest"
      port {
        name = "http"
        container_port = 80
      }
    }
  }
}
}
}
resource "kubernetes_service" "example" {
metadata {
name = "example-service"
namespace = kubernetes_namespace.example.metadata.0.name
}
spec {
selector = kubernetes_deployment.example.spec.0.template.0.metadata.0.labels
port {
name = "http"
port = 80
target_port = "http"
}
}
}</span></pre> <p><span class="koboSpan" id="kobo.555.1">This example creates a Kubernetes namespace, deployment, and service using Terraform. </span><span class="koboSpan" id="kobo.555.2">The deployment defines the container image, container name, container ports, and the number of replicas for the Pod. </span><span class="koboSpan" id="kobo.555.3">The service references the deployment and creates a load balancer that directs traffic to </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">the Pods.</span></span></p>
<p><span class="koboSpan" id="kobo.557.1">You can also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">kubernetes_config_map</span></strong><span class="koboSpan" id="kobo.559.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">kubernetes_secret</span></strong><span class="koboSpan" id="kobo.561.1"> resources to manage configuration data and secrets for </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">the Pod.</span></span></p>
<p><span class="koboSpan" id="kobo.563.1">It’s worth noting that this is a simple example of deploying a Pod to EKS using Terraform. </span><span class="koboSpan" id="kobo.563.2">You can use the full set of options that the Kubernetes resources provide to create and manage more complex EKS environments, such as auto scaling, rolling updates, and integration with other AWS services such as CloudWatch, CloudTrail, </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">and more.</span></span></p>
<p><span class="koboSpan" id="kobo.565.1">You can also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">terraform plan</span></strong><span class="koboSpan" id="kobo.567.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">terraform apply</span></strong><span class="koboSpan" id="kobo.569.1"> commands to preview and apply the changes made to the </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">EKS environment.</span></span></p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.571.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.572.1">In conclusion, containers are a powerful tool for packaging and deploying applications in a consistent and portable way. </span><span class="koboSpan" id="kobo.572.2">AWS offers a variety of container services and platforms, each with its own set of features and capabilities. </span><span class="koboSpan" id="kobo.572.3">Terraform is an </span><strong class="bold"><span class="koboSpan" id="kobo.573.1">infrastructure-as-code</span></strong><span class="koboSpan" id="kobo.574.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.575.1">IaC</span></strong><span class="koboSpan" id="kobo.576.1">) tool that can be used to manage and provision resources in AWS, including containers. </span><span class="koboSpan" id="kobo.576.2">By using Terraform to deploy containers to AWS, you can automate the process of creating and managing containerized applications, and ensure that your infrastructure is consistent, repeatable, and versionable. </span><span class="koboSpan" id="kobo.576.3">This can greatly simplify the process of deploying and scaling applications, and allows you to focus on the business logic of your application rather than managing the </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">underlying infrastructure.</span></span></p>
<p><span class="koboSpan" id="kobo.578.1">In the next chapter, we’ll take a closer look at how Terraform can be leveraged for enterprise-level AWS projects. </span><span class="koboSpan" id="kobo.578.2">You’ll learn about the unique challenges and considerations that come with managing large-scale infrastructure, and how to navigate the decision-making process when it comes to implementing AWS and Terraform at the enterprise level. </span><span class="koboSpan" id="kobo.578.3">We’ll cover topics such as project planning, design considerations, and best practices for successful enterprise deployments. </span><span class="koboSpan" id="kobo.578.4">Stay tuned for a deep dive into the world of enterprise AWS </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">and Terraform.</span></span></p>
</div>


<div class="Content" id="_idContainer038">
<h1 id="_idParaDest-186" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.1.1">Part 3:How to Structure and Advance Terraform in Enterprises</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In this section, we explore how to use Terraform in enterprise-level projects, focusing on structuring and advancing Terraform implementations to meet the demands of large-scale organizations. </span><span class="koboSpan" id="kobo.2.2">We discuss how to integrate Terraform into enterprises, including building Git workflows for IaC and Terraform projects to enable version control, collaboration, and automated deployment. </span><span class="koboSpan" id="kobo.2.3">You’ll learn how to automate the deployment of Terraform projects, streamlining the provisioning and management of cloud resources. </span><span class="koboSpan" id="kobo.2.4">We also delve into governance and security, exploring how to use Terraform to govern AWS resources and build a secure infrastructure on AWS. </span><span class="koboSpan" id="kobo.2.5">Finally, we discuss how to achieve a perfect AWS infrastructure with Terraform, optimizing performance, reliability, and cost-effectiveness. </span><span class="koboSpan" id="kobo.2.6">By the end of this part, you’ll be equipped to structure and advance Terraform implementations in enterprises, ensuring scalable, secure, and efficient </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">cloud infrastructure.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B18198_10.xhtml#_idTextAnchor186"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 10</span></em></a><em class="italic"><span class="koboSpan" id="kobo.7.1">, Leveraging Terraform for the Enterprise</span></em></li>
<li><a href="B18198_11.xhtml#_idTextAnchor196"><em class="italic"><span class="koboSpan" id="kobo.8.1">Chapter 11</span></em></a><em class="italic"><span class="koboSpan" id="kobo.9.1">, Building Git Workflows for IaC and Terraform Projects</span></em></li>
<li><a href="B18198_12.xhtml#_idTextAnchor204"><em class="italic"><span class="koboSpan" id="kobo.10.1">Chapter 12</span></em></a><em class="italic"><span class="koboSpan" id="kobo.11.1">, Automating the Deployment of Terraform Projects</span></em></li>
<li><a href="B18198_13.xhtml#_idTextAnchor213"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 13</span></em></a><em class="italic"><span class="koboSpan" id="kobo.13.1">, Governing AWS with Terraform</span></em></li>
<li><a href="B18198_14.xhtml#_idTextAnchor227"><em class="italic"><span class="koboSpan" id="kobo.14.1">Chapter 14</span></em></a><em class="italic"><span class="koboSpan" id="kobo.15.1">, Building a Secure Infrastructure with AWS Terraform</span></em></li>
<li><a href="B18198_15.xhtml#_idTextAnchor258"><em class="italic"><span class="koboSpan" id="kobo.16.1">Chapter 15</span></em></a><em class="italic"><span class="koboSpan" id="kobo.17.1">, Perfecting AWS Infrastructure with Terraform</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer039">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer040">
</div>
</div>
</body></html>