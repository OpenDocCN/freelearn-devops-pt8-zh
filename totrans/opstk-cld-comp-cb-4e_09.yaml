- en: Chapter 9. OpenStack Orchestration Using Heat and Ansible
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章：使用 Heat 和 Ansible 进行 OpenStack 编排
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction – orchestrating with OpenStack
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 – 使用 OpenStack 进行编排
- en: Creating your first stack with Heat
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Heat 创建您的第一个堆栈
- en: Launching your stack with Heat
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Heat 启动您的堆栈
- en: Viewing the resources and output of a stack created with Heat
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看通过 Heat 创建的堆栈的资源和输出
- en: Deleting a Heat stack
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除 Heat 堆栈
- en: Updating a Heat stack
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新 Heat 堆栈
- en: Installing and configuring Ansible for OpenStack
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和配置 Ansible 以用于 OpenStack
- en: Using Ansible to launch instances
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ansible 启动实例
- en: Using Ansible to orchestrate software installation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ansible 编排软件安装
- en: Using Ansible to orchestrate software installations across multiple instances
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ansible 在多个实例之间编排软件安装
- en: Using Ansible to fully orchestrate the creation of a web server and load balancer
    stack
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ansible 完全编排 Web 服务器和负载均衡器堆栈的创建
- en: Introduction – orchestrating with OpenStack
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 – 使用 OpenStack 进行编排
- en: OpenStack is chosen as a platform for many reasons, but one that frequently
    tops the list is orchestration. Without an element of orchestration in your OpenStack
    environment, you have a powerful turbo engine car that is just used for the school-run.
    As with any cloud environment, there are various tools to help with your orchestrated
    workloads, but out of the box, OpenStack provides Heat, the orchestration engine.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: OpenStack 被选择作为平台有很多原因，但其中一个经常排在首位的是编排。如果您的 OpenStack 环境没有编排元素，那么您就拥有了一辆强大的涡轮增压赛车，却仅仅用于接送孩子上学。与任何云环境一样，帮助编排工作负载的工具有很多，但
    OpenStack 自带 Heat——编排引擎。
- en: With Heat, you can define rich environments in a template, such as a multi-tier
    web application, which allows users consistency in launching these relatively
    complex deployments. I view the Heat orchestration templates (known as **HOT**
    (**Heat Orchestration Template**) – get it?) as a recipe that is written in **YAML**
    (**Yet Another Markup Language**). You define your ingredients that make up the
    environment. In a cooking recipe, this would be listing the amount of chocolate,
    flour, and sugar that is required for something like a cake. In a HOT ()file,
    this is the parameters section. You define the flavor of instances, the images
    used, and what networks the instances should launch against.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Heat，您可以在模板中定义丰富的环境，例如多层 Web 应用程序，这使得用户在启动这些相对复杂的部署时保持一致性。我将 Heat 编排模板（称为
    **HOT**（**Heat Orchestration Template**）——明白了吗？）看作是用 **YAML**（**Yet Another Markup
    Language**）编写的食谱。您定义构成环境的配料。在烹饪食谱中，这将列出制作蛋糕所需的巧克力、面粉和糖的数量。在 HOT 文件中，这就是参数部分。您定义实例的规格、使用的镜像以及实例应该在哪些网络上启动。
- en: Like any good recipe, you can override these defaults—so if you fancy experimenting
    with jam instead of chocolate sauce, or varying the amount of sugar required—you
    can adjust these. Also, with Heat you do this in an environment file. This file
    is laid out as though you're assigning values to the parameters. For example,
    an input parameter in the HOT file might be `image_name`, and in an environment
    file, you assign `image_name=ubuntu-image`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 像任何好的食谱一样，您可以覆盖这些默认值——所以如果您想尝试用果酱代替巧克力酱，或者调整所需糖分的量——您可以进行调整。此外，在 Heat 中，您是在环境文件中执行此操作。此文件的布局就像您正在为参数分配值。例如，HOT
    文件中的输入参数可能是 `image_name`，而在环境文件中，您将 `image_name=ubuntu-image` 进行分配。
- en: The next section in the HOT file is the largest and most complex as it is the
    method section of the recipe – the "how all the ingredients create a cake" section.
    In Heat, this is the start of the resources section. The resources section describes
    how the instances interact with each other. For example, a load balancer might
    get created during the Heat run that includes three web servers. The load balancer
    resources would have a method to attach these three unknown web servers to the
    load balance pool for that resource to be complete.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: HOT 文件中的下一部分是最大的也是最复杂的，因为它是配方的“方法”部分——即“所有配料如何创造一个蛋糕”的部分。在 Heat 中，这是资源部分的开始。资源部分描述了实例之间如何相互作用。例如，在
    Heat 运行期间，可能会创建一个包含三个 Web 服务器的负载均衡器。负载均衡器资源将有一个方法，将这三个未知的 Web 服务器附加到负载均衡池中，以便该资源完成。
- en: The final section is the output section. In a cooking recipe, you'd be taking
    the cake out of the oven. In OpenStack, this will be the end result—your multi-tier
    web application. However, with OpenStack and the nature of launching a number
    of instances into an environment that may not have even had a network created
    at that point, it would be hard to know the IP addresses that have been used,
    which may be needed in order to access the deployed stack. So, for this, we have
    the output section where a user of OpenStack can interrogate the stack and get
    useful information so that the launched stack is usable.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分是输出部分。在烹饪食谱中，你会把蛋糕从烤箱中取出。在 OpenStack 中，这将是最终结果——你的多层 Web 应用程序。然而，由于 OpenStack
    以及启动多个实例到可能尚未创建网络的环境中的特性，很难知道已经使用了哪些 IP 地址，而这些信息可能是访问已部署堆栈所需要的。因此，为此，我们有了输出部分，OpenStack
    的用户可以查询堆栈并获得有用的信息，以便已启动的堆栈可用。
- en: However, we are not limited to using the Heat orchestration engine within OpenStack
    when it comes to instance and application life cycle management. As introduced
    in [Chapter 1](part0014_split_000.html#DB7S2-189e69df43a248268db97cde1b1a8e47
    "Chapter 1. Installing OpenStack with Ansible"), *Installing OpenStack with Ansible*,
    Ansible is a great example of a platform independent tool that we can use to help
    orchestrate tasks. Using Ansible modules specific to the target environment, such
    as OpenStack, we can launch instances and perform software installations in a
    structured way that may suit users of both OpenStack and other cloud environments.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实例和应用程序生命周期管理方面，我们不仅限于使用 OpenStack 内的 Heat 编排引擎。如[第1章](part0014_split_000.html#DB7S2-189e69df43a248268db97cde1b1a8e47
    "第1章 安装 OpenStack 使用 Ansible") *《使用 Ansible 安装 OpenStack》* 中介绍的，Ansible 是一个平台无关的工具，我们可以利用它来帮助编排任务。通过使用特定于目标环境（如
    OpenStack）的 Ansible 模块，我们可以以结构化的方式启动实例并执行软件安装，这种方式适用于 OpenStack 用户和其他云环境的用户。
- en: The basic structure of Ansible is quite straightforward. In its simplest form,
    it has a notion of playbooks, plays, and tasks. If you study the OpenStack-Ansible
    playbooks that were described in [Chapter 1](part0014_split_000.html#DB7S2-189e69df43a248268db97cde1b1a8e47
    "Chapter 1. Installing OpenStack with Ansible"), *Installing OpenStack with Ansible*
    you'll get an insight into advanced features not covered in this chapter, which
    allow you to extend your OpenStack-based cloud environments into fully orchestrated
    masterpieces!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 的基本结构非常简单。最基本的形式中，它包括剧本（playbooks）、剧本任务（plays）和任务（tasks）。如果你研究[第1章](part0014_split_000.html#DB7S2-189e69df43a248268db97cde1b1a8e47
    "第1章 安装 OpenStack 使用 Ansible") *《使用 Ansible 安装 OpenStack》* 中描述的 OpenStack-Ansible
    剧本，你将获得一些本章未涉及的高级功能的见解，这些功能可以帮助你将基于 OpenStack 的云环境扩展为完全编排的杰作！
- en: Creating your first stack
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的第一个堆栈
- en: With Heat, we can create a wide variety of templates from spinning up basic
    instances, to creating complete environments for an application. In this section,
    we will show the basics of Heat by spinning up an instance and attaching it to
    an existing Neutron network, and assigning a floating IP to it. Heat templates
    describe the resources being used, the type and size of the instances, the network
    an instance will be attached to, among other pieces of information required to
    run that environment.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Heat，我们可以创建各种各样的模板，从启动基本实例，到为应用程序创建完整的环境。在这一部分，我们将通过启动一个实例并将其附加到现有的 Neutron
    网络，并为其分配浮动 IP，来展示 Heat 的基础知识。Heat 模板描述了所使用的资源、实例的类型和大小、实例将附加的网络，以及运行该环境所需的其他信息。
- en: In this section, we will show you how to use a HOT file to spin up two web servers
    running Apache, connected behind a third instance running HAProxy acting as the
    load balancer.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将展示如何使用 HOT 文件启动两个运行 Apache 的 Web 服务器，并将其连接到第三个运行 HAProxy 的实例上，后者充当负载均衡器。
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure that you are logged onto a correctly configured OpenStack client and
    can access the OpenStack environment. Refer to [Chapter 2](part0024_split_000.html#MSDG1-189e69df43a248268db97cde1b1a8e47
    "Chapter 2. The OpenStack Client"), *The OpenStack Client*, for details of setting
    up your environment to use Heat.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已登录到正确配置的 OpenStack 客户端，并能够访问 OpenStack 环境。有关如何设置环境以使用 Heat 的详细信息，请参考[第2章](part0024_split_000.html#MSDG1-189e69df43a248268db97cde1b1a8e47
    "第2章 OpenStack 客户端") *《OpenStack 客户端》*。
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'In this section, we will download a HOT file called `cookbook.yaml`, which
    will describe our instance and the network to attach it to:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将下载一个名为 `cookbook.yaml` 的 HOT 文件，该文件将描述我们的实例及其要连接的网络：
- en: 'First, we download the HOT file from the Cookbook GitHub repository:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们从 Cookbook GitHub 仓库下载 HOT 文件：
- en: '[PRE0]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Heat takes input parameters from the command line, or from an environment file,
    which get passed to the template. These parameters are seen at the top of the
    HOT file, as shown here:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Heat 从命令行或环境文件中获取输入参数，这些参数会传递给模板。这些参数出现在 HOT 文件的顶部，如下所示：
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As can be seen, we expect to pass in various parameters when we launch this
    template. Ensure that we have these details by running the following commands:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如图所示，我们在启动这个模板时预计会传入多个参数。通过运行以下命令，确保我们拥有这些详细信息：
- en: '[PRE2]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `openstack network list` output may look like the following:'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`openstack network list` 的输出可能如下所示：'
- en: '![How to do it...](img/00166.jpeg)'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![How to do it...](img/00166.jpeg)'
- en: 'With the information at hand, we create an environment file that will be used
    to store our parameters that we will pass to the HOT file when we launch the stack.
    Create `cookbook-env.yaml` in the same directory as `cookbook.yaml` with the following
    contents based on the output of the previous commands (adjust to suit your environment):'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了手头的信息后，我们创建一个环境文件，用于存储将在启动堆栈时传递给 HOT 文件的参数。根据之前命令的输出，在与 `cookbook.yaml` 相同的目录下创建
    `cookbook-env.yaml` 文件（根据你的环境进行调整）：
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Heat Orchestration Templates (HOT) are YAML files that describe our environment,
    or "Stacks" as they''re known. The basic templates generally have the following
    structure:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Heat Orchestration Templates (HOT) 是描述我们的环境的 YAML 文件，环境也称为“堆栈”（Stacks）。基本模板通常具有以下结构：
- en: '`description:`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description:`'
- en: '`parameters:`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parameters:`'
- en: '`resources:`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources:`'
- en: '`outputs:`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`outputs:`'
- en: The `description:` section has a number of words that helps a user understand
    what is expected to occur when the template is used.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`description:` 部分包含了一些词语，帮助用户理解使用模板时预期会发生什么。'
- en: 'The `parameters:` section defines the input variables, for example, the type
    of image(s) to be used, the network(s) to attach the instances on, and the key
    pair name to associate with the instances. Parameters are arbitrary and can contain
    any information needed to execute the template properly. The parameters: section
    works directly with the information found in the accompanying environment file
    (as specified by the `--environment` parameter). Each parameter must either have
    a default value or be specified in the environment file for the stack to launch
    successfully.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`parameters:` 部分定义了输入变量，例如，要使用的镜像类型、要将实例附加到的网络、以及与实例关联的密钥对名称。参数是任意的，可以包含执行模板所需的任何信息。`parameters:`
    部分与附带的环境文件中的信息直接配合（如 `--environment` 参数所指定）。每个参数必须要么有默认值，要么在环境文件中指定，以便堆栈能够成功启动。'
- en: The `resources:` section is usually the biggest section as it describes the
    environment. It can describe the instances that will be used, the naming of them,
    which networks to attach, and essentially how all of the elements relate to each
    other and how the environment is orchestrated. Explanations of how best to write
    these resources are beyond the scope of this book.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources:` 部分通常是最大的一部分，因为它描述了环境。它可以描述将要使用的实例、实例的命名、需要附加的网络，以及所有元素如何相互关联以及环境是如何协调的。如何编写这些资源的最佳方法超出了本书的范围。'
- en: The `outputs:` section refers to the "return" values from running the stack.
    For example, a user will need to know how to access a particular stack that has
    just been created. Random IPs and hostnames can all be assigned as normal operation
    of running stacks, so being able to interrogate the right information in order
    to access the environment is a must.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`outputs:` 部分指的是运行堆栈时的“返回”值。例如，用户需要知道如何访问刚刚创建的某个堆栈。随机的 IP 和主机名可以像正常运行堆栈一样被分配，因此，能够查询正确的信息以访问环境是必须的。'
- en: Launching your stack with Heat
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Heat 启动堆栈
- en: 'To launch a Heat stack we need three things: a *name* for the stack, the *template*
    (HOT) that describes the deployment, and finally, the *environment file* that
    fills in the blanks of the input parameters.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动一个 Heat 堆栈，我们需要三样东西：堆栈的 *名称*，描述部署的 *模板*（HOT），以及最后，填补输入参数空白的 *环境文件*。
- en: Getting ready
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Ensure that you are logged on to a correctly configured OpenStack client and
    can access the OpenStack environment. Refer to [Chapter 2](part0024_split_000.html#MSDG1-189e69df43a248268db97cde1b1a8e47
    "Chapter 2. The OpenStack Client"), *The OpenStack Client*, for details of setting
    up your environment to use OpenStack.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已登录到正确配置的OpenStack客户端，并且能够访问OpenStack环境。有关如何设置环境以使用OpenStack的详细信息，请参考[第2章](part0024_split_000.html#MSDG1-189e69df43a248268db97cde1b1a8e47
    "第2章. OpenStack客户端")，*OpenStack客户端*。
- en: Tip
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you get the `openstack: ''stack'' is not an openstack` command, refer to
    `openstack --help`.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '如果收到`openstack: ''stack'' 不是一个openstack`命令，请参考`openstack --help`。'
- en: 'Ensure that the `python-heatclient` package is installed:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 确保已安装`python-heatclient`包：
- en: '`sudo -H pip install python-heatclient`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo -H pip install python-heatclient`'
- en: Also ensure that you have downloaded the example `cookbook.yaml` Heat template
    and have created the environment file, as described in the previous recipe.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 还要确保您已下载示例`cookbook.yaml` Heat模板，并根据前面的步骤创建了环境文件。
- en: How to do it...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this section, we will download a HOT file called `cookbook.yaml`, which
    will describe our instance and the network to attach it to:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将下载一个名为`cookbook.yaml`的HOT文件，该文件将描述我们的实例及其要连接的网络：
- en: 'We will launch the stack with the following commands:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用以下命令启动堆栈：
- en: '[PRE4]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Tip**: You can use the `-t` flags instead of `--template`, and `-e` instead
    of `--environment`.'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**提示**：您可以使用`-t`标志代替`--template`，使用`-e`代替`--environment`。'
- en: 'This will produce an output like the following:'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将生成如下输出：
- en: '![How to do it...](img/00167.jpeg)'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00167.jpeg)'
- en: 'To view a list of stacks, execute the following command:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看堆栈列表，请执行以下命令：
- en: '[PRE5]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will bring back a list of stacks currently running:'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回当前运行的堆栈列表：
- en: '![How to do it...](img/00168.jpeg)'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00168.jpeg)'
- en: Note **Stack Status**. A successful launch is when it is marked as **CREATE_COMPLETE**.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意**堆栈状态**。成功启动时，状态会标记为**CREATE_COMPLETE**。
- en: How it works...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Launching a stack is simple. We will specify the HOT file with the `--template`
    parameter, and then we will specify the inputs that get described in the template
    in a file that we specify with the `--environment` parameter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 启动堆栈很简单。我们将使用`--template`参数指定HOT文件，然后使用`--environment`参数指定一个文件，该文件中描述了模板中的输入。
- en: 'The syntax is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 语法如下：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the name of the stack must be unique in your project.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，堆栈名称在您的项目中必须是唯一的。
- en: Viewing the resources and output of a stack created with Heat
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看使用Heat创建的堆栈的资源和输出
- en: A stack is an orchestrated set of services, where the user launching the stack
    shouldn't care too much about what IP addresses were assigned. However, the application
    stack has been launched to serve a purpose and therefore it is helpful to know
    how to access it! To access the environment, the user interrogates the "outputs"
    of the stack, which were defined as part of the template. In this example, we
    are concerned about how to access the website running behind the HAProxy server.
    The HAProxy server has been assigned a floating IP from the GATEWAY_NET network,
    and it is assumed that this is how the application will be accessed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈是一个编排的服务集，启动堆栈的用户不需要过多关心分配了哪些IP地址。然而，应用堆栈的启动是为了某个目的，因此了解如何访问它非常有用！要访问该环境，用户需要查询堆栈的“输出”，这些输出是模板的一部分。在本示例中，我们关心的是如何访问在HAProxy服务器后面运行的网站。HAProxy服务器已从GATEWAY_NET网络分配了一个浮动IP地址，假设这是访问该应用程序的方式。
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure that you are logged on to a correctly configured OpenStack client and
    can access the OpenStack environment. Refer to [Chapter 2](part0024_split_000.html#MSDG1-189e69df43a248268db97cde1b1a8e47
    "Chapter 2. The OpenStack Client"), *The OpenStack Client*, for details of setting
    up your environment to use Heat.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已登录到正确配置的OpenStack客户端，并且能够访问OpenStack环境。有关如何设置环境以使用Heat的详细信息，请参考[第2章](part0024_split_000.html#MSDG1-189e69df43a248268db97cde1b1a8e47
    "第2章. OpenStack客户端")，*OpenStack客户端*。
- en: How to do it...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To view the application stack and get information about how to access it, carry
    out the following steps:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看应用堆栈并获取有关如何访问它的信息，请执行以下步骤：
- en: 'You can view more details of a stack using the following command:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用以下命令查看堆栈的更多详细信息：
- en: '[PRE7]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will bring back a number of details about the created stack:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回关于创建的堆栈的多个详细信息：
- en: '![How to do it...](img/00169.jpeg)'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00169.jpeg)'
- en: 'A section in the template references *outputs*. Outputs allow a user to interrogate
    these values so that they can access the running stack. Without this, the user
    would have to do more digging into the running systems to find out what IP addresses
    were assigned to the instances that make up the stack. To see a list of outputs
    associated with our running stack, execute the following command:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板中的一部分引用了*输出*。输出使得用户可以查询这些值，从而访问正在运行的堆栈。如果没有这个功能，用户就需要深入研究运行中的系统，才能找出分配给堆栈组成实例的
    IP 地址。要查看与我们正在运行的堆栈相关联的输出列表，请执行以下命令：
- en: '[PRE8]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will bring back the following output:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回以下输出：
- en: '![How to do it...](img/00170.jpeg)'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00170.jpeg)'
- en: 'To view a particular value, such as the public IP (*floating IP*) assigned
    to our HAProxy instance, we can access the websites that are running on private
    addresses behind the load balancer. To do so, issue the following command:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看特定的值，比如分配给 HAProxy 实例的公共 IP（*浮动 IP*），我们可以访问通过负载均衡器后面的私有地址运行的站点。要做到这一点，请执行以下命令：
- en: '[PRE9]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This gives the IP address that we would then use to access this particular
    service set up as a stack:'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回我们用于访问该特定服务的 IP 地址，该服务设置为一个堆栈：
- en: '![How to do it...](img/00171.jpeg)'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00171.jpeg)'
- en: In this example application stack, we can then use the `http://192.168.100.108/`
    address, which will send the request to either of the web servers that are running,
    configured as part of this HAProxy load balancer demonstration.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个示例应用堆栈中，我们可以使用`http://192.168.100.108/`地址，它会将请求发送到任意正在运行的 Web 服务器，这些服务器是作为
    HAProxy 负载均衡器演示的一部分进行配置的。
- en: How it works…
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'A stack is designed to take a number of inputs, performs some actions, and
    produces a number of instances running an application ready for service. However,
    this hands-off approach means a lot of decisions are automatically dictated by
    OpenStack—predominantly because the instances get served from DHCP-enabled subnets.
    In order to find out the state of the stack and information about how to access
    the stack, a user would interrogate the **outputs**, which were described in the
    template. In the example template, the output section looks like the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一个堆栈被设计为接受多个输入，执行一些操作，并生成多个运行应用的实例，准备提供服务。然而，这种免操作的方式意味着许多决策都是由 OpenStack 自动决定的——主要是因为这些实例是从启用
    DHCP 的子网中提供的。为了了解堆栈的状态以及如何访问堆栈的信息，用户需要查询模板中描述的**输出**。在示例模板中，输出部分如下所示：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The outputs that have more information are labelled as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 包含更多信息的输出标注如下：
- en: '`webserver1_private_ip`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`webserver1_private_ip`'
- en: '`webserver2_private_ip`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`webserver2_private_ip`'
- en: '`haproxy_public_ip`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`haproxy_public_ip`'
- en: 'In this recipe, we specifically targeted `haproxy_public_ip`, as this is how
    we would access the web service that we created. We issued the following command
    to do this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们特别针对`haproxy_public_ip`进行了设置，因为这是我们访问所创建的 Web 服务的方式。我们执行了以下命令来实现这一点：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Deleting a Heat stack
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除 Heat 堆栈
- en: To delete a running Heat stack we will make a simple call as shown in this recipe.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除一个运行中的 Heat 堆栈，我们将按照此教程中的方式发出一个简单的调用。
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Ensure that you are logged on to a correctly configured OpenStack client and
    can access the OpenStack environment. Refer to [Chapter 2](part0024_split_000.html#MSDG1-189e69df43a248268db97cde1b1a8e47
    "Chapter 2. The OpenStack Client"), *The OpenStack Client* for details of setting
    up your environment to use OpenStack.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经登录到正确配置的 OpenStack 客户端，并能够访问 OpenStack 环境。有关如何设置环境以使用 OpenStack，请参阅[第 2
    章](part0024_split_000.html#MSDG1-189e69df43a248268db97cde1b1a8e47 "第 2 章：OpenStack
    客户端")，*OpenStack 客户端*，其中详细介绍了如何设置您的环境。
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In this section, we'll show how to delete a stack.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示如何删除堆栈。
- en: 'To delete a running stack named `myStack`, issue the following command:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要删除名为`myStack`的运行堆栈，请执行以下命令：
- en: '[PRE12]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You will be prompted to confirm this deletion, as shown here. Type `y` to continue
    destroying the stack:![How to do it...](img/00172.jpeg)
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统会提示您确认是否删除，正如下面所示。输入`y`以继续销毁堆栈：![如何操作...](img/00172.jpeg)
- en: 'You can check on the status of the deletion by listing the created stacks:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过列出已创建的堆栈来检查删除状态：
- en: '[PRE13]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will bring back an empty list if there is no stack to show or the following
    during deletion:'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果没有堆栈可显示，或者在删除期间出现以下情况，它将返回一个空列表：
- en: '![How to do it...](img/00173.jpeg)'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00173.jpeg)'
- en: How it works...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In very much the same way that we can launch a stack easily, deleting one is
    achieved by simply specifying which stack we want to destroy and using the `stack
    delete` command.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们可以轻松启动堆栈一样，删除堆栈只需指定我们要销毁的堆栈，并使用`stack delete`命令即可。
- en: 'If you prefer to destroy a stack without confirmation, use the following syntax:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望在不确认的情况下销毁堆栈，请使用以下语法：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Updating a Heat stack
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新Heat堆栈
- en: Our running Stack is based on templates, so this allows us to modify our application
    stack by altering the inputs. If we wanted to change the size of a flavor, or
    the key used, you can trigger a rebuild of the instances in the stack by altering
    the inputs and issuing the `stack update` command.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的运行堆栈是基于模板的，这允许我们通过更改输入来修改应用程序堆栈。如果我们想更改flavor的大小或使用的密钥，可以通过更改输入并发出`stack
    update`命令来触发堆栈中实例的重建。
- en: Getting ready
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure that you are logged on to a correctly configured OpenStack client and
    can access the OpenStack environment. Refer to [Chapter 2](part0024_split_000.html#MSDG1-189e69df43a248268db97cde1b1a8e47
    "Chapter 2. The OpenStack Client"), *The OpenStack Client*, for details of setting
    up your environment to use OpenStack.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已登录到配置正确的OpenStack客户端，并能够访问OpenStack环境。有关设置环境以使用OpenStack的详细信息，请参阅[第2章](part0024_split_000.html#MSDG1-189e69df43a248268db97cde1b1a8e47
    "第2章. OpenStack客户端")，*OpenStack客户端*。
- en: How to do it...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In this section, we'll modify the environment file to change a flavor from `m1.tiny`
    to `m1.large`. (Ensure that you have a valid flavor with this name before continuing!)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将修改环境文件，将flavor从`m1.tiny`更改为`m1.large`。（在继续之前，请确保您有一个有效的flavor名称！）
- en: 'We first edit the environment file, called `cookbook-env.yaml`, to show the
    changes we want to make to our running stack:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先编辑名为`cookbook-env.yaml`的环境文件，展示我们希望对正在运行的堆栈进行的更改：
- en: '[PRE15]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Ensure that the stack is running without issues by viewing the resources:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过查看资源，确保堆栈正在正常运行：
- en: '[PRE16]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This will bring back an output like the following:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回类似以下的输出：
- en: '![How to do it...](img/00169.jpeg)'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00169.jpeg)'
- en: 'We will now use the updated environment file to modify the running stack:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用更新后的环境文件来修改正在运行的堆栈：
- en: '[PRE17]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tip
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Tip: We''re using the parameter **--existing** to avoid specifying the template
    and environment file again.'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示：我们使用`--existing`参数，以避免再次指定模板和环境文件。
- en: 'This will bring back an output like the following, showing the update has started:'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回类似以下的输出，显示更新已经开始：
- en: '![How to do it...](img/00174.jpeg)'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00174.jpeg)'
- en: 'Also we can view the state of the stack once this has been completed, to show
    the reflected change:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，我们还可以查看堆栈的状态，以显示反映的更改：
- en: '[PRE18]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will bring back an output like the following (note that the flavor has
    changed from `m1.tiny` to `m1.large`). Also note that the IP addresses have not
    changed:'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回类似以下的输出（注意flavor已从`m1.tiny`更改为`m1.large`）。还请注意，IP地址没有改变：
- en: '![How to do it...](img/00175.jpeg)'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00175.jpeg)'
- en: How it works...
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The OpenStack Orchestration service, Heat, is designed to follow a template
    to provide a running service to end users. Everything is automated from start
    to finish. This crucial feature allows us to update a running stack, effectively
    redeploying the stack with updates, which runs through the fully automated routine
    to restore the service, on the same IP addresses, but with the required changes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: OpenStack Orchestration服务Heat旨在遵循模板为最终用户提供运行中的服务。从头到尾，所有操作都是自动化的。这个关键功能允许我们更新正在运行的堆栈，实际上是通过更新重新部署堆栈，运行完全自动化的流程来恢复服务，使用相同的IP地址，但做出所需的更改。
- en: 'The syntax for updating the stack is as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 更新堆栈的语法如下：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In our example, we omitted the `--environment` and `--template` parameters
    as we made the required change to our stack directly in the environment file used
    originally. This allowed for a simpler syntax:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们省略了`--environment`和`--template`参数，因为我们直接在最初使用的环境文件中对堆栈进行了所需的更改。这使得语法更简单：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Installing and configuring Ansible for OpenStack
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置Ansible以用于OpenStack
- en: Ansible has relatively few prerequisites that are not installed on most Linux-
    and macOS-based systems. However, there are a few steps to follow before we can
    use Ansible for managing our OpenStack environment.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible对大多数Linux和macOS系统的先决条件要求较少。然而，在我们能使用Ansible来管理OpenStack环境之前，仍有一些步骤需要遵循。
- en: Getting ready
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure that you are logged on to a correctly configured OpenStack client and
    can access the OpenStack environment. Refer to [Chapter 2](part0024_split_000.html#MSDG1-189e69df43a248268db97cde1b1a8e47
    "Chapter 2. The OpenStack Client"), *The OpenStack Client*, for details of setting
    up your environment to use OpenStack.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已登录到正确配置的OpenStack客户端，并且可以访问OpenStack环境。有关如何设置环境以使用OpenStack的详细信息，请参见[第2章](part0024_split_000.html#MSDG1-189e69df43a248268db97cde1b1a8e47
    "第2章. OpenStack客户端")，*OpenStack客户端*。
- en: The version of Ansible 2.x requires Python 2.6 or 2.7\. Most modern Linux distributions
    and macOS/OS X have this already installed. If you were able to successfully execute
    the `openstack` commands as described in [Chapter 2](part0024_split_000.html#MSDG1-189e69df43a248268db97cde1b1a8e47
    "Chapter 2. The OpenStack Client"), *The OpenStack Client*, then you're good to
    go here.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 2.x版本需要Python 2.6或2.7。大多数现代Linux发行版和macOS/OS X都已经安装了这些。如果您能成功执行[第2章](part0024_split_000.html#MSDG1-189e69df43a248268db97cde1b1a8e47
    "第2章. OpenStack客户端")中描述的`openstack`命令，*OpenStack客户端*，那么您就可以继续进行。
- en: 'You may need to install Shade. Shade is a simple client library for interacting
    with OpenStack clouds. Red Hat and CentOS environments don''t have this installed
    by default. Install it with the following command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要安装Shade。Shade是一个与OpenStack云交互的简单客户端库。Red Hat和CentOS环境默认未安装此库。可以通过以下命令进行安装：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be aware that Shade may pull in other dependencies that may break your environment.
    It is suggested that you use a **virtual environment** (**venv**) to avoid this
    issue.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Shade可能会引入其他依赖项，这些依赖项可能会破坏您的环境。建议您使用**虚拟环境**（**venv**）来避免此问题。
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: As we're performing this on our client machine, ensure that you have the necessary
    permissions to install software. When ready, carry out the following steps depending
    on your chosen operating system.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在客户端计算机上执行此操作，请确保您拥有安装软件的必要权限。准备好后，根据您选择的操作系统执行以下步骤。
- en: Ubuntu
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ubuntu
- en: 'For Ubuntu, we can use the Ansible PPA as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Ubuntu，我们可以按以下方式使用Ansible PPA：
- en: 'First, ensure that we can add **PPA** (**Personal Package Archives**) by installing
    the following tool:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，确保我们可以通过安装以下工具来添加**PPA**（**个人软件包档案**）：
- en: '[PRE22]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we will add the PPA:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加PPA：
- en: '[PRE23]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we will run the installation:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将运行安装：
- en: '[PRE24]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: macOS/OS X (and for those wanting to use pip)
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: macOS/OS X（以及那些想使用pip的人）
- en: 'For macOS, we can use pip as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于macOS，我们可以按照以下方式使用pip：
- en: 'Ensure that `pip` is available:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保`pip`可用：
- en: '[PRE25]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, use `pip` to install Ansible:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用`pip`安装Ansible：
- en: '[PRE26]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Verifying the installation
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证安装
- en: 'To verify the installation, issue the following command:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证安装，请发出以下命令：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This should produce an output like the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生如下输出：
- en: '![Verifying the installation](img/00176.jpeg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![验证安装](img/00176.jpeg)'
- en: How it works...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In order for us to be able to use Ansible to manage our OpenStack environment,
    we must ensure that we have a good working Ansible set up. The preceding steps
    merely helped us install Ansible onto our client using the tools available for
    that operating system.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用Ansible管理我们的OpenStack环境，我们必须确保已经正确设置了Ansible。前面的步骤仅帮助我们使用该操作系统提供的工具将Ansible安装到我们的客户端上。
- en: Using Ansible to launch instances
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible启动实例
- en: Launching an instance using Ansible is a convenient, platform agnostic method.
    While we have to specify how to do this for OpenStack, as a particular task, an
    Ansible playbook could be extended to allow a user to use the same Ansible command
    to launch an instance on any cloud. This recipe is a very basic introduction to
    the use of Ansible with OpenStack.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ansible启动实例是一种方便的平台无关方法。虽然我们需要为OpenStack指定如何执行此操作作为特定任务，但Ansible playbook可以扩展，使用户能够使用相同的Ansible命令在任何云上启动实例。本教程是将Ansible与OpenStack一起使用的一个非常基础的介绍。
- en: Getting ready
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Ensure that you are logged on to a correctly configured OpenStack client and
    can access the OpenStack environment that has Ansible installed.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已登录到正确配置的OpenStack客户端，并且可以访问已安装Ansible的OpenStack环境。
- en: How to do it...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Ansible executes tasks in what is known as a playbook. In this example, we
    will create a simple task that launches a specific instance called `cookbook1`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible通过称为playbook的任务执行文件来执行任务。在本例中，我们将创建一个简单的任务来启动名为`cookbook1`的特定实例：
- en: 'The first step is to create the Ansible playbook for our tasks that will launch
    our instance. Create the following file called `launch-instance.yml` on your client,
    in a directory of your choosing:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是为我们的任务创建 Ansible playbook，该任务将启动我们的实例。在你的客户端创建一个名为`launch-instance.yml`的文件，放在你选择的目录中：
- en: '[PRE28]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once that has been described, we will simply run that particular task using
    the `ansible-playbook` command, as follows:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦描述了这些，我们只需使用`ansible-playbook`命令运行该特定任务，如下所示：
- en: '[PRE29]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This will bring back the familiar Ansible output like the following:'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将恢复熟悉的 Ansible 输出，如下所示：
- en: '![How to do it...](img/00177.jpeg)'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![How to do it...](img/00177.jpeg)'
- en: Note
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is a `localhost` task, so the warning can be ignored.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个`localhost`任务，因此可以忽略警告。
- en: 'We can verify that an instance was launched in OpenStack by viewing the server
    listing as follows:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过查看服务器列表来验证是否在 OpenStack 中启动了实例，如下所示：
- en: '[PRE30]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This will bring back an output like the following:'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将恢复如下所示的输出：
- en: '![How to do it...](img/00178.jpeg)'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![How to do it...](img/00178.jpeg)'
- en: Note that the task automatically assigned a public floating IP address from
    the `GATEWAY_NET` network. This is an important detail as Ansible can do much
    more than just launch instances. If we want to be able to install and configure
    instances, Ansible must be able to SSH from the client to the running instance.
    Private tenant networks are generally not accessible; therefore, Ansible would
    use the public routed network to access the instance, just like you would if you
    were to SSH to it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，任务自动从`GATEWAY_NET`网络分配了一个公共浮动 IP 地址。这是一个重要细节，因为 Ansible 能做的不仅仅是启动实例。如果我们希望能够安装和配置实例，Ansible
    必须能够从客户端通过 SSH 连接到正在运行的实例。私有租户网络通常无法访问；因此，Ansible 将使用公共路由网络来访问实例，就像你通过 SSH 连接到它一样。
- en: How it works...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Launching an instance using Ansible uses the `os_server` Ansible module. This
    is available from Ansible 2.0 onwards. The `os_server` module takes a number of
    parameters that describe the usual parameters you would expect when launching
    instances using the command line.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Ansible 启动实例使用的是`os_server` Ansible 模块。该模块从 Ansible 2.0 版本开始可用。`os_server`模块接受许多参数，这些参数描述了使用命令行启动实例时通常会遇到的参数。
- en: Note that we didn't specify any authentication details as part of the task.
    This is because this module interprets our shell environment variables, just like
    we would use when executing OpenStack client tools.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在任务中没有指定任何认证细节。这是因为该模块会解释我们的 shell 环境变量，就像我们使用 OpenStack 客户端工具时一样。
- en: 'You will notice that one of the entries in the task denotes the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，任务中的一个条目标明了如下内容：
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This has a specific intent in Ansible, as Ansible is designed to give state
    consistency of running that task, despite how many times that task may get run.
    This simple statement basically says that this instance must be present. If not,
    it will launch that instance. Once it has launched, it satisfies that predicate.
    In the Ansible output, you will see that the overall run says **ok=1 changed=1**.
    This means that it changes the state of this environment. In other words, it launched
    the instance (which is a change of state).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 Ansible 中有特定的意图，因为 Ansible 旨在确保任务的状态一致性，无论该任务执行多少次。这个简单的语句基本上表示该实例必须存在。如果不存在，它将启动该实例。一旦实例启动，它将满足该条件。在
    Ansible 输出中，你会看到整体运行状态为**ok=1 changed=1**。这意味着它改变了这个环境的状态。换句话说，它启动了实例（这是一种状态变化）。
- en: 'However, if we run the task again, we get the following subtle change in the
    output denoting that the task didn''t need to run to satisfy the fact the instance
    needed to be "present" (that is, running):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们再次运行该任务，输出中会出现以下微妙的变化，表明任务不需要执行，因为实例已经“存在”（即，正在运行）：
- en: '![How it works...](img/00179.jpeg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![How it works...](img/00179.jpeg)'
- en: Note that the task executed successfully, but didn't need to change anything
    as denoted by the **changed=0** output in the **PLAY RECAP** line.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，任务执行成功，但由于**changed=0**输出的原因，**PLAY RECAP**行中没有需要更改的内容。
- en: See also
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: Visit [http://docs.ansible.com/ansible/latest/os_server_module.html](http://docs.ansible.com/ansible/latest/os_server_module.html)
    for more information
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 [http://docs.ansible.com/ansible/latest/os_server_module.html](http://docs.ansible.com/ansible/latest/os_server_module.html)
    获取更多信息
- en: For those who do not want to source environment variables into their playbooks
    using the `source openrc` method, visit [https://docs.openstack.org/shade/latest/](https://docs.openstack.org/shade/latest/)
    to set up a `clouds.yaml` cloud environment file
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于那些不想通过 `source openrc` 方法将环境变量导入到 playbook 中的用户，可以访问 [https://docs.openstack.org/shade/latest/](https://docs.openstack.org/shade/latest/)
    来设置 `clouds.yaml` 云环境文件
- en: Using Ansible to orchestrate software installation
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ansible 来协调软件安装
- en: 'Launching an instance using Ansible doesn''t provide a user much beyond consistency,
    in that a playbook describes the end state of the environment: every time a user
    runs the task, it will either need to launch that specific instance to ensure
    that it is present, or it will skip that task because the instance is already
    running. However, we can achieve a lot more with Ansible beyond just launching
    a virtual machine. In this recipe, we will launch another instance that will install
    and start Apache.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Ansible 启动实例并不会为用户提供太多，除了提供一致性，因为 playbook 描述了环境的最终状态：每次用户运行任务时，要么需要启动该特定实例以确保它存在，要么跳过该任务，因为该实例已经在运行。然而，我们可以通过
    Ansible 实现更多的功能，而不仅仅是启动虚拟机。在这个食谱中，我们将启动另一个实例，该实例将安装并启动 Apache。
- en: Getting ready
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure that you are logged on to a correctly configured OpenStack client and
    can access the OpenStack environment that has Ansible installed.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经登录到正确配置的 OpenStack 客户端，并且可以访问安装了 Ansible 的 OpenStack 环境。
- en: How to do it...
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Ansible executes playbooks of tasks. In this example, we will extend the task
    that launches a specific instance to allow Ansible to then connect to that instance
    and install Apache:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 执行任务的 playbook。在此示例中，我们将扩展启动特定实例的任务，允许 Ansible 连接到该实例并安装 Apache：
- en: 'We start off by extending the Ansible playbook introduced in the previous recipe
    to include the creation of *security group rules* (this is to ensure that Ansible
    can access to the instance on port `22`, and we are ultimately able to access
    the running web server on port `80`). Create the file called `orchestrate-instance.yml`
    with the following contents:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过扩展前面食谱中介绍的 Ansible playbook 来开始，增加了创建*安全组规则*（这是为了确保 Ansible 可以通过端口 `22`
    访问实例，并且最终能够通过端口 `80` 访问运行的 Web 服务器）。创建一个名为 `orchestrate-instance.yml` 的文件，内容如下：
- en: '[PRE32]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once we have our **security groups** configured, we can then ensure that these
    security group rules are included in the **task** that launches the instance.
    We also ensure that we include a new entry called `register`. This allows us to
    set a variable associated with this instance that we can then refer to in other
    tasks. Carry on editing this file with the following tasks:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们配置了**安全组**，我们就可以确保这些安全组规则包含在**任务**中，该任务用于启动实例。我们还确保包括一个新的条目，名为`register`。这使我们能够设置与该实例关联的变量，然后可以在其他任务中引用该变量。继续编辑此文件并加入以下任务：
- en: '[PRE33]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we will add in a task that adds this particular instance to an internal
    in-memory inventory that we can then access later on in the playbook. As part
    of this inventory, we''re telling Ansible that when the particular inventory item
    is accessed, when Ansible wants to connect to it (via `ssh`), it will use a particular
    IP address (in our case, the public floating IP). Carry on editing the file and
    add this next entry as shown as follows. As we are using YAML, ensure that the
    spacing matches for each element. For example, this additional `- name: Add instance
    to Inventory` block must match the same column as the previous block `- name:
    Deploy an instance`, as it is a task that is part of the same play:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '接下来，我们将添加一个任务，将该特定实例添加到一个内部的内存库存中，我们可以在 playbook 后续部分访问该库存。作为这个库存的一部分，我们告诉
    Ansible，当访问该库存项时，当 Ansible 想连接到它（通过 `ssh`）时，它将使用特定的 IP 地址（在我们的案例中是公共浮动 IP）。继续编辑文件并添加下一个条目，格式如下所示。由于我们使用的是
    YAML，确保每个元素的缩进一致。例如，这个额外的 `- name: Add instance to Inventory` 块必须与前一个 `- name:
    Deploy an instance` 块在同一列对齐，因为它是同一个 play 的一部分：'
- en: '[PRE34]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Next, we will add in a new play that tells Ansible to wait for this instance
    to complete its boot process. As Ansible uses SSH to perform its tasks, it makes
    sense to only continue when the SSH daemon is running and accepting connections.
    Ensure that your private key running the Ansible task matches the public key portion
    described in `key_name:`.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个新的任务，告诉 Ansible 等待该实例完成启动过程。由于 Ansible 使用 SSH 执行任务，因此合理的做法是仅在 SSH
    守护进程运行并接受连接时继续。确保运行 Ansible 任务的私钥与 `key_name:` 中描述的公钥部分匹配。
- en: Tip
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that this is a new play and task, so ensure that this entry begins at the
    start of the line at column 0.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，这是一个新的剧本和任务，因此确保这一条目从行的起始列（列 0）开始。
- en: '[PRE35]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This final set of tasks perform the steps inside the running instance; this
    next task performs the installation of Apache on this running instance. Ansible
    knows to operate on this instance because this set of tasks is performed against
    the `webservers` group of hosts. We registered this new group, in the in-memory
    inventory, in the task in step 2.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这最后一组任务在运行中的实例内执行步骤；下一任务将在该运行中的实例上安装 Apache。Ansible 知道操作这个实例，因为这组任务是对`webservers`主机组执行的。我们在步骤
    2 的任务中，在内存中的库存中注册了这个新组。
- en: Note
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `pre_tasks:` section is *optional* and may not be needed in all circumstances.
    The example in this book was created using an Ubuntu 16.04 image. Ubuntu 16.04
    doesn't install Python 2 by default, however this particular Ansible `apt` module,
    that will ultimately install Apache, expects to execute Python 2 code in order
    to work. So, we do an initial `raw` command, that doesn't execute any Python,
    to run some shell script to set some things up for us. This example is also further
    complicated if you are using the accompanying Vagrant environment, which the instances
    do not have direct access to the internet. So, as part of the `pre_tasks:` section,
    we also configure a proxy server for APT to use.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`pre_tasks:` 部分是*可选*的，在所有情况下可能不需要。本书中的示例是使用 Ubuntu 16.04 镜像创建的。Ubuntu 16.04
    默认不安装 Python 2，然而这个特定的 Ansible `apt` 模块，最终将安装 Apache，需要执行 Python 2 代码才能正常工作。因此，我们执行一个初始的
    `raw` 命令，这个命令不执行任何 Python，而是运行一些 shell 脚本来为我们设置一些东西。如果你正在使用随附的 Vagrant 环境，这个示例也会更加复杂，因为实例没有直接访问互联网的权限。所以，作为
    `pre_tasks:` 部分的一部分，我们还配置了一个 APT 代理服务器。'
- en: '[PRE36]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Tip
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Hint: This playbook can also be found at [https://raw.githubusercontent.com/OpenStackCookbook/vagrant-openstack/master/orchestrate-instance.yml](https://raw.githubusercontent.com/OpenStackCookbook/vagrant-openstack/master/orchestrate-instance.yml).'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示：这个剧本也可以在[https://raw.githubusercontent.com/OpenStackCookbook/vagrant-openstack/master/orchestrate-instance.yml](https://raw.githubusercontent.com/OpenStackCookbook/vagrant-openstack/master/orchestrate-instance.yml)找到。
- en: 'Once this file has been created, save and exit. Then run the following commands
    which will launch an instance and install Apache:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此文件后，保存并退出。然后运行以下命令，这将启动一个实例并安装 Apache：
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This will bring back the familiar Ansible output like the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回类似下面的熟悉的 Ansible 输出：
- en: '![How to do it...](img/00180.jpeg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/00180.jpeg)'
- en: How it works...
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: What we did here was extending the original, simple *playbook* that launched
    a single instance, and adding in subsequent *tasks* that allow us to install some
    software onto that instance once it has completed its boot process. The important
    details of how this is achieved are described here.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是扩展原本简单的*剧本*，该剧本启动了一个单一实例，并在实例完成启动过程后，添加了后续的*任务*，使我们能够在该实例上安装一些软件。如何实现这一点的关键细节在这里描述。
- en: In the first *play*, named `Launch instance on OpenStack`, we first configure
    some tasks to set up our security group rules. By default, there are no incoming
    connections allowed, and Ansible uses SSH to perform its tasks, so we have to
    at least ensure that TCP port 22 is open. We also configure rules appropriate
    for the service that we are installing. In this case, we are running Apache, so
    we open up TCP port 80\. Once the security groups are configured, we then have
    a *task* named `Deploy an instance`. We ensure this instance is launched with
    the appropriate security groups that we have just configured, and we also register
    that instance in a variable named `nova_cookbook`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个*剧本*中，名为 `Launch instance on OpenStack`，我们首先配置一些任务来设置我们的安全组规则。默认情况下，不允许任何传入连接，而
    Ansible 使用 SSH 来执行任务，因此我们至少需要确保 TCP 端口 22 是开放的。我们还配置了适合我们正在安装的服务的规则。在这种情况下，我们运行
    Apache，所以我们打开 TCP 端口 80。安全组配置好之后，我们有一个名为 `Deploy an instance` 的*任务*。我们确保这个实例启动时使用我们刚刚配置的安全组，并且我们还将该实例注册到名为
    `nova_cookbook` 的变量中。
- en: 'Ansible uses an **inventory** of data to allow subsequent plays and tasks to
    access details that Ansible have performed in your environment, and so the next
    *task*, named `Add instance to Inventory` places a *host* named `cookbook1` into
    a **host group** called `webservers`. And for this particular *host*, named `cookbook1`,
    in the group `webservers`, we are setting the variable that Ansible would use
    to access that instance as the floating IP address assigned: `(ansible_ssh_host={{
    nova_cookbook.server.accessIPv4 }}`. As you can see, we are using our registered
    variable, `nova_cookbook`, to access some information that Ansible has stored
    about that instance. It is important that we use the floating IP because the private
    tenant network is not routable from our client, and therefore Ansible would not
    be able to connect to perform the Apache install.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible使用**inventory**数据来允许后续的play和task访问Ansible在环境中执行过的详细信息，因此下一个名为`Add instance
    to Inventory`的*task*会将一个名为`cookbook1`的*host*放入一个名为`webservers`的**host group**中。对于这个特定的*host*（名为`cookbook1`，属于`webservers`组），我们设置了Ansible访问该实例时使用的变量，即分配的浮动IP地址：`(ansible_ssh_host={{
    nova_cookbook.server.accessIPv4 }}`。如你所见，我们使用了已注册的变量`nova_cookbook`来访问Ansible存储的该实例的信息。使用浮动IP地址非常重要，因为私有租户网络无法从我们的客户端路由，因此Ansible无法连接以执行Apache安装。
- en: The next *play* named `Wait for port 22 to be ready` basically has a *task*
    that waits for SSH to be running. This signals that the instance is ready for
    use, and therefore we are able to SSH into this to run further Ansible commands.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个名为`Wait for port 22 to be ready`的*play*基本上是一个等待SSH启动的*task*。这表示实例已准备好使用，因此我们可以通过SSH进入该实例并执行进一步的Ansible命令。
- en: The last one is the *play* that has *tasks* that perform the install of Apache.
    As described earlier, we have placed an optional set of `pre_tasks` into this
    section to overcome the fact that Ubuntu 16.04 doesn't come with the necessary
    prerequisite Python packages needed for Ansible to run. We have also set an optional
    APT proxy here too, so feel free to remove and adjust this section according to
    the image and environment you are operating with.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个*play*包含执行Apache安装的*tasks*。如前所述，我们在此部分加入了一组可选的`pre_tasks`，以解决Ubuntu 16.04没有提供Ansible运行所需的Python依赖包的问题。我们还在这里设置了一个可选的APT代理，因此可以根据所使用的镜像和环境自由删除和调整此部分。
- en: The last set of *tasks* in this *play* basically ensure that Apache is installed
    and runs. Here you could then add in additional tasks to pull in Apache configuration
    data from GitHub, or install additional packages, thus completing the set up of
    this instance from a single Ansible command.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*play*中的最后一组*tasks*基本上确保Apache已经安装并运行。在这里，你可以进一步添加*tasks*从GitHub拉取Apache配置数据，或者安装其他软件包，从而通过单个Ansible命令完成该实例的设置。
- en: Using Ansible to orchestrate software installations across multiple instances
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible在多个实例上协调软件安装。
- en: So far, we created playbooks that first launched an instance, and then we extended
    this in the previous recipe to subsequently install Apache onto the running instance.
    This recipe describes a playbook that can launch any number of instances, and
    install Apache onto each of those instances.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们创建的playbook首先启动了一个实例，然后在前一个配方中扩展了该过程，接着在运行中的实例上安装了Apache。本配方描述了一个playbook，它可以启动任意数量的实例，并在每个实例上安装Apache。
- en: Getting ready
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure that you are logged on to a correctly configured OpenStack client and
    can access the OpenStack environment that has Ansible installed.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已登录到一个正确配置的OpenStack客户端，并能够访问安装了Ansible的OpenStack环境。
- en: How to do it...
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We will extend the previous recipe's playbook to add flexibility to include
    a variable number of instances.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展前一个配方中的playbook，以增加灵活性，支持包括可变数量的实例。
- en: 'The basic structure was provided in the previous recipe, so the only **play**
    we need to adjust is the first one that launches the instances, called `Launch
    instances on OpenStack`. This complete *play* is shown as follows, where we introduce
    a variable called `count`, which we have set to `2`, and we also introduce the
    `with_sequence` section, which forms our loop that will execute that *task* the
    specified number of *count* times. Note that we also include the count value as
    part of the instance name:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基本结构在前面的配方中已经提供，因此我们唯一需要调整的是第一个启动实例的**play**，名为`Launch instances on OpenStack`。这个完整的*play*如下所示，其中我们引入了一个名为`count`的变量，已设置为`2`，并且我们还引入了`with_sequence`部分，形成一个循环，该循环会执行指定次数的*task*。请注意，我们还将count值作为实例名称的一部分：
- en: '[PRE38]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The next set of plays copy what was described in the previous recipe, such
    as waiting for the instance''s SSH to be available and subsequently installing
    Apache, and is shown here for completeness:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一组任务与前面的食谱中描述的内容相同，例如等待实例的 SSH 可用并随后安装 Apache，这里列出是为了完整性：
- en: '[PRE39]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `pre_tasks:` section is optional. Your use will vary on any implicit restrictions
    imposed on the image or environment you are using. This was described in the previous
    recipe on its use here:'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`pre_tasks:` 部分是可选的。您的使用方式将根据您所使用的镜像或环境所施加的任何隐性限制而有所不同。有关如何使用它的说明，请参见前面一篇食谱中的描述：'
- en: '[PRE40]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Assuming the file that you have created is called `multi-orchestrate-instances.yml`,
    you execute this with the following:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设您创建的文件名为 `multi-orchestrate-instances.yml`，您可以使用以下命令执行它：
- en: '[PRE41]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This will bring back an output like the following. This produces more output
    than the other plays so far, so only the last part is shown:'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回如下输出。这产生的输出比到目前为止的其他任务要多，因此这里只显示了最后一部分：
- en: '![How to do it...](img/00181.jpeg)'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00181.jpeg)'
- en: How it works...
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We have included a few extra items in this playbook that extends the previous
    playbook that installs Apache to a newly launched instance. These are described
    here:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个剧本中添加了一些额外的内容，扩展了前一个用于将 Apache 安装到新启动实例的剧本。这里对这些内容进行了描述：
- en: '[PRE42]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We introduce a variable called `count`, to which we assign the value `2`. This
    variable is limited to the scope of this particular play (named `Launch instances
    on OpenStack`). This variable is used to form a loop, as indicated by this attribute
    assigned to the `os_server` call:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了一个名为 `count` 的变量，给它赋值为 `2`。这个变量的作用范围仅限于当前特定的任务（名为 `Launch instances on
    OpenStack`）。这个变量用于形成一个循环，正如下面这个分配给 `os_server` 调用的属性所示：
- en: '[PRE43]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This basically states: run the `os_server` module task when `count = 1`, and
    when `count = 2`. As we are in a sequence, we have access to the value of `count`,
    in a variable called `item`. We use this to append to the `name` variable of the
    instance allowing us to end up with `cookbook1` and `cookbook2` with the following
    syntax:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上表示：当 `count = 1` 时运行 `os_server` 模块任务，`count = 2` 时也运行。在这个顺序中，我们可以访问 `count`
    的值，并存储在一个名为 `item` 的变量中。我们利用这个值来追加到实例的 `name` 变量中，从而最终生成 `cookbook1` 和 `cookbook2`，其语法如下：
- en: '[PRE44]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Using Ansible to fully orchestrate the creation of a web server and load balancer
    stack
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ansible 完全编排创建 Web 服务器和负载均衡器堆栈
- en: The previous recipes launched instances into an existing environment, including
    existing networks, images and keys, for example. However, using Ansible for orchestration
    of OpenStack environments brings a full suite of modules that can be used to operate
    more than just Nova. For example, we can use Ansible to control Glance, Neutron,
    Cinder, and so on.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的食谱将实例启动到一个现有环境中，包括现有的网络、镜像和密钥等。例如，使用 Ansible 编排 OpenStack 环境提供了完整的模块集，可以用于操作不仅仅是
    Nova。例如，我们可以使用 Ansible 来控制 Glance、Neutron、Cinder 等。
- en: In this recipe, we only assume that a user is able to authenticate into a project.
    We don't assume that any networks exist, or even any images exist. We can get
    Ansible's view of the world to ensure that images and networks are present, and
    if not—create them.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们仅假设用户能够对一个项目进行身份验证。我们不假设任何网络存在，甚至假设没有镜像存在。我们可以获取 Ansible 的世界视图，以确保镜像和网络存在，如果不存在——就创建它们。
- en: Note that this recipe is intended to introduce you to the wonderful world of
    Ansible. The example is to show the creation of a stack from start to finish.
    Optimizing Ansible playbooks is beyond the scope of this book.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个食谱旨在带您进入 Ansible 的美妙世界。这个示例展示了从头到尾创建堆栈的过程。优化 Ansible 剧本超出了本书的范围。
- en: Getting ready
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure that you are logged on to a correctly configured OpenStack client and
    can access the OpenStack environment that has Ansible installed.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已登录到正确配置的 OpenStack 客户端，并且可以访问已安装 Ansible 的 OpenStack 环境。
- en: How to do it...
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Carry out the following steps to launch an environment that ensures an image
    is available for use, sets the correct security groups, creates new networks and
    routers, and finally installs Apache onto two web servers:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以启动一个环境，确保镜像可用，设置正确的安全组，创建新的网络和路由器，最后在两台 Web 服务器上安装 Apache：
- en: 'We can assume a blank OpenStack project, but we want to ensure that we have
    the appropriate running instances and services. We first include tasks as part
    of our `Create OpenStack Cloud Environment` play that first downloads an Ubuntu
    16.04 image and then loads into OpenStack. Start off by creating the `full-stack.yml`
    file with the following contents:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以假设一个空白的 OpenStack 项目，但我们要确保有适当运行的实例和服务。我们首先将任务包含在 `Create OpenStack Cloud
    Environment` 的剧本中，该剧本首先下载 Ubuntu 16.04 镜像，并将其加载到 OpenStack 中。首先创建 `full-stack.yml`
    文件，并添加以下内容：
- en: '[PRE45]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we will create the *private tenant network and router*. We only assume
    that a shared provider network already exists. In this instance, we assume this
    provider network—that provides floating IP addresses—is called `GATEWAY_NET`.
    Carry on editing the file to include the following *tasks* as part of the same
    `Create OpenStack Cloud Environment` play:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建 *私有租户网络和路由器*。我们假设已经存在一个共享的提供者网络。在此实例中，我们假设这个提供者网络（提供浮动 IP 地址）被称为 `GATEWAY_NET`。继续编辑文件，将以下
    *任务* 添加到相同的 `Create OpenStack Cloud Environment` 剧本中：
- en: '[PRE46]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Optional (if using the Vagrant environment)*. Currently, the `os_router` module
    is unable to insert static routes into a router, so if you have a requirement
    to utilize static routes into your Ansible controlled playbooks, a workaround
    is to execute an `openstack` command instead as shown as follows. If you are using
    the *Vagrant* lab that accompanies this book, you may need to provide static routes
    to your router in order for traffic to flow from the physical host to the VirtualBox/VMware
    environment. If you require this, add in the following *task* (edit to suit your
    environment). In this instance, the physical host running the Vagrant environment
    has an IP of 192.168.100.1 and allows traffic to flow from the physical host to
    the instances that have a floating IP from a `192.168.100.0/24` provider network.
    This provider network here is the `GATEWAY_NET` referred to in this example:'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*可选（如果使用 Vagrant 环境）*。当前，`os_router` 模块无法向路由器中插入静态路由，因此，如果您需要在 Ansible 控制的剧本中使用静态路由，可以通过执行
    `openstack` 命令来实现，如下所示。如果您使用的是本书附带的 *Vagrant* 实验环境，您可能需要为路由器提供静态路由，以便流量从物理主机流向
    VirtualBox/VMware 环境。如果需要此功能，请添加以下 *任务*（根据您的环境进行修改）。在此示例中，运行 Vagrant 环境的物理主机 IP
    地址为 192.168.100.1，并允许流量从物理主机流向通过 `192.168.100.0/24` 提供商网络的实例，这里的提供商网络即为示例中的 `GATEWAY_NET`：'
- en: '[PRE47]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, we configure the security groups. Remember that Ansible uses SSH to connect
    to servers, and by default, cloud images prevent any incoming connections. So
    one of the rules should be for allowing incoming SSH connections. We also need
    to configure security group rules for the intended service that is to run on the
    instances. In this case, we''re running Apache and HAProxy on TCP Port 80, so
    that also needs to be set up here:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们配置安全组。记住，Ansible 使用 SSH 连接到服务器，而默认情况下，云镜像会阻止任何传入连接。因此，其中一条规则应该是允许传入的 SSH
    连接。我们还需要配置安全组规则，以支持将在实例上运行的服务。在这种情况下，我们将在 TCP 端口 80 上运行 Apache 和 HAProxy，因此这里也需要进行配置：
- en: '[PRE48]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As we are running Ansible from one specific host, we can further secure the
    Ansible SSH security group rule by limiting the access from a single IP address,
    and not a general 0.0.0.0/0 range.
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们是从一个特定的主机上运行 Ansible，因此可以通过限制来自单个 IP 地址的访问，而不是 0.0.0.0/0 的通用范围，进一步增强 Ansible
    SSH 安全组规则：
- en: 'We can now launch the instances. Carry on editing this file to add in the tasks
    to launch multiple web servers and a single HAProxy instance as follows. Note
    that the chosen network, image, and security groups match what we created in the
    preceding tasks:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以启动实例。继续编辑此文件，以添加启动多个网页服务器和一个单独 HAProxy 实例的任务，如下所示。请注意，选择的网络、镜像和安全组应与前面任务中创建的设置相匹配：
- en: '[PRE49]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As we have seen, we need to wait for SSH to be available before Ansible should
    continue, so we add in a *wait* until this is so. Note that we apply this play
    to both the `webservers` and `haproxy` *hosts* groups:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们需要等到 SSH 可用后，Ansible 才能继续，因此我们添加一个 *wait*，直到满足此条件。请注意，我们将此剧本应用于 `webservers`
    和 `haproxy` *hosts* 组：
- en: '[PRE50]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'With the instances up and running, the final tasks are concerned with installation
    and configuration of the services that run on the instances. We will first install
    Apache on our web servers. This play is applied to our `webservers` hosts, so
    these tasks will run for each of them:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦实例启动并运行，最后的任务是安装和配置在实例上运行的服务。我们将首先在我们的网页服务器上安装 Apache。这个剧本应用于我们的 `webservers`
    主机，因此这些任务将在每台主机上运行：
- en: '[PRE51]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As our plays have `gather_facts` set to `False` (because the *image* we''re
    using doesn''t have the Python libraries expected to run Ansible out of the box,
    which would mean that the Ansible task that gathers facts about a running instance
    would immediately fail), we will launch a separate task in a new play that just
    populates the Ansible inventory of facts, knowing we installed the prerequisite
    Python 2 libraries in the preceding play. We need this information to populate
    the HAProxy configuration file later on:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的Plays将`gather_facts`设置为`False`（因为我们使用的*镜像*没有预期的Python库来运行Ansible，默认情况下Ansible任务会立即失败，这意味着我们将在新的Play中启动一个单独的任务来填充Ansible的事实清单，我们在前面的Play中安装了先决条件Python
    2库）。我们需要这些信息以后来填充HAProxy配置文件：
- en: '[PRE52]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We can now install and configure HAProxy. This gets applied to our *haproxy*
    group of hosts (of which there is only one server, named *haproxy*). As part of
    this play, we will reference a HAProxy configuration file template. We will create
    this in the next step.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以安装和配置HAProxy。这将应用于我们*haproxy*主机组（只有一个名为*haproxy*的服务器）。作为这个Play的一部分，我们将引用一个HAProxy配置文件模板。我们将在下一步中创建这个模板。
- en: Note
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Ansible provides pre-defined, and extensively tested roles that can be used
    for the installation of software. The guide below is for example purposes only.
    In reality, you would utilize roles from [https://galaxy.ansible.com/](https://galaxy.ansible.com/).
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Ansible提供了预定义且经过广泛测试的角色，可用于软件安装。以下指南仅供示例目的。实际上，您将利用来自[https://galaxy.ansible.com/](https://galaxy.ansible.com/)的角色。
- en: 'Carry on building out this `full-stack.yml` playbook file with the following
    contents:'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 继续构建此`full-stack.yml` playbook文件，其中包含以下内容：
- en: '[PRE53]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Before we can continue executing our playbook, we need to create the HAProxy
    configuration template file as specified in the previous step. The configuration
    pointed to a template file named `haproxy.cfg.j2` in the `templates` directory.
    Create this directory from the current working directory where you are editing
    the `full-stack.yml` file:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们继续执行playbook之前，我们需要根据前面步骤中指定的内容创建HAProxy配置模板文件。配置指向一个名为`haproxy.cfg.j2`的模板文件，位于`templates`目录中。在您正在编辑`full-stack.yml`文件的当前工作目录中创建此目录：
- en: '[PRE54]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Populate the `haproxy.cfg.j2` file with the following contents:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`haproxy.cfg.j2`文件填充如下内容：
- en: '[PRE55]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `server {{ hostvars[host]...check` line is all on a single line.
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`server {{ hostvars[host]...check`行都在一行上。'
- en: 'The `templates/haproxy.cfg.j2` file also refers to some variables that we have
    not yet declared to Ansible, such as `haproxy_app_name` and `haproxy_algorithm`.
    These are in a `group_var` file specific to our `haproxy` group. To create this
    group variable file, we need to create a `group_vars/haproxy` directory, with
    a file called `main.yml` that lists these variables. From the same directory as
    our `full-stack.yml` file, carry out the following steps:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`templates/haproxy.cfg.j2`文件还涉及到一些我们尚未向Ansible声明的变量，例如`haproxy_app_name`和`haproxy_algorithm`。这些变量位于特定于我们`haproxy`组的`group_var`文件中。要创建此组变量文件，我们需要创建一个名为`group_vars/haproxy`的目录，并在其中创建一个名为`main.yml`的文件。从与我们的`full-stack.yml`文件相同的目录中执行以下步骤：'
- en: '[PRE56]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Populate the `group_vars/haproxy/main.yml` file with the following contents:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`group_vars/haproxy/main.yml`文件填充如下内容：
- en: '[PRE57]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We are now ready to run our `full-stack.yml` playbook to create our environment
    similar to the one described by the Heat example. Execute the following commands:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以准备运行我们的`full-stack.yml` playbook，以创建类似于Heat示例描述的环境。执行以下命令：
- en: '[PRE58]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This will produce an output similar to the following. Due to this being a longer
    playbook, only the last part is shown:'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将产生类似于以下内容的输出。由于这是一个较长的playbook，只显示最后部分：
- en: '![How to do it...](img/00182.jpeg)'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/00182.jpeg)'
- en: 'We are also able to verify that these instances are running, and the addresses
    it has assigned by viewing an `openstack server list` output:'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还可以通过查看`openstack server list`的输出来验证这些实例正在运行并分配的地址：
- en: '![How to do it...](img/00183.jpeg)'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/00183.jpeg)'
- en: Finally, we can test our setup by visiting the HAProxy server floating IP address,
    as shown here. Here we can view the HAProxy stats:![How to do it...](img/00184.jpeg)
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以通过访问HAProxy服务器的浮动IP地址来测试我们的设置，如下所示。在这里，我们可以查看HAProxy统计信息：![如何做...](img/00184.jpeg)
- en: How it works...
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理是这样的...
- en: 'What we did here was to methodically build out a playbook, called `full-stack.yml`,
    that carries out the following steps:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是系统地构建一个名为`full-stack.yml`的playbook，它执行以下步骤：
- en: Download and install Ubuntu 16.04 image if necessary
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如有必要，请下载并安装Ubuntu 16.04镜像
- en: Create our web server and ansible SSH security groups
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的Web服务器和Ansible SSH安全组
- en: Create a private tenant network, router and configure the router
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个私有租户网络、路由器并配置路由器
- en: Launch two web server instances and one HAProxy instance
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动两个Web服务器实例和一个HAProxy实例
- en: For each web server, install Apache
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个Web服务器安装Apache
- en: For the HAProxy server, install HAProxy and configure the configuration file,
    auto-populated with information that Ansible knows about from launching the web
    servers (such as what IP address was assigned to each of them)
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于HAProxy服务器，安装HAProxy并配置配置文件，自动填充Ansible从启动Web服务器中获取的信息（例如分配给每个Web服务器的IP地址）。
- en: 'In this recipe, we introduced a few notable items: Ansible *facts*, the *Jinja2*
    configuration template file (the `haproxy.cfg.j2` file), and `group_vars`.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们介绍了几个显著的项：Ansible *事实*、*Jinja2*配置模板文件（`haproxy.cfg.j2`文件）和`group_vars`。
- en: 'The Ansible facts and HAProxy `group_var` variables were used to populate the
    HAProxy configuration file called `templates/haproxy.cfg.j2`. This file mostly
    looks like a normal `haproxy.cfg` file, but has elements that are applicable to
    Jinja2, which Ansible interprets. Of particular interest is the `haproxy.cfg`
    file that has the load balance pool member lines, that ordinarily look like the
    following basic construct:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible的事实和HAProxy的`group_var`变量被用来填充HAProxy配置文件`templates/haproxy.cfg.j2`。这个文件大部分看起来像普通的`haproxy.cfg`文件，但包含适用于Jinja2的元素，Ansible会解析这些元素。特别值得注意的是`haproxy.cfg`文件，它包含负载均衡池成员行，通常看起来像以下基本结构：
- en: '[PRE59]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'When we launch our instances into OpenStack, we have no idea what IP address
    they will be assigned, however Ansible does this with its *fact gathering*. If
    we take a look at the same line in our template, we get the following:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将实例启动到OpenStack时，我们不知道它们会被分配什么IP地址，但Ansible通过其*事实收集*做到了这一点。如果我们看看模板中的同一行，我们得到以下内容：
- en: '[PRE60]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This line has some static text at the beginning and end, denoted by `server`
    and `check`. They're the same `server` and `check` text, as we can see in our
    final output.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行在开头和结尾有一些静态文本，用`server`和`check`表示。它们是相同的`server`和`check`文本，正如我们在最终输出中看到的。
- en: 'The magic of the template and Ansible is what we can do with the loop that
    surrounds this line and `hostvars` we can access. The loop says:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 模板和Ansible的魔力在于我们可以通过循环来做的事情，这个循环包围了这一行和我们可以访问的`hostvars`。循环说明：
- en: For each of the `hosts` in the `webservers` *group* (recall that we registered
    the web server instances into this specific inventory group), get the value of
    `hostvars[host].inventory_hostname` and `hostvars[host]['ansible_all_ipv4_addresses'][0](`from
    the **gathered facts**). This last variable takes the first entry in the `ansible_all_ipv4_addresses`
    dict, which is our internal IP of our instance.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`webservers` *组*中的每个`hosts`（回顾一下，我们将Web服务器实例注册到这个特定的清单组中），获取`hostvars[host].inventory_hostname`和`hostvars[host]['ansible_all_ipv4_addresses'][0]`（来自**收集的事实**）的值。这个最后的变量取`ansible_all_ipv4_addresses`字典中的第一个条目，它是我们实例的内部IP。
- en: The result is the output shown on the previous page, which lists the web servers
    that HAProxy can access in the load balance pool.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是上一页显示的输出，列出了HAProxy可以访问的负载均衡池中的Web服务器。
- en: 'We aren''t restricted to the variables that Ansible has gathered. We have specified
    a `group_var` variable file that specifies the following:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不局限于Ansible收集到的变量。我们指定了一个`group_var`变量文件，内容如下：
- en: '[PRE61]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This is referenced directly in the template file in the following places. This
    allows us to add some static elements that are user-configurable, but allows us
    to maintain a flexible, environment agnostic set of playbooks.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这在模板文件中的以下位置直接引用。这允许我们添加一些可配置的静态元素，同时保持灵活的、环境无关的Playbook集合。
- en: '[PRE62]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
