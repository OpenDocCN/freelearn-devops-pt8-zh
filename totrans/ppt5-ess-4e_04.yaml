- en: Combining Resources in Classes and Defined Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you have already performed some production-grade tasks with Puppet.
    You learned how to write standalone manifests and then invoke `puppet apply` to
    put them to use. While setting up your first Puppet master and agent, you created
    a simple example for a node manifest on the master. In a `node '<hostname>'` block,
    you created the equivalent of a manifest file. This way, the Puppet master used
    just this manifest for the specified agent node.
  prefs: []
  type: TYPE_NORMAL
- en: While this is all useful and essentially important, it will obviously not suffice
    for daily business. By working with `node` blocks that contain sets of resources,
    you will end up performing lots of copy and paste operations for similar nodes,
    and the whole construct will become unwieldy very quickly. This is an unnatural
    approach to developing Puppet manifests. Despite the great differences to many
    other languages that you might be familiar with, the Puppet DSL is a programming
    language. Building manifests merely from `node` blocks and resources would be
    the same as writing C with no functions except `main`, or Ruby without any classes
    of your own.
  prefs: []
  type: TYPE_NORMAL
- en: The manifests that you can write with the means that are already at your disposal
    are not flat, you learned about common control structures such as `if` and `case`.
    Your manifests can use these to adapt to various circumstances on the agent by
    querying the values of Facter facts and branching in accordance with the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, these constructs should be complemented by the language tools to create
    reusable units of manifest code, similar to functions or methods in procedural
    languages. This chapter introduces these concepts through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing classes and defined types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dynamic aspect of defined types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ordering and events among classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making classes more flexible through parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing classes and defined types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Puppet''s equivalents to methods or functions are twofold: there are **classes**
    on one hand and defined types (also just referred to as defines) on the other.'
  prefs: []
  type: TYPE_NORMAL
- en: You will find that the function analogy is a bit weak for classes, but fits
    defined types quite well.
  prefs: []
  type: TYPE_NORMAL
- en: They are similar at first glance, in that they both hold a chunk of reusable
    Puppet DSL code. There are big differences in the way each is used though. Let's
    take a look at classes first.
  prefs: []
  type: TYPE_NORMAL
- en: Defining and declaring classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Puppet class can be considered to be a container containing collections of
    Puppet resource declarations. It is created once (class definition) and used by
    all nodes that need to make use of the prepared functionality. Each class represents
    a well-known subset of a system's configuration, such as `ntp`, `nginx`, and `ssh`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a classic use `case` is a class that installs the Apache web server
    and applies some basic settings. This class will look the same as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'All web server nodes will make use of this class. To this end, their manifests
    need to contain a simple statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is referred to as including a class, or declaring it. If your `apache`
    class is powerful enough to do all that is needed, this line might fully comprise
    a `node` block''s content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In your own setup, you will probably not write your own Apache class. You can
    use open source classes that are available through Puppet modules. [Chapter 5](3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml),
    *Combining Classes, Configuration Files, and Extensions into Modules*, will give
    you all the details.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our tour of classes in a nutshell. There is yet more to discuss,
    of course, but let's take a look at defined types before that.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using defined types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A defined type can be regarded as a new resource type which makes use of existing
    resource types. This is useful when you have repeating instances of existing resource
    types, as you can wrap them in a defined type. As a class, it consists mainly
    of a body containing the manifest code. However, a defined type takes arguments
    and makes their values available in its body as local variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another typical example of a defined type, the Apache virtual host
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Data types such as `String` have been available since Puppet 4\. In Puppet 3
    and earlier, you would have just skipped these; all variables used to be untyped.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code might still seem pretty cryptic. It will become clearer in the context
    of how it is actually used from other places in your manifest; the following code
    shows you how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is why the construct is called a defined type; you can now place what appear
    to be resources in your manifest, but you really call your own manifest code construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'When declaring multiple resources of the same type, as in the preceding code,
    you can do so in a single block and separate them with a semicolon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The official style guide forbids this syntax, but it can make manifests more
    readable and maintainable in some cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `virtual_host` type takes two arguments: the `content` argument is mandatory
    as it has no default value and is used verbatim in the configuration file resource.
    Puppet will synchronize that file''s content to what is specified in the manifest.
    The `priority` argument is optional and its value becomes the file name prefix.
    If omitted, the respective virtual host definition uses the default priority of
    `050`.'
  prefs: []
  type: TYPE_NORMAL
- en: Both parameters of this example type are of the `String` type. For details about
    Puppet's variable type system, see [Chapter 5](3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml),
    *Combining Classes, Configuration Files, and Extensions into Modules*. It suffices
    to say that you can restrict parameters to certain value types. This is optional,
    however. You can omit the type name, and Puppet will accept any value for the
    parameter in question.
  prefs: []
  type: TYPE_NORMAL
- en: Also, each defined type can implicitly refer to the name (or title) by which
    it was called. In other words, each instance that you define gets a name, and
    you can access it through the `$name` or `$title` variable.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few other *magic* variables that are available in the body of a
    defined type. If a resource of the defined type is declared with a metaparameter
    such as `require => ...`, its value can be accessed through the `$require` variable
    in the body. The variable value remains empty if the metaparameter is not used.
    This works for metaparameters, such as `before`, `notify`, and all the others,
    but you will probably never need to make use of this. The metaparameters automatically
    do the right thing.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and leveraging the differences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The respective purposes of Puppet's class and defined type are very specific
    and they usually don't overlap.
  prefs: []
  type: TYPE_NORMAL
- en: The class declares resources and properties that are in some way centric to
    the system. A class is a finalized description of one, or sometimes more, aspect
    of your system as a whole. Whatever the class represents, it can only ever exist
    in one form; to Puppet, each class is implicitly a singleton, a fixed set of information
    that either applies to your system (the class is included), or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The typical resources you will encapsulate in a class for convenient inclusion
    in a manifest are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: One or more packages that should be installed (or removed)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A specific configuration file in `/etc`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A common directory, needed to store scripts or configs for many subsystems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cron jobs that should be mostly identical on all applicable systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The define is used for all things that exist in multiple instances. All aspects
    that appear in varying quantities in your system can possibly be modeled using
    this language construct. In this regard, the define is very similar to the full-fledged
    resource it mimics with its declaration syntax. Some of the typical contents of
    defined types are:'
  prefs: []
  type: TYPE_NORMAL
- en: Files in a `conf.d` style directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entries in an easily parseable file such as `/etc/hosts`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache virtual hosts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schemas in a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rules in a firewall
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The class''s singleton nature is especially valuable because it prevents clashes
    in the form of multiple resource declarations. Remember that each resource must
    be unique to a catalog. For example, consider a second declaration of the Apache
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This declaration can be anywhere in the manifest of one of your web servers
    (for example, right in the `node` block, next to `include apache`); this additional
    declaration will prevent the successful compilation of a catalog.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for the prevention of a successful compilation is that Puppet currently
    cannot make sure that both declarations represent the same target state, or can
    be merged to form a composite state. It is likely that multiple declarations of
    the same resource may conflict about the desired value of property (for example,
    one declaration might want to ensure that a package is `absent`, while the other
    needs it to be `present`). You want to see Puppet as a declarative description
    of your system configuration state.
  prefs: []
  type: TYPE_NORMAL
- en: The virtue of the class is that there can be an arbitrary number of `include`
    statements for the same class strewn throughout the manifest. Puppet will commit
    the class's contents to the catalog just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'The uniqueness constraint for resources applies to defined types. No two instances
    of your own define can share the same name. Using a name twice or more produces
    a compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your knowledge of classes and defined types is still rather academic. You have
    learned about their defining aspects and the syntax to use them, but we have yet
    to give you a feeling of how these concepts come to bear in different real-life
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections will present an overview of what you can do with these
    language tools.
  prefs: []
  type: TYPE_NORMAL
- en: Writing comprehensive classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many classes are written to make Puppet perform momentous tasks on the agent
    platform. Of these, the Apache class is probably one of the more modest examples.
    You can conceive a class that can be included from any machine''s manifest and
    make sure that the following conditions are met:'
  prefs: []
  type: TYPE_NORMAL
- en: The firewalling software is installed and configured with a default ruleset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The malware detection software is installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cron jobs run the scanners at set intervals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mailing subsystem is configured to make sure the cron jobs can deliver their
    output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are two general ways you can go about the task of creating a class of
    this magnitude. It can either become what one might call a **monolithic** implementation,
    a class with a large body that comprises all resources that work together to form
    the desired security baseline. This approach has the benefit of precisely describing
    your infrastructure, but it lacks maintainability. On the other hand, you could
    aim for a **composite** design, with few resources (or none at all) in the class
    body, and a number of `include` statements for simpler classes instead. The functionality
    is compartmentalized, and the central class acts as a collector. This is the common
    best practice way in which Puppet module developers work.
  prefs: []
  type: TYPE_NORMAL
- en: We have not yet touched on the ability of classes to include other classes.
    That's because it's quite simple. The body of a class can comprise almost any
    manifest, and the `include` statement is no exception. Among the few things that
    cannot appear in a class are `node` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding some life to the descriptions, this is roughly what the respective classes
    will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When developing your own functional classes, you should not try to pick either
    of these extremes. Most classes will end up anywhere on the spectrum in between.
    The choice can be largely based on your personal preference. The technical implications
    are subtle, but these are the respective drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: Consequently aiming for monolithic classes opens you up to resource clashes,
    because you take almost no advantage of the singleton nature of classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting up classes too much can make it difficult to impose order and distribute
    refresh events, you can refer to the Combining classes, configuration files and
    extensions into Modules section later in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Neither of these aspects is of critical importance at most times. The case-by-case
    design choices will be based on each author's experience and preference. When
    in doubt, lean towards composite designs at first.
  prefs: []
  type: TYPE_NORMAL
- en: Writing component classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is another common use case for classes. Instead of filling a class with
    lots of aspects that work together to achieve a complex goal, you can also limit
    the class to a very specific purpose. Some classes will contain just one resource.
    The class wraps the resource, so to speak.
  prefs: []
  type: TYPE_NORMAL
- en: This is useful for resources that are needed in different contexts. By wrapping
    them away in a class, you can make sure that those contexts do not create multiple
    declarations of the same resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `netcat` package can be useful to firewall servers, but also
    to web application servers. There is probably a `firewall` class and an `appserver`
    class. Both declare the `netcat` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If any server ever has both roles (this might happen for budget reasons or
    in other unforeseen circumstances), it is a problem; when both the `firewall`
    and `appserver` classes are included, and the resulting manifest declares the
    `netcat` package twice. This is forbidden. To resolve this situation, the package
    resource can be wrapped in a `netcat` class, which is included by both the `firewall`
    and `appserver` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s consider another typical example for component classes that ensures
    the presence of a common file path. Assume your IT policy requires all custom
    scripts and applications to be installed in `/opt/company/bin`. Many classes,
    such as `firewall` and `appserver` from the previous example, will need some relevant
    content there. Each class needs to make sure that the directories exist before
    a script can be deployed inside it. This will be implemented by including a component
    class that wraps the `file` resources of the `directory` tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The component class is a pretty precise concept. However, as you have seen in
    the previous section about the more powerful classes, the whole range of possible
    class designs forms a fine-grained scale between the presented examples. All manifests
    you write will likely comprise more than a few classes. The best way to get a
    feeling for the best practices is to just go ahead and use classes to build the
    manifests you need.
  prefs: []
  type: TYPE_NORMAL
- en: The terms **comprehensive** class and **component** class are not official Puppet
    language, and the community does not use them to communicate design practices.
    We chose them arbitrarily to describe the ideas we laid out in these sections.
    The same holds `true` for the descriptions of the use cases for defined types,
    which will be seen in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's look at some uses for defined types.
  prefs: []
  type: TYPE_NORMAL
- en: Using defined types as resource wrappers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For all their apparent similarity to classes, defined types are used in different
    ways. For example, the component class was described as *wrapping a resource*.
    This is accurate in a very specific context, the wrapped resource is a singleton,
    and it can only appear in one form throughout the manifest.
  prefs: []
  type: TYPE_NORMAL
- en: When wrapping a resource in a defined type instead, you end up with a variation
    on the respective resource type. The manifest can contain an arbitrary number
    of instances of the defined type, and each will wrap a distinct resource.
  prefs: []
  type: TYPE_NORMAL
- en: For this to work, the name of the resource that is declared in the body of the
    defined type must be dynamically created. It is almost always the `$name` variable
    of the respective defined type instance, or a value derived from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is yet another typical example from the many manifests out there: most
    users who make use of Puppet''s file serving capabilities will want to wrap the
    `file` type at some point so that the respective URL need not be typed for each
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes it easy to get Puppet to sync files from the master to the agent.
    The master copy must be properly placed in the named modules on the master:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This resource will make Puppet retrieve the `ntp.conf` file from the `ntp`
    module. The preceding declaration is more concise and less redundant than the
    fully written file resource with the Puppet URL (especially for the large number
    of files you might need to synchronize), which would resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'For a wrapper such as `module_file`, which will probably be used very widely,
    you will want to make sure that it supports all attributes of the wrapped resource
    type. In this case, the `module_file` wrapper should accept all `file` attributes.
    For example, this is how you add the `mode` attribute to the wrapper type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `File { ... }` block declares some default values for all `file` resource
    attributes in the same scope. The `undef` value is similar to Ruby's `nil`, and
    is a convenient parameter default value, because it is very unlikely that a user
    will need to pass it as an actual value for the wrapped resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can employ the override syntax instead of the default syntax as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This makes the intent of the code slightly more obvious, but is not necessary
    in the presence of just one `file` resource. [Chapter 6](60cec52e-6b29-4028-bc15-3b5685598e6b.xhtml),
    *The Puppet Beginners Advanced Parts*, holds more information about overrides
    and defaults.
  prefs: []
  type: TYPE_NORMAL
- en: Using defined types as resource multiplexers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wrapping single resources with a defined type is useful, but sometimes you will
    want to add functionality beyond the resource type you are wrapping. At other
    times, you might wish for your defined type to unify a lot of functionality, just
    as the comprehensive classes from the beginning of the section.
  prefs: []
  type: TYPE_NORMAL
- en: 'For both scenarios, what you want to have is multiple resources in the body
    of your defined type. There is a classic example for this as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This code allows you to create user accounts with authorized SSH keys in one
    resource declaration. This code sample has some notable aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: Since you are essentially wrapping multiple resource types, the titles of all
    inner resources are derived from the instance title (or name) of the current defined
    type instance; actually, this is a required practice for all defined types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can hardcode parts of your business logic; in this example, we dispensed
    with the support for non-RSA SSH keys and defined `users` as the default group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using defined types as macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some source code requires many repetitive tasks. Assume that your site uses
    a subsystem that relies on symbolic links at a certain location to enable configuration
    files, just as `init` does with the symlinks in `rc2.d/` and its siblings, which
    point back to `../init.d/<service>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A manifest that enables a large number of configuration snippets might look
    the same as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is tiring to read and somewhat painful to maintain. In a C program, one
    would use a preprocessor macro that just takes the base name of both link and
    target and expands to the three lines of each resource description. Puppet does
    not use a preprocessor, but you can use defined types to achieve a similar result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The defined type actually acts more as a simple function call than an actual
    macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'The define requires no arguments, it can rely solely on its resource name,
    so the preceding code can now be simplified to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, the following code is even more terse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This array notation leads us to another use of defined types.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting array values using defined types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the more common scenarios in programming is the requirement to accept
    an array value from some source and perform a task on each value. Puppet manifests
    are not exempt from this.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that the symbolic links from the previous example actually led
    to directories, and that each such directory would contain a subdirectory to hold
    optional links to regions. Puppet should manage those links as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, after learning about the macro aspect of defined types, you would
    not want to add each of those regions as distinct resources to your manifest.
    However, you will need to devise a way to map region names to countries. Seeing
    as there is already a defined resource type for countries, there is a very direct
    approach to this: make the list of regions an attribute (or rather, a parameter)
    of the defined type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the parameter is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual challenge is putting these values to use. A naïve approach is to
    add the following to the definition of `example_app_config`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this will not work. The `$name` variable does not refer to the title
    of the `file` resource that is being declared. It actually refers, just like `$title`,
    to the name of the enclosing class or defined type (in this case, the country
    name). Still, the actual construct will seem quite familiar to you. The only missing
    piece here is yet another defined type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete definition of the `example_app_config` defined type should look
    like this then:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The *outer* defined type adapts the behavior of the `example_app_region` type
    to its respective needs by passing its own resource name as a parameter value.
  prefs: []
  type: TYPE_NORMAL
- en: Using iterator functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Puppet 4 and later versions, you probably would not write code like the
    one in the previous section. Thanks to new language features, using defined types
    as iterators is no longer necessary. We will outline the alternative using the
    following examples, with a more thorough exploration in [Chapter 7](b38488ca-86a7-4ecf-9a69-16938576d852.xhtml),
    *New Features from Puppet 4 and* *5*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The plain country links can now be declared from an Array using the `each`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The regions can be declared from structured data. A hash suffices for this
    use case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In new manifests, you should opt for iteration using the `each` and `map` functions
    over using defined types for this purpose. You will find examples of the former
    in older manifest code, however. See [Chapter 7](b38488ca-86a7-4ecf-9a69-16938576d852.xhtml),
    *New Features from Puppet 4 and 5*, for more information on the topic.
  prefs: []
  type: TYPE_NORMAL
- en: Including classes from defined types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `example_app_config` type that was defined in the previous example is supposed
    to serve a very specific purpose. Therefore, it assumes that the base directory,
    `/etc/example_app`, and its subdirectories were managed independently, outside
    the defined type. This was a sound design, but many defined types are meant to
    be used from lots of independent classes or other defined types. Such defines
    need to be self-contained.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, the defined type needs to make sure that the following resources
    are part of the manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Just putting this declaration into the body of the define will lead to duplicate
    resource errors. Each instance of `example_app_config` will try to declare the
    directories by itself. However, we already have discussed a pattern to avoid just
    that issue we called it the component class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure that any instance of the `example_app_config` type is self-contained
    and works on its own, wrap the preceding declaration in a class (for example,
    `class example_app_config_directories`) and make sure you include this class right
    in the body of the define:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You can refer to the examples that come with your copy of this book for the
    definition of the class.
  prefs: []
  type: TYPE_NORMAL
- en: Ordering and events among classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Puppet's classes bear little or no similarity to classes that you find in object-oriented
    programming languages such as Java or Ruby. There are no methods or attributes.
    There are no distinct instances of any class. You cannot create interfaces or
    abstract base classes.
  prefs: []
  type: TYPE_NORMAL
- en: One of the few shared characteristics is the encapsulation aspect. Just like
    classes from OOP, Puppet's classes hide implementation details. To get Puppet
    to start managing a subsystem, you just need to include the appropriate class.
  prefs: []
  type: TYPE_NORMAL
- en: Passing events between classes and defined types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By sorting all resources into classes, you make it unnecessary (for your co-workers
    or other collaborators) to know about each single resource. This is beneficial.
    You can think of the collection of classes and defined types as your interface.
    You would not want to read all of the manifests that anyone on your project ever
    wrote.
  prefs: []
  type: TYPE_NORMAL
- en: However, the encapsulation is inconvenient for passing resource events. Say
    you have a daemon that creates live statistics from your Apache log files. It
    should subscribe to Apache's configuration files so that it can restart if there
    are any changes (which might be of consequence to this daemon's operation). In
    another scenario, you might have Puppet manage some external data for a self-compiled
    Apache module. If Puppet updates such data, you will want to trigger a restart
    of the Apache service to reload everything.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with the knowledge that there is a service, `Service['apache2']`, defined
    somewhere in the `apache` class, you can just go ahead and have your module data
    files notify that resource. It would work Puppet does not apply any sort of protection
    to resources that are declared in foreign classes. However, it would pose a minor
    maintainability issue.
  prefs: []
  type: TYPE_NORMAL
- en: The reference to the resource is located far from the resource itself. When
    maintaining the manifest later, you or a coworker might wish to look at the resource
    when encountering the reference. In the case of Apache, it's not difficult to
    figure out where to look, but in other scenarios, the location of the reference
    target can be less obvious.
  prefs: []
  type: TYPE_NORMAL
- en: Looking up a targeted resource is usually not necessary, but it can be important
    to find out what that resource actually does. It gets especially important during
    debugging, if after a change to the manifest, the referenced resource is no longer
    found.
  prefs: []
  type: TYPE_NORMAL
- en: Besides, this approach will not work for the other scenario, in which your daemon
    needs to subscribe to configuration changes. You could blindly subscribe the central
    `apache2.conf` file, of course. However, this would not yield the desired results
    if the responsible class opted to do most of the configuration work inside snippets
    in `/etc/apache2/conf.d`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both scenarios can be addressed cleanly and elegantly by directing the `notify`
    or `subscribe` parameters at the whole class that is managing the entity in question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the signals are now sent (or received) indiscriminately the file
    not only notifies `Service['apache2']`, but also every other resource in the `apache`
    class. This is usually acceptable, because most resources ignore events.
  prefs: []
  type: TYPE_NORMAL
- en: As for the `logwatch` daemon, it might refresh itself needlessly if a resource
    in the `apache` class needs a sync action. The odds for this occurrence depend
    on the implementation of the class. For ideal results, it might be sensible to
    relocate the configuration file resources into their own class so that the daemon
    can subscribe to that instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'With your defined types, you can apply the same rules: subscribe to and notify
    them as required. Doing so feels quite natural, because they are declared like
    native resources anyway. This is how you subscribe several instances of the defined
    type, `symlink`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Granted, this very example is a bit awkward, because it requires all `symlink`
    resource titles to be available in an array variable. In this case, it would be
    more natural to make the defined type instances notify the service instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This notation passes a metaparameter to a defined type. The result is that this
    parameter value is applied to all resources declared inside the define.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a defined type wraps or contains a `service` or `exec` type resource, it
    can also be desirable to notify an instance of that define to refresh the contained
    resource. The following example assumes that the `service` type is wrapped by
    a defined type called `protected_service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Ordering containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `notify` and `subscribe` metaparameters are not the only ones that you can
    direct at classes and instances of defined types the same holds `true` for their
    siblings, `before` and `require`. These allow you to define an order for your
    resources relative to classes, order instances of your defined types, and even
    order classes among themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'The latter works by virtue of the chaining operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The effect of this code is that all resources from the `firewall` class will
    be synchronized before any resource from the `loadbalancing` class, and failure
    of any resource in the former class will prevent all resources in the latter from
    being synchronized.
  prefs: []
  type: TYPE_NORMAL
- en: The chaining arrow cannot just be placed in between the `include` statements.
    It works only between resource definitions or resource references.
  prefs: []
  type: TYPE_NORMAL
- en: Because of these ordering semantics, it is actually quite wholesome to require
    a whole class. You effectively mark the resource in question as being dependent
    on the class. As a result, it will only be synchronized if the entire subsystem
    that the class models is successfully synchronized first.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sadly, there is a rather substantial issue with both the ordering of containers
    and the distribution of refresh events: neither will transcend the `include` statements
    of further classes. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: I have often mentioned how the comprehensive `apache` class models everything
    about the Apache server subsystem, and in the previous section, I went on to explain
    that directing a `require` parameter at such a class will make sure that Puppet
    only touches the dependent resource if the subsystem has been successfully configured.
  prefs: []
  type: TYPE_NORMAL
- en: This is mostly true, but, due to the limitation concerning class boundaries,
    it doesn't achieve the desired effect in this scenario. The dependent configuration
    file should actually require the `Package['apache']` package, declared in `class
    apache::package`. However, the relationship does not span multiple class inclusions,
    so this particular dependency will not be part of the resulting catalog at all.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, any refresh events sent to the `apache` class will have no effect;
    they are distributed to resources declared in the class's body (of which there
    are none), but are not passed on to included classes. Subscribing to the class
    will make no sense either, because any resource events generated inside the included
    classes will not be forwarded by the `apache` class.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is that relationships to classes cannot be built in utter ignorance
    of their implementation. If in doubt, you need to make sure that the resources
    that are of interest are actually declared directly inside the class you are targeting.
  prefs: []
  type: TYPE_NORMAL
- en: The discussion revolved around the example of the `include` statements in classes,
    but since it is common to use them in defined types as well; the same limitation
    applies in this case too.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a bright side to this as well. A more correct implementation of the
    Apache configuration file from the example explained would depend on the package,
    but would also synchronize itself before the service, and perhaps even notify
    it (so that Apache restarts if necessary). When all resources are part of the
    `apache` class and you want to adhere to the pattern of interacting with the container
    only, it would lead to the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This forms an instant dependency circle: the `file` resource requires all parts
    of the `apache` class to be synchronized before it gets processed, but to notify
    them, they must all be put after the `file` resource in the order graph. This
    cannot work. With the knowledge of the inner structure of the `apache` class,
    the user can pick metaparameter values that actually work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: For the curious, the preceding code shows what the inner classes look like,
    roughly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other good news is that invoking defined types does not pose the same kind
    of issue that an `include` statement of a class does. Events are passed to resources
    inside defined types just fine, transcending an arbitrary number of stacked invocations.
    Ordering also works just as expected. Let''s keep the example brief:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This `apache` class also creates a virtual host using the defined type, `virtual_host`.
    A resource that requires this class will implicitly require all resources from
    within this `virtual_host` instance. A subscriber to the class will receive events
    from those resources, and events directed at the class will reach the resources
    of this `virtual_host`.
  prefs: []
  type: TYPE_NORMAL
- en: There is actually a good reason to make the `include` statements behave differently
    in this regard. As classes can be included very generously (thanks to their singleton
    aspect), it is common for classes to build a vast network of includes. By adding
    a single `include` statement to a manifest, you might unknowingly pull hundreds
    of classes into this manifest. Assume, for a moment, that relationships and events
    transcend this whole network. All manner of unintended effects would be the consequence.
    Dependency circles would be almost inevitable. The whole construct would become
    utterly unmanageable. The cost of such relationships would also grow exponentially.
    Refer to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The performance implications of container relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is another aspect that you should keep in mind whenever you are referencing
    a container type to build a relationship to it. The Puppet agent will have to
    build a dependency graph from this. This graph contains all resources as nodes
    and all relationships as edges. Classes and defined types get expanded to all
    their declared resources. All relationships to the container are expanded to relationships
    to each resource.
  prefs: []
  type: TYPE_NORMAL
- en: This is mostly harmless if the other end of the relationship is a native resource.
    A file that requires a class with five declared resources leads to five dependencies.
    That does not hurt. It gets more interesting if the same class is required by
    an instance of a defined type that comprises three resources. Each of these builds
    a relationship to each of the class's resources, so you end up with 15 edges in
    the graph.
  prefs: []
  type: TYPE_NORMAL
- en: It gets even more expensive when a container invokes complex defined types,
    perhaps even recursively.
  prefs: []
  type: TYPE_NORMAL
- en: A more complex graph means more work for the Puppet agent, and its runs will
    take longer. This is especially annoying when running agents interactively during
    the debugging or development of your manifest. To avoid the unnecessary effort,
    consider your relationship declarations carefully, and use them only when they
    are really appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Mitigating the limitations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The architects of the Puppet language have devised two alternative approaches
    to solve the ordering issues. We will consider both, because you might encounter
    them in existing manifests. In new setups, you should always choose the latter
    variant.
  prefs: []
  type: TYPE_NORMAL
- en: The anchor pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `anchor` pattern is the classic workaround for the problem with ordering
    and signaling in the context of recursive class `include` statements. It can be
    illustrated by the following example class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Consider a resource that is placed `before``=> Class['example_app']`. It ends
    up in the chain before each `anchor`, and therefore, also before any resource
    in `example_app_config`, despite the `include` limitation. This is because the
    `Anchor['example_app::begin']` pseudo-resource notifies the included class and
    is therefore ordered before all of its resources. A similar effect works for objects
    that require the class, by virtue of the `example::end` anchor.
  prefs: []
  type: TYPE_NORMAL
- en: The `anchor` resource type was created for this express purpose. It is not part
    of the Puppet core, but has been made available through the `stdlib` module instead
    (the next chapter will familiarize you with modules). Since it also forwards refresh
    events, it is even possible to notify and subscribe this anchored class, and events
    will propagate into and out of the included `example_app_config` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `stdlib` module is available in the Puppet Forge, but more about this in
    the next chapter. There is a descriptive document for the `anchor` pattern to
    be found online as well, in Puppet documentation at [http://projects.puppetlabs.com/projects/puppet/wiki/Anchor_Pattern](https://docs.puppet.com/puppet/latest/lang_containment.html).
    It is somewhat dated, given that the anchor pattern has been supplanted as well
    by Puppet's ability to contain a class in a container.
  prefs: []
  type: TYPE_NORMAL
- en: The contain function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make composite classes work directly around the limitations of the `include`
    statement, you can take advantage of the `contain` function found in Puppet version
    3.4.x or newer.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the earlier `apache` example had been written like the following one, there
    would have been no issues concerning ordering and refresh events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The official documentation describes the behavior as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A contained class will not be applied before the containing class is begun,
    and will be finished before the containing class is finished."'
  prefs: []
  type: TYPE_NORMAL
- en: This might read like we're now discussing the panacea for the presented class
    ordering issues here. Should you just be using `contain` in place of `include`
    from here on out and never worry about class ordering again? Of course not; this
    would introduce lots of unnecessary ordering constraints and lead you into unfixable
    dependency circles very quickly. Do contain classes, but make sure that it makes
    sense. The contained class should really form a vital part of what the containing
    class is modeling.
  prefs: []
  type: TYPE_NORMAL
- en: The quoted documentation refers to classes only, but classes can be contained
    in defined types just as well. The effect of containment is not limited to ordering
    aspects either. Refresh events are also correctly propagated.
  prefs: []
  type: TYPE_NORMAL
- en: Making classes more flexible through parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Up until this point, classes and defines were presented as direct opposites
    with respect to flexibility; defined types are inherently adaptable through different
    parameter values, whereas classes model just one static piece of state. As the
    section title suggests, this is not entirely true. Classes, too, can have parameters.
    Their definition and declaration become rather similar to those of defined types
    in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'With a definition like the preceding one, the class can be declared with a
    parameter value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This enables some very elegant designs, but introduces some drawbacks as well.
  prefs: []
  type: TYPE_NORMAL
- en: The caveats of parameterized classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The consequence of allowing class parameters is almost obvious: you lose the
    singleton characteristic. Well, that''s not entirely true either, but your freedom
    in declaring the class gets limited drastically.'
  prefs: []
  type: TYPE_NORMAL
- en: Classes that define default values for all parameters can still be declared
    with the `include` statement. This can still be done an arbitrary number of times
    in the same manifest.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the resource like declaration of `class { ''name'': }` cannot appear
    more than once for any given class in the same manifest. This is in keeping with
    the rules for resources and should not be very surprising-after all, it would
    be very awkward to try to bind different values to a class''s parameters in different
    locations throughout the manifest.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Things become very confusing when mixing `include` with the alternative syntax
    though. It is valid to include a class an arbitrary number of times after it has
    been declared using the resource-like notation. However, you cannot use the resource
    style declaration after a class has been declared using `include`. That''s because
    the parameters are then determined to assume their default values, and a `class
    { ''name'': }` declaration clashes with that.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nutshell, the following code works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the following code does not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As a consequence, you effectively cannot add parameters to component classes,
    because the `include` statement is no longer safe to use in large quantities.
    Therefore, parameters are essentially only useful for comprehensive classes, which
    usually don't get included from different parts of the manifest.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml), *Combining Classes,
    Configuration Files, and Extensions into Modules*, we will discuss some alternate
    patterns, some of which exploit class parameters. Also note that Chapter 8, *Separation
    of Code and Data with Hiera*, presents a solution that gives you more flexibility
    with parameterized classes. Using this, you can be more liberal with your class
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Preferring the include keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ever since class parameters have been available, some Puppet users have felt
    compelled to write (example) code that would make it a point to forgo the `include`
    keyword in favor of resource-like class declarations, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Doing this is a very bad idea. We cannot stress this enough: one of the most
    powerful concepts about Puppet''s classes is their singleton aspect the ability
    to include a class in a manifest arbitrarily and without worrying about clashes
    with other code. The mentioned declaration syntax deprives you of this power,
    even when the classes in question don''t support parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: The safest route is to use `include` whenever possible, and to avoid the alternate
    syntax whenever you can. In fact, Chapter 8, *Separation of Code and Data with
    Hiera*, introduces the ability to use class parameters without the resource same
    as class declaration. This way, you can rely solely on `include`, even when parameters
    are in play. These are the safest recommended practices to keep you out of trouble
    from incompatible class declarations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Classes and defined types are the essential tools to create reusable Puppet
    code. While classes hold resources that must not be repeated in a manifest, the
    define is capable of managing a distinct set of adapted resources upon every invocation.
    It does that by leveraging the parameter values it receives. While classes do
    support parameters as well, there are some caveats to bear in mind.
  prefs: []
  type: TYPE_NORMAL
- en: To use defined types in your manifest, you declare instances just like resources
    of native types. Classes are mainly used through the `include` statement, although
    there are alternatives such as the `class { }` syntax or the `contain` function.
    There are also some ordering issues with classes that the `contain` function can
    help mitigate. In theory, classes and defines suffice to build almost all the
    manifests that you will ever need. In practice, you will want to organize your
    code into larger structures.
  prefs: []
  type: TYPE_NORMAL
- en: The [Chapter 5](3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml), *Combining Classes,
    Configuration Files, and Extensions into Modules*, will show you how to do exactly
    that, and introduce you to a whole range of useful functionality beyond it.
  prefs: []
  type: TYPE_NORMAL
