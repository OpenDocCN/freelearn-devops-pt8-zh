<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Deploying Web Applications as Containers</h1>
                </header>
            
            <article>
                
<p>Containers are one of the hottest topics in the IT industry. They allow for deploying an application in "a box," so we don't have to worry about the OS it runs under or the installed services that are required for it. While containers <span>are </span>sometimes criticized for redundant abstraction over underlying resources, they guarantee a stabilized environment for both developing and hosting applications.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li style="font-weight: 400;">Understanding containers and their best use cases</li>
<li style="font-weight: 400;"><strong>Azure Kubernetes Service</strong> (<strong>AKS</strong>) and hosting a Kubernetes environment using PaaS components</li>
<li style="font-weight: 400;">Web App for containers for scalable applications</li>
<li style="font-weight: 400;">Azure Container instances and how to manage a container without managing servers</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To start working with containers in Azure, you will need the following:</p>
<ul>
<li>A basic understanding of Docker concepts (<a href="https://docs.docker.com/get-started/">https://docs.docker.com/get-started/</a>)</li>
<li>Docker development environment (depending on the OS you are using—<a href="https://docs.docker.com/docker-for-mac/">https://docs.docker.com/docker-for-mac/</a>, <a href="https://docs.docker.com/docker-for-windows/">https://docs.docker.com/docker-for-windows/</a>, or <a href="https://docs.docker.com/install/">https://docs.docker.com/install/</a>)</li>
<li>A Docker Hub account</li>
<li>The Azure CLI (<a href="https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest">https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest</a>)</li>
<li>A basic understanding of Kubernetes (<a href="https://kubernetes.io/docs/home/">https://kubernetes.io/docs/home/</a>)</li>
<li>The Kubernetes CLI (<a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/">https://kubernetes.io/docs/tasks/tools/install-kubectl/</a>)</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with AKS</h1>
                </header>
            
            <article>
                
<p>AKS eases the process of deploying and managing <span>containerized applications by eliminating the need to maintain or upgrade your resources on your own. It is a managed Kubernetes service hosted in Azure with many helpful features such as integrated logging and monitoring, identity and security management, and virtual network integration. In this section, we will create a simple application hosted in an AKS cluster, which we will scale and update.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Preparing an application</h1>
                </header>
            
            <article>
                
<p>Let's start with a tutorial application proposed by the Docker documentation:</p>
<ol>
<li>To begin, we need <kbd>Dockerfile</kbd>, which is a definition of how our container environment should look. It contains keywords such as <kbd>FROM</kbd> (defines an image that will be used for the container), <kbd>WORKDIR</kbd> (the working directory of the application), <kbd>ADD</kbd> (adds a directory to a container), <kbd>RUN</kbd> (runs a command), <kbd>EXPOSE</kbd> (exposes a given port in the container), <kbd>ENV</kbd> (adds an environment variable), and <kbd>CMD</kbd> (declares an entry point):</li>
</ol>
<pre style="padding-left: 90px;">FROM python:2.7-slim<br/>WORKDIR /app<br/>ADD . /app<br/>RUN pip install --trusted-host pypi.python.org -r requirements.txt<br/>EXPOSE 80<br/>ENV NAME HandsOnAzure<br/>CMD ["python", "app.py"]</pre>
<ol start="2">
<li>We will need two more files:
<ul>
<li><kbd>requirements.txt</kbd>: This one defines the external dependencies our application has to download</li>
<li><kbd>app.py</kbd>: The main file of an application</li>
</ul>
</li>
</ol>
<div class="packt_infobox">If you are familiar with Docker, you can prepare your very own <kbd>Dockerfile</kbd> and application; there is no need to follow everything in this section as we are covering very basic topics.</div>
<ol start="3">
<li>Here, you can find the contents of <kbd>requirements.txt</kbd>:</li>
</ol>
<pre style="padding-left: 90px;">Flask<br/>Redis</pre>
<ol start="4">
<li>And of course, <kbd>app.py</kbd>, which is the script we want to run. It is a simple Python application that uses Flask to host a web app and defines the default route that exposes an HTML web page. Note that it accesses the <kbd>HandsOnAzure</kbd> environment variable defined in the <span>Dockerfile: </span></li>
</ol>
<pre style="padding-left: 90px;">from flask import Flask<br/>from redis import Redis, RedisError<br/>import os<br/>import socket<br/><br/># Connect to Redis<br/>redis = Redis(host="redis", db=0, socket_connect_timeout=2, socket_timeout=2)<br/><br/>app = Flask(__name__)<br/><br/>@app.route("/")<br/>def hello():<br/>    try:<br/>        visits = redis.incr("counter")<br/>    except RedisError:<br/>        visits = "&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;"<br/><br/>    html = "&lt;h3&gt;Hello {name}!&lt;/h3&gt;" \<br/>           "&lt;b&gt;Hostname:&lt;/b&gt; {hostname}&lt;br/&gt;" \<br/>           "&lt;b&gt;Visits:&lt;/b&gt; {visits}"<br/>    return html.format(name=os.getenv("NAME", "HandsOnAzure"), hostname=socket.gethostname(), visits=visits)<br/><br/>if __name__ == "__main__":<br/>    app.run(host='0.0.0.0', port=80)</pre>
<ol start="5">
<li>Now, you need two more things—to build an image and check whether it works. To build an image, you will need the following command:</li>
</ol>
<pre style="padding-left: 90px;">docker build -t {IMAGE_NAME} .</pre>
<p class="mce-root"/>
<ol start="6">
<li>After Docker fetches all of the packages and builds an image, you can run it. I used the <kbd>4000</kbd><strong> </strong>port but you can choose whichever works for you:</li>
</ol>
<pre style="padding-left: 90px;">docker run -p 4000:80 {IMAGE_NAME}</pre>
<ol start="7">
<li>If everything is correct, you should be able to see a running application:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/69093daa-f9c4-42d4-a8fc-75e8ee1915f7.png" width="330" height="154"/></div>
<p>In the next section, we will create a container registry and Kubernetes cluster to host an application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Container Registry and Kubernetes clusters</h1>
                </header>
            
            <article>
                
<p>To use a Docker image in Azure, we have to put it in a container registry. To do so, we can use <strong>Azure Container Registry</strong> (<strong>ACR</strong>), which is a private registry for hosting container images. To get started, go to Azure Portal, click on <span class="packt_screen">+ Create a resource</span>, and search for <kbd>Container Registry</kbd>. When you click <span class="packt_screen">Create</span>,<span class="packt_screen"> </span>you will see a familiar screen containing multiple fields needed for service configuration. The following need clarification for now:</p>
<ul>
<li><span class="packt_screen">Admin user</span>: If you want to log in to your registry using the registry name and admin access key, you can turn on this feature. By default it is disabled.</li>
<li><span class="packt_screen">SKU</span>: This defines the overall performance of the registry and available features. To start with, the <span class="packt_screen">Basic </span>tier should be more than enough.</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The following screenshot shows my current configuration:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/4c7f0280-f5bf-4d05-af0f-a50f35c82374.png" style="width:22.42em;height:30.75em;" width="329" height="451"/></div>
<p>If you are satisfied with the configuration, you can click <span class="packt_screen">OK</span>. Now we will push an image with an application to the registry to use it in Azure.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Pushing a Docker image to Azure Container Registry</h1>
                </header>
            
            <article>
                
<p>To push an image to Azure Container Registry, we have to know the exact <span>name of the image</span>:</p>
<ol>
<li>To list available images, use the following command:</li>
</ol>
<pre style="padding-left: 90px;"><strong>docker images</strong></pre>
<ol start="2">
<li>The result of running the command is a list of all repositories available for Docker:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="Images/0251b209-9d62-4e00-9106-7795c5678689.png" style="width:41.08em;height:5.83em;" width="781" height="111"/></div>
<ol start="3">
<li>I want to push <kbd>handsonazurehello</kbd>, which I created previously, to Azure. To do so, I will need firstly to tag an image using the following command:</li>
</ol>
<pre style="padding-left: 90px;"><strong>docker tag handsonazurehello {ACR_LOGIN_SERVER}/handsonazurehello:v1</strong></pre>
<p style="padding-left: 60px;">The reason for tagging is to both set a version for my container and give it the appropriate name that is required to push it to a private registry.</p>
<ol start="4">
<li>You can find <span class="packt_screen">Login server</span><strong> </strong>on the <span class="packt_screen">Overview </span>blade:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="Images/9fabdfaf-3c58-4232-b211-5fccc25fbef4.png" width="188" height="34"/></div>
<ol start="5">
<li>Now you can try to push an image with the following command:</li>
</ol>
<pre style="padding-left: 90px;"><strong>docker push handsonazureregistry.azurecr.io/handsonazurehello:v1</strong></pre>
<ol start="6">
<li>Of course, you have to push your image name and registry server login. When you execute the preceding command, you will see the following result:</li>
</ol>
<pre style="padding-left: 90px;"><strong>$ docker push handsonazureregistry.azurecr.io/handsonazurehello:v1</strong><br/><strong>The push refers to repository [handsonazureregistry.azurecr.io/handsonazurehello]</strong><br/><strong>bbdbf9d56e79: Preparing</strong><br/><strong>128193523190: Preparing</strong><br/><strong>f78e6f8eec4b: Preparing</strong><br/><strong>20f93bdcee9c: Preparing</strong><br/><strong>21b24882d499: Preparing</strong><br/><strong>db9dabc5cfee: Waiting</strong><br/><strong>d626a8ad97a1: Waiting</strong><br/><strong>unauthorized: authentication required</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="7">
<li>Still there is something wrong—we are pushing a container to the correct registry, but we have not authenticated yet. To have access to Azure Container Registry, we have to use Azure CLI. Use two commands:</li>
</ol>
<pre style="padding-left: 90px;"><strong>az login</strong><br/><strong>az acr login --name {REGISTRY_NAME}</strong></pre>
<ol start="8">
<li>The first one is used to authenticate in Azure, the second one will let you work with your instance of Container Registry. After successfully authenticating, you can retry pushing an image—this time everything should work smoothly:</li>
</ol>
<pre style="padding-left: 90px;"><strong>$ docker push handsonazureregistry.azurecr.io/handsonazurehello:v1</strong><br/><strong>The push refers to repository [handsonazureregistry.azurecr.io/handsonazurehello]</strong><br/><strong>bbdbf9d56e79: Pushed</strong><br/><strong>128193523190: Pushed</strong><br/><strong>f78e6f8eec4b: Pushed</strong><br/><strong>20f93bdcee9c: Pushed</strong><br/><strong>21b24882d499: Pushed</strong><br/><strong>db9dabc5cfee: Pushed</strong><br/><strong>d626a8ad97a1: Pushed</strong><br/><strong>v1: digest: sha256:2e689f437e1b31086b5d4493c8b4ef93c92640ad576f045062c81048d8988aa6 size: 1787</strong></pre>
<ol start="9">
<li>You can verify it is available in the portal:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/e6df1be3-6edc-43cf-b964-fd4250d16fd1.png" width="951" height="255"/></div>
<p>The next thing we need is a Kubernetes cluster—this is why we use AKS to provision a managed Kubernetes service.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a Kubernetes cluster using AKS</h1>
                </header>
            
            <article>
                
<p>To create a Kubernetes service, perform the following steps:</p>
<ol>
<li><em>G</em>o to the portal.</li>
<li>Click on the <span class="packt_screen">+ Create a resource </span>button and search for <kbd>AKS</kbd>.</li>
<li>When you click <span class="packt_screen">Create</span>, you should see the following screen:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="Images/4404f199-8450-43ee-a713-ffdc30302ca5.png" width="733" height="695"/></div>
<p class="mce-root"/>
<p>As you can see, we have plenty of different options and fields here. Some of them should be self-explanatory. Initially, I recommend using default values for most fields, such as <span class="packt_screen">Kubernetes version</span><strong> </strong>or <span class="packt_screen">Service principal,</span><strong> </strong>as they matter only if you have existing requirements regarding your application.</p>
<div class="packt_tip">To learn more about applications and service principal objects in Azure AD, you can read this short article from the documentation: <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-application-objects">https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-application-objects</a>.</div>
<p>You can go to different tabs such as <span class="packt_screen">Networking </span>or <span class="packt_screen">Monitoring </span>to see whether you want to change something—however, the current settings should be correct for the very first AKS cluster.</p>
<p>Once you have reviewed all fields, click on the <span class="packt_screen">Review + create </span>button. The following screenshot shows my configuration:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/727919e2-e7fb-447f-a01b-0509aaf06eb7.png" width="753" height="521"/></div>
<p>When you click on <span class="packt_screen">Create</span>, you will have to wait a moment until deployment is finished. </p>
<div class="packt_infobox">Creating a cluster can take a while, especially when you select several machines to be deployed at once. Be patient!</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Running, scaling, and updating an application in AKS</h1>
                </header>
            
            <article>
                
<p>To run and deploy an application in AKS in Azure, we will need the Kubernetes manifest file, which will define how an image should be deployed. However, before we perform that part of the exercise, we have to configure Kubernetes locally, so it can connect with our cluster. To do so, perform the following steps:</p>
<ol>
<li>Run the following command:</li>
</ol>
<pre style="padding-left: 90px;"><strong>kubectl get nodes</strong></pre>
<ol start="2">
<li>Initially, it will return the following result:</li>
</ol>
<pre style="padding-left: 90px;"><strong>Unable to connect to the server: dial tcp [::1]:8080: connectex: No connection could be made because the target machine actively refused it.</strong></pre>
<ol start="3">
<li>That means that we have not configured <kbd>kubectl </kbd>with the AKS cluster we just created. To do so, use the following Azure CLI command:</li>
</ol>
<pre style="padding-left: 90px;"><strong>az aks get-credentials --resource-group {RESSOURCE_GROUP} --name {AKS_CLUSTER_NAME}</strong></pre>
<p style="padding-left: 60px;">Running it should merge your cluster as a current context in your local configuration. Now, when you verify your connection, everything should be set and ready. We can go back to our manifest file—the initial version can be found in the <em>Chapter03</em> in the repository. In general, it is a simple YML file that defines and configures services and deployment.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="4">
<li>Put the file in the directory for your application and use the following command to deploy it:</li>
</ol>
<pre style="padding-left: 90px;"><strong>kubectl apply -f handsonazure.yml</strong></pre>
<ol start="5">
<li>After a moment, you should see the status of the process:</li>
</ol>
<pre style="padding-left: 90px;"><strong>$ kubectl apply -f handsonazure.yml</strong><br/><strong>deployment "handsonazurehello-back" created</strong><br/><strong>service "handsonazurehello-back" created</strong><br/><strong>deployment "handsonazurehello" configured</strong><br/><strong>service "handsonazurehello" unchanged</strong></pre>
<ol start="6">
<li>Now, we need one more command to get the external IP of our service:</li>
</ol>
<pre style="padding-left: 90px;"><strong>$ kubectl get service handsonazurehello --watch</strong><br/><strong>NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE</strong><br/><strong>handsonazurehello LoadBalancer 10.0.223.94 40.118.7.118 80:30910/TCP 4m</strong></pre>
<ol start="7">
<li>Initially, you could see the <kbd>EXTERNAL-IP</kbd> field as pending—it should change in a second. Now you can verify the installation of an application:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="Images/0ab0908c-fb6a-4c57-b8e9-3d0cd6d0d7d8.png" width="330" height="125"/></div>
<ol start="8">
<li>There is also one more method to get the status of the whole cluster. Try to run the following command:</li>
</ol>
<pre style="padding-left: 90px;"><strong>az aks browse --resource-group {RESOURCE_GROUP} --name {AKS_CLUSTER_NAME}</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="9">
<li>After a moment, you should see the whole Kubernetes dashboard available locally. Read all of the information carefully as it is really helpful when diagnosing possible issues with AKS:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="Images/69fb2ba1-64bd-4b67-baf3-70d8db69549c.png" style="width:47.42em;height:27.08em;" width="1317" height="753"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Solving problems with authentication</h1>
                </header>
            
            <article>
                
<p>Sometimes AKS cannot access Azure Container Registry and needs the creation of a service principal, which can be used in pod deployment. To create it, you will need to perform the following script:</p>
<pre><strong>$ az acr show --name {REGISTRY_NAME} --query loginServer --output tsv</strong><br/><strong>{YOUR_REGISTRY_NAME}</strong><br/><br/><strong>$ az acr show --name handsonazureregistry --query id --output tsv</strong><br/><strong>/subscriptions/94f33c43-60b5-4042-ae74-51777f69f99a/resourceGroups/handsonazure-rg/providers/Microsoft.ContainerRegistry/registries/handsonazureregistry</strong><br/><strong>{REGISTRY_ID}</strong><br/><br/><strong>$ az ad sp create-for-rbac --name acr-service-principal --role Reader --scopes {REGISTRY_ID} --query password --output tsv</strong><br/><strong>{PASSWORD}</strong><br/><br/><strong>$ az ad sp show --id http://acr-service-principal --query appId --output tsv</strong><br/><strong>{CLIENT_ID}</strong><br/><br/><strong>$ kubectl create secret docker-registry acr-auth --docker-server {YOUR_REGISTRY_NAME} --docker-username {CLIENT_ID} --docker-password {PASSWORD} --docker-email {DOCKER_ACCOUNT_EMAIL}</strong></pre>
<p>The full script can be also found in the source code for this chapter. Once the secret is created, you can modify the manifest file and add the <kbd>imagePullSecrets</kbd> line to it:</p>
<pre><strong>containers:</strong><br/><strong>      - name: handsonazurehello</strong><br/><strong>       image: handsonazureregistry.azurecr.io/handsonazurehello:v1</strong><br/><strong>        ports:</strong><br/><strong>        - containerPort: 80</strong><br/><strong>        resources:</strong><br/><strong>          requests:</strong><br/><strong>            cpu: 250m</strong><br/><strong>          limits:</strong><br/><strong>            cpu: 500m</strong><br/><strong>        env:</strong><br/><strong>        - name: REDIS</strong><br/><strong>          value: "handsonazurehello-back"</strong><br/><strong>      imagePullSecrets:</strong><br/><strong>      - name: acr-auth</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Scaling a cluster</h1>
                </header>
            
            <article>
                
<p>Scaling in AKS is one of the easiest things to do. All you need to do is go to Azure Portal, find your AKS instance, and click on the <span class="packt_screen">Scale</span><strong> </strong>blade:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/687cdef4-2be9-4696-9070-350407190317.png" style="width:60.83em;height:26.25em;" width="889" height="382"/></div>
<p>Once there, you can change the cluster capacity depending on your needs.</p>
<div class="packt_tip">Make sure you have the required number of nodes available for your application—such information can be found in the Kubernetes dashboard. If you don't have enough machines, some of your images might not be deployed.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Updating an application</h1>
                </header>
            
            <article>
                
<p>Updating an application in AKS requires two things:</p>
<ul>
<li>Publishing a new image to Azure Container Registry</li>
<li>Setting a new image as the actual one in AKS</li>
</ul>
<p>When you make changes in your application, you need two commands to update it in a registry. First, change its version to a new one:</p>
<pre><strong>docker tag handsonazurehello {ACR_LOGIN_SERVER}/handsonazurehello:v2</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Now what you need is to push this version to make it available in the cloud:</p>
<pre><strong><span>docker push<br/></span>{ACR_LOGIN_SERVER}/handsonazurehello:v2</strong></pre>
<p>The final step to tell Kubernetes to update an image:</p>
<pre><strong><span>kubectl </span><span class="hljs-keyword">set</span><span> </span><span class="hljs-keyword">image</span><span> </span><span class="hljs-keyword">deployment</span><span> handsonazurehello handsonazurehello=<br/></span>{ACR_LOGIN_SERVER}/handsonazurehello:v2</strong></pre>
<div class="packt_tip">To ensure that your application is fully functional while updating, you have to scale it out to multiple pods. You can do it with the following command:<br/>
<kbd><strong>kubectl scale --replicas=3 deployment/{YOUR_APPLICATION}</strong></kbd></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Azure Container Instances</h1>
                </header>
            
            <article>
                
<p>While AKS is a complete orchestration solution, you might <span>sometimes</span> like to use a lightweight service instead that provides the most crucial features related to running containers. These features include no need to provision and manage virtual machines, security, and integrated public IP connectivity. If you want to run a containerized simple application such as a <span>WebJob</span> or website, <strong>Azure Container Instances</strong> (<strong>ACI</strong>) can be used to satisfy your requirements.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating and deploying an application and container</h1>
                </header>
            
            <article>
                
<p>We will start our journey with ACI by creating an application that we will host in a container. In the previous section, we used a simple Python script—this time we will try to use Node.js. </p>
<div class="packt_infobox">As always, you can find source files in the appropriate<span> source file</span> folder for this chapter.</div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The very first thing we need once more is <kbd>Dockerfile</kbd>. As you remember, it contains instructions on how an application should be run. The following is an<span> example for this exercise:</span></p>
<pre><strong>FROM node:8.9.3-alpine</strong><br/><strong>RUN mkdir -p /bin/</strong><br/><strong>COPY ./app/ /bin/</strong><br/><strong>WORKDIR /bin</strong><br/><strong>RUN npm install</strong><br/><strong>CMD node index.js</strong></pre>
<p>If you read it carefully, you will find it pretty easy—what it does (step-by-step) is as follows:</p>
<ol>
<li>Installs the specific Node.js version (this time <strong>alpine</strong>, which is a smaller distribution well designed for running in containers)</li>
<li>Creates a new working directory</li>
<li>Copies files to it</li>
<li>Installs all dependencies with the <kbd>npm install</kbd><em> </em>command</li>
<li>Starts an application by providing its starting point</li>
</ol>
<p>Now we can create a container using the following command:</p>
<pre><strong>docker build ./ -t {CONTAINER_NAME}</strong></pre>
<p>After a moment, you should have a new image created and added. If you face any problems, make sure that you are in the correct directory and not doubling its name.</p>
<div class="packt_tip">Remember that you can always check what images are currently available for you and their names. To do so, you can use the following Docker command: <kbd>docker images</kbd><em>.</em></div>
<p>Now we can verify how our application works. To start it, use the following command:</p>
<pre><strong>docker run -d -p 8080:80 {CONTAINER_NAME}</strong></pre>
<p>You can go to <kbd>localhost:8080</kbd> and check whether your application is running. If everything is configured correctly, you should be able to see the <kbd>Welcome to Azure Container Instances!</kbd><em> </em>message in the center of the screen.</p>
<p class="mce-root"/>
<div class="packt_tip">Sometimes, you may face problems when working with <span>some</span> web applications and running them locally—for some reason, you cannot connect to them using the specified port. In such situations, it is always a good idea to reconfigure them and use different ports.</div>
<p>Now we will push an image to Azure so we can use it later in ACI.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Pushing an image to Azure Container Registry</h1>
                </header>
            
            <article>
                
<p>You can find full instructions on how you can work with ACI in <em>Container Registry and Kubernetes clusters </em>section of this chapter. Now, the idea is the same as when working with AKS—we have to perform the following actions:</p>
<ol>
<li>Log in to ACR</li>
<li>Tag an image</li>
<li>Push it to ACR</li>
</ol>
<p>You will need the following three commands:</p>
<pre><strong><span class="hljs-keyword">az</span><span> acr </span><span class="hljs-keyword">login</span><span class="hljs-parameter"> --name</span></strong><span><strong> {ACR_NAME}</strong><br/><strong>docker tag {CONTAINER_NAME} {ACR_LOGIN_SERVER}/{CONTAINER_NAME}:v1</strong><br/><strong>docker push {ACR_LOGIN_SERVER}/{CONTAINER_NAME}:v1</strong></span><span><br/></span></pre>
<p>After a successful push, we can deploy an application to ACI.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Deploying an application to ACI</h1>
                </header>
            
            <article>
                
<p>The first thing we need is an instance of ACI. <span>As usual</span>, in Azure Portal click on <span class="packt_screen">+ Create a resource</span><strong> </strong>and search for <kbd>Container Instances</kbd>.</p>
<p>You should see a similar wizard to the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/4cde788d-9dcb-4ec0-a652-fce4392ad3eb.png" style="width:40.42em;height:29.00em;" width="626" height="448"/></div>
<p>The important thing here is that you have to select <span class="packt_screen">Private</span><strong> </strong>when deciding on a <span class="packt_screen">Container image type</span>. Choosing this option will display additional fields, which have to be filled in. When creating ACI, you will need to provide <span class="packt_screen">Container image</span>. This is just the Docker tag you created when pushing an image to Container Registry. In my case it was <kbd>handsonazureregistry.azurecr.io/ handsonazure-aci</kbd>. The image registry login server<strong> </strong>is simply a login server for the registry (you can find it in the <span class="packt_screen">Overview</span><strong> </strong>blade of ACR). We need two more things—the registry username and password. While the username is simply the registry name, a password can be obtained using the following command:</p>
<pre><strong>az acr credential show --name {REGISTRY_NAME}--query "passwords[0].value"</strong></pre>
<div class="packt_infobox">To obtain a password, admin credentials have to be enabled. To enable them from CMD, use the following command:<br/>
<kbd><strong>az acr update -n {REGISTRY_NAME} --admin-enabled true</strong></kbd></div>
<p> Now we can go to the <span class="packt_screen">Configuration</span><strong> </strong>section:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/0eea2926-08bc-4a2a-af70-8ff62b4906e1.png" style="width:35.33em;height:47.42em;" width="605" height="812"/></div>
<p>This time, all of these fields should be self-explanatory and, in fact, I left the default values in force during this exercise. You can change them if you feel other values will meet your requirements (such as, for example, the OS or available memory). Once all is set, you can click <span class="packt_screen">OK</span><strong> </strong>and publish an instance of your container. </p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<div class="packt_tip">If you have problems deploying a container from the portal, you can always use the Azure CLI. Here is the full command to do the same as we did in Azure Portal:<br/>
<kbd><strong>az container create --resource-group {RG_NAME}--name {ACI_NAME} --image {ACR_LOGIN_SERVER}/{CONTAINER_NAME}:v1 --cpu 1 --memory 1 --registry-login-server {ACR_LOGIN_SERVER} --registry-username {REGISTRY_NAME} --registry-password {REGISTRY_PASSWORD} --dns-name-label {DNS_LABEL} --ports 80</strong></kbd></div>
<p>When deployment is complete, go to your instance of ACI and check the <span class="packt_screen">Overview</span><strong> </strong>blade. Copy the value of the <kbd>FQDN</kbd><span> field and paste it into your browser. You should be able to see the very same screen you saw locally:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/8c0992a4-3e53-492d-9380-a4362dce839a.png" style="width:39.33em;height:8.00em;" width="647" height="132"/></div>
<p>That is all! As you can see, using Azure Container Services is a really quick way to deploy your application in a container using a minimal set of features. In the next section, we will focus on leveraging containers in App Services.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Web App for Containers</h1>
                </header>
            
            <article>
                
<p>You do not have to use AKS or ACI to leverage features of containers in Azure—currently, there is one more feature available that you can use to deploy web applications written in an unsupported language (such as Go). Web App for Containers is an extension to App Services that uses Linux under the hood with Docker to run a service built on a stack, which is not currently supported by Azure.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a web app hosted in a container</h1>
                </header>
            
            <article>
                
<p>To create an App Service running with a Docker instance, you have to follow the very same steps from <a href="81d59e59-02b1-4973-95a0-9bf6a998e752.xhtml" target="_blank" rel="noopener noreferrer">Chapter 1</a>, <span><em>Azure App Service</em>, </span>when we were discussing the creation of a web app using Azure Portal.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Once you reach the web app creation blade, take a look at the <span class="packt_screen">OS</span><strong> </strong>field:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/bcb5903b-b11c-465b-af17-63e949e62f9d.png" width="240" height="36"/></div>
<p>As you can see, the <span class="packt_screen">Docker</span><strong> </strong>option is available. When you click on it, two more fields will need to be set:</p>
<ul>
<li><span class="packt_screen">App Service plan/Location</span>: This is the same as with "traditional" App Services with one important note. When you select <span class="packt_screen">Docker</span>, all App Service Plans you can choose from will be powered by the <span class="packt_screen">Linux</span><strong> </strong>operating system. This will impact both pricing and feature availability.</li>
<li><span class="packt_screen">Configure container</span>: When you select this option, you will see another screen with many different options depending on container settings. Currently, we have three different options to choose from—<span class="packt_screen">Single Container</span>, <span class="packt_screen">Docker Compose</span>, and <span class="packt_screen">Kubernetes</span>. The latest two are currently in preview, but we will also cover them. For now, select <span class="packt_screen">Single Container</span><strong> </strong>and use the <span class="packt_screen">Quickstart</span><strong> </strong>option.</li>
</ul>
<p>Here you can find my configuration:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/f5d0cf68-d6a6-43d5-926d-669da3af031a.png" style="width:17.25em;height:28.33em;" width="293" height="481"/></div>
<p>Now, after clicking on <span class="packt_screen">Create</span>, Azure finishes provisioning new resources after several seconds. After creation, go to the freshly created App Service and take a look at the blades on the left. You will see that some of them are disabled:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/b00058d9-ad5a-4c51-9f01-4c56da9747be.png" style="width:13.75em;height:44.17em;" width="239" height="774"/></div>
<p>As you can see, using Web App for Containers doesn't allow us to use features such as <span class="packt_screen">WebJobs</span> or <span class="packt_screen">Application Insights</span><em>.</em> Yet, we are still able to scale an application, attach a custom domain, or set a backup. Notice that one more blade is available—<span class="packt_screen">Container settings</span>. When you click on it, you will see the same screen as during App Service creation:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/6f922ebd-cdbf-4ca6-9cdc-9cf277b7216a.png" style="width:49.17em;height:39.17em;" width="844" height="673"/></div>
<p>Let's see what happens when we change the image for our container. Change the <span class="packt_screen">Image and optional tag</span><strong> </strong><span class="packt_screen">(eg 'image:tag')</span><strong> </strong>field to <kbd>appsvc/dotnetcore</kbd><strong> </strong>and then click <span class="packt_screen">Save</span>. After restarting an application, you should see a change in the visible logs:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/5f08f0ad-c6d3-4ddc-a4ee-c221628d0634.png" style="width:28.67em;height:12.00em;" width="449" height="188"/></div>
<p>Also, you should see a success message when browsing your web application:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/8556b293-2512-45d1-880b-8442a1560dd3.png" style="width:47.25em;height:12.50em;" width="907" height="239"/></div>
<p>Now we will try to deploy our own code and see whether it works.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Deploying a custom application</h1>
                </header>
            
            <article>
                
<p>In this section, we will focus on creating and deploying a custom application to our Docker container in the web app. For the purpose of this exercise, we will reuse the container image from the previous part of this chapter where we were discussing ACI.</p>
<div class="packt_infobox">If you would like to prepare a brand new application, go through the steps defined in the <em><span>Creating and deploying an application and container</span></em> section where we created a Docker image and pushed it to Azure Container Registry. </div>
<p>When you go once more to the <span class="packt_screen">Container settings</span><strong> </strong>blade, you can change <span class="packt_screen">Image source </span>to three different options:</p>
<ul>
<li><span class="packt_screen">Azure Container Registry</span>: It allows you to select images pushed to your own instance of ACR</li>
<li><span class="packt_screen">Docker Hub</span>: Provides access to all images available in this repository</li>
<li><span class="packt_screen">Private registry</span>: You can also define a private repository from which to deploy your images</li>
</ul>
<div class="packt_tip">Note that, if you use ACR, the two other sources will <span>also </span>point to ACR as it acts as your own private Docker Hub with your images.</div>
<p>Select the <span class="packt_screen">Azure Container Registry</span> tab<span class="packt_screen"> </span>and fill in all required fields as suggested by the portal:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/b3075b7c-a582-49be-8246-957a657d7c3b.png" style="width:59.92em;height:29.17em;" width="979" height="477"/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>After a moment, a new image should be reloaded and working. If you browse to the URL of your application, you should be able to see changes:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/f27f9e05-fdb1-458d-8045-6b6221cc04a0.png" style="width:33.75em;height:10.67em;" width="513" height="162"/></div>
<p>As you can see, the very same container image I used while working with ACI is fully functional here in Web App for Containers.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>As you saw, when working with containers in Azure you are able to focus on the delivery and shape of your application rather than configuration or maintenance. Of course, available features are not limited to those we covered in this chapter—you can also leverage functionalities such as continuous deployment, networking, or data volumes. What is available depends solely on the service you choose—Azure Container Instances and Web App for Containers are cloud components that are quite minimalistic and focus on running an application, while AKS delivers more advanced features. Nonetheless, containers are one of the most popular topics of recent months and it is quite possible that building and evolving that skill will help you in your future projects.</p>
<p>In the next chapter, you will learn a bit about another service that allows you to run containerized applications and get the out of from the microservice architecture in the Azure cloud—Azure Service Fabric.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is Azure Container Registry?</li>
<li>What is the <span class="packt_screen">Admin login</span><strong> </strong>feature in AKS?</li>
<li>Which OS do you have to choose while creating an App Service to be able to run containers?</li>
<li>Can you use images from the public registry in Web App for Containers?</li>
<li>Can you scale AKS in the portal?</li>
<li>How you can lower your application's downtime in AKS when updating it?</li>
<li>What do you have to do if AKS cannot authenticate to your instance of Azure Container Registry?</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li><a href="https://docs.microsoft.com/en-us/azure/container-instances/container-instances-orchestrator-relationship">https://docs.microsoft.com/en-us/azure/container-instances/container-instances-orchestrator-relationship</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/aks/networking-overview">https://docs.microsoft.com/en-us/azure/aks/networking-overview</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/monitoring/monitoring-container-health?toc=%2Fen-us%2Fazure%2Faks%2FTOC.json&amp;bc=%2Fen-us%2Fazure%2Fbread%2Ftoc.json">https://docs.microsoft.com/en-us/azure/monitoring/monitoring-container-health?toc=%2Fen-us%2Fazure%2Faks%2FTOC.json&amp;bc=%2Fen-us%2Fazure%2Fbread%2Ftoc.json</a></li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>