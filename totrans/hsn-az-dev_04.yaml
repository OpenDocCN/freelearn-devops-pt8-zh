- en: Distributed Applications and Microservices with Service Fabric
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Service Fabric** (**SF**) is a platform for distributed applications that
    greatly simplifies developing and deploying applications that are scalable and
    reliable. It''s one of the best solutions for developing cloud-native apps and
    lets users focus on developing rather than on maintaining infrastructure and connections
    between particular components. It''s a next-generation platform that is actively
    developed by Microsoft and has received much attention recently.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Microservice architecture and how to use it in the cloud with SF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic concepts of SF, such as services or actors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating between services in SF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing clusters in SF and securing them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring services in SF and how to diagnose them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To perform exercises in this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2017 with **Azure development** and **ASP.NET** and **web development** workloads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft Azure SF SDK ([http://www.microsoft.com/web/handlers/webpi.ashx?command=getinstallerredirect&appid=MicrosoftAzure-ServiceFabric-CoreSDK](http://www.microsoft.com/web/handlers/webpi.ashx?command=getinstallerredirect&appid=MicrosoftAzure-ServiceFabric-CoreSDK))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js ([https://nodejs.org/en/](https://nodejs.org/en/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Probably you have heard about an architecture called **microservices**. There
    is no single definition that we could quote here, so the main purpose of this
    chapter will be to acquire a better insight into what we can call a microservice
    and how to develop an application in such a manner. This directly connects to SF,
    which is one of the biggest and most advanced services in Azure. If you aim at
    building a modular, loosely-coupled, and modern application, this particular cloud
    component is designed for you.
  prefs: []
  type: TYPE_NORMAL
- en: Monolith versus microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start our journey with microservices by comparing them with a traditional
    application, which is composed of multiple layers serving different purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3755b0bf-a1ea-4aad-8984-19b4653f85cb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we define such services as monolithic, where the whole code
    base is deployed as one application. This one application has multiple responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Serving the UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running business logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running additional processes (such as jobs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can also look at it differently—as a single module that handles features
    from different domains. Let''s consider an e-shop, where we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Payment logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basket logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Order processing logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discounts logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many, many more different domains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now the question arises—should our application run such logic in one instance
    or should we divide it into multiple independent modules, which have different
    lifetimes, run differently, and can be developed individually? Maybe we would
    also like to scale them separately depending on current workload or business requirements.
    The choice always depends on the requirements your application will have to face.
    However, if you would like to give try microservices, SF is the way to go, especially
    if you aim at using cloud-native components.
  prefs: []
  type: TYPE_NORMAL
- en: Microservice approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may wonder whether the microservice architecture is one you would like to
    choose and work with. In this section, I would like to focus on specific features
    this approach provides and how you can address them when writing an application
    and, in the end, using SF.
  prefs: []
  type: TYPE_NORMAL
- en: Using different languages and frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we would like to address different problems resolved by our application
    by using different programming languages or tools. Maybe it is a good idea to
    write mainly in C# or Java and deliver more advanced features such as domain-specific
    calculations using a dedicated language. Maybe we have multiple teams working
    on different features and each one would like to use a different framework.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe the whole work is so globally distributed that dividing it into multiple
    smaller packages (and finally services) is the way to go. All of these problems
    are possible to solve using a single application but, on a bigger scale, such
    an approach could become cumbersome and insufficient. By leveraging the capabilities
    of SF in Azure, we can organize multiple applications (containing multiple services
    each) as a single platform, which can be managed from one place and deployed individually,
    saving time and money.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling and updating services individually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have just talked about deploying each service individually. Thanks to such
    an approach, you do not have to push the whole code base at once. I am sure you
    have had at least one project that was so big that the whole process of delivering
    it to the production environment was difficult to automate and took really long
    to finish. In such a scenario, dividing the project into smaller modules can also
    be beneficial let''s say that, in the last month, only one team delivered a new
    feature; you do not have to go through all your platform tests. What is more,
    if something is not right after deployment in a part of the system you have not
    modified, you do not have to bring in another team to investigate the problem.
    This confers the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: The process of delivering a business value is shorter and simpler, and hence
    less vulnerable to mistakes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can focus on a particular module and changes in it often do not affect other
    modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is one more interesting feature of the microservices architecture—you
    can scale each component separately. This means that if, for example, there is
    a module responsible for processing payments and you have just had a big discount
    in your online shop, resulting in a rapid growth of incoming orders, you do not
    have to worry that they overwhelm it. What you can do in such a situation is simply
    scale it out, so you can process each order in parallel using as many instances
    of your module as you currently need. Later in this chapter, you will learn how
    you can achieve such scalability in SF using different approaches depending on
    the actual structure of your application. The following diagram describes the
    difference between scaling microservices and monolith application—while the former
    gives you the possibility to scale up each service individually, the latter has
    to be scaled as a single entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b70e27f1-7128-4a45-9123-bdbfaa8d4ef5.png)'
  prefs: []
  type: TYPE_IMG
- en: Using well-designed interfaces and protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may ask, If we divide our application into, for instance, several smaller
    modules, how can we now ensure that communication between them will be smooth,
    seamless, and with the smallest latency possible? To satisfy such requirements,
    one has to refer to multiple communication patterns described by patterns for
    service-oriented architectures, which in fact are the very foundation of microservices.
    In general, you have to leverage well-known protocols such as HTTP or TCP, which
    are widely used in the IT industry and are understood by thousands of APIs, devices,
    and frameworks. Of course, you could think about designing a custom protocol or
    standard—while initially, it might be a good idea, sooner or later it may become
    an obstacle to expanding your application because it's not compatible with newer
    services. What is more, it is important to use popular serialization methods such
    as XML, JSON, or any binary format that is easily available and well documented.
    By following such guides, you can be sure that your microservice architecture
    will be easy to extend and integrate with.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nearly every application has some kind of state (of course, one can develop
    a stateless service, which does not have to store a state anywhere and just performs
    an action/returns a result; we will cover such services later in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: This state has to be managed and shared; in monolithic application handling,
    it is pretty straightforward and obvious—we have, for instance, a database, which
    holds all information from multiple parts of our system. In general, it is stored
    in one place (of course it can be scaled and shared, but we do not manage such
    features on our own), so we do not have to worry that we update it only partially
    (and if we do, there are always transactions). Of course, the state does not have
    to be stored in a database—we can use any kind of storage that holds data.
  prefs: []
  type: TYPE_NORMAL
- en: When using microservices, it turns out that each individual service has its
    own state and manages it independently. Problems arise where we have to query
    data from different modules or store data in more than one form of storage. To
    overcome such problems, one can use patterns such as eventual consistency. In SF,
    you can choose whether a state should be externalized or co-located. Additionally,
    SF takes care of making it highly available and durable.
  prefs: []
  type: TYPE_NORMAL
- en: Diagnosing and monitoring microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the process of monitoring traditional applications is pretty straightforward
    and simple, when you have tens or hundreds of smaller services, making it right
    is not that obvious. This has also other implications such as: What is the actual
    impact if one module goes down? When you have a monolith, you are immediately
    aware of any issues as your application simply stops working properly. With microservices,
    you may find it difficult to react in time if your monitoring does not cover all
    areas of your system. In SF, you have multiple levels of monitoring, which you
    can define as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application monitoring**: This tracks how your application is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cluster monitoring**: This allows you to monitor the whole SF cluster, so
    you can verify whether the whole service performs as expected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance monitoring**: Sometimes, it is hard to understand how your application
    behaves if you do not monitor its performance. In SF, it is easier to track resource
    utilization and predict possible issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Health monitoring**: When working with microservices, it is crucial to know
    whether particular modules are healthy or not. In SF, you can leverage the Health
    API or health reports available in SF Explorer to gain a better insight into the
    current status of your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers, services, and actors in SF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start with SF, we will cover three main topics, which allow you to divide
    an application logically and physically:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Containers**: Small, deployable components that are isolated from each other
    and enable you to virtualize the underlying operating system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reliable services**: One of the programming models available in SD for writing
    and managing stateful and stateless services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reliable a****ctors**: Another programming model on top of Reliable services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For now, SF supports two types of container:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker **on Linux'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows Server **containers on Windows Server 2016'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When working with containers in SF, you can use any programming language or
    framework (as you probably expected), but the most important thing related to
    such a model is the fact that you do not have to stick to built-in programming
    models (Reliable actors and Reliable services). What is more, this approach is
    very similar to running so-called **guest executables**, where you deploy an existing
    executable to SF.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start with containers, we will need to create an SF cluster. To do
    so, go to Azure Portal and click + Create a resource. Search for `Service Fabric
    Cluster` and click Create. You will see a familiar screen, where you have to fill
    multiple fields with your cluster configuration. In SF, the process of creation
    is divided into four different steps, which we will cover one by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the very first screen, you will have to enter basic information regarding
    the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4566481e-7e38-41ba-9496-d09745398369.png)'
  prefs: []
  type: TYPE_IMG
- en: There is one field that probably requires a little bit of clarification, namely, Operating
    system. As mentioned in the beginning of this chapter, SF supports both Windows and Linux containers,
    which you can select here. The choice affects both the pricing and available features,
    so you have to be sure which OS you're using.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are satisfied with the setup, you can proceed to the next screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f63ee24d-2611-4248-b7cc-016f6e794c8c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we begin with the actual cluster configuration. The first thing you have
    to do is select Node type count. To select the correct version, you have to understand
    what this actually means. This property defines the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Virtual machine (VM) sizes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of VMs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties of VMs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, to cut a long story short—if you need two different types of machine (because,
    for instance, you have a lightweight frontend and heavy backend), you will choose
    two different node types.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that you can always add or remove a node after cluster creation, but
    you will always need to have at least one.
  prefs: []
  type: TYPE_NORMAL
- en: On the Node type configurationblade, you will have to choose the size of virtual
    machines and their capacity and select a name for the node. You can also configure
    advanced options but, as we are just starting with SF, I would not recommend changing
    anything there.
  prefs: []
  type: TYPE_NORMAL
- en: Using fewer than five virtual machines initially designates a cluster as a test
    cluster. The reason why SF requires you to run five or more VMs is to make sure
    that your solution is more resilient to simultaneous failures. You still can use
    a test cluster to run production workloads, but it is not recommended.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now click OK to proceed. The last but one screen allows you to configure the
    security features of your cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a461416-515c-4e6f-ad5a-403141143d53.png)'
  prefs: []
  type: TYPE_IMG
- en: You can choose either the Basic or Custom configuration type—the difference
    between them is that, when using Basic, a certificate will be created for you
    and, when choosing Custom, you can enter certificate information on your own.
    Additionally, SF will require you to select a key vault (or create a new one)
    to store a certificate.
  prefs: []
  type: TYPE_NORMAL
- en: We will not cover Azure key vaults in this book. If you would like to know more
    about this service, please take a look at the documentation—[https://docs.microsoft.com/en-us/azure/key-vault/](https://docs.microsoft.com/en-us/azure/key-vault/)
  prefs: []
  type: TYPE_NORMAL
- en: 'When everything is set and ready, you can click OK, and you will see the final
    screen with a summary of the configuration of your cluster. Validate all of the
    information displayed there and, if you are ready to create the cluster, click
    on Create. When you go to the resource group you selected while creating the cluster,
    you should see a similar setup to mine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43a7b959-18bd-466d-99c9-459d5bebdc49.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, it contains many different services already:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Virtual machine scale set**: To make sure you can easily scale out, SF uses the
    VMs scale set to automate the whole process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service Fabric ****cluster**: The actual SF service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load balancer**: To distribute the load between your machines'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Public IP address**: So your application is available publicly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage account**: For storing data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Virtual network**: To secure and ease communication between machines, SF utilizes Azure
    Virtual Network to couple machines in the VMs scale set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a cluster configured and running, we can proceed to deploy
    the Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use Docker images in SF, we will need a registry in Azure Container Registry.
    You can go back to [Chapter 3](51d6dd91-dc4f-4c18-af05-e6ddc1b552fc.xhtml), *Deploying
    Web Applications as Containers*, where I described in detail how to work with
    ACR and Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will try to deploy a simple Python application—to start, we will need
    Dockerfile, of course:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, let''s create a Python application, which will display simple
    text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the `docker build` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be able to test and run it locally by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, all is working correctly—we can proceed by pushing an image
    and deploying it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a760e192-3e6a-4ea1-a7cf-ad93d14f14da.png)'
  prefs: []
  type: TYPE_IMG
- en: To push a container image, you will need of course a registry for it. If you
    want to use Azure Container Registry, please refer to the previous chapter for
    detailed instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, you will need three Dockercommands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker login`: To authenticate in ACR'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker tag`**:** To create an alias of an image and put it in the correct
    namespace'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker push`: To deploy an image to the registry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the full syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Packaging a service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To package our service, we will use Yeoman with the SF Yeoman container generator.
    To do so, you have to install them—in your command line, execute the following
    two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need one more thing—because the container image will be fetched from
    ACR, we have to configure its credentials in `ApplicationManifest.xml`.While the
    username can be traditionally found on the Overview blade of Container Registry,
    to find a password you have to run these two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will need to update the manifest generated by Yeoman so it uses our
    credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, log in to your cluster using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Finally, just run the `install.ps1`file Yeoman generated and wait a moment—your
    application image should be deployed to the SF cluster in the cloud and fully
    working.
  prefs: []
  type: TYPE_NORMAL
- en: To get a certificate, you can download it from the Certificates blade in key
    vault.
  prefs: []
  type: TYPE_NORMAL
- en: Reliable services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will try to create both stateless and stateful services
    using SF. This time, we will use Visual Studio to create a C# application and
    deploy it to our cluster. You can also start with Reliable serviceson Linux, but
    this will not be covered in this book. Refer to the *Further reading*section for
    links to the appropriate documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a SF application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you open a Visual Studio instance, go to File | New Project. In the new
    window search for Visual C# | Cloud templates; you should be able to find the Service
    Fabric Application option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc14a362-7565-4abe-92b3-053f7f823991.png)'
  prefs: []
  type: TYPE_IMG
- en: If you cannot find this option, make sure you have installed the SF SDK.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the next screen, you will see many different options, most of which we will
    discuss later. For now, select Stateless Serviceand click OK:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13a5a698-e9a3-4ffe-a318-6542987ed80b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After a moment you should be able to see that a stateless service template
    has been built with SF. You can now press *F5*to see how it works with all the
    default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b393b48b-2c84-4a90-8a87-383bfbda32a5.png)'
  prefs: []
  type: TYPE_IMG
- en: If you have trouble starting your local SF instance, make sure you have started
    Visual Studio as an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, each second a message—`Working-{N}`—is published. Take a look
    at the `RunAsync()`method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see that it is the source of those messages. In fact, it is the starting
    point of your service, which is called when it starts. It also accepts one parameter, `cancellationToken`, which
    is here to inform you about any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: There was a fatal error in your code and the service is currently in the invalid
    state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There was a hardware outage in a cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is an ongoing upgrade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current instance of service is no longer required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember to honor that `RunAsync()`should return a task. The system will wait
    until the service finishes executing, so always try to do it as quickly as possible
    if you discover that cancellation was requested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now try to add also a stateful service—to do so, add a new Service Fabric
    Applicationproject to the solution, but this time select Stateful Service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/262514e8-d2e8-4967-8b99-4a5cd0bc75b8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you compare the stateless `RunAsync()`with the stateful one, you will see
    many differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The most important one is a direct reference to state—in a stateful service,
    we have the state manager, which enables you to query state and execute actions
    within transactions. Here, in the previous example, we fetch a dictionary of the `IReliableDictionary<>` type
    from it—it is a reliable collection that stores data and replicates it to other
    machines. In fact, it is the same dictionary as, for example, `IDictionary<>`,
    but this time operations on a collection are asynchronous because data has to
    be persisted on disk.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that everything you store in the state manager has to be serializable.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you start your application, you will see that both services are running
    at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ad502eb-f52e-4249-bc9f-43ec34221e3c.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we would like to publish our simple application to Azure to see whether
    it really works.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an application to the cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you take a look, you will see that our solution contains now three projects:'
  prefs: []
  type: TYPE_NORMAL
- en: Stateless service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stateful service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SF project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now right-click on the SF project and click the Publish...option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90bb0bc6-4fe0-474a-8df8-6d9fbccd3faf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the new screen, you can configure things such as Target profileor Application
    Parameters File, but the most interesting one is Connection Endpoint, which is
    empty now. In fact, you cannot proceed without selecting one option, so let''s
    open the drop-down menu and see our options. Among the available options, you
    will have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Local cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create New Cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Trial Cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refresh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the local/new cluster option is self-explanatory, you might wonder what
    the Trial option is. When you select it, you will be given an option to sign-in
    to so-called **party clusters**. These are free-of-charge SF clusters, which you
    can use to play with this service a little bit and learn how it works. You do
    not need a subscription, but after an hour the cluster will be taken down. Because
    we are learning about services in Azure in this book, I will not use that option,
    but feel free to utilize it later if you decide you want to know much more about SF than
    this short chapter was able to provide.
  prefs: []
  type: TYPE_NORMAL
- en: When you select the Create New Clusteroption, a new screen will appear with
    the whole SF cluster configuration. It is very similar to the one you can see
    in the portal—it has the same sections, such as Cluster, Certificate, and VM Detail.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an SF cluster from Visual Studio has one downside—you do not know what
    the recommended values are and have no direct reference to the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows my configuration from the first tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/acaa76fb-9dfb-4b6d-95cc-85e366621bfa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, I set the Number of nodes to `1`—this is because I am not planning
    to deploy a production workload and do not need two different characteristics
    of virtual machines as both my services are more or less the same. When you click Next,
    you will see the second tab, where you will specify a certificate password. A
    certificate will be automatically created and imported if you leave the Import
    certificateoption checked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c888da57-7ae9-46d4-8cc4-fc7effb6f4db.png)'
  prefs: []
  type: TYPE_IMG
- en: Certificates in SF are a way to secure both node-to-node and client-to-node
    communication. These are X.509 certificates and, what is more, it is important
    to keep at least one valid—failing to do so can even make the cluster stop functioning.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next tab is VM Detail, where you can specify details of machines running
    your cluster. After providing a User name and Password, you have to choose which
    operating system will be used to run SF and the size of each VM. After entering
    all the required information, you can click on Create:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f419abf-58e7-443f-ada4-3f1ec783431e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Deploying an SF cluster can take a while so be patient. Once it is finished,
    you can take a look at it in Azure Portal to see that all parts of the whole ecosystem
    are deployed. However, when you enter the SF cluster in Azure, you will see that
    it has both `0` applications and `0` nodes attached. This is because we just created
    it without deploying anything. This is why we have to go back to Visual Studio
    and click Publish once more, this time selecting a cluster we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cbcd32d1-0685-40f9-af53-2e855db9362c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s go to Azure and explore our application. On the Overview blade
    of our SF instance, there is the Explorer button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86aee828-8e92-4f0e-95e8-a7abc002d786.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you click on it, new windows will open in your browser and you will be
    asked to select a certificate, which will be used to secure a connection. Remember
    to select the one you created and exported during SF cluster creation. After accepting
    it, you should be able to see Service Fabric Explorer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3fadbcd5-d990-4d20-8a73-ea9314d2fe13.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations—you have just created your very first microservice architecture
    using SF!
  prefs: []
  type: TYPE_NORMAL
- en: Reliable actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we created an application that is made up of two services—a
    stateful and stateless one. In SF, there are many different frameworks to build
    your system—another one is Reliable actors. It is designed for creating a platform
    of distributed services that can work concurrently and independently—because each
    actor is isolated, an issue with one instance does not affect others working at
    the same moment. You may wonder when to choose Reliable services and when the
    best option is Reliable Actors? The rule of thumb could be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If you require to divide your work among multiple workers (such as hundreds
    or thousands), choose Reliable Actors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to isolate your work and expect a single-threaded environment for
    simplicity, choose Reliable Actors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your business domain expects work to be performed in the transaction, choose Reliable
    Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your service has to be reliable and highly available, choose Reliable Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, the aforementioned reasons do not cover all possible scenarios, but
    you should be able to understand the difference by now. In general, you cannot
    expect that actors will be very durable as the idea is to spawn new ones and forward
    the workload to them instead of ensuring that they can work indefinitely.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a project with actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start our journey with Reliable actors by creating a brand new project
    in Visual Studio—for this, click on File | New projectand once more select an
    SF template. On the New Service Fabric Servicescreen, select the Actor Servicetemplate
    and click OK:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7f8d6c5-6fe8-4e26-95d2-28458cf6c95d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After your project is initialized, you will see that it is a bit different
    from the one for Reliable services—what is most important is that it now contains
    the `.Interfaces`project, which for now contains only one file with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It will act as our communication point between the actor and its clients. You
    may think of it as a contracts aggregator. Now, check the main actor project (in
    my case it is `ReliableActor`)—you will find there the current implementation
    of the previous interface. The following is the current code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Each actor implementation is decorated with the `[StatePersistence]`attribute.
    It has three different options:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Persisted: Here the state is persisted to disk and replicated to replicas (three
    or more). It is the most durable option and prevents you from losing it even during
    a complete cluster failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volatile: Instead of persisting a state to disk, it is only replicated and held
    in memory on three or more replicas. This is the less durable option, similar
    to holding your data only in RAM memory, which will be lost once power is lost.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: None: If you do not need to persist in your state, you can use this option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no best option here—it all depends on the requirements of your actors.
    Please note one more thing—an actor itself is not limited to some kind of "hard"
    contract; you define the code all by yourself and SF will do its best to replicate
    it, persist state (if needed), and scale out to meet your demands. Currently,
    we have only a worker—we also need a client to test our service.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an actor's client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a client, we will use the most traditional Console Application.Once
    more, click on File | New project and search for it or just right-click on the
    solution and click on Add | New project. You will have to add two more things
    before we write some code:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a reference to our `.Interfaces`project as we have to know which methods
    we would like to call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the `Microsoft.ServiceFabric.Actors` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will write a simple application that calls our actor, fetches the current
    count value, and updates it. The following shows my example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, I am doing three things:'
  prefs: []
  type: TYPE_NORMAL
- en: I am getting a reference to my actor service by using the `fabric` protocol
    and a specific interface I created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To obtain the count value, I am calling the `GetCountAsync()`method on my reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I am updating state by calling `SetCountAsync()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following shows the result of running both actor and client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2912129-005c-4c3a-b185-0498b5e4826a.png)'
  prefs: []
  type: TYPE_IMG
- en: Great—all works as expected. You may wonder how actor instances are distributed
    in the SF cluster and how we achieve the distribution of hundreds of instances
    of them. Well, it is all handled by SF runtime by partitioning instances and attaching
    them to different nodes on a cluster. Thanks to that, you can expect that the
    workload will be balanced—what is more, you can reference an actor by its ID (as
    opposed to the presented method, `ActorId.CreateRandom()`), but it is not always
    recommended as you have to ensure you are not overloading one actor.
  prefs: []
  type: TYPE_NORMAL
- en: Communication between services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You currently know how to work with SF using Reliable services and Reliable
    actors. The next important topic refers to communication between each instance
    of a service. As we discussed at the beginning of this chapter, the best option
    when building your microservices is to create a platform that will be agnostic
    when it comes to choosing what is the best way to communicate and accept incoming
    requests. In SF, you do not have a single way to exchange messages—instead you
    are provided with a complete framework to do it your way. In this section, we
    will focus on building a simple communication channel for your services.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a communication channel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a channel, you will need to implement the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there is no information regarding technology or the framework
    used—it is up to you. We will try to open the HTTP protocol in our service. Since
    we cannot cover all types of service in this book, we will focus on the stateless
    service. If you open the project from the section about it, in the main file of
    your service, you can find the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Currently, it returns an empty array—we would have to provide a custom implementation
    of `ServiceInstanceListener`and add it here. While it is, of course, possible
    to do so, it would take too much time to describe it in detail; instead, we use
    a NuGet package, which has the correct implementation of such a listener and is
    built using ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, it is possible to use Http Sys or Kestrel to resolve communication.
    Feel free to experiment as those technologies differ a little and are always a
    substitute for each other (for example, Http Sys is currently not designed for
    stateful services).
  prefs: []
  type: TYPE_NORMAL
- en: 'For this exercise, please install the following package: `Microsoft.ServiceFabric.AspNetCore.
    HttpSys`. Once you have it, you can modify the `CreateServiceInstanceListeners()`method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it provided the full implementation of a listener and a pipeline
    for handling a request. You will also need to implement the `Startup` class, which
    will handle communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This may look familiar to you as this is a simple ASP.NET Core stack, which
    you would implement in the same manner, creating a web application not hosted
    in SF. Only one thing remains for now—we have to modify `ServiceManifest.xml` and
    specify that our endpoint is exposed by a service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the endpoint name must match the one you defined in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when you run your application, you should be able to call it by using
    the exposed endpoint, which can be found in Service Fabric Explorer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/78fbe318-6fe3-4a32-9784-b3d07b56a62e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is the result of calling my service from the Postman application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7deca25b-2c8a-436e-8b28-33cd7059e0c2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now the question is: What you can do with such a feature? In fact, there are
    many possibilities—you can exchange messages between services, you can query a
    service for the status of a task currently performed, or you can change a state
    so a different path will be chosen when running a workload. This is a very powerful
    functionality and, in addition to all of the advantages that SF brings to distributed
    systems, you can be sure that your communication is reliable and fully under your
    control.'
  prefs: []
  type: TYPE_NORMAL
- en: Clusters in SF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have talked about clusters in SF, but how can you really understand such
    a concept in that service? You probably remember that, during the creation of
    a cluster, we had to choose both node types and their characteristics—the number
    of VMs and their type. If you choose to have three nodes with five machines in
    each one, you will end up with a cluster of fifteen machines in total. SF automatically
    balances it, so if you are changing its size, all services will be redeployed
    to achieve maximum utilization. In this chapter, we will talk a little about security,
    available features, and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a conceptual diagram of a cluster organization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7cb6390b-610a-4fd4-8d3a-ddfbb6a44ae0.png)'
  prefs: []
  type: TYPE_IMG
- en: Cluster security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you go back to the creation of a cluster, you will notice that we always
    had to create or import a certificate—without it, there was no way to proceed.
    You have to remember that it is your responsibility to secure your environment
    and prevent unauthorized access. As the documentation states, it is impossible
    to create an insecure cluster—this is, of course, true. However, if you expose
    your endpoint (especially in production workloads) publicly, there is always the
    possibility that somebody will figure it out and start abusing it.
  prefs: []
  type: TYPE_NORMAL
- en: Node-to-node security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s assume that you have three different nodes for different types of workload:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40fd6dd9-2024-4d7f-b431-b4b048ec93bf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Those nodes could be exposed (or not exposed) to the external network. Now,
    you may wonder how SF ensures that communication is handled in a secure manner.
    In fact, there are two possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Certificate security**: In such a scenario, a client (node) attaches credentials
    to each request and signs a message with the private key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows security**: Based on the Kerberos protocol'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final solution depends on your actual needs.
  prefs: []
  type: TYPE_NORMAL
- en: Client-to-node security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides communicating within a cluster, you may need to allow authorized users
    to exchange messages with individual nodes. In fact, this is cover by similar
    security options as **node-to-node **security—here you can choose between certificates
    and **Active Directory** (**AD**) security. What is the advantage of using AD
    in that scenario? There is one very important aspect—in most cases, you do not
    want to share certificates with your client (this could also be cumbersome with
    a large number of them). AD security can be set in the ARM template by providing
    additional options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Scaling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Scaling is one of the most important features of SF as the microservices architecture
    is all about being able to scale out when you need and preserving a stable environment
    while doing so. In most cases, you will need to scale horizontally (by getting
    more machines running your workloads) but, of course, it is also possible to scale
    vertically (so more powerful machines become available and, in some scenarios,
    it is a better option than scaling out). In general, the answer to whether you
    need to scale out or up depends on the work your code needs to do:'
  prefs: []
  type: TYPE_NORMAL
- en: If your work can be parallelized, choose to scale out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your work performs many calculations and is I/O-heavy and such actions cannot
    be distributed, choose to scale out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is more, each node type in SF is a separate VM scale set. That means that
    you can scale your nodes independently, according to your needs. This is a very
    important feature—you probably would not appreciate, if only one part of your
    system requires more computing power, having to update the whole cluster.
  prefs: []
  type: TYPE_NORMAL
- en: In SF, each node has specific requirements when it comes to scaling, as it is
    important to keep the correct number of nodes running production workloads. Details
    can be found in the documentation; you can find a link to it in the *Further reading*section
    at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling a cluster up or down
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, it is not recommended to scale a cluster up or down, as it is a
    dangerous operation (especially if you would like to change the VM SKU of the
    primary node). If you wonder why, please consider the following operation—you
    are about to scale down a node. This is an infrastructure operation, which requires
    changing available hardware for your application. If you do not monitor and orchestrate
    all operations correctly, you may end up with your stateful services losing data
    (for example, you temporarily lost access to a database) and even stateless services
    may become unstable. In fact, to scale up or down in a secure fashion, you should
    first create a new node type, and then gradually reduce the instance count of
    the old one, so SF is able to distribute the workload correctly before the old
    node is shut down.
  prefs: []
  type: TYPE_NORMAL
- en: The SF documentation states that it is highly inadvisable to change the SKU
    of VMs running a primary node. However, it is, of course, possible when done carefully; you
    can find a link to instructions in the *Further reading*section at the end of
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring and diagnostics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the final section of this chapter, we will cover some topics regarding monitoring
    and diagnosing your services in SF. As you probably remember, I noted such features
    as one of the most important in microservices, as you have to always be able to
    tell how each one works and perform the needed action (such as scale out, restart,
    or kill an instance) if required. In SF, there are a few levels of monitoring
    that we will briefly describe here.
  prefs: []
  type: TYPE_NORMAL
- en: Application monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In most cases, you want to monitor how your application works, what the user
    traffic is, and how your services communicate with each other. While you are able
    to bring your own framework, you can also leverage **Application Insights** (**AI**)
    integration—this will ensure that you are getting all necessary logs and available
    diagnostic messages. You can set up AI integration while creating a cluster for SF:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8f11568-683e-4857-ad31-91652b7aadb9.png)'
  prefs: []
  type: TYPE_IMG
- en: Cluster monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While working, your cluster emits a variety of events, which map to one particular
    entity within it:'
  prefs: []
  type: TYPE_NORMAL
- en: Cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replica
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can query these events by leveraging the `EventStore` service available
    in SF. It is possible to correlate them, so you can find out how one entity impacts
    others. The following is the example request to the API returning events from
    a specific time range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Health monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides monitoring your application and cluster, you will also want to check
    how a particular service is working. To check its health, SF introduces Service
    Fabric Explorer, which you can access to verify the health of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replica
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can access the Explorer both locally and in the cloud. It presents a nice
    UI, which displays a lot of useful information that you can use to determine the
    current status of the whole system, notice possible problems, and get the necessary
    details to investigate an issue further:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87d148c2-b6e6-40c0-b69c-35f50d14693a.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we only took a brief look at SF and the microservices built
    with this Azure component. You have learned the basic concepts of SF, such as
    Reliable services and Reliable actors, and how to implement a communication protocol
    to exchange messages between services and clients. Remember that building an application
    based on microservices is not a trivial task and requires sticking to many important
    rules to avoid problems with dealing with state, monitoring, or scaling. Use SF as
    a framework for building distributed applications, which takes care of ensuring
    that they are reliable and highly available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least: do not be discouraged if you have problems with SF or feel
    overwhelmed by its multiple options and configurations—this particular service
    has a pretty difficult learning curve, but after reading this whole chapter, you
    should be able to start writing your very own services without problems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 3](51d6dd91-dc4f-4c18-af05-e6ddc1b552fc.xhtml), *Deploying Web
    Applications as Containers*, you will learn about another PaaS service available
    in Azure: Azure Search, which lets you start using your own search engine to index
    and query stored documents.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between Reliable services and Reliable actors?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between stateless and stateful services?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What one has to be implemented to introduce its very own communication channel
    in SF?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is node type in SF?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you scale (up/out) node types individually?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you select a VM SKU when creating a cluster?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the two types of node security in SF?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between cluster, application, service, partition, and
    replica?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why does SF advocate creating a node with at least five VMs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the reliability tier in SF?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-technical-overview](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-technical-overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-cluster-creation-via-arm](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-cluster-creation-via-arm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-cluster-scaling](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-cluster-scaling)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-diagnostics-event-generation-operational](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-diagnostics-event-generation-operational)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-work-with-reliable-collections](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-work-with-reliable-collections)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
