- en: Swiss Army Knife - Azure Cosmos DB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to storage, we often have to store multiple schemas of data using
    multiple databases. Due to the need for using multiple services, managing our
    solution becomes cumbersome and requires a lot of skill to do it in the right
    fashion. Thanks to Azure Cosmos DB, we can both store records using different
    database models (such as MongoDB, Table Storage, or Gremlin), and pay only for
    what we agreed on—throughput, latency, availability, and consistency, all thanks
    to the serverless model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What Azure Cosmos DB is, and how it looks compared to other storage systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partitioning, throughput, and consistency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different Azure Cosmos DB database models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To perform the exercises in this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Visual Studio or Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure subscription
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Cosmos DB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with storage, you have probably heard about different kinds; relational
    databases, NoSQL databases, graph databases, document databases. There are plenty
    of different models available, with different characteristics, when it comes to
    storing data. If you need to easily maintain relationships between tables, in
    most cases you will choose something such as SQL Server. On the other hand, maybe
    you would like to save each record in the JSON file format, where the best solution
    would be an instance of MongoDB. While the choice is all yours, the biggest problem
    is that you need to have a different kind of service to serve the same purpose—storing
    data. This is where Azure Cosmos DB comes into play. With its multi-model capabilities,
    flexibility, and scalability it is a great choice for globally distributed and
    highly responsive applications. In this section, you will learn how to start working
    with this service and what its main functionalities are.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Cosmos DB instance in the portal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start our journey with Azure CosmosDB by creating it in the Azure portal:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click on + Create a resourceand search for `Azure Cosmos DB`, you
    will see a simple form that allows you to select the basic features of the service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/eef48642-0d4b-48da-92bd-37a50979efe7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are, however, some not-so-obvious features, which will require a little
    bit of explaining:'
  prefs: []
  type: TYPE_NORMAL
- en: '**API**: As mentioned earlier, Azure Cosmos DB enables you to use one of a
    few different APIs during creation. Currently, there are five available APIs:
    SQL, MongoDB, Cassandra, Azure Table, and Gremlin. Depending on the API selected,
    you will have different capabilities available (and what is more, different packages
    will be required for communicating with your database in the application''s code).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enable geo-redundancy: By selecting this option, your data will be distributed
    between two paired regions (depending on the one you selected in the Location drop-down),
    for example, West Europe and North Europe or Central US and East US 2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enable Multi Master: This is a new (and currently in preview) feature, where
    instead of having only a single master, you can have multiple master databases
    all around the globe. This greatly lowers latency when it comes to reading already
    saved data (as you do not have to wait for data propagation), and increases consistency
    and data integrity (as you have the possibility to write data to a master instance
    in a specific region).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Virtual networks:Depending on the model you choose, you may be able to restrict
    access to an instance of Azure Cosmos DB by putting it into a specific virtual
    network and subnet. Currently, this is possible for two database models: SQL and
    MongoDB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you are satisfied with all the entered data, you can create it by clicking
    on the Create button. Once your service is created, you can access the Overview blade
    to see how it works initially:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5d0b4b56-f433-4249-8e9a-02d106e47757.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, it displays a map in the center that tells you how your data
    is replicated across regions. If you click on the map, you will be able to reconfigure
    the initial settings. If you click on the Add new regionbutton, you will be able
    to search for a particular one and select it as an additional read region. Alternatively,
    you can just click on a region icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed8e4a92-228e-483c-b54e-0aa5a3b9a7cd.png)'
  prefs: []
  type: TYPE_IMG
- en: In the current setup, you are unable to add additional write regions. To be
    able to do so, you have to use the multi-master feature I described previously.
  prefs: []
  type: TYPE_NORMAL
- en: Once you save additional regions, both Manual Failoverand Automatic Failoverwill
    become active. The concept for failover is simple—if your write region goes down
    and becomes unavailable, another available read region can take its place. The
    only difference is whether you want to perform such failover manually or automatically.
  prefs: []
  type: TYPE_NORMAL
- en: If you opt for automatic failover, you can decide on the order of switching
    between read and write regions. If you want, for example, to switch from North
    Europe to West Europe in the first place, West Europe has to be the very first
    priority in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you go back to the Overview blade, you will notice some additional features:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Monitoring: Here you can easily find all requests to your database and their
    status.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enable geo-redundancy: If you did not enable this feature when creating an
    instance of Azure Cosmos DB, you may do this now.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data Explorer: By clicking on this button you can easily access an explorer,
    which allows you to insert and modify data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, you can go to the Quick start blade, where you will be able to
    start developing applications using this Azure service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/069d2761-adae-4f90-a18f-afcc76a422a3.png)'
  prefs: []
  type: TYPE_IMG
- en: Depending on the selected model of a database, you will have access to different
    initial configurations. Additionally, as you can see, you have a choice as to
    whether you would like to use .NET, Node.js, Java, or Python—all these languages
    can easily integrate with Azure Cosmos DB, making it an even better choice when
    it comes to creating a multi-platform application.
  prefs: []
  type: TYPE_NORMAL
- en: Using Azure Cosmos DB in Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides controlling Azure Cosmos DB in the portal, you are able to access it
    directly in your code and IDE, such as Visual Studio. Like many other services,
    you can use Cloud Explorerto browse all available instances of this database available
    within your subscription:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6e91c8e-ea8f-471d-9470-d37ce4371171.png)'
  prefs: []
  type: TYPE_IMG
- en: Now let's try to communicate with it from a simple application. While initially
    an instance of Cosmos DB is empty, we can quickly add a table to it.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will work with the table API in Cosmos DB. If you would
    like to work with any other type, you will have to consult tutorials in the *Further
    reading*section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are creating an empty table, which should be immediately
    available within an instance of Cosmos DB. Now if I check Cloud Exploreronce more,
    I see that, in fact, it is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f0a5e35-91dc-46ac-ba88-283742d706fd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we can add a record to it. We slightly modify our code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We now consult Data Explorerin the portal to see the difference between Visual
    Studio and the Azure portal. We should be able to see the entity we have just
    inserted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c3adb3f-1415-424f-8e49-502ed27d37ce.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, all you need to start working with a database with multiple
    database models, which can be quickly configured for geo-redundancy and scaled
    across the globe, is just several lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Pricing in Azure Cosmos DB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Azure Cosmos DB is part of the serverless services available in Azure. This
    means that the chances of configuring and provisioning servers to run it are either
    maximally limited or not available. As you probably noticed, we were not able
    to define how many instances of a service we would like to run (or nodes or clusters).
    Instead, we have to define throughput for each collection individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17c2f81b-fe7d-4097-9d5f-8162bde5b368.png)'
  prefs: []
  type: TYPE_IMG
- en: A simple calculator display also estimates the costs of a collection per hour
    and day. The unit of throughput in Azure Cosmos DB is **request units** (**RUs**).
    During the creation of a container (or a collection—you can use both definitions),
    you specify also its type—whether it has fixed capacity or unlimited.
  prefs: []
  type: TYPE_NORMAL
- en: Once the type of collection is defined, you cannot change it later.
  prefs: []
  type: TYPE_NORMAL
- en: 'By selecting different options, you can select different limits for RUs:'
  prefs: []
  type: TYPE_NORMAL
- en: For fixed, you can select between 400 to 10,000 RUs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For unlimited, you can go from 1,000 to a maximum of 100,000 RUs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regarding pricing, you are paying both for the amount of data stored ($0.25
    GB/month), and reserved RUs ($.008/hour per every 100 RUs). Having those values,
    we can quickly calculate the smallest bill possible—it is around $23\. Now there
    is a very important caveat. You are paying per each collection/table/container.
    That means that, if you have, for example, 20 different tables in your database,
    you will pay 20 * $23 = $462\. In such a scenario, it is sometimes better to model
    your database in such a way that it will be possible to store all data within
    a single container.
  prefs: []
  type: TYPE_NORMAL
- en: While Azure Cosmos DB seems like a quite an expensive service, please do remember
    that it does many things for you, such as geo-redundancy, multiple read regions,
    multi-master models, and many more. You always have to calculate the best options
    for you (and if you are able to do the same with the similar results). To do so,
    take a look at the Capacity Planner described in the *Further Reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning, throughput, and consistency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have learned something about Azure Cosmos DB—how it works and its most
    common features—we can focus a little bit on three really important topics in
    this service; partitioning, throughput, and consistency. Those factors are crucial
    when selecting a database engine to power your application. They directly tell
    you how it will be performing, how many requests it will be able to handle, and
    what guarantees apply when it comes to your data integrity.
  prefs: []
  type: TYPE_NORMAL
- en: Partitions in Azure Cosmos DB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Partitioning is directly connected with scaling in Azure Cosmos DB as it allows
    for load-balancing incoming requests. In fact, there are two different types of
    partition in this service:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Physical**: These are a combination of fixed storage and a variable amount
    of computing resources. This type of partition is fully managed by Cosmos DB—you
    cannot directly affect how your data is physically partitioned and how a service
    handles those partitions. In fact, you are also unaware of how many of those partitions
    are currently in use. Therefore, you should not design your containers against
    that specific concept.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logical**: This kind of partition holds data that has the same partition
    key. Because you are able to define that key (by specifying it in each entity),
    you are able to control how your data is partitioned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that a logical partition has a limit of 10 GB. Additionally, all data
    for a logical partition has to be stored within one physical partition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you may wonder how partitioning works in Azure Cosmos DB. This can be described
    in a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Each time a new container is provisioned (and you are providing a number of
    RUs), Cosmos DB has to provision physical partitions, which will be able to serve
    the number of requests specified in the number of RUs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It may turn out that the specified amount of RUs exceeds the maximum number
    of requests per second served by a partition. In that case, Cosmos DB will provision
    the number of partitions it needs to satisfy your requirements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next thing to do is to allocate space for partition key hashes. All provisioned
    partitions have to have the same space allocated (so it is distributed evenly).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, if after some time any partition reaches its storage limit, it is split
    into two new partitions, and data is distributed evenly between them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Of course, the partition key used for partitioning differs for each database
    model—for a table it is partition key, for SQL it will be a custom path. In general,
    this operation is slightly different depending on the database type, yet the overall
    concept remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that if your container has only one partition key for all the entities
    in it, then Cosmos DB will not be able to split a partition. That means that you
    could hit the maximum of 10 GB per partition and not be able to add any more data.
  prefs: []
  type: TYPE_NORMAL
- en: The best value for the partition key depends solely on your application data
    specification. In general, you have to choose a value that is quite differential
    (so partitioning can actually happen). On the other hand, you should not create
    a unique partition key for each record (while it is possible, it will be quite
    expensive). There is no one solution to that problem—you always have to analyze
    each scenario and select what suits you the most.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, it is worth including a partition key while filtering data, as
    it allows for high concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: Throughput in Azure Cosmos DB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Further reading*section, you will find a capacity calculator—a tool
    that enables you to plan your Cosmos DB instance and estimate the required RUs.
    As mentoned previously, in this particular service you are not defining the number
    of instances or clusters. Instead, while creating a container, you have to state
    your expected throughput for that specific collection (or a set of collections).
    Thanks to an **Service Level Agreement** (**SLA**) for Azure Cosmos DB, that value
    will be guaranteed for you. Additionally, even if you replicate a database to
    another region, you can expect that problems in one region will not affect others.
  prefs: []
  type: TYPE_NORMAL
- en: There is one important definition of 1 request unit—it is the processing capacity,
    that enables you to read a 1 KB entity using, for example, a simple GET request.
    The same is not true for operations such as inserting or deleting, as those require
    more computing power to be performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like to know exactly how many RUs a specific operation consumes,
    you have to consult the `x-ms-request-charge` header in a response from a Cosmos
    DB instance. This will tell you the cost of this operation—of course, you have
    to remember that it may differ depending on the number of records returned. In
    the documentation you can find the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Request unit charge |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Create item | ~15 RU |'
  prefs: []
  type: TYPE_TB
- en: '| Read item | ~1 RU |'
  prefs: []
  type: TYPE_TB
- en: '| Query item by ID | ~2.5 RU |'
  prefs: []
  type: TYPE_TB
- en: Those are values for executing an operation against an entity 1 KB in size.
    As you can see, the values are completely different depending on the operation
    type. You also can see, that it is crucial to carefully check all operations requirements—if
    you fail to do so, you may face an HTTP 429 response, which tells you that you
    have exceeded the reserved throughput limits. In such a scenario, you should honor
    the `x-ms-retry-after-ms` header response, which allows for an easy retry policy.
  prefs: []
  type: TYPE_NORMAL
- en: Consistency in Azure Cosmos DB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides different models of a database, Azure Cosmos DB offers also a different
    level of consistency. You may wonder what consistency is and how it affects your
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Consistency is a parameter of a database system, which reflects the way a transaction
    affects data. It defines the rules that are applied when different constraints
    or/and triggers affect data written to a database.
  prefs: []
  type: TYPE_NORMAL
- en: 'So basically it tells you what are the guarantees that, if your data becomes
    affected by a set of operations, it will not be malformed and you will be able
    to rely on it. The following are the available consistency models in Cosmos DB:'
  prefs: []
  type: TYPE_NORMAL
- en: STRONG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BOUNDED STATELESS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SESSION
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CONSISTENT PREFIX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EVENTUAL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the above list, each level below STRONGgives you less consistency. This
    is especially true for EVENTUAL, which could be familiar to you thanks to a topic
    known as eventual consistency. In general, you are setting the default consistency
    level for your account—then it is possible to override it per each request (of
    course, if you want to). If you want to know how exactly each consistency level
    works, please refer to the *Further reading*section. To set a particular level
    in your Cosmos DB instance, click on the Default consistencyblade:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2f6e600-c9ec-43f2-8d6f-df1417e8691f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, it allows you to easily switch to another consistency level
    depending on your needs. What is more, it displays a nice animation, which describes
    how reads/writes in multiple regions will work for this particular level. The
    following screenshot shows the animation for eventual consistency:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a21d58f-400e-4c64-93d7-ad1e0ca31e47.png)'
  prefs: []
  type: TYPE_IMG
- en: In this screenshot, each individual note represents an individual read or write
    in a particular region. Additionally, on this screen, you are able to set Maximum
    Lag (Time)when the BOUNDED STALENESSlevel is selected.
  prefs: []
  type: TYPE_NORMAL
- en: CosmosDB data models and APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, Azure Cosmos DB offers five different database models,
    all sharing the same infrastructure and concepts. This is a great feature, that
    makes this service really flexible and able to serve multiple different purposes.
    In this section, I will briefly describe each database model, so you will be able
    to select one that best serves your purposes.
  prefs: []
  type: TYPE_NORMAL
- en: SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you think about SQL, you probably see a relational database with tables,
    relations, and stored procedures. When working with **SQL API **in Cosmos DB,
    in fact you will work with documents that can be queried using the SQL syntax.
    Let us assume you want to query documents using the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can find an example of a query written in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is all about a simple LINQ query, which allows you to use
    a specific property to filter data. Because all records in Cosmos DB are stored
    as JSON documents, you can easily transform them from table to document representations
    (and possibly denormalize them).
  prefs: []
  type: TYPE_NORMAL
- en: Using document databases is completely different from storing data in relational
    databases. Always remember to model your data appropriately in line with database
    capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As Cosmos DB implements the MongoDB wire protocol, you can easily use all your
    applications that currently use that document database with new instances of Azure
    Cosmos DB, without changing anything (besides the connection string, of course).
    While it cannot mimic MongoDB completely yet (the full list of supported operations
    can be found in the *Further reading*section), in most cases you will be able
    to use it seamlessly. As Cosmos DB has a strict requirement regarding security,
    you will have to use SSL when communicating with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here you can see a template for a connection string, where `ssl=true`is present—it
    is required when communicating with this Azure service. What is more, you will
    not be able to set a communication without authenticating a request.
  prefs: []
  type: TYPE_NORMAL
- en: Graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Azure Cosmos DB supports Gremlin as a graph database model. If you are not
    familiar with graph databases, you may think about them as a structure composed
    of vertices and edges. They can very easily show you relations between different
    elements of a graph as you can quickly traverse the connections and see that element
    A knows something about element B indirectly, thanks to element C. To be more
    specific, Cosmos DB supports a more specific model of a graph database known as
    a **property graph**. The following is an example query for Gremlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example is taken from the documentation and literally answers
    the question: What operating systems do relations of the user of the `thomas.1` ID
    use?. Graph databases are great for applications such as social media portals
    or IoT hubs.'
  prefs: []
  type: TYPE_NORMAL
- en: Table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While you can use Azure Storage Table for your applications (which will be
    covered in upcoming chapters), it is possible to also take advantage of Cosmos
    DB''s Table API and consider more advanced scenarios with that service. There
    are some differences between both services:'
  prefs: []
  type: TYPE_NORMAL
- en: While the current maximum limit for operations in Azure Storage Tables is 20,000
    operations/sec, with Cosmos DB you can achieve millions of them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot initiate failover for Storage Table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Cosmos DB, data is indexed on all properties, not only on the partition key
    and row key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different pricing (storage versus throughput)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different consistency levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Developing against Cosmos DB Table API is the same as working with Azure Table
    Storage. The following is an example of code in C# retrieving entities from a
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Cassandra
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last available model in Azure Cosmos DB is Cassandra. Cassandra is a scalable,
    durable, and decentralized database for storing massive amounts of data. Now,
    if you use it with Cosmos DB, you can focus on development rather than on operations
    or performance management, and choice of consistency. While currently this model
    is in preview, you can test it and check what advantages it gives to you. Under
    the hood, it uses the Cassandra API, so it is possible to use Cassandra Query
    Language to communicate and interact with data. This model has the same feel as
    MongoDB—you can use the same tools you used for your current Cassandra instances
    and should not notice any difference.
  prefs: []
  type: TYPE_NORMAL
- en: Different features of CosmosDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Cosmos DB has multiple different features that can be used to lower your
    bills, secure an instance, or integrate with other services. In this section,
    we will quickly take a look at most of them, so you will fully understand the
    basics of this service and will be able to progress on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Account level throughput
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of defining throughput per each collection, sometimes you would like
    to set a fixed value for the whole account. This is a great addition if you have
    many different containers and instead of paying for each individually (as you
    remember—it was over $20 per month), you can go to Account level throughputand
    set a throughput for the whole account:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f751068-bbf5-4766-922d-5bec4effbc33.png)'
  prefs: []
  type: TYPE_IMG
- en: The only limitation of this feature is you can no tables currently in the account.
    If you enable it, all your requests to all tables will share the same amount of
    throughput (so you can pay less, but in the case of "greedy" collections you can
    run out of RUs). The downside of that functionality is that you will pay for the
    provisioned throughput, whether you have created collections or not.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the aforementioned feature is available only for the Table API.
  prefs: []
  type: TYPE_NORMAL
- en: Database level throughput
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Azure Cosmos DB it is also possible to provision throughput directly on
    the database. To do so, you need to select the Provision throughput checkbox during
    database creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46f2bcf5-8708-4699-9272-2098d9bc4794.png)'
  prefs: []
  type: TYPE_IMG
- en: With that feature on, all provisioned RUs will be shared across all collection
    available for a database.
  prefs: []
  type: TYPE_NORMAL
- en: Firewall and virtual networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you configured the virtual network feature during Cosmos DB creation, in
    this blade you will be able to configure it further. What is more, it is also
    possible to configure a firewall—so you can restrict access to a specific range
    of IPs or disallow connections from other Azure data centers. In general, you
    do not want to have a database that can be accessed by everyone, so if this feature
    is available, I strongly recommend you use it.
  prefs: []
  type: TYPE_NORMAL
- en: Note that currently firewalls and VNets are available only for the SQL API and
    Mongo API. Support for other APIs should be available soon.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can easily integrate Azure Cosmos DB with Azure Functions by using the Add
    Azure Functionblade:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0154b628-5612-42f5-b34d-150a53842fc8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Creating a function from Cosmos DB will add the following code to your Function
    App:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is CSX code, which we did not cover—however, besides slight changes in
    syntax, it is pure C#. This function will listen to changes to a collection you
    selected during creation—it is up to you what it will do next. In general, it
    is a quick and easy way to integrate these two services. What is more, you can
    have more than just one Azure Function generated for your collection or table.
    Now if I add a document, I can see it triggers a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Stored procedures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Cosmos DB allows for creating stored procedures that can be executed individually
    and can hold extra logic, which you do not want to share.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you go to your collection in Data Explorer,you will see the New Stored Proceduretab
    and the ability to create one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00ad3946-c75e-4b1d-91fe-7b3b5966ef94.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Stored procedures are written in JavaScript—this allows you to easily access
    the document''s schema (as they are all JSON). What is more, they are registered
    per collection. Here you can find an example of the easiest stored procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: User-defined functions and triggers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To extend the query language, you can write your own **user-defined function**
    (**UDF**) and in your queries. Note that you cannot use these in Stored Procedures.
    UDFs are used to extend the SQL query language in Azure Cosmos DB and can be only
    called from inside queries. Triggers, however, are divided into two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Pre-triggers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Post-triggers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, you can select an operation that this trigger refers to:'
  prefs: []
  type: TYPE_NORMAL
- en: All
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here you can find an example of a trigger that updates a timestamp in a document
    before it is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Triggers, of course, are also available from Data Explorer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43a704b5-66c8-495d-9bc9-ebae4e0079f4.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned about another serverless Azure component named Azure
    Cosmos DB. You saw multiple database models that this service supports, and also
    multiple different features, such as geo-redundancy and the ability to easily
    scale up and introduce new read regions, where data will be replicated. What is
    more, you are now aware of multiple consistency models and how to change them
    in the Azure portal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, you will learn about another hot topic: reactive architecture
    with Azure Event Grid.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which APIs does Azure Cosmos DB support currently?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are there any differences between the capabilities of Azure Table Storage and Table
    API in Cosmos DB?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the available consistency models?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which consistency model is more consistent—bounded, staleness, or eventual?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it possible to restrict access to Azure Cosmos DB to only a single IP?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is SQL API the same as SQL Server?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the reason for using stored procedures?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it possible to provision throughput in Azure Cosmos DB for the whole account
    instead of per collection?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Partitioning data in Azure Cosmos DB: [https://docs.microsoft.com/en-us/azure/cosmos-db/partition-data](https://docs.microsoft.com/en-us/azure/cosmos-db/partition-data)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Capacity planner: [https://www.documentdb.com/capacityplanner](https://www.documentdb.com/capacityplanner)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Cosmos DB RUs: [https://docs.microsoft.com/en-us/azure/cosmos-db/request-units](https://docs.microsoft.com/en-us/azure/cosmos-db/request-units)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consistency levels: [https://docs.microsoft.com/en-us/azure/cosmos-db/consistency-levels](https://docs.microsoft.com/en-us/azure/cosmos-db/consistency-levels)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mongo DB support: [https://docs.microsoft.com/en-us/azure/cosmos-db/mongodb-feature-support#mongodb-protocol-support](https://docs.microsoft.com/en-us/azure/cosmos-db/mongodb-feature-support#mongodb-protocol-support)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph API and Gremlin: [http://tinkerpop.apache.org/docs/current/reference/#intro](http://tinkerpop.apache.org/docs/current/reference/#intro)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
