<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Messaging in the Cloud Using Amazon SNS and Amazon SQS</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we briefly explored the AWS code suite of services, namely AWS CodeCommit, AWS CodeDeploy, and AWS CodePipeline, and how they tie into the continuous integration and continuous delivery life cycle of an application.</p>
<p>In this chapter, we will be learning and exploring yet another group of AWS services that are extremely useful when it comes to developing modern cloud-ready applications, as well as for the general housekeeping of your AWS accounts: Amazon <strong>Simple Notification Services</strong>, or <strong>SNS</strong>, and Amazon <strong>Simple Queue Service</strong>, or <strong>SQS</strong>.</p>
<p>Keeping this in mind, let's have a quick look at the various topics that we will be covering in this chapter:</p>
<ul>
<li>Introducing the various messaging services provided by AWS, along with an insight into which service to use for what purpose</li>
<li>Introducing Amazon SNS and Amazon SQS, along with their core concepts and terminologies</li>
<li>Creating your own SNS topics and subscriptions, and leveraging them for your AWS account</li>
<li>Monitoring SNS notifications using Amazon CloudWatch</li>
<li>Integrating Amazon SNS with Slack for a richer, user notification experience</li>
<li>Getting started with standard and FIFO queues, and integrating Amazon SNS with Amazon SQS</li>
</ul>
<p>So, without any further ado, let's get started!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding the AWS messaging services</h1>
                </header>
            
            <article>
                
<p>We all know by now that AWS provides a plethora of services designed to help you with developing a rich set of cloud-ready applications; but with so many different services to choose from, how do you make the right set of choices to begin with? That's exactly what we will be learning and exploring in this section, starting with a brief understanding and comparison of a few commonly used AWS messaging services, as depicted in the following diagram:</p>
<div class="chapter-content CDPAlignCenter CDPAlign"><img height="546" width="1312" src="Images/4ceb42aa-aaf7-419e-ab19-6b469fcf27dc.png"/></div>
<ul>
<li><strong>Amazon SNS:</strong> Amazon <strong>SNS</strong>, or <strong>Simple Notification Service</strong>, is a synchronous, managed service that provides the end user with the ability to deliver or send messages to one or more endpoints or clients. This works by using a <strong>Publisher–</strong><strong>Subscriber</strong>-like model, as depicted in the following diagram:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img style="font-size: 1em" height="341" width="1169" src="Images/2967ae78-1d27-44d0-8ce9-3cf53823afc0.png"/></div>
<p style="padding-left: 90px">One or more publishers or producers post a message to a corresponding SNS <strong>topic</strong> without knowing which subscribers or consumers will ultimately consume the message. The producer also doesn't wait for a response back from the consumers, thus making SNS a loosely-coupled service. It is the consumer's task to subscribe to the topic and get notified of the incoming messages. SNS supports a variety of consumer implementation options, such as email, mobile push notifications or SMS, HTTP/HTTPS notifications, and even Lambda functions.</p>
<ul>
<li><strong>Amazon SQS:</strong> Amazon <strong>SQS</strong>, or <strong>Simple Queue Service</strong>, on the other hand, is an asynchronous managed service that provides users with the ability to push and pull messages from a queue. Here too, one or more producers can be used to push messages into the queue, which a corresponding set of consumers on the other end consume and process the messages one at a time. An important point to note here is that, unlike its counterpart, SNS, where the consumers are notified of a new message, here, the consumers have to poll the queue in short intervals of time for newer messages. Once a message is found, the consumer has to process it and then delete it from the queue. The process is shown here:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img height="356" width="1639" src="Images/031e540b-e8d8-4646-9645-803989fd882c.png"/></div>
<ul>
<li><strong>Amazon Kinesis</strong>: Amazon Kinesis functions a lot like Amazon SQS; however, it is fundamentally designed and optimized for high-throughput data writes and reads. Here, instead of a queue, you are provided with a stream that consumers can use to read from multiple times. The stream is automatically trimmed after a span of 24 hours, so, unlike your consumers from the queue, here you are not required to delete the messages once they are processed:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img height="704" width="954" src="Images/60bab0ac-5337-495e-8d73-fa98b952294e.png"/></div>
<p>Similar to Amazon Kinesis, AWS also provides a streaming functionality with DynamoDB as well, called DynamoDB streams. Using this feature, you can basically enable real-time changes to certain items within your tables in the form of a stream. And, finally, you also get the standard request–reply model of messaging using a combination of Amazon API Gateway, ELBs, AWS Lambda, and other services. This mode of communication is also synchronous in nature and can be used to fit a variety of use cases, as per your requirements.</p>
<p>Keeping these basic differences in mind, let's now move forward and learn more about SNS.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting started with Amazon Simple Notification Service</h1>
                </header>
            
            <article>
                
<p>As discussed briefly earlier, SNS is a managed web service that you, as an end user, can leverage to send messages to various subscribing endpoints. SNS works in a publisher–subscriber or producer and consumer model, where producers create and send messages to a particular topic, which is in turn consumed by one or more subscribers over a supported set of protocols. At the time of writing this book, SNS supports HTTP, HTTPS, email, push notifications in the form of SMS, as well as AWS Lambda and Amazon SQS, as the preferred modes of subscribers.</p>
<p>SNS is a really simple and yet extremely useful service that you can use for a variety of purposes, the most common being pushing notifications or system alerts to cloud administrators whenever a particular event occurs. We have been using SNS throughout this book for this same purpose; however, there are many more features and use cases that SNS can be leveraged for. For example, you can use SNS to send out promotional emails or SMS to a large group of targeted audiences, or even use it as a mobile push notification service where the messages are pushed directly to your Android or IOS applications.</p>
<p>With this in mind, let's quickly go ahead and create a simple SNS topic of our own:</p>
<ol>
<li>To do so, first log in to your AWS Management Console and, from the <span class="packt_screen">Filter</span> option, filter out <kbd>SNS</kbd> service. Alternatively, you can also access the <span class="packt_screen">SNS</span> dashboard by selecting <a href="https://console.aws.amazon.com/sns">https://console.aws.amazon.com/sns</a>.<a href="https://console.aws.amazon.com/sns"/></li>
<li>If this is your first time with SNS, simply select the <span class="packt_screen">Get Started</span> option to begin. Here, at the <span class="packt_screen">SNS</span> dashboard, you can start off by selecting the <span class="packt_screen">Create topic</span> option, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="311" width="565" src="Images/5ab61416-e32b-4a10-a48a-88887bbf394f.png"/></div>
<ol start="3">
<li>Once selected, you will be prompted to provide a suitable <span class="packt_screen">Topic name</span> and its corresponding <span class="packt_screen">Display name</span>. Topics form the core functionality for SNS. You can use topics to send messages to a particular type of subscribing consumer. Remember, a single topic can be subscribed by more than one consumer. Once you have typed in the required fields, select the <span class="packt_screen">Create topic</span> option to complete the process. That's it! Simple, isn't it?</li>
<li>Having created your topic, you can now go ahead and associate it with one or more subscribers. To do so, first we need to create one or more subscriptions. Select the <span class="packt_screen">Create subscription</span> option provided under the newly created topic, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="280" width="785" src="Images/9775190b-9918-4ccf-97ea-d049457aaad2.png"/></div>
<ol start="5">
<li>Here, in the <span class="packt_screen">Create subscription</span> dialog box, select a suitable <span class="packt_screen">Protocol</span> that will subscribe to the newly created topic. In this case, I've selected <span class="packt_screen">Email</span> as the <span class="packt_screen">Protocol</span>. Next, provide a valid email address in the subsequent <span class="packt_screen">Endpoint</span> field. The <span class="packt_screen">Endpoint</span> field will vary based on the selected protocol. Once completed, click on the <span class="packt_screen">Create subscription</span> button to complete the process.</li>
<li>With the subscription created, you will now have to validate the subscription. This can be performed by launching your email application and selecting the <span class="packt_screen">Confirm subscription</span> link in the mail that you would have received.</li>
<li>Once the subscription is confirmed, you will be redirected to a confirmation page where you can view the subscribed topic's name as well as the subscription ID, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="248" width="544" src="Images/f674ccdd-a2e4-46e9-b3ac-3396b17e2806.png"/></div>
<ol start="8">
<li>You can use the same process to create and assign multiple subscribers to the same topic. For example, select the <span class="packt_screen">Create subscription</span> option, as performed earlier, and from the <span class="packt_screen">Protocol</span> drop-down list, select <span class="packt_screen">SMS</span> as the new protocol. Next, provide a valid phone number in the subsequent <span class="packt_screen">Endpoint</span> field. The number can be prefixed by your country code, as shown in the following screenshot. Once completed, click on the <span class="packt_screen">Create subscription</span> button to complete the process:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="183" width="529" src="Images/c9bbe421-b9b7-4540-8605-b2beea459f1d.png"/></div>
<ol start="9">
<li>With the subscriptions created successfully, you can now test the two by publishing a message to your topic. To do so, select the <span class="packt_screen">Publish to topic</span> option from your topics page. Once a message is published here, SNS will attempt to deliver that message to each of its subscribing endpoints; in this case, to the email address as well as the phone number.</li>
</ol>
<ol start="10">
<li>Type in a suitable <span class="packt_screen">Subject</span> name followed by the actual message that you wish to send. Note that if your character count exceeds 160 for an SMS, SNS will automatically send another SMS with the remainder of the character count. You can optionally switch the <span class="packt_screen">Message format</span> between <span class="packt_screen">Raw</span> and <span class="packt_screen">JSON</span> to match your requirements. Once completed, select <span class="packt_screen">Publish Message</span>.</li>
<li>Check your email application once more for the published message. You should receive an mail, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="122" width="696" src="Images/40f8b3ed-8ae2-441c-b5d1-4920f43e199e.png"/></div>
<p>Similarly, you can create and associate one or more such subscriptions to each of the topics that you create. In the next section, we will look at how you can leverage SNS to send SMS messages or text messages to one or multiple phone numbers.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sending text messages using SNS</h1>
                </header>
            
            <article>
                
<p>Amazon SNS also provides users with a really easy-to-use interface which allows you to send text messages or SMS messages to one or multiple phone numbers. It also provides you with the ability to classify and send messages based on their criticality, as well as specify the maximum amount that you wish to spend on sending SMS messages each month. So, without wasting any time, let's get straight to it:</p>
<ol>
<li>To send SMS messages using SNS, first log in to the SNS dashboard by selecting <a href="https://console.aws.amazon.com/sns/">https://console.aws.amazon.com/sns/</a>.<a href="https://console.aws.amazon.com/sns/"/></li>
<li>Once logged in, select the <span class="packt_screen">Text messaging (SMS)</span> option from the navigation pane. This will bring up the <span class="packt_screen">Text messaging (SMS)</span> dashboard, where you can set your SMS preferences as well as send messages to one or more phone numbers. First up, let's set some preferences by selecting the <span class="packt_screen">Manage text messaging preferences</span> option from the dashboard.</li>
</ol>
<ol start="3">
<li>Fill in the following preference fields:
<ul>
<li><span class="packt_screen">Default message type</span>: SNS provides two message types: <span class="packt_screen">Promotional</span> and <span class="packt_screen">Transactional</span>. The <span class="packt_screen">Promotional</span> option can be selected if the messages that you wish to send require less criticality, for example, simple marketing messages, and so on. On the other hand, <span class="packt_screen">Transactional</span> messages are ideally suited for critical messages, such as one-time passwords, transaction details, and so on. SNS optimizes the message delivery for <span class="packt_screen">Transactional</span> messages to achieve the best reliability.</li>
</ul>
</li>
</ol>
<div class="packt_infobox">At the time of writing this book, sending SMS messages is supported in the countries listed at <a href="https://docs.aws.amazon.com/sns/latest/dg/sms_supported-countries.html">https://docs.aws.amazon.com/sns/latest/dg/sms_supported-countries.html</a>.</div>
<p style="padding-left: 90px" class="mce-root">For this particular scenario, I've selected the <span class="packt_screen">Promotional</span> option, as shown in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="375" width="809" src="Images/cd797451-30a0-46e5-99af-d992c876b9b4.png"/></div>
<ul>
<li style="list-style-type: none">
<ul>
<li><span class="packt_screen">Account spend limit</span>: The maximum amount you wish to spend, in USD, for sending messages in a month. By default, the limit is set to USD 1.00. For this scenario, we are not going to change this value.</li>
</ul>
</li>
</ul>
<div style="padding-left: 60px" class="packt_infobox">Both <span class="packt_screen">Promotional</span> and <span class="packt_screen">Transactional</span> message types have different costs based on the specified country or region. You can look up the prices at <a href="https://aws.amazon.com/sns/sms-pricing/">https://aws.amazon.com/sns/sms-pricing/</a>.</div>
<ul>
<li style="list-style-type: none">
<ul>
<li><span class="packt_screen">IAM role for CloudWatch Logs access</span>: This option is used to create an IAM role that basically allows Amazon SNS to write its logs to CloudWatch. Since this is the first time we are configuring this feature, select the <span class="packt_screen">Create IAM role</span> option. This will redirect you to a new page where you should select the <span class="packt_screen">Allow</span> option to grant SNS the necessary rights. Here is a snippet of the rights that are provided for your IAM role:</li>
</ul>
</li>
</ul>
<pre style="padding-left: 60px">{ 
  "Version": "2012-10-17", 
  "Statement": [ 
    { 
      "Effect": "Allow", 
      "Action": [ 
        "logs:CreateLogGroup", 
        "logs:CreateLogStream", 
        "logs:PutLogEvents", 
        "logs:PutMetricFilter", 
        "logs:PutRetentionPolicy" 
      ], 
      "Resource": [ 
        "*" 
      ] 
    } 
  ] 
} </pre>
<ul>
<li style="list-style-type: none">
<ul>
<li><span class="packt_screen">Default percentage of success to sample</span>: This option is used to specify the percentage of successful SMS messages delivered, based on which SNS will write logs into CloudWatch. To write only logs for failed message deliveries, set this value to <kbd>0</kbd>. By default, SNS will write logs for all successful deliveries (100%).</li>
<li><span class="packt_screen">Default sender ID</span>: This option is used to specify the name of the message's sender. You can provide any meaningful name here.</li>
<li><span class="packt_screen">Reports storage</span>: Use this option to configure an S3 bucket that will store daily SMS usage reports from Amazon SNS. If you are providing an existing bucket as your <span class="packt_screen">Reports storage</span> then ensure that it has the necessary access rights to interact with the SNS service.</li>
</ul>
</li>
</ul>
<ol start="4">
<li>Once the required fields are filled in, select the <span class="packt_screen">Update preferences</span> option to complete the process.</li>
</ol>
<p>To send the SMS messages, simply select the <span class="packt_screen">Send a text message (SMS)</span> option from the <span class="packt_screen">Text messaging (SMS)</span> dashboard. This will bring up the <span class="packt_screen">Send text message (SMS)</span> dialog box, as shown in the following screenshot. Provide a valid phone <span class="packt_screen">Number</span> and a <span class="packt_screen">Message</span>. Remember to prefix your country code in the phone number as well:</p>
<div class="CDPAlignCenter CDPAlign"><img height="262" width="543" src="Images/96b04b21-cc91-4e2a-9f24-9f66b624aa28.png"/></div>
<p>You can optionally even overwrite the <span class="packt_screen">Sender ID</span> field here, however, for this case, we have left it to the default value that was configured in the preferences stage. After the required fields are filled in, simply select <span class="packt_screen">Send text message</span> to complete the message-sending process. You can also verify the delivery status of each message sent, either <span class="packt_screen">Transactional</span> or <span class="packt_screen">Promotional</span>, by using the <span class="packt_screen">Account stats</span> section provided in the <span class="packt_screen">Text messaging (SMS)</span> page.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using Amazon SNS as triggers</h1>
                </header>
            
            <article>
                
<p>One of the key benefits of having a service such as SNS is that it can also be used as a trigger mechanism for a variety of use cases. Messages sent by SNS can be used to trigger simple Lambda functions that in turn perform some action over another AWS service, or simply process the message from SNS and forward its contents to another application. In this section, we will be exploring a really simple use case where an SNS topic is used as a trigger mechanism for a Lambda function to push CloudWatch alerts over to Slack! The alerts will be sent out to a custom-made Slack channel that your IT team can use to track alerts and other important notifications with regards to your AWS environment.</p>
<p>At a broader level, here are the list of things that we plan to do for this activity:</p>
<ul>
<li>Create an SNS topic that will act as the Lambda trigger</li>
<li>Create a CloudWatch alarm for one of our EC2 machines, say, if CPU utilization goes higher than 80% then trigger the alarm</li>
<li>The CloudWatch alarm will post the notification to an SNS topic</li>
<li>The SNS topic will act as a trigger to our Lambda function</li>
<li>As soon as the Lambda function gets a trigger, it will post the notification to our Slack channel</li>
</ul>
<p>Sounds simple? Let's get down to implementing it then:</p>
<ol>
<li>First, we will need to create a simple SNS topic which will act as a trigger for the Lambda function. Go ahead and create a simple SNS topic as we did in our earlier steps. Once completed, make a note of the SNS topic's ARN from the topics dashboard. In this case, our SNS is configured to send notifications to an email subscriber in the form of an IT admin email alias.</li>
<li>Next up, we create our CloudWatch alarm. To do so, select the <span class="packt_screen">CloudWatch</span> service from the AWS Management Console and click on <span class="packt_screen">Alarms</span> in the navigation panel. Select <span class="packt_screen">Create alarm</span> to get started.</li>
<li>In this scenario, we will be monitoring the EC2 instances in our environment, so I've gone ahead and selected the <span class="packt_screen">EC2 Metrics</span> option. Alternatively, you can select any other <span class="packt_screen">Metrics,</span> as per your requirements. In our case, we have gone ahead and configured a simple <span class="packt_screen">CPUUtilization</span> alarm, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="380" width="601" src="Images/108e1972-18e0-4f59-bf71-afaa0c1c8952.png"/></div>
<ol start="4">
<li>Make sure that you set up a notification for the alerts and point it to the newly created SNS topic, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="185" width="584" src="Images/aa361d85-1ba4-49c8-914f-4ece2ddce92f.png"/></div>
<p>With the SNS topic and CloudWatch alarm in place, we now need to configure a Slack channel where the alert notifications will be posted. For that, we will need an incoming webhook to be set and a hook URL that will be used to post the notifications:</p>
<ol start="1">
<li>Go to your Slack team's settings page and select the <span class="packt_screen">Apps &amp; integrations</span> option, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="186" width="271" src="Images/7ae85fcd-290c-4028-a7c6-499ed8ede6f4.jpg"/></div>
<div style="padding-left: 60px" class="packt_infobox">You can sign up for a free Slack account at <a href="https://slack.com/get-started">https://slack.com/get-started</a>.<a href="https://slack.com/get-started"/></div>
<ol start="2">
<li>Once you click on <span class="packt_screen">Apps &amp; integrations</span>, it will take you to a new page which lists a variety of pre-configured apps. Search for <kbd>Incoming</kbd> and select the <span class="packt_screen">Incoming Webhooks</span> from the options that appear.</li>
<li>Next, click on <span class="packt_screen">Add Configuration</span>. It will ask you to select the <span class="packt_screen">Channel</span> to post, along with a few other necessary parameters. Make sure that you copy and save the <span class="packt_screen">Webhook URL</span> before you proceed any further with the next steps.</li>
</ol>
<p>Now that we have our Slack hook URL ready, we can finally get started with deploying our Lambda function. For this exercise, we will be using an existing AWS Lambda function blueprint designed for Slack integration, using the Node.js 4.3 version:</p>
<ol>
<li>From the AWS Management dashboard, filter the service <span class="packt_screen">Lambda</span> using the <span class="packt_screen">Filter</span> option, or alternatively, select <a href="https://console.aws.amazon.com/lambda/home">https://console.aws.amazon.com/lambda/home</a>.</li>
<li>From the <span class="packt_screen">AWS Lambda</span> landing page, select the <span class="packt_screen">Create a function</span> option to get started.</li>
</ol>
<ol start="3">
<li>For working with Lambda functions, you can choose to create your own function from scratch, or alternatively, filter and use a function from a list of predefined and configured blueprints. In this case, select the <span class="packt_screen">Blueprints</span> option and use the adjoining blueprints filter to search for the following function: <span class="packt_screen">Blueprint name</span><span class="packt_screen">: cloudwatch-alarm-to-slack</span> (as shown in the following screenshot):</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="322" width="599" src="Images/48fa3787-c106-4faf-b468-c848188bde69.png"/></div>
<ol start="4">
<li>Select the blueprint and fill out the necessary information for your function, such as its name, role name, and so on. Once done, from the <span class="packt_screen">SNS</span> section, select the newly created SNS topic from the drop-down list.</li>
<li>Remember to select the <span class="packt_screen">Enable trigger</span> checkbox before proceeding with the next steps.</li>
<li>Finally, in the <span class="packt_screen">Environment variables</span> section, provide the appropriate values for the <kbd>slackChannel</kbd> and <kbd>kmsEncryptedHookUrl</kbd> parameters, as shown in the following screenshot. Remember, the <kbd>kmsEncryptedHookUrl</kbd> is nothing but the <span class="packt_screen">Slack hook URL</span> that we created a while back:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="109" width="790" src="Images/21efa3ea-75cf-4419-bc3b-0cff721aee5f.png"/></div>
<ol start="7">
<li>With the values filled in, simply select the <span class="packt_screen">Create function</span> option and let the magic begin!</li>
</ol>
<p>Based on the selected CloudWatch metric for your alarm, go ahead and create some synthetic load for your EC2 instance. Once the load crosses the set threshold in the alarm, it triggers a corresponding message to the SNS topic, which in turn triggers the Lambda function to post the alert over on the Slack channel. In this way, you can also use the same SNS topic for subscribing to various other services, such as Amazon SQS, for other processing requirements.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Monitoring Amazon SNS using Amazon CloudWatch metrics</h1>
                </header>
            
            <article>
                
<p>Amazon SNS automatically collects and sends various metrics about message deliveries to Amazon CloudWatch. You can view these metrics and assign them with alarms to alert you, in case a message delivery rate drops beyond a certain threshold. You can additionally view the message delivery logs, as well using the CloudWatch Logs page:</p>
<ol>
<li>To get started, first ensure that you have assigned an IAM role that allows SNS to write SMS delivery logs over to CloudWatch. To do so, from the navigation pane, select the <span class="packt_screen">Text messaging (SMS)</span> option.</li>
<li>Next, from the <span class="packt_screen">Manage text messaging preferences</span> option, ensure that you have a valid IAM role provided under the <span class="packt_screen">IAM role for CloudWatch Logs access</span> field.</li>
<li>Once the IAM role is created, log in to your CloudWatch dashboard by selecting <a href="https://console.aws.amazon.com/cloudwatch/home">https://console.aws.amazon.com/cloudwatch/home</a>.</li>
<li>Here, select the <span class="packt_screen">Logs</span> option from the navigation pane to bring up the CloudWatch <span class="packt_screen">Log Groups</span> page. You should see a default Log Group created here, by the name of <kbd>DirectPublishToPhoneNumber</kbd>.</li>
</ol>
<ol start="5">
<li>Select the Log Group to view the SMS delivery log messages. The logs will either show a <kbd>SUCCESS</kbd> or <kbd>FAILURE</kbd> in the <kbd>status</kbd> field, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="Images/0c1357dd-ed17-45dd-844f-cb32dde6274e.png" width="500" height="291"/></div>
<ol start="6">
<li>You can additionally create and associate CloudWatch alarms with your monitored SNS metrics. To do so, from the CloudWatch dashboard, select the <span class="packt_screen">Metrics</span> option.</li>
<li>From the <span class="packt_screen">All metrics</span> tab, filter and select the <span class="packt_screen">SNS</span> option.</li>
<li>Based on the requirements, you can now select between viewing the metrics based on the <span class="packt_screen">PhoneNumber</span>, or <span class="packt_screen">Country</span>, <span class="packt_screen">SMSType</span>, and so on. In this case, we have selected the <span class="packt_screen">PhoneNumber</span> option to view the <span class="packt_screen">NumberOfNotificationsFailed</span> and <span class="packt_screen">NumberOfNotificationsDelivered</span> metrics.</li>
<li>Next, select the <span class="packt_screen">Graphed metrics</span> tab to view the two metrics and their associated actions. Using the <span class="packt_screen">Actions</span> column, select the <span class="packt_screen">Create alarm</span> option for the metric that you wish to monitor.</li>
<li>Fill in the respective details and configure the alarm's threshold values based on your requirements. Once completed, click on <span class="packt_screen">Create Alarm</span> to complete the process.</li>
</ol>
<p>In this way, you can leverage Amazon CloudWatch to create and view logs and alerts generated by the SNS service. In the next section, we will be exploring and learning a bit about the second part of the AWS messaging services: SQS.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introducing Amazon Simple Queue Service</h1>
                </header>
            
            <article>
                
<p>Amazon SQS is a managed, highly scalable, and durable service that provides developers with a mechanism to store messages that can be later consumed by one or more applications. In this section, we will be exploring a few of the concepts and terminologies offered by SQS along with an understanding of which SQS, queue to use for what scenarios, so let's get started!</p>
<p>To start off with, SQS is provided in two different modes:</p>
<ul>
<li><strong>Standard queue</strong>: Standard queues are the default selection when it comes to working with SQS. Here, the queues created offer a nearly-unlimited <strong>transaction per second</strong> (<strong>TPS</strong>) rate coupled with an <em>at-least-once</em> delivery model. What this model means is that a message can be delivered at least once, but occasionally there is a good probability that more than one copy of that same message can be delivered as well. This is due to the fact that SQS is designed and built on a highly distributed system that is known to create copies of the same message in order to maintain a high-availability scenario. As a result, you may end up with the same message more than once.</li>
</ul>
<p style="padding-left: 90px">Standard queues also work on a <em>best-effort ordering</em> model, in which case, messages might be delivered in a different order to the one in which they were sent. It is up to your application to sort the messages into the right order in which the messages should be received. So, when is the standard queue an ideal choice for decoupling your applications? Well, if your application has a high throughput requirement, for example, processing of batch messages, decoupling incoming user requests from an intense background processing work, and so on, then standard queues are the right way to go.</p>
<p style="padding-left: 90px">Standard queues are available across all AWS regions.</p>
<ul>
<li><strong>FIFO queues</strong>: When working with standard queues, there is a problem of maintaining the order of the messages and also ensuring that each message is processed only once. To solve this issue, AWS introduced the FIFO queue that provides developers with a guaranteed order of delivery of messages, as well as the assurance that each message is delivered only once, where no duplicates or copies are ever sent out.</li>
</ul>
<p>FIFO queues, on the other hand, do not offer an unlimited throughput capacity, unlike their predecessor. At the time of writing this book, FIFO queues support up to 300 messages sent per second, with an additional 3,000 messages per second capacity if a batch of 10 messages per operation is performed.</p>
<p>Such queues are really useful when the order of the messages is of critical importance, for example, ensuring that a user follows the correct order of events while registering or purchasing of a product, and so on.</p>
<p>FIFO queues are currently only available in the US East (N. Virginia), US East (Ohio), US West (Oregon), and EU (Ireland) regions.</p>
<p>With this basic understanding, let's look at some simple steps to get you started with your very own queue in a matter of minutes!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating your first queue</h1>
                </header>
            
            <article>
                
<p>Getting started with your own SQS queue is a fairly straightforward process. In this section, we will be looking at how you can create your very own standard queue using the AWS Management Console:</p>
<ol>
<li>To begin with, log in to your AWS Management Console and filter out the <span class="packt_screen">SQS</span> service using the <span class="packt_screen">Filter</span> option provided. Alternatively, you can also access the SQS dashboard by selecting <a href="https://console.aws.amazon.com/sqs/home">https://console.aws.amazon.com/sqs/home</a>.<a href="https://console.aws.amazon.com/sqs/home"/></li>
<li>Since this is our first time configuring the SQS queue, select the <span class="packt_screen">Get started now</span> option to continue.</li>
<li>Here, in the <span class="packt_screen">Create New Queue</span> page, start off by providing a suitable name for your queue by filling in the <span class="packt_screen">Queue Name</span> field.</li>
</ol>
<div class="packt_infobox">If you are building a FIFO queue, you will need to suffix <kbd>.fifo</kbd> after your queues name, for example: <kbd>myQueue.fifo</kbd>.</div>
<ol start="4">
<li>With the queue name filled out, the next step is to select the type of queue you wish to set up. In this case, let's first start off by selecting the <kbd>Standard Queue</kbd> option.</li>
</ol>
<ol start="5">
<li>Next, select the <span class="packt_screen">Configure Queue</span> option to go through some of the queue's configuration parameters. Alternatively, you can also select the <span class="packt_screen">Quick-Create Queue</span> option to select all the default parameters for your queue.</li>
<li>In the <span class="packt_screen">Queue Attributes</span> section, feel free to modify the following set of parameters for your queue, based on your requirements:
<ul>
<li><span class="packt_screen">Default Visibility Timeout</span>: Amazon SQS does not automatically delete messages from the queue, even if they are processed by the consumers. Hence, it is the consumer's duty to delete the respective message from the queue after it has been received and processed.</li>
</ul>
</li>
</ol>
<p style="padding-left: 150px">However, due to the distributed nature of SQS, there is no guarantee that other consumers may not try to read from a copy of the same message. To prevent such scenarios from occurring, SQS sets a small <em>Visibility Timeout</em> period on a message once it is received by a consumer. This prevents other consumers from reading that message until the timeout expires.</p>
<p style="padding-left: 150px">By default, the Visibility Timeout can be set to a minimum of 30 seconds to a maximum of 12 hours. If, by chance, the consumer is not able to process the message in the allocated timeout window, then the message will be delivered to another consumer and the process will continue until the message is not deleted from the queue by a consumer.</p>
<ul>
<li style="list-style-type: none">
<ul>
<li><span class="packt_screen">Message Retention Period</span>: The amount of time Amazon SQS retains a message in case it is not deleted. The accepted values here are a minimum of 1 minute and a maximum of 14 days.</li>
<li><span class="packt_screen">Maximum Message Size</span>: The maximum message size in bytes accepted by Amazon SQS. The maximum limit is 256 KB.</li>
<li><span class="packt_screen">Delivery Delay</span>: Amazon SQS allows you to temporarily delay the delivery of new messages in a queue for a specified amount of seconds. This is achieved by placing the new messages in a <span class="packt_screen">Delay queue</span> which is completely managed by AWS itself. Although it seems similar to the concept of Visibility Timeouts, a delay queue hides a message when it is first added to the queue, unlike the latter where the message is hidden when it is picked up by a consumer. The accepted values here are between 0 seconds and 15 minutes:</li>
</ul>
</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img height="272" width="743" src="Images/2d065b21-0899-4674-8f26-45c3deaf9c82.png"/></div>
<ul>
<li style="list-style-type: none">
<ul>
<li><span class="packt_screen">Receive Message Wait Time</span>: Amazon SQS periodically queries a small subset of the servers to determine if any new messages are available for consumption. This method is called <strong>short polling</strong> and is generally enabled by default when the <span class="packt_screen">Receive Message Wait Time</span> is set to <kbd>0</kbd>. This method, however, results in a lot of empty responses as well, as sometimes messages just may not be present in the queue for consumption. In that case, SQS also provides a concept of <strong>long polling</strong>, whereby Amazon SQS waits until a message is available in the queue before sending a response. This drastically reduces the number of empty responses and is helpful in reducing the overall running costs of your system. To enable long polling, simply change the value of <span class="packt_screen">Receive Message Wait Time</span> to a value between 0 and 20 seconds.</li>
</ul>
</li>
</ul>
<p>With these basic settings configured, you can now go ahead and create your very own queue. Note, however, that there are a few additional settings that you can configure, such as a <strong>dead letter queue</strong> and a <strong>server-side encryption</strong>. However, we will park these out for the time being. Select <span class="packt_screen">Create Queue</span> once done.</p>
<p>With the new queue created, you can now start using it by simply copying the queue's URL (<kbd>https://sqs.us-east-1.amazonaws.com/&lt;ACCOUNT_ID&gt;/&lt;QUEUE_NAME&gt;</kbd>) and providing the same to your applications or consumers to consume from:</p>
<div class="CDPAlignCenter CDPAlign"><img height="259" width="849" src="Images/199544a4-05a7-4e81-a907-c7513676c523.png"/></div>
<p>You can also test the functionality of your queue by sending a test message to it using the <span class="packt_screen">SQS</span> dashboard itself. Select the newly-created queue from the <span class="packt_screen">SQS</span> dashboard, and from the <span class="packt_screen">Queue Actions</span> drop-down menu select the <span class="packt_screen">Send a Message</span> option.</p>
<p>This will bring up the <span class="packt_screen">Send a Message</span> dialog box, as shown in the following screenshot. Next, type in a test message in the <span class="packt_screen">Message Body</span> section and click on <span class="packt_screen">Send Message</span> to complete the process:</p>
<div class="CDPAlignCenter CDPAlign"><img height="296" width="656" src="Images/68d86778-b486-446b-b12c-50068c08d23c.png"/></div>
<p>You can optionally also change the delivery delay of this individual message by enabling the <span class="packt_screen">Delay delivery of this message by</span> option and providing a value between 0 and 15 minutes.</p>
<p>With the message sent, you will be notified of the message's <em>identifier</em> along with an <em>MD5 checksum</em> of the body. Click on <span class="packt_screen">Close</span> to close the <span class="packt_screen">Send a Message</span> dialog box. With this, the status of the <span class="packt_screen">Messages Available</span> column should change to <span class="packt_screen">1</span> as the new message is now waiting to be read or consumed. To read the message from the <span class="packt_screen">SQS</span> dashboard, once again select the <span class="packt_screen">Queue Actions</span> drop-down menu and select the <span class="packt_screen">View/Delete Messages</span> option.</p>
<p>This brings up the <span class="packt_screen">View/Delete Messages</span> dialog box, as shown in the following screenshot. Here, the dialog will poll the queue once every 2 seconds until you have specified the polling to run using the <span class="packt_screen">Poll queue for</span> option. You can also change the maximum number of messages viewed by modifying the <span class="packt_screen">View up to</span> field. Once done, select the <span class="packt_screen">Start Polling for Messages</span> option to get things underway:</p>
<div class="CDPAlignCenter CDPAlign"><img height="321" width="1014" src="Images/3eda1805-0997-4578-81c5-2e7b4f9b915c.png"/></div>
<p>With the polling started, you should see your test message in the display area, shortly. You can also verify the validity of the message by selecting the <span class="packt_screen">More Details</span> option adjoining the message and verifying the MD5 checksum from the earlier recorded one.</p>
<p>Once completed, select the message and click on the <span class="packt_screen">Delete Messages</span> option to remove the message from the queue. Remember, this is a permanent action and it cannot be undone. With the message deleted, your queue should once again show zero messages in flight or available.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a FIFO queue using the AWS CLI</h1>
                </header>
            
            <article>
                
<p>Working with the AWS Management Console is easy enough, but the AWS CLI makes things even simpler! In this section, we will look at a few simple AWS CLI commands that you can use to create and work on your first FIFO queue:</p>
<ol>
<li>To get started, we require a server or instance with the latest version of the AWS CLI installed and configured. If you don't already have this working, you might want to have a quick look at the detailed steps provided at <a href="https://docs.aws.amazon.com/cli/latest/userguide/installing.html">https://docs.aws.amazon.com/cli/latest/userguide/installing.html</a>.<a href="https://docs.aws.amazon.com/cli/latest/userguide/installing.html"/></li>
<li>With the AWS CLI installed and prepped, you can now use the following command to create your first FIFO queue. First, create a simple JSON file that will store the necessary list of attributes that we wish to pass to our new FIFO queue:</li>
</ol>
<pre style="padding-left: 60px"><strong># vi fifo-queue.json 
#### PASTE THE FOLLOWING CONTENTS ##### 
{"VisibilityTimeout" : "30", 
"MaximumMessageSize" : "262144", 
"MessageRetentionPeriod" : "345600", 
"DelaySeconds" : "10", 
"ReceiveMessageWaitTimeSeconds" : "0", 
"FifoQueue" : "true", 
"ContentBasedDeduplication" : "true" 
}</strong> </pre>
<p style="padding-left: 90px">Here, most of the values are probably known to you already, such as the <kbd>VisibilityTimeout</kbd>, the <kbd>MaximumMessageSize</kbd>, <kbd>DelaySeconds</kbd>, and so on. The two new attributes listed here specifically for the FIFO queue are:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li><kbd>FifoQueue</kbd>: Used to designate a queue as a FIFO queue. Note that you cannot change an existing standard queue to a FIFO queue. You will have to create a new FIFO queue altogether. Additionally, when you set this attribute for your queue, you must also provide the <kbd>MessageGroupId</kbd> for your messages explicitly.</li>
<li><kbd>ContentBasedDeduplication</kbd>: It enables each message to be processed exactly one time from the queue. Once <kbd>ContentBasedDeduplication</kbd> is enabled, messages with identical content sent within the deduplication interval are treated as duplicates and only one copy of the message is actually delivered.</li>
</ul>
</li>
</ul>
<ol start="3">
<li>Once the JSON file is created, run the following command to create your FIFO queue:</li>
</ol>
<pre style="padding-left: 60px"><strong># aws sqs create-queue --queue-name myQueue.fifo
--attributes file://fifo-queue.json</strong> </pre>
<p>You should receive the new FIFO queues endpoint URL in the output, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="126" width="827" src="Images/4c6a8f93-0439-4e1f-86af-cf23ca7a77d4.png"/></div>
<ol start="4">
<li>With the queue created, you can additionally use the CLI to pass messages to the queue as well. This is also accomplished by using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong># aws sqs send-message  
--queue-url https://queue.amazonaws.com/012345678910/myQueue.fifo  
--message-body "Well this is far easier than I expected."  
--message-group-id "R@nD0M"</strong> </pre>
<p style="padding-left: 90px">The <kbd>send-message</kbd> command accepts the queue URL as one of the input parameters, along with the actual message that has to be sent. The message can be raw, JSON, or XML formatted. In addition to this, the <kbd>send-message</kbd> command also uses the <kbd>--message-group-id</kbd> parameter that essentially tags the message to belong to a specific message group. Messages that belong to the same message group are processed in a FIFO manner:</p>
<div class="CDPAlignCenter CDPAlign"><img height="214" width="789" src="Images/7722207c-e8b1-4a19-9a26-b46e9b381cd7.png"/></div>
<div style="padding-left: 60px" class="packt_infobox"><span>The </span><kbd>--message-id-group</kbd><span> parameter is mandatory when working with FIFO queues.</span></div>
<ol start="5">
<li>With the message now sent to the queue, you can use the AWS CLI to receive the message as well. Use the following command to fetch the messages from your FIFO queue:</li>
</ol>
<pre style="padding-left: 60px"><strong># aws sqs receive-message  
--queue-url https://queue.amazonaws.com/012345678910/myQueue.fifo</strong> </pre>
<p>You can also additionally use the <kbd>--max-number-of-messages</kbd> attribute to list up to 10 messages that are currently available in the queue. Here is a snippet of the output that you may get with the previous command:</p>
<pre>{ 
    "Messages": [ 
        { 
            "Body": "Well this is far easier than I expected.", 
            "ReceiptHandle": "AQnmzJjGNrI9cl7ZyZ2NyVDDDy==", 
            "MD5OfBody": "d733b7da2656ffc18d99bea3613e24d7", 
            "MessageId": "a075bd88-4942-416d-b632-0258ac8" 
        } 
    ] 
} </pre>
<p>You can similarly use the AWS CLI to list the available queues in your environment, modify their parameters, push and poll for new messages, delete messages, and much more! Remember, the messages will persist in the queue unless you manually delete them or the validity of the queue's <kbd>MessageRetentionPeriod</kbd> has expired.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Integrating Amazon SNS and Amazon SQS</h1>
                </header>
            
            <article>
                
<p>One of the key features of Amazon SQS is that it can easily be integrated with other AWS services, such as Amazon SNS. Why would I need something like that? To begin with, let us quickly recap the things we have learned so far about both SNS and SQS:</p>
<table class="MsoTableGrid">
<tbody>
<tr>
<td>
<p><strong>Amazon SNS</strong></p>
</td>
<td>
<p><strong>Amazon SQS</strong></p>
</td>
</tr>
<tr>
<td>
<p>Leverages the push mechanism</p>
</td>
<td>
<p>Leverages the polling mechanism</p>
</td>
</tr>
<tr>
<td>
<p>Amazon SNS messages can push messages to mobile devices or other subscribers directly</p>
</td>
<td>
<p>Amazon SQS needs a worker to poll the messages</p>
</td>
</tr>
<tr>
<td>
<p>Persistence of messages is not supported</p>
</td>
<td>
<p>Amazon SQS supports message persistence which can come in really handy if you can't reach your consumers due to a network failure</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>From the table, it is easy to see that both the services offer their own pros and cons when it comes to working with them. However, when we join the two services, you can actually leverage them to design and build massively scalable yet decoupled applications. One common architectural pattern that you can leverage by combining both SNS and SQS is called the <strong>fan out pattern</strong>.</p>
<p>In this pattern, a single message published to a particular SNS topic can be distributed to a number of SQS queues in parallel. Thus, you can build highly-decoupled applications that take advantage of parallel and asynchronous processing. Consider a simple example to demonstrate this pattern. A user uploads an image to his S3 bucket, which triggers an SNS notification to be sent to a particular SNS topic. This topic can be subscribed by a number of SQS queues, each running a completely independent process from the other. For example, one queue can be used to process the image's metadata while the other can be used to resize the image to a thumbnail, and so on. In this pattern, the queues can work independently of each other without even having to worry about whether or not the other completed its processing or not. Here is a representational figure of this pattern:</p>
<div class="CDPAlignCenter CDPAlign"><img height="682" width="1355" src="Images/1dd28266-9131-4304-ab7e-7df08ab1fc94.png"/></div>
<ol>
<li>To integrate both the SNS and SQS services, you will first be required to create a simple SNS topic of your own. Go ahead and create a new SNS topic using the AWS Management Console, as performed earlier in this chapter.</li>
<li>Once the topic is ready, the next step involves the creation of an associated subscription. To do so, from the SNS dashboard, select the <span class="packt_screen">Subscriptions</span> option from the navigation pane and click on <span class="packt_screen">Create subscription</span> to get started.</li>
</ol>
<ol start="3">
<li>In the <span class="packt_screen">Create subscription</span> dialog box, copy and paste the newly created topic's ARN in the <span class="packt_screen">Topic ARN</span> field, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="247" width="719" src="Images/668d026c-465c-40a1-a6cf-9897b35a6038.png"/></div>
<ol start="4">
<li>Once the <span class="packt_screen">Topic ARN</span> is pasted, select the <span class="packt_screen">Amazon SQS</span> option from the <span class="packt_screen">Protocol</span> drop-down list, followed by pasting a queue's ARN in the <span class="packt_screen">Endpoint</span> field. In this case, I'm using the standard queue's endpoint that we created a while back in this chapter.</li>
<li>With the required fields filled out, select <span class="packt_screen">Create subscription</span> to complete the process.</li>
<li>Next, from the SQS dashboard, select the queue that you have identified for this integration and, from the <span class="packt_screen">Permissions</span> tab, select <span class="packt_screen">Add a Permission</span> to allow the SNS service to send messages to the queue. To do so, provide the following set of permissions:
<ul>
<li><span class="packt_screen">Effect</span>: <span class="packt_screen">Allow</span></li>
<li><span class="packt_screen">Principal</span>: <span class="packt_screen">Everybody</span></li>
<li><span class="packt_screen">Actions</span>: <span class="packt_screen">SendMessage</span></li>
</ul>
</li>
</ol>
<ol start="7">
<li>Once done, click on <span class="packt_screen">Add Permission</span> to grant the SNS service the required set of permissions.</li>
<li>We are now ready to test the integration! To do so, simply fire a sample message using the <span class="packt_screen">Publish to Topic</span> option from the SNS dashboard. Once the message is successfully sent, cross over to the SQS dashboard and poll the queue using the <span class="packt_screen">View/Delete Messages</span> option from under the <span class="packt_screen">Queue Actions</span> drop-down list.</li>
</ol>
<p class="mce-root">Here is a snippet of the <span class="packt_screen">Message Body</span> obtained after long polling the queue:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/520433e2-0bb8-4b01-a086-64f1b96777df.png" width="592" height="206"/></div>
<p>Similarly, you can use such a fan out pattern to design and build your very own highly scalable and decoupled cloud-ready applications.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Planning your next steps</h1>
                </header>
            
            <article>
                
<p>Well, that was really quite a lot to learn and try out, but we are not done yet! There are still a few things that you ought to try on your own with SNS, as well as with SQS. First up, Amazon SNS mobile push notifications.</p>
<p>We have already touched upon the fact that Amazon SNS can be used to send notifications to a variety of subscribers, including HTTP, HTTPS endpoints, Amazon SQS, and AWS Lambda, but one other key feature recently added is SNS' ability to push notifications directly to your applications on mobile devices. This is called <strong>SNS mobile push notifications</strong> and, as of now, SNS supports the following push notification services:</p>
<ul>
<li><strong>Amazon Device Messaging</strong> (<strong>ADM</strong>)</li>
<li><strong>Apple Push Notification Service</strong> (<strong>APNS</strong>) for both iOS and macOS</li>
<li><strong>Baidu Cloud Push</strong> (<strong>Baidu</strong>)</li>
<li><strong>Google Cloud Messaging</strong> (<strong>GCM</strong>) for Android </li>
<li><strong>Microsoft Push Notification Service</strong> (<strong>MPNS</strong>) for Windows Phone</li>
<li><strong>Windows Push Notification Services</strong> or <strong>Windows Notification Service</strong> (<strong>WNS</strong>)</li>
</ul>
<p>It's pretty easy and straightforward to get started with mobile push notifications. All you need is a set of credentials for connecting to one of the supported push notification services, a device token or registration ID for the mobile application and device itself, and an Amazon SNS configured to send push notification messages to the mobile endpoints.</p>
<div class="packt_infobox">You can read more about SNS <span>mobile push notification</span> services at <a href="https://docs.aws.amazon.com/sns/latest/dg/SNSMobilePush.html">https://docs.aws.amazon.com/sns/latest/dg/SNSMobilePush.html</a>.</div>
<p>The other important feature worth trying out is the configuration of server-side encryption for your Amazon SQS queue. You can leverage SSE to encrypt and protect data stored in your queue, however, this feature is only available in the US East (N. Virginia), US East (Ohio), and US West (Oregon) regions at present.</p>
<p>Encrypting the queue can be done at the time of the queue's creation, as well as after the queue has been created. Old messages present in the queue, however, are not encrypted if the SSE is switched on in an existing queue.</p>
<p>You can configure SSE for an existing queue simply by selecting it from the <span class="packt_screen">SQS</span> dashboard and selecting the <span class="packt_screen">Configure Queue</span> option present in the <span class="packt_screen">Queue Actions</span> drop-down menu. Here, check the <span class="packt_screen">Use SSE</span> checkbox to enable the server-side encryption on your queue. At this time, you will be prompted to select a <strong>customer master key</strong> (<strong>CMK</strong>) ID which you can leave to the default value if you do not have an CMK of your own. Once done, set a duration for the <span class="packt_screen">Data key reuse period</span> of between 1 minute and 24 hours. Click on <span class="packt_screen">Save changes</span> to apply the recent modifications to the queue.</p>
<p>You can read more about SSE and how to enable it on a new queue, at <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-create-queue-sse.html">https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-create-queue-sse.html</a>.<a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-create-queue-sse.html"/></p>
<p>Last, but not the least, I also recommend that you try out the <em>dead letter queue</em> feature provided by Amazon SQS. Dead letter queues are nothing more than queues that you create for storing messages that could not be processed by your application's main processing queue. This comes in really handy when you need to debug issues in your application or the messaging system. However, it is very important to note that the dead letter queue of a standard queue is always a standard queue, and the same applies for a FIFO-based queue as well.</p>
<p>You can configure any queue within your account to be a dead letter queue for another queue by simply configuring the <span class="packt_screen">Redrive Policy</span> of your application's main queue. To know more about dead letter queues and how they work, check out <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-dead-letter-queues.html">https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-dead-letter-queues.html</a>.<a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-dead-letter-queues.html"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Well, this has been a really insightful chapter indeed. Before we move on to the next chapter, here's a quick look at the things we have learned so far!</p>
<p>First up, we started with a quick look at the various messaging services that are provided by AWS. Next, we deep dived into the amazing world of Amazon SNS, created our very first topic, and subscribed to both email and phone subscriptions. We also looked at how to configure and leverage SNS' text messaging service.</p>
<p>Once we had the basics of SNS covered, we moved on to the next messaging service, SQS, and learned a bit about its concepts and terminologies as well. We created our first queues using both the AWS Management Console and the AWS CLI, and finally we looked at a really useful integration of the two services that you can use to design and build scalable and decoupled cloud applications. We finally topped it all off with a handy next steps guide that you ought to try out in your free time!</p>
<p>In the next chapter, we will be learning and exploring two really awesome analytics services, in the form of Amazon Elastic MapReduce and Amazon Redshift, so stay tuned!</p>


            </article>

            
        </section>
    </div>



  </body></html>