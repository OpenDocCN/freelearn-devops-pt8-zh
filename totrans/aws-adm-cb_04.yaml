- en: Using AWS Compute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a key pair
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching an instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securely accessing private instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto scaling an application server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating machine images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating security groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a load balancer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Elastic Cloud Compute** (**EC2**) is by far the most utilized and complex
    service in the AWS catalogue. More than *just virtual machines*, EC2 provides
    a framework of sub-services to help you secure and manage your instances elastically.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a key pair
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A key pair is used to access your instances via SSH. This is the quickest and
    easiest way to access your instances.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To perform this recipe, you must have your AWS CLI tool configured correctly.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the key pair, and save it to disk:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the permissions on the created file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This call requests a new private key from EC2\. The response is then parsed
    using a JMESPath query, and the private key (in the `KeyMaterial` property) is
    saved to a new key file with the `.pem` extension.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we change the permissions on the key file so that it cannot be read
    by other users—this is required before SSH will allow you to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Launching an instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There will be scenarios—usually when testing and developing your infrastructure
    code—when you need quick access to an instance. Creating it via the AWS CLI is
    the quickest and most consistent way to create one-off instances.
  prefs: []
  type: TYPE_NORMAL
- en: There are other recipes in the book that will require a running instance. This
    recipe will get you started.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, you must have an existing key pair.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are launching an instance of AWS Linux using an AMI ID in
    the `us-east-1` region. If you are working in a different region, you will need
    to update your `image-id` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: You must have configured your AWS CLI tool with working credentials.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the following AWS CLI command, using your own key-pair name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While you can create an instance via the AWS web console, it involves many distracting
    options. When developing and testing, the CLI tool is the best way to provision
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: While the `key-name` argument is optional, you will not be able to connect to
    your instance unless you have pre-configured some other way of logging in.
  prefs: []
  type: TYPE_NORMAL
- en: The `t2.micro` instance type used in this recipe is included in the AWS free
    tier. You can run one micro instance per month for free during the first 12 months
    of your usage. See [https://aws.amazon.com/free](https://aws.amazon.com/free)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: As no VPC or security groups are specified, the instance will be launched in
    your account's default VPC and security group. The default security group allows
    access from anywhere, on all ports, and so is not suitable for long-lived instances.
    You can modify an instance's security groups after it is launched, without stopping
    it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have created your own AMI, then you can change the `image-id` argument
    to quickly launch your specific AMI.
  prefs: []
  type: TYPE_NORMAL
- en: You may also want to take note of the `InstanceId` value in the response from
    the API, as you may need it for future commands.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a key pair* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating machine images* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ideally, you will have defined all your storage requirements up-front as code
    using a service such as CloudFormation. However, sometimes that is not possible
    due to application restrictions or changing requirements.
  prefs: []
  type: TYPE_NORMAL
- en: You can easily add additional storage to your instances while they are running
    by attaching a new volume.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A running instance's ID. It will start with `i-` followed by alphanumeric characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AZ the instance is running in. This looks like the region name with a letter
    after it; for example, `us-east-1a`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we are using an AWS Linux instance. If you are using a different
    operating system, the steps to mount the volume will be different. We will be
    running an instance in the AZ `us-east-1a`.
  prefs: []
  type: TYPE_NORMAL
- en: You must have configured your AWS CLI tool with working credentials.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a volume:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Take note of the returned `VolumeId` in the response. It will start with `vol-`
    followed by alphanumeric characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Attach the volume to the instance, using the volume ID noted in the last step
    and the instance ID you started with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'On the instance itself, mount the volume device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we start by creating a volume. Volumes are created from snapshots.
    If you do not specify a snapshot ID it uses a blank snapshot, and you get a blank
    volume.
  prefs: []
  type: TYPE_NORMAL
- en: While volumes are hosted redundantly, they are only hosted in a single AZ, so
    must be provisioned in the same AZ the instance is running in.
  prefs: []
  type: TYPE_NORMAL
- en: The `create-volume` command returns a response that includes the newly created
    volume's `VolumeId`. We then use this ID in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: It can sometimes take a few seconds for a volume to become available. If you
    are scripting these commands, use the `aws ec2 wait` command to wait for the volume
    to become available.
  prefs: []
  type: TYPE_NORMAL
- en: In step 3, we attach a volume to the instance. When attaching to an instance,
    you must specify the name of the device that it will be presented to the operating
    system as. Unfortunately, this does not guarantee what the device will appear
    as. In the case of AWS Linux, `/dev/sdf` becomes `/dev/xvdf`.
  prefs: []
  type: TYPE_NORMAL
- en: Device naming is kernel-specific, so if you are using something other than AWS
    Linux, the device name may be different. See [http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/device_naming.html](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/device_naming.html)
    for full details.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Launching an instance* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Working with network storage* recipe in [Chapter 3](3061e8a1-9092-4f75-931a-8c4da66160b7.xhtml),
    *Storage and Content Delivery*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securely accessing private instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any instance or resource living in a private subnet in your VPC will be inaccessible
    from the Internet. This makes good sense from a security perspective because it
    gives your instances a higher level of protection.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if they can't be accessed from the Internet, then they're not going
    to be easy to administer.
  prefs: []
  type: TYPE_NORMAL
- en: 'One common pattern is to use a VPN server as a single, highly controlled, entry
    point to your private network. This is what we''re going to show you in this recipe,
    as pictured in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06236_04_01.png)'
  prefs: []
  type: TYPE_IMG
- en: Accessing private instances securely
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to use OpenVPN for this example. They provide a free (for up to
    two users) AMI in the AWS marketplace, which has OpenVPN already installed and
    configured. You'll need to accept the terms and conditions for using this AMI.
    You can do so by visiting the AMI's marketplace page at [https://aws.amazon.com/marketplace/pp/B00MI40CAE/](https://aws.amazon.com/marketplace/pp/B00MI40CAE/).
  prefs: []
  type: TYPE_NORMAL
- en: You need to decide on a password, which will be your *temporary* admin password.
    We'll feed this password into a CloudFormation template and then change it after
    we create our stack.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the default VPC for this example.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new CloudFormation template and add the following `Mappings`. This
    is a list of all the latest `OpenVPN` AMIs in each region. We''re adding these
    to maximize region portability for our template—you can omit the regions you have
    no intention of using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to define some `Parameters`. Firstly we''ll need to know which
    VPC and subnet to deploy our VPN instance to. Note that you need to specify a
    *public* subnet here, otherwise you won''t be able to access your OpenVPN server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to define `InstanceType` and `KeyName`. These are the EC2 instance
    class and SSH key pair to use to launch our OpenVPN server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We need a parameter for `AdminPassword`. This is the temporary password which
    will be given to the `openvpn` user (administrator) when the server starts up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The last parameter is the CIDR block, which we wish to allow to connect to
    our VPN server. You may wish to lock this down to the public IP range of your
    corporate network, for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The first `Resource` we need to define is the security group our OpenVPN server
    will live in. You''ll also use this security group to allow access to other resources
    in your network. Add it to your template as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now define the actual OpenVPN instance itself. You''ll notice that we
    are explicitly configuring the network interface. This is required, because we
    want to declare that this instance must get a public IP address (otherwise you
    won''t be able to access it). In the `UserData`, we declare some variables that
    the OpenVPN software will pick up when it starts so that it can configure itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add some helpful `Outputs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Go ahead and launch this stack in the CloudFormation web console, or via the
    CLI, with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once your stack is created, you''ll want to change the password for the `openvpn`
    user (administrator). Go to the admin control panel and do this now: `https://<ip-or-hostname-of-vpn-server>/admin`.
    If your VPN server is operating as expected you''ll be greeted with a status page
    after logging in, as pictured in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06236_04_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'While you''re there, you should create a non-administrator user account. This
    will be the account you''ll use to connect to the VPN. Add this account on the
    User Permissions page as pictured in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06236_04_03-1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Under Server Network Settings, in the Hostname or IP address field, enter the
    hostname or IP address of the server. This step is important, and when you download
    your OpenVPN config file from the server (next step), it will make your life much
    easier if it has the correct hostname or IP address in it. The next screenshot
    shows what you can expect to see on the Server Network Settings page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06236_04_04.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You should now be able to connect to your VPN server. Go to the user login
    page and log in with the credentials you gave to the previously mentioned non-administrator
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://<ip-or-hostname-of-vpn-server>/`'
  prefs: []
  type: TYPE_NORMAL
- en: After logging in, you will have the option to download the OpenVPN client with
    configuration which is specific to your account. Alternatively, if you already
    have a VPN client installed, you can just download the configuration on its own.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a couple of important points you''ll need to keep in mind now that
    you are up and running with an OpenVPN server:'
  prefs: []
  type: TYPE_NORMAL
- en: If you need to SSH to the instance, you must connect with the username `openvpnas`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To access your other instances, you'll need to allow connections from the VPN
    security group created in this recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto scaling an application server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Auto scaling** is a fundamental component of compute in the cloud. It provides
    not only the ability to scale up and down in response to application load, but
    also redundancy, by ensuring that capacity is always available. Even in the unlikely
    event of an AZ outage, the auto scaling group will ensure that instances are available
    to run your application.'
  prefs: []
  type: TYPE_NORMAL
- en: Auto scaling also allows you to pay for only the EC2 capacity you need, because
    underutilized servers can be automatically de-provisioned.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You must supply two or more subnet IDs for this recipe to work.
  prefs: []
  type: TYPE_NORMAL
- en: The following example uses an AWS Linux AMI in the `us-east-1` region. Update
    the parameters as required if you are working in a different region.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start by defining the template version and description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `Parameters` section with the required parameters that will be used later
    in the template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Still under the `Parameters` section, add the optional instance configuration
    parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Still under the `Parameters` section, add the optional auto scaling group-configuration
    parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `Resources` section, and define the auto scaling group resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Still under the `Resources` section, define the launch configuration used by
    the auto scaling group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, define two scaling policy resources—one to scale up and the other to
    scale down:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Define an alarm that will alert when the CPU goes *over* the `ThresholdCPUHigh`
    parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, define an alarm that will alert when the CPU goes *under* the `ThresholdCPULow`
    parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Save the template with the filename `04-auto-scaling-an-application-server.yaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Launch the template with the following AWS CLI command, supplying your subnet
    IDs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This example defines an auto scaling group and the dependent resources. These
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A launch configuration to use when launching new instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two scaling policies, one to scale the number of instances up, and an inverse
    policy to scale back down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An alarm to alert when the CPU crosses a certain threshold, for a certain number
    of minutes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The auto scaling group and launch-configuration resource objects in this example
    use mostly default values. You will need to specify your own `SecurityGroups`
    and a `KeyName` parameter in the `LaunchConfiguration` resource configuration
    if you want to be able to connect to the instances (for example, via SSH).
  prefs: []
  type: TYPE_NORMAL
- en: AWS will automatically take care of spreading your instances evenly over the
    subnets you have configured, so make sure they are in different AZs! When scaling
    down, the oldest instances will be removed before the newer ones.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The scaling policies detail how many instances to create or delete when they
    are triggered. It also defines a `Cooldown` value, which helps prevent *flapping*
    servers—when servers are created and deleted before they have finished starting
    and are useful.
  prefs: []
  type: TYPE_NORMAL
- en: While the scaling policies in this example use equal values, you might want
    to change that so your application can scale *up* quickly, and scale *down* slowly
    for the best user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Alarms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `CPUHighAlarm` parameter will alert when the average CPU utilization goes
    over the value set in the `ThresholdCPUHigh` parameter. This alert will be sent
    to the `ScaleUpPolicy` resource provisioning more instances, which will bring
    the average CPU utilization down across the whole auto scaling group. As the name
    suggests, the `CPULowAlarm` parameter does the reverse when the average CPU utilization
    goes under the `ThresholdCPULow` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: This means that new instances will be launched until the CPU utilization across
    the auto scaling group stabilizes somewhere between 40-60% (based on the default
    parameter values), or the `MaxSize` of instances is reached.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to leave a gap between the high and low alarms thresholds.
    If they are too close together, the alarms will not stabilize and you will see
    instances created and destroyed almost continually.
  prefs: []
  type: TYPE_NORMAL
- en: The minimum charge for an instance is *one hour*, so creating and destroying
    them multiple times in one hour may result in higher than expected charges.
  prefs: []
  type: TYPE_NORMAL
- en: Creating machine images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating or *baking* your own **Amazon Machine Images** (**AMIs**) is a key
    part of systems administration in AWS. Having a pre-baked image helps you provision
    your servers faster, easier, and more consistently than configuring it by hand.
  prefs: []
  type: TYPE_NORMAL
- en: Packer is the de facto standard tool that helps you make your own AMIs. By automating
    the launch, configuration, and clean-up of your instances, it makes sure you get
    a repeatable image every time.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create an image with the Apache web server pre-installed
    and configured. While this is a simple example, it is also a very common use-case.
  prefs: []
  type: TYPE_NORMAL
- en: By baking-in your web server, you can scale up your web serving layer to dynamically
    match the demands on your websites. Having the software already installed and
    configured means you get the fastest and most reliable start-up possible.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, you must have the Packer tool available on your system. Download
    and install Packer from the project's website [https://www.packer.io/downloads.html](https://www.packer.io/downloads.html).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new Packer template file, and start by defining an `amazon-ebs` builder
    in the `builders` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The entire template file must be a valid JSON object. Remember to enclose the
    sections in curly braces: `{ ... }`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `provisioners` section, and include the following snippet to install
    and activate Apache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Save the file with a specific name, such as `04-creating-machine-images.json`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Validate the configuration file you''ve created with the following `packer
    validate` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When valid, build the AMI with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait until the process is complete. While it is running, you will see an output
    similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06236_04_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Take note of the AMI ID returned by Packer so that you can use it when launching
    instances in the future:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06236_04_06.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While this is a very simple recipe, there is a lot going on behind the scenes.
    This is why we recommend you use Packer to create your machine images.
  prefs: []
  type: TYPE_NORMAL
- en: Template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `builders` section of the template, we define our build details.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are using the most common type of AMI builder: `amazon-ebs`. There are other
    types of AWS builders, for instance, storage-backed instance types.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define the type of instance to use when baking.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that you can often decrease the time it takes to bake your instance
    by using a larger instance size. Remember that the minimum price paid for an instance
    is one hour of billable time.
  prefs: []
  type: TYPE_NORMAL
- en: The `source_ami` property in this recipe is an AWS Linux AMI ID in the `region`
    we have specified. The `ssh_username` allows you to set the username used to connect
    and run `provisioners` on the instance. This will be determined by your operating
    system, which in our case is `ec2-user`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `ami_name` field includes the built-in Packer variable `{{timestamp}}`.
    This ensures the AMI you create will always have a unique name.
  prefs: []
  type: TYPE_NORMAL
- en: Validate the template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `packer validate` command is a quick way to ensure your template is free
    of syntax errors before you launch any instances.
  prefs: []
  type: TYPE_NORMAL
- en: Build the AMI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you have created and validated your template, the `packer build` command
    does the following for you:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a one-time key pair for SSH access to the instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a dedicated security group to control access to the instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launches an instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waits until SSH is ready to receive connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runs the provisioner steps on the instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stops the instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generates an AMI from the stopped instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminates the instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the Packer documentation for more provisioners and functionality at [https://www.packer.io/docs/](https://www.packer.io/docs/).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Packer makes the administration of images much easier on AWS, there are
    still a few things to watch out for.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Obviously, with so many steps being automated for you, there are many things
    that can potentially go wrong. Packer gives you a few different ways to debug
    issues with your builds.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most useful arguments to use with Packer is the `-debug` flag. This
    will force you to manually confirm each step *before* it takes place. Doing this
    makes it easy to work out exactly which step in the command is failing, which
    in turn usually makes it obvious what needs to be changed.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful thing to do is to raise the level of logging output during a
    Packer command. You can do this by setting the `PACKER_LOG` variable to `true`.
    The easiest way to do this is with `PACKER_LOG=1` at the beginning of your Packer
    command line. This will mean you get a lot more information printed to the console
    (for example, SSH logs, AWS API calls, and so on) during the command. You may
    even want to run with this level of logging normally in your builds, for auditing
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Orphaned resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packer does a great job of managing and cleaning up the resource it uses, but
    it can only do that while it is running.
  prefs: []
  type: TYPE_NORMAL
- en: If your Packer job aborts for any reason (most likely network issues) then there
    may be some resources left **orphaned**, or **unmanaged**. It is good practice
    to check for any Packer instances (they will have *Packer* in their name), and
    stop them if there are no active Packer jobs running.
  prefs: []
  type: TYPE_NORMAL
- en: You may also need to clean up any leftover key pairs and security groups, but
    this is less of an issue as there is no cost associated with them (unlike instances).
  prefs: []
  type: TYPE_NORMAL
- en: Deregistering AMIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As it becomes easier to create AMIs, you may find you end up with more than
    you need!
  prefs: []
  type: TYPE_NORMAL
- en: AMIs are made up of EC2 snapshots, which are stored in S3\. There is a cost
    associated with storing snapshots, so you will want to clean them up periodically.
    Given the size of most AMIs (usually a few GBs), it is unlikely to be one of your
    major costs.
  prefs: []
  type: TYPE_NORMAL
- en: An even greater cost is the administrative overhead of managing too many AMIs.
    As your images improve and fixes are applied (especially security fixes), you
    may want to prevent people from using them.
  prefs: []
  type: TYPE_NORMAL
- en: To remove an AMI, you must first *deregister* it, and then remove the underlying
    snapshots.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you do not deregister AMIs that are currently in use. For example,
    an auto scaling group that references a deregistered AMI will fail to launch new
    instances!
  prefs: []
  type: TYPE_NORMAL
- en: You can easily deregister snapshots through the web console or using the AWS
    CLI tool.
  prefs: []
  type: TYPE_NORMAL
- en: Once an AMI is no longer registered, you can remove the associated snapshots.
    Packer automatically adds the AMI ID to the snapshots' description. By searching
    your snapshots for the deregistered AMI ID, you can find which ones need to be
    deleted.
  prefs: []
  type: TYPE_NORMAL
- en: You will not be able to delete snapshots if the AMI has not been deregistered,
    or if the deregistration is still taking place (it can take a few minutes).
  prefs: []
  type: TYPE_NORMAL
- en: Other platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is also worth noting that Packer can build for more platforms that just AWS.
    You can also build images for VMWare, Docker, and many others.
  prefs: []
  type: TYPE_NORMAL
- en: This means you could build almost exactly the same machine image locally (for
    example, using Docker) as you do in AWS. This makes it much more convenient when
    setting up local development environments, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Check the `builders` section of the Packer documentation for details.
  prefs: []
  type: TYPE_NORMAL
- en: Creating security groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS describes security groups as *virtual firewalls*. While this analogy helps
    newcomers to the EC2 platform understand their purpose and function, it's probably
    more accurate to describe them as a *firewall-like* method of authorizing traffic.
    They don't offer all the functionality you'd find in a traditional firewall, but
    this simplification also makes them extremely powerful, particularly when combined
    with Infrastructure as Code and modern SDLC practices.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to go through a basic scenario involving a web server and load balancer.
    We want the load balancer to respond to HTTP requests from everywhere, and we
    want to isolate the web server from everything except the load balancer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we get started there''s a small list of things you''ll need to have
    ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AmiId` This is the ID of an AMI in your region. For this recipe, we''d recommend
    using an AWS Linux AMI because our instance will attempt to run some `yum` commands
    on startup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VPCID`: This is the ID of the VPC you wish to launch the EC2 server into.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SubnetIDs`: These are the subnets which our EC2 instance can launch in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open up your text editor and create a new CloudFormation template. We''re going
    to start by adding a few `Parameters` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at a security group we''ll apply to a public load balancer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Anything which resides in this security group will allow inbound TCP connections
    on port `80` from anywhere (`0.0.0.0/0`). Note that a security group can contain
    more than one rule; we'd almost certainly want to also allow HTTPS (`443`), but
    we've left it out to simplify this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at a security group for a web server sitting behind our load
    balancer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here you can see we are not specifying a source IP range. Instead, we're specifying
    a source security group, which we will accept connections from. In this case,
    we're saying that we want to allow anything from our ELB security group to connect
    to anything in our EC2 instance security group on port `80`.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is the only rule we're specifying, our web server will not accept
    connections from anywhere except our load balancer, to port `80` or otherwise.
    Our web server isn't wide open to the Internet, and it is even isolated from other
    instances in our VPC
  prefs: []
  type: TYPE_NORMAL
- en: Remember that multiple instances can reside in a security group. In a scenario
    where you have multiple web servers attached to this load balancer it would be
    unnecessary, inefficient, and somewhat of an anti-pattern to create a new security
    group for each web server. Given that all web servers attached to this load balancer
    would be serving the same role or function, it makes sense to apply the same security
    group to them.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the power of security groups really comes in. If an EC2 instance
    is serving multiple roles—let's say you have an outbound HTTP proxy server in
    your VPC which you also want to act as an SMTP relay—then you can simply apply
    multiple security groups to it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to add our load balancer. This is probably the most basic load
    balancer configuration you'll come across. The following code will give you a
    load balancer, a listener and a target group containing our EC2 instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The last resource we'll add to our template is an EC2 server. This server will
    install and start `nginx` when it boots.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we're going to add some `Outputs` to the template to make it a little
    more convenient to use our ELB and EC2 instance after the stack is created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and launch this template using the CloudFormation web console or the
    AWS CLI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ll eventually run into circular dependency issues when configuring security
    groups using CloudFormation. Let''s say you want all servers in our `ExampleEC2InstanceSecurityGroup`
    to be able to access each other on port `22` (SSH). In order to achieve this,
    you would need to add this rule as the separate resource type `AWS::EC2::SecurityGroupIngress`.
    This is because a security group can''t refer to itself in CloudFormation when
    it is yet to be created. This is what the extra resource type looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Differences from traditional firewalls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security groups can't be used to explicitly block traffic. Only rules of a permissive
    kind can be added; deny style rules are not supported. Essentially, all inbound
    traffic is denied unless you explicitly allow it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your rules also may not refer to source ports; only destination ports are supported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When security groups are created, they will contain a rule which allows all
    outbound connections. If you remove this rule, new outbound connections will be
    dropped. It's a common pattern to leave this rule in place and filter all your
    traffic using inbound rules only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you do replace the default outbound rule, it's important to note that only
    new outbound connections will be filtered. Any outbound traffic being sent in
    response to an inbound connection will still be allowed. This is because security
    groups are *stateful*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike security groups, network ACLs are not stateful and do support `DENY`
    rules. You can use them as a complementary layer of security inside your VPC,
    especially if you need to control traffic flow between subnets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a load balancer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'AWS offers two kinds of load balancers:'
  prefs: []
  type: TYPE_NORMAL
- en: Classic load balancer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application load balancer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We're going to focus on the application load balancer. It's effectively an upgraded,
    second generation of the ELB service, and it offers a lot more functionality than
    the classic load balancer. HTTP/2 and WebSockets are supported natively, for example.
    The hourly rate also happens to be cheaper.
  prefs: []
  type: TYPE_NORMAL
- en: Application load balancers do not support layer-4 load balancing. For this kind
    of functionality, you'll need to use a classic load balancer.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open up your text editor and create a new CloudFormation template. We''re going
    to require a VPC ID and some subnet IDs as `Parameters`. Add them to your template
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we need to add some `Mappings` of ELB account IDs. These will make it
    easier for us to give the load balancer permission to write logs to an S3 bucket.
    Your mappings should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can find the complete list of ELB account IDs here [http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/enable-access-logs.html#attach-bucket-policy](http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/enable-access-logs.html#attach-bucket-policy).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We can now start adding `Resources` to our template. First we're going to create
    an S3 bucket and bucket policy for storing our load balancer logs. In order to
    make this template portable, we'll omit a bucket name, but for convenience we'll
    include the bucket name in our outputs so that CloudFormation will echo the name
    back to us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to create a security group for our load balancer to reside in.
    This security group will allow inbound connections to port `80` (HTTP). To simplify
    this recipe, we''ll leave out port `443` (HTTPS), but we''ll briefly cover how
    to add this functionality later in this section. Since we''re adding a public
    load balancer, we want to allow connections to it from everywhere (`0.0.0.0/0`).
    This is what our security group looks like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We now need to define a target group. Upon completion of this recipe, you can
    go ahead and register your instances in this group so that HTTP requests will
    be forwarded to it. Alternatively, you can attach the target group to an auto
    scaling group and AWS will take care of the instance registration and de-registration
    for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The target group is where we specify the health checks our load balancer should
    perform against the target instances. This health check is necessary to determine
    if a registered instance should receive traffic. The example provided with this
    recipe includes these health-check parameters with the values all set to their
    defaults. Go ahead and tweak these to suit your needs, or, optionally, remove
    them if the defaults work for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We need to define at least one listener to be added to our load balancer. A
    listener will *listen* for incoming requests to the load balancer on the port
    and protocol we configure for it. Requests matching the port and protocol will
    be forwarded through to our target group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The configuration of our listener is going to be reasonably simple. We're listening
    for HTTP requests on port `80`. We're also setting up a default action for this
    listener, which will forward our requests to the target group we've defined before.
    There is a limit of 10 listeners per load balancer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, AWS only supports one action: forward.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, now that we have all `Resources` we need, we can go ahead and set
    up our load balancer. We''ll need to define at least two subnets for it to live
    in—these are included as `Parameters` in our example template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we're going to add some `Outputs` to our template for convenience. We're
    particularly interested in the name of the S3 bucket we created and the URL of
    the load balancer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, we're applying a logging configuration which points to the S3
    bucket we've created. We're configuring this load balancer to be Internet-facing,
    with an idle timeout of 60 seconds (the default).
  prefs: []
  type: TYPE_NORMAL
- en: All load balancers are Internet-facing by default, so it's not strictly necessary
    to define a `Scheme` in our example; however, it can be handy to include this
    anyway. This is especially the case if your CloudFormation template contains a
    mix of public and private load balancers.
  prefs: []
  type: TYPE_NORMAL
- en: If you specify a logging configuration but the load balancer can't access the
    S3 bucket, your CloudFormation stack will fail to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Private ELBs are not Internet-facing and are available only to resources which
    live inside your VPC.
  prefs: []
  type: TYPE_NORMAL
- en: That's it! You now have a working application load balancer configured to ship
    logs to an S3 bucket.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Load balancers on AWS are highly configurable and there are many options available
    to you. Here are some of the more frequent ELB options you''ll encounter:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTPS/SSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you wish to accept HTTPS requests, you''ll need to configure an additional
    listener. It will look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The listener will need to reference a valid **Amazon Resource Name** (**ARN**)
    for the certificate you wish to use. It's really easy to have AWS Certificate
    Manager create a certificate for you, but it does require validation of the domain
    name you're generating the certificate for. You can, of course, bring your own
    certificate if you wish. You'll need to import it in to AWS Certificate Manager
    before you can use it with your ELB (or CloudFront distribution).
  prefs: []
  type: TYPE_NORMAL
- en: Unless you have specific requirements around ciphers, a good starting approach
    is to not define an SSL Policy and let AWS choose what is currently *best of breed*.
  prefs: []
  type: TYPE_NORMAL
- en: Path-based routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you are comfortable with ELB configuration, you can start to experiment
    with path-based routing. In a nutshell, it provides a way to inspect a request
    and proxy it to different targets based on the path requested.
  prefs: []
  type: TYPE_NORMAL
- en: One common scenario you might encounter is needing to route requests for `/blog`
    to a different set of servers running WordPress, instead of to your main server
    pool, which is running your Ruby on Rails application.
  prefs: []
  type: TYPE_NORMAL
