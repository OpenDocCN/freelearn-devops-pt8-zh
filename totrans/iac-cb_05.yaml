- en: Chapter 5. Provisioning the Last Mile with Cloud-Init
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using cloud-init on AWS, Digital Ocean, or OpenStack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling files using cloud-init
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the server's time zone using cloud-init
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing users, keys, and credentials using cloud-init
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing repositories and packages using cloud-init
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running commands during boot using cloud-init
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring CoreOS using cloud-init
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying Chef client from start to finish using cloud-init
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a remote Docker server using cloud-init
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cloud-init is a cloud instance initialization system, standard across most Linux
    distributions. It's supported by all recent distributions (Ubuntu, Arch, CentOS/Red
    Hat, Fedora, and more), as well as a variant found on CoreOS systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'With cloud-init, a number of actions are taken during the initialization phases
    of booting a cloud instance (new or not): installing packages, copying files or
    SSH keys, deploying Chef, defining repositories, or rebooting (when done).'
  prefs: []
  type: TYPE_NORMAL
- en: The scope of action of cloud-init is really intended for the initialization
    phase; it's not a configuration management tool and is globally not meant to be
    run again afterwards to update configuration, like one would with Ansible or Chef.
    It's only used to obtain an instance properly configured for the next step to
    happen, and to ensure a set of commands are executed in order during boot. In
    other words, Terraform (the tool covered in [Chapter 2](ch02.html "Chapter 2. Provisioning
    IaaS with Terraform"), *Provisioning IaaS with Terraform*, [Chapter 3](ch03.html
    "Chapter 3. Going Further with Terraform"), *Going Further with Terraform*, and
    [Chapter 4](ch04.html "Chapter 4. Automating Complete Infrastructures with Terraform"),
    *Automating Complete Infrastructures with Terraform*) is perfect to define all
    the aspects of the underlying infrastructure, but cloud-init can be an easy and
    awesome solution for handling the first and subsequent boots before letting a
    full-fledged configuration management tool such as Chef or Ansible play its part
    for the rest of the instance life.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cloud-init** is defined as a simple YAML file (cloud-config), sent in the
    **user-data** field of a cloud instance. We''ll see how this works in the coming
    sections.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will present the most useful use cases with cloud-init,
    such as copying files, creating users, managing SSH keys, adding repositories
    and installing packages, running arbitrary commands, bootstrapping a Chef client,
    or managing CoreOS and Docker with it.
  prefs: []
  type: TYPE_NORMAL
- en: Using cloud-init on AWS, Digital Ocean, or OpenStack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As cloud-init is an initialization system for cloud instances, we need to find
    a way to send the cloud-config YAML file to the bootstrapping process. On all
    IaaS providers supporting cloud-init, there's a field where we can paste our file.
    We'll review how cloud-init works on three important IaaS providers—AWS, Digital
    Ocean, and OpenStack.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need an account on Amazon Web Services,
    Digital Ocean, or some OpenStack deployment, or on all of them if you want to
    try them all!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To illustrate cloud-init usage, we''ll create the simplest cloud-config file
    on Ubuntu 16.04 and CentOS 7.2, installing packages such as `htop`, `tcpdump`,
    `docker`, or `nmap` that aren''t usually installed by default on most Linux distributions.
    This is how a very simple cloud-config file looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Using cloud-init on Amazon Web Services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using the AWS Console, when launching your instance, click on **Advanced Details**
    and we''ll be able to paste our sample (and simple) cloud-config YAML file, or
    even simply upload it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using cloud-init on Amazon Web Services](img/B05671_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, the Ubuntu 16.04 instance we just launched will already have
    the `htop` and `tcpdump` system tools installed, along with the Linux distribution''s
    supported version of Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can manually update `cloud-config.yml` of a particular instance by powering
    off the instance, then under the **Actions** menu, navigate to **Instance Settings**
    | **View/Change User Data**. Start the EC2 instance again and the updated configuration
    is applied.
  prefs: []
  type: TYPE_NORMAL
- en: Using cloud-init on Digital Ocean
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The situation is similar on Digital Ocean. When creating a new **droplet**,
    be sure to tick the **User data** checkbox under the **Select additional options**
    section and paste the cloud-config file content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using cloud-init on Digital Ocean](img/B05671_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After a few seconds of boot time and package installation, our customized Ubuntu
    distribution is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Using cloud-init on OpenStack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When creating an instance on OpenStack, using the Horizon dashboard, click
    on the **Post-Creation** tab, and paste the cloud-config YAML content in the text
    box. Alternatively, it is possible to upload the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using cloud-init on OpenStack](img/B05671_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Verify the requested packages were installed, this time on a CentOS 7.2 box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Combining cloud-init and Terraform for any IaaS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous chapters about Terraform, we've in fact already used a `cloud-init`
    file a few times.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Amazon Web Services, using the `aws_instance` resource to launch an EC2
    VM, we use the `user_data` argument to pass the cloud-config file content, and
    in this case, using the `file()` interpolation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent for a Digital Ocean VM is the `user_data` argument as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Handling files using cloud-init
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An early need we all face is to have a file, a license, or a script in place
    right from the beginning of the instance life. Cloud-init proposes different ways
    of sending those files over the new instance. We'll see how to send files using
    plain text and base64 data encodings.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need:'
  prefs: []
  type: TYPE_NORMAL
- en: Access to a cloud-config enabled infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first file we''ll write is a **MOTD** (short for **Message Of The Day**)
    with root read-write permissions, read-only for everyone else. This file will
    have its content declared right from the cloud-config file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This machine, when booted, will have `/etc/motd` in place and display the string
    at login:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way of including file content is to encode it in base64\. Let''s say
    we want to create a file named `/etc/server-id` with the content `abc-123`, with
    permissions `0600`. Begin by obtaining the base64 version of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output we''ll integrate into the `content` field of the cloud-config
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s verify the remote content is what we expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It works! Our file is read/write for the owner only, and the content is `abc-123`.
  prefs: []
  type: TYPE_NORMAL
- en: Another possibility is to compress the file using `gzip`, or even to base64
    encode the resulting compressed gzip file.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the server's time zone using cloud-init
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One very common configuration step on a new instance is setting the time zone.
    This time we'll explicitly set the EDT (New York) time zone for our server (even
    if the server is running in Europe or somewhere else). It is sometimes important
    to have as early as possible a correct date and time set up (for things like registration
    times, delays, and other issues depending on dates and times).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In most setups, I personally prefer to ensure all the systems are set to GMT,
    wherever they are on the planet, GMT or not. This way, it's much easier to debug,
    compare logs or behavior when failures arise, without losing time doing the math
    of the time zones.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need:'
  prefs: []
  type: TYPE_NORMAL
- en: Access to a cloud-config enabled infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To set the server''s time zone automatically to `America/New_York`, use the
    `timezone` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'That is it! Our server is now configured from the beginning to use the correct
    time zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This, in fact, has simply set the `/etc/timezone` file to the correct value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Managing users, keys, and credentials using cloud-init
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's a high probability we won't plan to use the default root account, or
    even the default user account from our distribution (those ubuntu or centos users).
    There's an even higher probability we'll need a Unix account very early in the
    process, even before the proper configuration management tool enters the game.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say our IT security policy wants us to have an `emergency` user account
    in a group named `infosec` for the IT security team with passwordless `sudo` rights
    and the simple `/bin/sh` shell. This account has one authorized public key automatically
    populated. The policy is also to remove the default `ubuntu` account.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need:'
  prefs: []
  type: TYPE_NORMAL
- en: Access to a cloud-config enabled infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a group, we use a directive simply named `groups`, taking a list
    of groups. Any group can have a sublist of users to put in that group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a user, let''s use a directive named `users`, taking a list of users.
    This list of users has a set of keys, such as `groups` the user is a member of,
    `sudo` rights, which `shell` to default to, or an SSH public key to authorize.
    Here''s how it looks for our user `emergency`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once logged in as `emergency` using the private key, let''s verify cloud-init
    did the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We never explicitly asked to remove the default `ubuntu` user account: it''s
    automatic as soon as we create an initial user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we wanted to keep the default user from our Linux distribution,
    we''d just have to add the following `default` user to the `users` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Managing repositories and packages using cloud-init
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unless we need a very specific release of a Linux distribution, it's highly
    probable we'll expect a fully updated system as soon as possible (think security
    patches and other bug fixes). Similarly, we usually expect a set of tools to be
    available in the new system. However, things might change, default tools might
    be removed – better to be safe than sorry. If one of our bootstrap scripts needs
    `wget` or `curl` and `nmap`, let's ensure those are present long before the proper
    configuration management tool starts its job (such as Chef or Puppet). We may
    also want to reboot the server after applying critical initial packages such as
    the kernel, or add a custom package repository.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need:'
  prefs: []
  type: TYPE_NORMAL
- en: Access to a cloud-config enabled infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To upgrade all the packages right after bootstrap, simply set the `package_upgrade`
    directive to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful directive is to reboot the system if required by the package
    manager (common case with kernel updates). It''s often better to reboot as soon
    as possible with the most secure kernel, but proceed with caution according to
    your own environment (you might not want to reboot while another action is taking
    place, maybe a Chef run or similar management software):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure the required packages are installed, use the `packages` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also add a custom APT repository using `apt_sources`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s launch a new instance and verify it''s fully updated, so no updates
    can be applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify our required tools are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Good thing! Now we're sure to always have a fully updated system with the required
    set of tools installed, even our own, right from the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: Running commands during boot using cloud-init
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When bootstrapping a new server or instance, the first boot is often very different
    from all the other boots the instance will experience in its life, and most often
    we want some commands to be executed very early or very late in the boot process.
    For example, let's say our cloud instance is launched with an attached block storage.
    We might want to format this storage space and be sure it's mounted on the host,
    but while we always want the disk to mount, we probably don't want it to be formatted
    at each boot! The `bootcmd` directive is there to handle everything related to
    commands to be executed very early in the boot process, while the `runcmd` directive
    is executed much later in the boot process (and only once).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`bootcmd` will be executed at every boot of the instance.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need:'
  prefs: []
  type: TYPE_NORMAL
- en: Access to a cloud-config enabled infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll launch three commands during boot. The first one is a simple file with
    a dynamic content (the `$INSTANCE_ID` variable made available to us by cloud-init),
    which will always be rewritten, no matter what, at each boot. The second command
    is printing the date in the logs (so we know when the boot process started). The
    final command is the `ext4` formatting of a block device attached on `/dev/xvdb`.
    For the sake of the exercise, we'll also mount the new device under `/srv/www`
    on the host.
  prefs: []
  type: TYPE_NORMAL
- en: 'To launch any command at boot time that will be run as early as possible, every
    time the machine boots, simply add it to the list of the `bootcmd` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If we delete or modify this file, at the next reboot it will be overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, if we want to run a command only once inside the `bootcmd`
    directive, we can use the helper script `cloud-init-per`. You can choose to launch
    the command once per `boot` or once per `instance`. In our case, we want to format
    the `/dev/xvdb` device (so, unless we want to format our drive each time we reboot,
    we probably want this to happen only once on this instance. So let''s add the
    `instance` argument to the `cloud-init-per` helper script):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s use the `mounts` directive to mount the now formatted `/dev/xvdb`
    on the `/srv/www` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'After boot, let''s verify the block device is mounted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also test the existence of the file we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Try to delete this file and reboot the server: the file will be there again.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at how different the `runcmd` directive is. Let''s
    add a very similar command to the date output in the `bootcmd` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Start a new instance, and observe the difference in timestamps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `runcmd` directive started 12 seconds later than the `bootcmd` directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now reboot the instance, and observe that `runcmd` didn''t run again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now we know what directive to use in each case.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring CoreOS using cloud-init
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CoreOS supports its own version of cloud-init, with added support for the CoreOS
    environment, and without everything else incompatible with its environment, so
    we can boot a fully configured system and cluster.
  prefs: []
  type: TYPE_NORMAL
- en: We'll take a look at the CoreOS specificities, as we can refer to earlier tips
    on how to manage users, files, authorized SSH keys, and other standard cloud-init
    directives. At the end of this part, you'll know how to configure the etcd key
    value store, the fleet cluster manager, the flannel overlay network, control the
    update mechanism, and ensure systemd units are started as early as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CoreOS proposes a very useful cloud-config file validator at [https://coreos.com/validate/](https://coreos.com/validate/).
    It's super useful when we're not sure if a directive is supported or not in the
    distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need:'
  prefs: []
  type: TYPE_NORMAL
- en: Access to a cloud-config enabled infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll get through the most important configuration options that can be manipulated
    for CoreOS. This includes the etcd distributed key value store, the fleet scheduler,
    the fleet network, the update strategy, and some systemd unit configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring etcd using cloud-init
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The etcd key value store is used in CoreOS to share multiple configuration data
    between members of a same cluster. To begin with, we need a discovery token, that
    can be obtained from [https://discovery.etcd.io/new](https://discovery.etcd.io/new).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can specify the minimum required size of the CoreOS cluster by adding the
    `size=` argument to the URL [https://discovery.etcd.io/new?size=3](https://discovery.etcd.io/new?size=3).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have a valid discovery token, let''s add it to our `cloud-config.yml`
    file under the `etcd2` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to configure etcd:'
  prefs: []
  type: TYPE_NORMAL
- en: How should etcd listen for peer traffic? (`listen-peer-urls`). We want the local
    interface on the default port (TCP/`2380`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How should etcd listen for client traffic? (`listen-client-urls`). We want all
    available interfaces on the default port (TCP/`2379`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How should etcd initially advertise to the rest of the cluster? (`initial-advertise-peer-urls`).
    We want the local interface, using the same peer traffic port (TCP/`2380`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How should etcd advertise the client URLs to the rest of the cluster? (`advertise-client-urls`).
    We want the local interface, using the same client traffic port (TCP/`2379`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To make it more dynamic, we can use variables compatible with most IaaS providers—`$private_ipv4`
    and `$public_ipv4`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how our `cloud-config.yml` file looks with all the etcd configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This will generate the right variables in the `systemd` unit file found at `/run/systemd/system/etcd2.service.d/20-cloudinit.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'When we have our cluster ready, we''ll be able to request information as a
    client on the specified port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also navigate the etcd key value store to confirm we can access it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Configuring fleet using cloud-init
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Fleet is a distributed init manager based on systemd that we use to schedule
    services on our CoreOS cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important configuration parameters are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public_ip`: This specifies which interface to use to communicate with other
    hosts. We want the public IP of the host so we can interact with fleet right from
    our workstation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`metadata`: This is any key value relevant to our needs, so we can schedule
    units accordingly. We want to store the provider (`aws`), the region (`eu-west-1`),
    and the name of the cluster (`mycluster`). This is totally arbitrary; adapt keys
    and values to your own needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how it looks in the `cloud-config.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate the right variables in the systemd unit at `/run/systemd/system/fleet.service.d/20-cloudinit.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Using fleet is outside of the scope of this book, but we can at least verify
    the connection to the fleet cluster manager is working from the instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We can now submit and start services on our working fleet cluster!
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the update strategy using cloud-init
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'CoreOS can handle updates in various ways, including rebooting immediately
    after a new CoreOS version is made available, scheduling with etcd for an ideal
    time so the cluster never breaks, a mix of both (the default), or even to never
    reboot. We can also explicitly specify which CoreOS channel to use (stable, beta,
    or alpha). We want to ensure the cluster never breaks, using the `etcd-lock` strategy,
    and be sure the stable release is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This section generates the `/etc/coreos/update.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can force an update check to verify it''s working (sample taken from a system
    with an update available):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Configuring locksmith using cloud-init
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we''re sure the update system is correctly triggered, we are facing a new
    problem: nodes from our cluster can reboot at any time when an update is available.
    It''s probably less than desirable in a high load environment. So we can configure
    **locksmith** to allow reboots only during a specific timeframe, such as "every
    night from Friday to Saturday, between 4 am and 6 am". We''re not limited to a
    single day, so we could also allow reboots any day at 4 am:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates the following content in `/run/systemd/system/locksmithd.service.d/20-cloudinit.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'At any time, we can check for a reboot slot availability using the `locksmithctl`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If another machine is currently rebooting, its ID is displayed so we know who's
    rebooting.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring systemd units using cloud-init
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can manage units easily from cloud-init, so critical parts of the system
    are started right when we need them. For example, we know we want the etcd2 and
    fleet services to start at every boot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Configuring flannel using cloud-init
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Flannel is used to create an overlay network across all hosts in the cluster,
    so containers can talk to each other over the network, whatever node they run
    on. To configure flannel before starting it, we can add more configuration information
    to the cloud-config file. We know we want our flannel network to work on the 10.1.0.0/16
    network, so we can create a drop-in systemd configuration file with its content
    that will be executed before the `flanneld` service. In this case, setting the
    flannel network is done by writing the key/value combination to etcd under `/coreos.com/network/config`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This will simply create the file `/etc/systemd/system/flanneld.service.d/50-network-config.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify we have a correct `flannel0` interface in the correct IP network range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Launch a container to verify it''s also running in the 10.1.0.0/16 network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: It's all working great!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that it may take a while to get the interface up, depending on the host
    Internet connection speed, as flannel is running from a container that needs to
    be downloaded first (51 MB to date).
  prefs: []
  type: TYPE_NORMAL
- en: We now know the most useful configuration options to bootstrap automatically
    a CoreOS cluster using cloud-init.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Chef Client from start to finish using cloud-init
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can deploy Chef using the official **omnibus** installer through cloud-init.
    This installer embeds everything needed to deploy Chef and all its dependencies.
    We'll then configure the Chef client to authenticate securely against the Chef
    Server organization, and finally apply an initial set of cookbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Warning: The current cloud-init version shipped with Ubuntu 16.04 LTS and CentOS
    7 is having issues installing Chef. This recipe is using Ubuntu 14.04 LTS waiting
    for the issue to be fixed.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Access to a cloud-config enabled infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working Chef Server and organization setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Everything related to Chef with cloud-init is configured under the directive
    named `chef`.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the Chef omnibus installer using cloud-init
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we want to use the official omnibus build (other choices are installing Chef
    through a Ruby gem—deprecated and too dependent on a locally installed Ruby version
    and through a package, which is already documented), let's define the installation
    type to `omnibus`, and ensure it is installed even if, for some reason, the Chef
    client was found to be already present on the system. Finally, let's explicitly
    define the installer full URL, so we're sure about what we install (maybe point
    it to a local version on your own servers).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output something like the following in the cloud-init logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you'll have a valid Chef installation under `/opt/chef`, though
    not yet configured.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Chef against a Chef Server organization using cloud-init
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Three pieces of information are needed for a chef client to authenticate correctly
    against a pre-existing Chef Server organization: the URL of the Chef server ([https://api.chef.io/organizations/iacbook](https://api.chef.io/organizations/iacbook)),
    the private key allowing you to add nodes to the organization, and the name linked
    to this key (by default, the organization name, such as `iacbook`). This information
    is mapped like this in the cloud-config file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'With this information, the initial chef-client run will be able to authenticate
    itself against the Chef organization and add the node. In the cloud-init logs,
    this step is found at this moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Applying a Chef cookbook at bootstrap using cloud-init
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We certainly want to apply at least an initial cookbook for configuring the
    instance. In this case, we''ll simply apply the starter cookbook shipped with
    the starter kit, but we can add as many required roles and cookbooks as we want.
    Refer to the dedicated chapter of this book for more information on obtaining
    this cookbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In the logs, we''ll see this being applied like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Our instance is now both registered and configured automatically, as early as
    possible, with just a few lines in the cloud-config file.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a remote Docker server using cloud-init
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It can be very handy to have a remote Docker server instead of the default local
    configuration from our workstation because of bandwidth issues, testing a production
    environment, maybe a customer demonstration, or distant team collaboration. Being
    able to send the usual Docker commands to a remote server has a multitude of advantages.
    For speed and comfort, we'll deploy a basic CoreOS system, add one user (Jane)
    and its public key. Docker will be modified to listen to the network through a
    socket kind of systemd service, and we'll configure the server time zone to be
    in New York.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need:'
  prefs: []
  type: TYPE_NORMAL
- en: Access to a cloud-config enabled infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by simply calling this server `"docker"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In the final system, this will set the hostname to the correct value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create the `Jane` user, so she can log in to the instance to remotely
    help us. She needs to be in the `docker` group, so she can manipulate the containers,
    and she gave us her SSH public key. This is how it translates in the cloud-config
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In the final system, Jane is able to log in using her private key, and interact
    with the docker daemon as she''s a member of the docker group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The SSH public key ends up in the following file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Setting the timezone on CoreOS using cloud-init
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'CoreOS uses a system built around NTP (short for Network Time Protocol), controlled
    by the `timedatectl` command. We won''t find the usual `/etc/timezone` on CoreOS,
    so the default `timezone` directive from cloud-init we''ve seen earlier in this
    book won''t work. To set the time zone to New York on CoreOS, we would set it
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Easy! So let''s launch that command through a systemd unit in the cloud-config
    file, so we''re sure the time zone is set. In-depth knowledge of systemd is out
    of the scope of this book, but to do that, we''ll have to add two options to the
    unit: one that tells systemd to not think the unit has crashed because the command
    exited (`RemainAfterExit=yes`), and one that tells the unit type is not executing
    a long running process, but instead a short one that should exit before continuing
    (`Type=oneshot`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the unit in the `cloud-config.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Enabling Docker TCP socket for network access
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our final objective is to be able to use a Docker Engine remotely from our
    workstation. The default Docker configuration is to listen to the Unix socket
    (`/var/run/docker.sock`)—and we want it to listen to a TCP socket on port 2375
    (the default unencrypted port, it''s highly recommended to configure TLS encryption;
    this will use the TCP/2376 by convention). To configure this, we''ll use a systemd
    feature—socket activation. To make it short, this creates a systemd service that
    listens on port 2375, and spawns the regular `docker.service` unit along with
    the socket description. This way, this particular Docker Engine will answer to
    requests on the TCP socket and not on the Unix socket (while keeping the possibility
    to activate more TCP sockets, or keeping the default `docker.service` clean).
    Here''s how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start a remote server with this whole configuration and use it a little
    for the demonstration (in this example, the Docker remote host is `52.211.117.98`,
    and we''ll launch an `nginx` container with HTTP port forwarding). Refer to the
    Docker section of this book for more information on the command-line options used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Make some requests on the remote Docker host HTTP port and it will answer. We
    now have a full on-demand CoreOS host, capable of giving us control over a Docker
    Engine remotely, using a nifty systemd configuration feature!
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When connecting to various remote Docker Engines, we will sooner or later connect
    to a server not using the same version of the server as our client. In this case,
    we''ll get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The easy workaround is to override the `DOCKER_API_VERSION` environment variable
    and set it to the same value as the server (1.22 in this example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Docker 1.13 greatly improved this situation, by managing the version/feature
    negotiation between the client and the server directly in the CLI.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information about systemd socket activation refer to [http://0pointer.de/blog/projects/socket-activation.html](http://0pointer.de/blog/projects/socket-activation.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
