<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Provisioning the Last Mile with Cloud-Init"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Provisioning the Last Mile with Cloud-Init</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using cloud-init on AWS, Digital Ocean, or OpenStack</li><li class="listitem" style="list-style-type: disc">Handling files using cloud-init</li><li class="listitem" style="list-style-type: disc">Configuring the server's time zone using cloud-init</li><li class="listitem" style="list-style-type: disc">Managing users, keys, and credentials using cloud-init</li><li class="listitem" style="list-style-type: disc">Managing repositories and packages using cloud-init</li><li class="listitem" style="list-style-type: disc">Running commands during boot using cloud-init</li><li class="listitem" style="list-style-type: disc">Configuring CoreOS using cloud-init</li><li class="listitem" style="list-style-type: disc">Deploying Chef client from start to finish using cloud-init</li><li class="listitem" style="list-style-type: disc">Deploying a remote Docker server using cloud-init</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec58"/>Introduction</h1></div></div></div><p>Cloud-init is a cloud instance initialization system, standard across most Linux distributions. It's supported by all recent distributions (Ubuntu, Arch, CentOS/Red Hat, Fedora, and more), as well as a variant found on CoreOS systems.</p><p>With cloud-init, a number of actions are taken during the initialization phases of booting a cloud instance (new or not): installing packages, copying files or SSH keys, deploying Chef, defining repositories, or rebooting (when done).</p><p>The scope of action of cloud-init is really intended for the initialization phase; it's not a configuration management tool and is globally not meant to be run again afterwards to update configuration, like one would with Ansible or Chef. It's only used to obtain an instance properly configured for the next step to happen, and to ensure a set of commands are executed in order during boot. In other words, Terraform (the tool covered in <a class="link" href="ch02.html" title="Chapter 2. Provisioning IaaS with Terraform">Chapter 2</a>, <span class="emphasis"><em>Provisioning IaaS with Terraform</em></span>, <a class="link" href="ch03.html" title="Chapter 3. Going Further with Terraform">Chapter 3</a>, <span class="emphasis"><em>Going Further with Terraform</em></span>, and <a class="link" href="ch04.html" title="Chapter 4. Automating Complete Infrastructures with Terraform">Chapter 4</a>, <span class="emphasis"><em>Automating Complete Infrastructures with Terraform</em></span>) is perfect to define all the aspects of the underlying infrastructure, but cloud-init can be an easy and awesome solution for handling the first and subsequent boots before letting a full-fledged configuration management tool such as Chef or Ansible play its part for the rest of the instance life.</p><p>
<span class="strong"><strong>Cloud-init</strong></span> is defined as a simple YAML file (cloud-config), sent in the <span class="strong"><strong>user-data</strong></span> field of a cloud instance. We'll see how this works in the coming sections.</p><p>In this chapter, we will present the most useful use cases with cloud-init, such as copying files, creating users, managing SSH keys, adding repositories and installing packages, running arbitrary commands, bootstrapping a Chef client, or managing CoreOS and Docker with it.</p></div></div>
<div class="section" title="Using cloud-init on AWS, Digital Ocean, or OpenStack"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec59"/>Using cloud-init on AWS, Digital Ocean, or OpenStack</h1></div></div></div><p>As cloud-init <a id="id464" class="indexterm"/>is an initialization <a id="id465" class="indexterm"/>system for cloud instances, we need to <a id="id466" class="indexterm"/>find a way to send the cloud-config YAML <a id="id467" class="indexterm"/>file to the bootstrapping process. On <a id="id468" class="indexterm"/>all IaaS providers supporting cloud-init, there's <a id="id469" class="indexterm"/>a field where we can paste our file. We'll review how cloud-init works on three important IaaS providers—AWS, Digital Ocean, and OpenStack.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec134"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need an account on Amazon Web Services, Digital Ocean, or some OpenStack deployment, or on all of them if you want to try them all!</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec135"/>How to do it…</h2></div></div></div><p>To illustrate cloud-init usage, we'll create the simplest cloud-config file on Ubuntu 16.04 and CentOS 7.2, installing packages such as <code class="literal">htop</code>, <code class="literal">tcpdump</code>, <code class="literal">docker</code>, or <code class="literal">nmap</code> that aren't usually installed by default on most Linux distributions. This is how a very simple cloud-config file looks:</p><div class="informalexample"><pre class="programlisting">#cloud-config
# Install packages on first boot
packages:
  - tcpdump
  - docker
  - nmap</pre></div><div class="section" title="Using cloud-init on Amazon Web Services"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec95"/>Using cloud-init on Amazon Web Services</h3></div></div></div><p>Using the <a id="id470" class="indexterm"/>AWS Console, when <a id="id471" class="indexterm"/>launching your instance, click on <span class="strong"><strong>Advanced Details</strong></span> and we'll be able to paste our sample (and simple) cloud-config YAML file, or even simply upload it:</p><div class="mediaobject"><img src="graphics/B05671_05_01.jpg" alt="Using cloud-init on Amazon Web Services"/></div><p>In this case, the Ubuntu 16.04 instance we just launched will already have the <code class="literal">htop</code> and <code class="literal">tcpdump</code> system tools installed, along with the Linux distribution's supported version of Docker:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ubuntu@ip-172-31-40-77:~$ which htop</strong></span>
<span class="strong"><strong>/usr/bin/htop</strong></span>
<span class="strong"><strong>ubuntu@ip-172-31-40-77:~$ which tcpdump</strong></span>
<span class="strong"><strong>/usr/sbin/tcpdump</strong></span>
<span class="strong"><strong>ubuntu@ip-172-31-40-77:~$ docker --version</strong></span>
<span class="strong"><strong>Docker version 1.11.2, build b9f10c9</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>We can manually update <code class="literal">cloud-config.yml</code> of a particular instance by powering off the instance, then under the <span class="strong"><strong>Actions</strong></span> menu, navigate to <span class="strong"><strong>Instance Settings</strong></span> | <span class="strong"><strong>View/Change User Data</strong></span>. Start the EC2 instance again and the updated configuration is applied.</p></div></div></div><div class="section" title="Using cloud-init on Digital Ocean"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec96"/>Using cloud-init on Digital Ocean</h3></div></div></div><p>The <a id="id472" class="indexterm"/>situation is similar on Digital Ocean. When creating <a id="id473" class="indexterm"/>a new <span class="strong"><strong>droplet</strong></span>, be sure to tick the <span class="strong"><strong>User data</strong></span> checkbox under the <span class="strong"><strong>Select additional options</strong></span> section <a id="id474" class="indexterm"/>and paste the cloud-config file content:</p><div class="mediaobject"><img src="graphics/B05671_05_02.jpg" alt="Using cloud-init on Digital Ocean"/></div><p>After a <a id="id475" class="indexterm"/>few seconds of boot time and package installation, our <a id="id476" class="indexterm"/>customized Ubuntu distribution is available:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@ubuntu-512mb-nyc3-01:~# which htop</strong></span>
<span class="strong"><strong>/usr/bin/htop</strong></span>
<span class="strong"><strong>root@ubuntu-512mb-nyc3-01:~# which tcpdump</strong></span>
<span class="strong"><strong>/usr/sbin/tcpdump</strong></span>
<span class="strong"><strong>root@ubuntu-512mb-nyc3-01:~# docker --version</strong></span>
<span class="strong"><strong>Docker version 1.11.2, build b9f10c9</strong></span>
</pre></div></div><div class="section" title="Using cloud-init on OpenStack"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec97"/>Using cloud-init on OpenStack</h3></div></div></div><p>When creating an instance on <a id="id477" class="indexterm"/>OpenStack, using the Horizon dashboard, click <a id="id478" class="indexterm"/>on the <span class="strong"><strong>Post-Creation</strong></span> tab, and paste the cloud-config YAML content in the text box. Alternatively, it is possible to upload the file:</p><div class="mediaobject"><img src="graphics/B05671_05_03.jpg" alt="Using cloud-init on OpenStack"/></div><p>Verify <a id="id479" class="indexterm"/>the requested packages were installed, this time <a id="id480" class="indexterm"/>on a CentOS 7.2 box:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[centos@cloud-init-demo ~]$ which nmap</strong></span>
<span class="strong"><strong>/usr/bin/nmap</strong></span>
<span class="strong"><strong>[centos@cloud-init-demo ~]$ docker --version</strong></span>
<span class="strong"><strong>Docker version 1.10.3, build cb079f6-unsupported</strong></span>
<span class="strong"><strong>[centos@cloud-init-demo ~]$ which tcpdump</strong></span>
<span class="strong"><strong>/usr/sbin/tcpdump</strong></span>
</pre></div></div><div class="section" title="Combining cloud-init and Terraform for any IaaS"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec98"/>Combining cloud-init and Terraform for any IaaS</h3></div></div></div><p>In the <a id="id481" class="indexterm"/>previous chapters about Terraform, we've in fact <a id="id482" class="indexterm"/>already used a <code class="literal">cloud-init</code> file a few times.</p><p>On <a id="id483" class="indexterm"/>Amazon Web Services, using the <code class="literal">aws_instance</code> resource <a id="id484" class="indexterm"/>to launch an EC2 VM, we use the <code class="literal">user_data</code> argument to pass the cloud-config file content, and in this case, using the <code class="literal">file()</code> interpolation:</p><div class="informalexample"><pre class="programlisting">resource "aws_instance" "vm" {
  ami           = "ami-643d4217"
  instance_type = "t2.micro"
  key_name      = "manual cloud init"
  user_data     = "${file("cloud-config.yml")}"
}</pre></div><p>The <a id="id485" class="indexterm"/>equivalent <a id="id486" class="indexterm"/>for a <a id="id487" class="indexterm"/>Digital <a id="id488" class="indexterm"/>Ocean VM is the <code class="literal">user_data</code> argument as well:</p><div class="informalexample"><pre class="programlisting">resource "digitalocean_droplet" "vm" {
  image              = "ubuntu-14-04-x64"
  name               = "ubuntu"
  region             = "ams3"
  size               = "512mb"
  ssh_keys           = ["keys/admin_key"]
  user_data          = "${file("cloud-config.yml")}"
}</pre></div></div></div></div>
<div class="section" title="Handling files using cloud-init"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec60"/>Handling files using cloud-init</h1></div></div></div><p>An early <a id="id489" class="indexterm"/>need we all face is to have a file, a license, or a script in place right from the beginning of the instance life. Cloud-init proposes <a id="id490" class="indexterm"/>different ways of sending those files over the new instance. We'll see how to send files using plain text and base64 data encodings.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec136"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Access to a cloud-config enabled infrastructure</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec137"/>How to do it…</h2></div></div></div><p>The first <a id="id491" class="indexterm"/>file we'll write is a <span class="strong"><strong>MOTD</strong></span> (short for <span class="strong"><strong>Message Of The Day</strong></span>) with root read-write permissions, read-only for everyone else. This file will have its content declared right from the cloud-config file:</p><div class="informalexample"><pre class="programlisting">#cloud-config
write_files:
  - path: /etc/motd
    content: |
      This server is configured using cloud-init.
      Welcome.
    owner: root:root
    permissions: '0644'</pre></div><p>This machine, when booted, will have <code class="literal">/etc/motd</code> in place and display the string at login:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ssh ubuntu@server_ip</strong></span>
<span class="strong"><strong>Welcome to Ubuntu 16.04.1 LTS (GNU/Linux 4.4.0-36-generic x86_64)</strong></span>
<span class="strong"><strong>[...]</strong></span>
<span class="strong"><strong>This server is configured using cloud-init.</strong></span>
<span class="strong"><strong>Welcome.</strong></span>
<span class="strong"><strong>[...]</strong></span>
<span class="strong"><strong>ubuntu@ip-172-31-44-177:~$</strong></span>
</pre></div><p>Another <a id="id492" class="indexterm"/>way of including file content is to encode it in <a id="id493" class="indexterm"/>base64. Let's say we want to create a file named <code class="literal">/etc/server-id</code> with the content <code class="literal">abc-123</code>, with permissions <code class="literal">0600</code>. Begin by obtaining the base64 version of the file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ base64 server-id</strong></span>
<span class="strong"><strong>YWJjLTEyMwo=</strong></span>
</pre></div><p>This is the output we'll integrate into the <code class="literal">content</code> field of the cloud-config file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  - path: /etc/server-id</strong></span>
<span class="strong"><strong>    content: YWJjLTEyMwo=</strong></span>
<span class="strong"><strong>    encoding: b64</strong></span>
<span class="strong"><strong>    permissions: '0600'</strong></span>
</pre></div><p>Let's verify the remote content is what we expected:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ls -al /etc/server-id</strong></span>
<span class="strong"><strong>-rw------- 1 root root 8 Sep 20 10:15 /etc/server-id</strong></span>
<span class="strong"><strong>$ sudo cat /etc/server-id</strong></span>
<span class="strong"><strong>abc-123</strong></span>
</pre></div><p>It works! Our file is read/write for the owner only, and the content is <code class="literal">abc-123</code>.</p><p>Another possibility is to compress the file using <code class="literal">gzip</code>, or even to base64 encode the resulting compressed gzip file.</p></div></div>
<div class="section" title="Configuring the server's time zone using cloud-init"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec61"/>Configuring the server's time zone using cloud-init</h1></div></div></div><p>One very <a id="id494" class="indexterm"/>common configuration step <a id="id495" class="indexterm"/>on a new instance is setting the time zone. This time we'll explicitly set the EDT (New York) time zone for our server (even if the server is running in Europe or somewhere else). It is sometimes important to have as early as possible a correct date and time set up (for things like registration times, delays, and other issues depending on dates and times).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>In most setups, I personally prefer to ensure all the systems are set to GMT, wherever they are on the planet, GMT or not. This way, it's much easier to debug, compare logs or behavior when failures arise, without losing time doing the math of the time zones.</p></div></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec138"/>Getting ready</h2></div></div></div><p>To step <a id="id496" class="indexterm"/>through this recipe, you will need:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Access to a cloud-config enabled infrastructure</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec139"/>How to do it…</h2></div></div></div><p>To set <a id="id497" class="indexterm"/>the server's time zone automatically to <code class="literal">America/New_York</code>, use the <code class="literal">timezone</code> directive:</p><div class="informalexample"><pre class="programlisting">#cloud-config
timezone: "America/New_York"</pre></div><p>That is it! Our server is now configured from the beginning to use the correct time zone:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ date</strong></span>
<span class="strong"><strong>Sun Sep 25 10:48:32 EDT 2016</strong></span>
</pre></div><p>This, in fact, has simply set the <code class="literal">/etc/timezone</code> file to the correct value:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cat /etc/timezone</strong></span>
<span class="strong"><strong>America/New_York</strong></span>
</pre></div></div></div>
<div class="section" title="Managing users, keys, and credentials using cloud-init"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec62"/>Managing users, keys, and credentials using cloud-init</h1></div></div></div><p>There's a <a id="id498" class="indexterm"/>high probability we won't plan to use <a id="id499" class="indexterm"/>the default root account, or even the default <a id="id500" class="indexterm"/>user account from our distribution (those ubuntu or centos users). There's an even higher probability we'll need <a id="id501" class="indexterm"/>a Unix account very early in the process, even <a id="id502" class="indexterm"/>before the proper configuration management <a id="id503" class="indexterm"/>tool enters the game.</p><p>Let's say our IT security policy wants us to have an <code class="literal">emergency</code> user account in a group named <code class="literal">infosec</code> for the IT security team with passwordless <code class="literal">sudo</code> rights and the simple <code class="literal">/bin/sh</code> shell. This account has one authorized public key automatically populated. The policy is also to remove the default <code class="literal">ubuntu</code> account.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec140"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Access to a cloud-config enabled infrastructure</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec141"/>How to do it…</h2></div></div></div><p>To create <a id="id504" class="indexterm"/>a group, we use a directive simply named <code class="literal">groups</code>, taking a list of groups. Any group can have a sublist of users to put in that group:</p><div class="informalexample"><pre class="programlisting">#cloud-config
groups:
  - infosec: [emergency]</pre></div><p>To create <a id="id505" class="indexterm"/>a user, let's use a directive named <code class="literal">users</code>, taking <a id="id506" class="indexterm"/>a list of users. This list of users <a id="id507" class="indexterm"/>has a set of keys, such as <code class="literal">groups</code> the user <a id="id508" class="indexterm"/>is a member of, <code class="literal">sudo</code> rights, which <code class="literal">shell</code> to default <a id="id509" class="indexterm"/>to, or an SSH public key to authorize. Here's how it looks for our user <code class="literal">emergency</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>users:</strong></span>
<span class="strong"><strong>  - name: emergency</strong></span>
<span class="strong"><strong>    groups: sudo</strong></span>
<span class="strong"><strong>    shell: /bin/sh</strong></span>
<span class="strong"><strong>    sudo: ['ALL=(ALL) NOPASSWD:ALL']</strong></span>
<span class="strong"><strong>    ssh-authorized-keys:</strong></span>
<span class="strong"><strong>      - ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC+fAfzjw5+mUZ7nGokB0tzO9fOLKrjHGVlabpRUxvsIN/dRRmiBA9NDh5YRZ/ThAhn+RvPKGTBrXmuv3qWd/iWc3nie0fc2zDX1/Dc8EAIF9ybXfSxT2DXOWWLOvNdUVOZNifmsmCQ1z0p9hg3bo65c0ZEBpXHIk+l75uFWAIYZ/4jnXyFWz1ptmQR7gnAk2KBK19sj1Ii0pNjGyVbl5bNitWb3ulaviIT3FCswZoOsYvcLpOwQrMA3k12kEAb30CYpesGcq6WDHAZSpWkFvc3Cd/AET4/SjtyYpQVEhUn84v106WbNeDyJpUX6cz2WG2UaEqZc0VqZVhI63jG7wUR emergency@host</strong></span>
</pre></div><p>Once logged in as <code class="literal">emergency</code> using the private key, let's verify cloud-init did the job:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ whoami</strong></span>
<span class="strong"><strong>emergency</strong></span>
<span class="strong"><strong>$ groups emergency</strong></span>
<span class="strong"><strong>emergency : emergency sudo</strong></span>
<span class="strong"><strong>$ echo $SHELL</strong></span>
<span class="strong"><strong>/bin/sh</strong></span>
<span class="strong"><strong>$ sudo whoami</strong></span>
<span class="strong"><strong>root</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note30"/>Note</h3><p>We never explicitly asked to remove the default <code class="literal">ubuntu</code> user account: it's automatic as soon as we create an initial user.</p></div></div><p>However, if <a id="id510" class="indexterm"/>we wanted to keep the default user <a id="id511" class="indexterm"/>from <a id="id512" class="indexterm"/>our <a id="id513" class="indexterm"/>Linux distribution, we'd <a id="id514" class="indexterm"/>just have to add the following <code class="literal">default</code> user <a id="id515" class="indexterm"/>to the <code class="literal">users</code> directive:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>users:</strong></span>
<span class="strong"><strong>  - default</strong></span>
</pre></div></div></div>
<div class="section" title="Managing repositories and packages using cloud-init"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec63"/>Managing repositories and packages using cloud-init</h1></div></div></div><p>Unless <a id="id516" class="indexterm"/>we need a very specific release of a Linux <a id="id517" class="indexterm"/>distribution, it's highly probable we'll expect a fully updated system as soon as possible (think security patches and other bug fixes). Similarly, we usually expect a set of tools to be available in the new system. However, things <a id="id518" class="indexterm"/>might change, default <a id="id519" class="indexterm"/>tools might be removed – better to be safe than sorry. If one of our bootstrap scripts needs <code class="literal">wget</code> or <code class="literal">curl</code> and <code class="literal">nmap</code>, let's ensure those are present long before the proper configuration management tool starts its job (such as Chef or Puppet). We may also want to reboot the server after applying critical initial packages such as the kernel, or add a custom package repository.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec142"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Access to a cloud-config enabled infrastructure</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec143"/>How to do it…</h2></div></div></div><p>To upgrade all the packages right after bootstrap, simply set the <code class="literal">package_upgrade</code> directive to <code class="literal">true</code>:</p><div class="informalexample"><pre class="programlisting">#cloud-config
package_upgrade: true</pre></div><p>Another useful directive is to reboot the system if required by the package manager (common case with kernel updates). It's often better to reboot as soon as possible with the most secure kernel, but proceed with caution according to your own environment (you might not want to reboot while another action is taking place, maybe a Chef run or similar management software):</p><div class="informalexample"><pre class="programlisting">apt_reboot_if_required: true</pre></div><p>To ensure the required packages are installed, use the <code class="literal">packages</code> directive:</p><div class="informalexample"><pre class="programlisting">packages:
  - htop
  - nmap
  - curl
  - wget</pre></div><p>We can <a id="id520" class="indexterm"/>also add a custom APT repository using <code class="literal">apt_sources</code>:</p><div class="informalexample"><pre class="programlisting">apt_sources:
  -  source: "ppa:nginx/stable"</pre></div><p>Let's <a id="id521" class="indexterm"/>launch a new instance and verify it's fully updated, so no updates can be applied:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get dist-upgrade</strong></span>
<span class="strong"><strong>Reading package lists... Done</strong></span>
<span class="strong"><strong>Building dependency tree</strong></span>
<span class="strong"><strong>Reading state information... Done</strong></span>
<span class="strong"><strong>Calculating upgrade... Done</strong></span>
<span class="strong"><strong>0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.</strong></span>
</pre></div><p>Verify <a id="id522" class="indexterm"/>our required tools are available:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ which nmap</strong></span>
<span class="strong"><strong>/usr/bin/nmap</strong></span>
<span class="strong"><strong>$ which htop</strong></span>
<span class="strong"><strong>/usr/bin/htop</strong></span>
<span class="strong"><strong>$ which curl</strong></span>
<span class="strong"><strong>/usr/bin/curl</strong></span>
<span class="strong"><strong>$ which wget</strong></span>
<span class="strong"><strong>/usr/bin/wget</strong></span>
</pre></div><p>Good <a id="id523" class="indexterm"/>thing! Now we're sure to always have a fully updated system with the required set of tools installed, even our own, right from the beginning.</p></div></div>
<div class="section" title="Running commands during boot using cloud-init"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec64"/>Running commands during boot using cloud-init</h1></div></div></div><p>When <a id="id524" class="indexterm"/>bootstrapping a new server or instance, the <a id="id525" class="indexterm"/>first boot is often very different from all the other boots the instance will experience in its life, and most often we want some commands to be executed very early or very late in the boot process. For example, let's say our cloud instance is launched with an attached block storage. We <a id="id526" class="indexterm"/>might want to format this storage <a id="id527" class="indexterm"/>space and be sure it's mounted on the host, but while we always want the disk to mount, we probably don't want it to be formatted at each boot! The <code class="literal">bootcmd</code> directive is there to handle everything related to commands to be executed very early in the boot process, while the <code class="literal">runcmd</code> directive is executed much later in the boot process (and only once).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note31"/>Note</h3><p>
<code class="literal">bootcmd</code> will be executed at every boot of the instance.</p></div></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec144"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Access to a cloud-config enabled infrastructure</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec145"/>How to do it…</h2></div></div></div><p>We'll launch three commands during boot. The first one is a simple file with a dynamic content (the <code class="literal">$INSTANCE_ID</code> variable made available to us by cloud-init), which will always be rewritten, no matter what, at each boot. The second command is printing the date in the logs (so we know when the boot process started). The final command is the <code class="literal">ext4</code> formatting of a block device attached on <code class="literal">/dev/xvdb</code>. For the sake of the exercise, we'll also mount the new device under <code class="literal">/srv/www</code> on the host.</p><p>To launch any command at boot time that will be run as early as possible, every time the machine boots, simply add it to the list of the <code class="literal">bootcmd</code> directive:</p><div class="informalexample"><pre class="programlisting">#cloud-config
bootcmd:
  - echo bootcmd started at $(date)
  - echo $INSTANCE_ID &gt; /etc/instance_id</pre></div><p>If we delete or modify this file, at the next reboot it will be overwritten.</p><p>On the other hand, if we want to run a command only once inside the <code class="literal">bootcmd</code> directive, we can use the helper script <code class="literal">cloud-init-per</code>. You can choose to launch the command once per <code class="literal">boot</code> or once per <code class="literal">instance</code>. In our case, we want to format the <code class="literal">/dev/xvdb</code> device (so, unless we want to format our drive each time we reboot, we probably want this to happen only once on this instance. So let's add the <code class="literal">instance</code> argument to the <code class="literal">cloud-init-per</code> helper script):</p><div class="informalexample"><pre class="programlisting">#cloud-config
bootcmd:
  - cloud-init-per instance mkfs-xvdb mkfs -t ext4 /dev/xvdb</pre></div><p>Finally, let's use the <code class="literal">mounts</code> directive to mount the now formatted <code class="literal">/dev/xvdb</code> on the <code class="literal">/srv/www</code> folder:</p><div class="informalexample"><pre class="programlisting">mounts:
  - [ /dev/xvdb, /srv/www ]</pre></div><p>After boot, let's verify the block device is mounted:</p><div class="informalexample"><pre class="programlisting"># df -h /srv/www/
Filesystem      Size  Used Avail Use% Mounted on
/dev/xvdb       4.8G   10M  4.6G   1% /srv/www</pre></div><p>We can also test the existence of the file we created:</p><div class="informalexample"><pre class="programlisting"># cat /etc/instance_id
i-03005dd324599df11</pre></div><p>Try to <a id="id528" class="indexterm"/>delete this file and reboot the server: the file will be there again.</p><p>Now, let's take a look at how different the <code class="literal">runcmd</code> directive is. Let's add a very similar command <a id="id529" class="indexterm"/>to the date output in the <code class="literal">bootcmd</code> directive:</p><div class="informalexample"><pre class="programlisting">runcmd:
 - 'echo runcmd started at $(date)'</pre></div><p>Start a new instance, and observe the difference in timestamps:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ grep "started at" /var/log/cloud-init-output.log</strong></span>
<span class="strong"><strong>bootcmd started at Fri Sep 23 07:02:35 UTC 2016</strong></span>
<span class="strong"><strong>+ echo runcmd started at Fri Sep 23 07:02:47 UTC 2016</strong></span>
<span class="strong"><strong>runcmd started at Fri Sep 23 07:02:47 UTC 2016</strong></span>
</pre></div><p>The <code class="literal">runcmd</code> directive started 12 seconds later than the <code class="literal">bootcmd</code> directive.</p><p>Now reboot the instance, and observe that <code class="literal">runcmd</code> didn't run again:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ grep "started at" /var/log/cloud-init-output.log</strong></span>
<span class="strong"><strong>bootcmd started at Fri Sep 23 07:04:31 UTC 2016</strong></span>
</pre></div><p>Now we know what directive to use in each case.</p></div></div>
<div class="section" title="Configuring CoreOS using cloud-init"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec65"/>Configuring CoreOS using cloud-init</h1></div></div></div><p>CoreOS <a id="id530" class="indexterm"/>supports its own version of cloud-init, with <a id="id531" class="indexterm"/>added support for the CoreOS environment, and without everything else incompatible with its environment, so we can boot a fully configured system and cluster.</p><p>We'll take a look at the CoreOS specificities, as we can refer to earlier tips on how to manage users, files, authorized SSH keys, and other standard cloud-init directives. At the end of <a id="id532" class="indexterm"/>this part, you'll know how to configure <a id="id533" class="indexterm"/>the etcd key value store, the fleet cluster manager, the flannel overlay network, control the update mechanism, and ensure <a id="id534" class="indexterm"/>systemd units are started as early as possible.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note32"/>Note</h3><p>CoreOS proposes a very useful cloud-config file validator at <a class="ulink" href="https://coreos.com/validate/">https://coreos.com/validate/</a>. It's super useful when we're not sure if a directive is supported or not in the distribution.</p></div></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec146"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Access to a cloud-config enabled infrastructure</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec147"/>How to do it…</h2></div></div></div><p>We'll get through the most important configuration options that can be manipulated for CoreOS. This includes the etcd distributed key value store, the fleet scheduler, the fleet network, the update strategy, and some systemd unit configuration.</p><div class="section" title="Configuring etcd using cloud-init"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec99"/>Configuring etcd using cloud-init</h3></div></div></div><p>The etcd <a id="id535" class="indexterm"/>key value store is used in <a id="id536" class="indexterm"/>CoreOS to share multiple configuration <a id="id537" class="indexterm"/>data between <a id="id538" class="indexterm"/>members of a same cluster. To begin with, we need a discovery token, that can be obtained from <a class="ulink" href="https://discovery.etcd.io/new">https://discovery.etcd.io/new</a>.</p><div class="informalexample"><pre class="programlisting">$ curl -w "\n" 'https://discovery.etcd.io/new'
https://discovery.etcd.io/638d980c4edf94d6ddff8d6e862bc7d9</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note33"/>Note</h3><p>We can specify the minimum required size of the CoreOS cluster by adding the <code class="literal">size=</code> argument to the URL <a class="ulink" href="https://discovery.etcd.io/new?size=3">https://discovery.etcd.io/new?size=3</a>.</p></div></div><p>Now we <a id="id539" class="indexterm"/>have a valid discovery token, let's add it to our <code class="literal">cloud-config.yml</code> file under the <code class="literal">etcd2</code> directive:</p><div class="informalexample"><pre class="programlisting">#cloud-config
coreos:
  etcd2:
    discovery: "https://discovery.etcd.io/638d980c4edf94d6ddff8d6e862bc7d9"</pre></div><p>The next step is to configure etcd:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How should etcd listen for peer traffic? (<code class="literal">listen-peer-urls</code>). We want the local interface on the default port (TCP/<code class="literal">2380</code>).</li><li class="listitem" style="list-style-type: disc">How should etcd listen for client traffic? (<code class="literal">listen-client-urls</code>). We want all available interfaces on the default port (TCP/<code class="literal">2379</code>).</li><li class="listitem" style="list-style-type: disc">How should etcd initially advertise to the rest of the cluster? (<code class="literal">initial-advertise-peer-urls</code>). We want the local interface, using the same peer traffic port (TCP/<code class="literal">2380</code>).</li><li class="listitem" style="list-style-type: disc">How should etcd advertise the client URLs to the rest of the cluster? (<code class="literal">advertise-client-urls</code>). We want the local interface, using the same client traffic port (TCP/<code class="literal">2379</code>).</li></ul></div><p>To make <a id="id540" class="indexterm"/>it more dynamic, we can use <a id="id541" class="indexterm"/>variables compatible <a id="id542" class="indexterm"/>with most IaaS providers—<code class="literal">$private_ipv4</code> and <code class="literal">$public_ipv4</code>.</p><p>This is how our <code class="literal">cloud-config.yml</code> file looks with all the etcd configuration:</p><div class="informalexample"><pre class="programlisting">#cloud-config
coreos:
  etcd2:
    discovery: "https://discovery.etcd.io/b8724b9a1456573f4d527452cba8ebdb"
    advertise-client-urls: "http://$private_ipv4:2379"
    listen-client-urls: "http://0.0.0.0:2379"
    initial-advertise-peer-urls: "http://$private_ipv4:2380"
    listen-peer-urls: "http://$private_ipv4:2380"</pre></div><p>This will generate the right variables in the <code class="literal">systemd</code> unit file found at <code class="literal">/run/systemd/system/etcd2.service.d/20-cloudinit.conf</code>.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cat /run/systemd/system/etcd2.service.d/20-cloudinit.conf</strong></span>
<span class="strong"><strong>[Service]</strong></span>
<span class="strong"><strong>Environment="ETCD_ADVERTISE_CLIENT_URLS=http://172.31.15.59:2379"</strong></span>
<span class="strong"><strong>Environment="ETCD_DISCOVERY=https://discovery.etcd.io/b8724b9a1456573f4d527452cba8ebdb"</strong></span>
<span class="strong"><strong>Environment="ETCD_INITIAL_ADVERTISE_PEER_URLS=http://172.31.15.59:2380"</strong></span>
<span class="strong"><strong>Environment="ETCD_LISTEN_CLIENT_URLS=http://0.0.0.0:2379"</strong></span>
<span class="strong"><strong>Environment="ETCD_LISTEN_PEER_URLS=http://172.31.15.59:2380"</strong></span>
</pre></div><p>When we have our cluster ready, we'll be able to request information as a client on the specified port:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ etcdctl cluster-health</strong></span>
<span class="strong"><strong>member 7466dcc2053a98a4 is healthy: got healthy result from http://172.31.15.59:2379</strong></span>
<span class="strong"><strong>member 8f9bd8a78e0cca38 is healthy: got healthy result from http://172.31.8.96:2379</strong></span>
<span class="strong"><strong>member e0f77aacba6888fc is healthy: got healthy result from http://172.31.1.27:2379</strong></span>
<span class="strong"><strong>cluster is healthy</strong></span>
</pre></div><p>We can <a id="id543" class="indexterm"/>also navigate the etcd key <a id="id544" class="indexterm"/>value store to confirm we <a id="id545" class="indexterm"/>can access it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ etcdctl ls</strong></span>
<span class="strong"><strong>/coreos.com</strong></span>
</pre></div></div><div class="section" title="Configuring fleet using cloud-init"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec100"/>Configuring fleet using cloud-init </h3></div></div></div><p>Fleet is <a id="id546" class="indexterm"/>a distributed init manager based on systemd that we use to schedule services on our CoreOS cluster.</p><p>The most <a id="id547" class="indexterm"/>important configuration parameters are the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">public_ip</code>: This specifies which interface to use to communicate with other hosts. We want the public IP of the host so we can interact with fleet right from our workstation.</li><li class="listitem" style="list-style-type: disc"><code class="literal">metadata</code>: This is any key value relevant to our needs, so we can schedule units accordingly. We want to store the provider (<code class="literal">aws</code>), the region (<code class="literal">eu-west-1</code>), and the name of the cluster (<code class="literal">mycluster</code>). This is totally arbitrary; adapt keys and values to your own needs.</li></ul></div><p>This is <a id="id548" class="indexterm"/>how it looks in the <code class="literal">cloud-config.yml</code> file:</p><div class="informalexample"><pre class="programlisting">coreos:
  fleet:
    public-ip: "$public_ipv4"
    metadata: "region=eu-west-1,provider=aws,cluster=mycluster"</pre></div><p>This will generate the right variables in the systemd unit at <code class="literal">/run/systemd/system/fleet.service.d/20-cloudinit.conf</code>:</p><div class="informalexample"><pre class="programlisting">$ cat /run/systemd/system/fleet.service.d/20-cloudinit.conf
[Service]
Environment="FLEET_METADATA=region=eu-west-1,provider=aws,cluster=mycluster"
Environment="FLEET_PUBLIC_IP=52.209.159.4"</pre></div><p>Using fleet is outside of the scope of this book, but we can at least verify the connection to the <a id="id549" class="indexterm"/>fleet cluster manager is working from the instance:</p><div class="informalexample"><pre class="programlisting">$ fleetctl list-machines
MACHINE         IP              METADATA
441bf02a...     52.31.10.18     cluster=mycluster,provider=aws,region=eu-west-1
b95a5262...     52.209.159.4    cluster=mycluster,provider=aws,region=eu-west-1
d9fa1d18...     52.31.109.156   cluster=mycluster,provider=aws,region=eu-west-1</pre></div><p>We can <a id="id550" class="indexterm"/>now submit and start services on <a id="id551" class="indexterm"/>our working fleet cluster!</p></div><div class="section" title="Configuring the update strategy using cloud-init"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec101"/>Configuring the update strategy using cloud-init</h3></div></div></div><p>CoreOS <a id="id552" class="indexterm"/>can handle updates in various <a id="id553" class="indexterm"/>ways, including rebooting immediately after a new CoreOS version is made available, scheduling with etcd for an <a id="id554" class="indexterm"/>ideal time so the cluster never breaks, a mix of both (the default), or even to never reboot. We can also explicitly specify which CoreOS channel to use (stable, beta, or alpha). We want to ensure the cluster never breaks, using the <code class="literal">etcd-lock</code> strategy, and be sure the stable release is used:</p><div class="informalexample"><pre class="programlisting">coreos:
  update:
    reboot-strategy: "etcd-lock"
    group: "stable"</pre></div><p>This section generates the <code class="literal">/etc/coreos/update.conf</code> file:</p><div class="informalexample"><pre class="programlisting">$ cat /etc/coreos/update.conf
GROUP=stable
REBOOT_STRATEGY=etcd-lock</pre></div><p>We can force an update check to verify it's working (sample taken from a system with an update available):</p><div class="informalexample"><pre class="programlisting">$ sudo update_engine_client -update
[0924/131749:INFO:update_engine_client.cc(243)] Initiating update check and install.
[0924/131750:INFO:update_engine_client.cc(248)] Waiting for update to complete.
CURRENT_OP=UPDATE_STATUS_UPDATE_AVAILABLE
[...]</pre></div></div><div class="section" title="Configuring locksmith using cloud-init"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec102"/>Configuring locksmith using cloud-init </h3></div></div></div><p>Now <a id="id555" class="indexterm"/>we're sure the update system is correctly <a id="id556" class="indexterm"/>triggered, we are facing a new problem: nodes <a id="id557" class="indexterm"/>from our cluster can reboot at any time when an update is available. It's probably less than desirable in a high load environment. So we can <a id="id558" class="indexterm"/>configure <span class="strong"><strong>locksmith</strong></span> to allow reboots only during a specific timeframe, such as "every night from Friday to Saturday, between 4 am and 6 am". We're not limited to a single day, so we could also allow reboots any day at 4 am:</p><div class="informalexample"><pre class="programlisting">coreos:
  locksmith:
    window-start: Sat 04:00
    window-length: 2h </pre></div><p>This generates the following content in <code class="literal">/run/systemd/system/locksmithd.service.d/20-cloudinit.conf</code>:</p><div class="informalexample"><pre class="programlisting">$ cat /run/systemd/system/locksmithd.service.d/20-cloudinit.conf
[Service]
Environment="REBOOT_WINDOW_START=04:00"
Environment="REBOOT_WINDOW_LENGTH=2h"</pre></div><p>At any time, we can check for a reboot slot availability using the <code class="literal">locksmithctl</code> command:</p><div class="informalexample"><pre class="programlisting">$ locksmithctl status
Available: 1
Max: 1</pre></div><p>If another machine is currently rebooting, its ID is displayed so we know who's rebooting.</p></div><div class="section" title="Configuring systemd units using cloud-init"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec103"/>Configuring systemd units using cloud-init</h3></div></div></div><p>We can <a id="id559" class="indexterm"/>manage units easily from <a id="id560" class="indexterm"/>cloud-init, so critical parts of the system are started right when we need them. For example, we know we want the etcd2 <a id="id561" class="indexterm"/>and fleet services to start at every boot:</p><div class="informalexample"><pre class="programlisting">  coreos: 
units:
    - name: etcd2.service
      command: start
    - name: fleet.service
      command: start </pre></div></div><div class="section" title="Configuring flannel using cloud-init"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec104"/>Configuring flannel using cloud-init</h3></div></div></div><p>Flannel <a id="id562" class="indexterm"/>is used to create an overlay network <a id="id563" class="indexterm"/>across all hosts in the cluster, so containers <a id="id564" class="indexterm"/>can talk to each other over the network, whatever node they run on. To configure flannel before starting it, we can add more configuration information to the cloud-config file. We know we want our flannel network to work on the 10.1.0.0/16 network, so we can create a drop-in systemd configuration file with its content that will be executed before the <code class="literal">flanneld</code> service. In this case, setting the flannel network is done by writing the key/value combination to etcd under <code class="literal">/coreos.com/network/config</code>:</p><div class="informalexample"><pre class="programlisting">coreos:
  units:
    - name: flanneld.service
      drop-ins:
        - name: 50-network-config.conf
          content: |
            [Service]
            ExecStartPre=/usr/bin/etcdctl set /coreos.com/network/config '{ "Network": "10.1.0.0/16" }'</pre></div><p>This will simply create the file <code class="literal">/etc/systemd/system/flanneld.service.d/50-network-config.conf</code>:</p><div class="informalexample"><pre class="programlisting">$ cat /etc/systemd/system/flanneld.service.d/50-network-config.conf
[Service]
ExecStartPre=/usr/bin/etcdctl set /coreos.com/network/config '{ "Network": "10.1.0.0/16" }'</pre></div><p>Verify we have a correct <code class="literal">flannel0</code> interface in the correct IP network range:</p><div class="informalexample"><pre class="programlisting">$ ifconfig flannel0
flannel0: flags=4305&lt;UP,POINTOPOINT,RUNNING,NOARP,MULTICAST&gt;  mtu 8973
        inet 10.1.19.0  netmask 255.255.0.0  destination 10.1.19.0
[...]</pre></div><p>Launch a container to verify it's also running in the 10.1.0.0/16 network:</p><div class="informalexample"><pre class="programlisting">$ docker run -it --rm alpine ifconfig eth0
eth0      Link encap:Ethernet  HWaddr 02:42:0A:01:13:02
          inet addr:10.1.19.2  Bcast:0.0.0.0  Mask:255.255.255.0
[...]</pre></div><p>It's all working great!</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note34"/>Note</h3><p>Note that it may take a while to get the interface up, depending on the host Internet connection speed, as flannel is running from a container that needs to be downloaded first (51 MB to date).</p></div></div><p>We now <a id="id565" class="indexterm"/>know the most useful configuration <a id="id566" class="indexterm"/>options to bootstrap automatically <a id="id567" class="indexterm"/>a CoreOS cluster using cloud-init.</p></div></div></div>
<div class="section" title="Deploying Chef Client from start to finish using cloud-init"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec66"/>Deploying Chef Client from start to finish using cloud-init</h1></div></div></div><p>We can <a id="id568" class="indexterm"/>deploy Chef using the official <span class="strong"><strong>omnibus</strong></span> installer through cloud-init. This installer embeds everything needed to deploy Chef and <a id="id569" class="indexterm"/>all its dependencies. We'll then <a id="id570" class="indexterm"/>configure the Chef client to authenticate securely against the Chef Server organization, and finally apply an initial set of cookbooks.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note35"/>Note</h3><p>Warning: The current cloud-init version shipped with Ubuntu 16.04 LTS and CentOS 7 is having issues installing Chef. This recipe is using Ubuntu 14.04 LTS waiting for the issue to be fixed.</p></div></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec148"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Access to a cloud-config enabled infrastructure</li><li class="listitem" style="list-style-type: disc">A working Chef Server and organization setup</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec149"/>How to do it…</h2></div></div></div><p>Everything related to Chef with cloud-init is configured under the directive named <code class="literal">chef</code>.</p><div class="section" title="Deploying the Chef omnibus installer using cloud-init"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec105"/>Deploying the Chef omnibus installer using cloud-init</h3></div></div></div><p>As we <a id="id571" class="indexterm"/>want to use the official omnibus build (other choices are installing Chef through a Ruby gem—deprecated and too dependent on a locally installed Ruby version and through a package, which is already documented), let's define the installation type to <code class="literal">omnibus</code>, and ensure it is installed even if, for some reason, the Chef client was found to be already present on the system. Finally, let's explicitly define the installer full URL, so we're sure about what we install (maybe point it to a local version on your own servers).</p><div class="informalexample"><pre class="programlisting">#cloud-config
chef:
  install_type: "omnibus"
  force_install: true
  omnibus_url: "https://www.getchef.com/chef/install.sh"</pre></div><p>This <a id="id572" class="indexterm"/>will output something like the following in the cloud-init logs:</p><div class="informalexample"><pre class="programlisting">Getting information for chef stable  for ubuntu...
downloading https://omnitruck-direct.chef.io/stable/chef/metadata?v=&amp;p=ubuntu&amp;pv=14.04&amp;m=x86_64
  to file /tmp/install.sh.1294/metadata.txt
[...]
version 12.14.89
[...]
Installing chef
[...]
Unpacking chef (12.14.89-1) ...
Setting up chef (12.14.89-1) ...
Thank you for installing Chef!</pre></div><p>At this point, you'll have a valid Chef installation under <code class="literal">/opt/chef</code>, though not yet configured.</p></div><div class="section" title="Configuring Chef against a Chef Server organization using cloud-init"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec106"/>Configuring Chef against a Chef Server organization using cloud-init </h3></div></div></div><p>Three <a id="id573" class="indexterm"/>pieces of information are needed for a chef client to authenticate correctly against a pre-existing Chef <a id="id574" class="indexterm"/>Server organization: the URL of the Chef server (<a class="ulink" href="https://api.chef.io/organizations/iacbook">https://api.chef.io/organizations/iacbook</a>), the private key allowing you to add nodes to the organization, and the name linked to this key (by default, the organization name, such as <code class="literal">iacbook</code>). This information is mapped like this in the cloud-config file:</p><div class="informalexample"><pre class="programlisting">#cloud-config
chef:
  server_url: "https://api.chef.io/organizations/iacbook"
  validation_name: "iacbook"
  validation_cert: |
    -----BEGIN RSA PRIVATE KEY-----
    MIIEowIBAAKCAQEAuR[...]
    -----END RSA PRIVATE KEY-----</pre></div><p>With this information, the initial chef-client run will be able to authenticate itself against the Chef <a id="id575" class="indexterm"/>organization and add the node. In the cloud-init logs, this step is found at this moment:</p><div class="informalexample"><pre class="programlisting">[...]
Starting Chef Client, version 12.14.89
Creating a new client identity for i-0913e870fb28af4bd using the validator key.
[...]</pre></div></div><div class="section" title="Applying a Chef cookbook at bootstrap using cloud-init"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec107"/>Applying a Chef cookbook at bootstrap using cloud-init</h3></div></div></div><p>We <a id="id576" class="indexterm"/>certainly want to apply at least an initial cookbook for configuring the instance. In this case, we'll simply apply the starter cookbook shipped with the starter kit, but we can add as many required roles and cookbooks as we want. Refer to the dedicated chapter of this book for more information on obtaining this cookbook:</p><div class="informalexample"><pre class="programlisting">#cloud-config
chef:
  run_list:
  - "recipe[starter]"</pre></div><p>In the logs, we'll see this being applied like this:</p><div class="informalexample"><pre class="programlisting">[...]
Loading cookbooks [starter@1.0.0]
Storing updated cookbooks/starter/attributes/default.rb in the cache.
Storing updated cookbooks/starter/recipes/default.rb in the cache.
Storing updated cookbooks/starter/templates/default/sample.erb in the cache.
Storing updated cookbooks/starter/files/default/sample.txt in the cache.
Storing updated cookbooks/starter/metadata.rb in the cache.
Processing log[Welcome to Chef, Sam Doe!] action write (starter::default line 4)
Welcome to Chef, Sam Doe!
Chef Run complete in 2.625856409 seconds</pre></div><p>Our instance is now both registered and configured automatically, as early as possible, with just a few lines in the cloud-config file.</p></div></div></div>
<div class="section" title="Deploying a remote Docker server using cloud-init"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec67"/>Deploying a remote Docker server using cloud-init	 </h1></div></div></div><p>It can <a id="id577" class="indexterm"/>be very handy to have a remote <a id="id578" class="indexterm"/>Docker server instead of the default local configuration from our workstation because of bandwidth issues, testing a production environment, maybe a customer demonstration, or distant team collaboration. Being able to send the usual Docker commands to a remote server has a <a id="id579" class="indexterm"/>multitude of advantages. For <a id="id580" class="indexterm"/>speed and comfort, we'll deploy a basic CoreOS system, add one user (Jane) and its public key. Docker will be modified to listen to the network through a socket kind of systemd service, and we'll configure the server time zone to be in New York.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec150"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Access to a cloud-config enabled infrastructure</li></ul></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec151"/>How to do it...</h2></div></div></div><p>Let's start by simply calling this server <code class="literal">"docker"</code>:</p><div class="informalexample"><pre class="programlisting">#cloud-config
hostname: "docker"</pre></div><p>In the final system, this will set the hostname to the correct value:</p><div class="informalexample"><pre class="programlisting">$ hostname
docker
$ cat /etc/hostname
docker</pre></div><p>Now let's create the <code class="literal">Jane</code> user, so she can log in to the instance to remotely help us. She needs to be in the <code class="literal">docker</code> group, so she can manipulate the containers, and she gave us her SSH public key. This is how it translates in the cloud-config file:</p><div class="informalexample"><pre class="programlisting">#cloud-config
users:
  - name: "jane"
    gecos: "Jane Docker"
    groups:
      - "docker"
    ssh-authorized-keys:
      - "ssh-rsa AAAAB[...] jane"</pre></div><p>In the final system, Jane is able to log in using her private key, and interact with the docker daemon as she's a member of the docker group:</p><div class="informalexample"><pre class="programlisting">jane@docker ~ $ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</pre></div><p>The SSH public key ends up in the following file:</p><div class="informalexample"><pre class="programlisting">jane@docker ~ $ cat .ssh/authorized_keys.d/coreos-cloudinit
ssh-rsa AAAAB [..] jane</pre></div><div class="section" title="Setting the timezone on CoreOS using cloud-init"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec108"/>Setting the timezone on CoreOS using cloud-init</h3></div></div></div><p>CoreOS <a id="id581" class="indexterm"/>uses a system built around NTP (short for Network Time Protocol), controlled by the <code class="literal">timedatectl</code> command. We won't find the usual <code class="literal">/etc/timezone</code> on CoreOS, so the default <code class="literal">timezone</code> directive from cloud-init we've seen earlier in this book won't work. To set the time zone to New York on CoreOS, we would set it like this:</p><div class="informalexample"><pre class="programlisting">$ /usr/bin/timedatectl set-timezone America/New_York</pre></div><p>Easy! So let's launch that command through a systemd unit in the cloud-config file, so we're sure the time zone is set. In-depth knowledge of systemd is out of the scope of this book, but to do that, we'll have to add two options to the unit: one that tells systemd to not think the unit has crashed because the command exited (<code class="literal">RemainAfterExit=yes</code>), and one that tells the unit type is not executing a long running process, but instead a short one that should exit before continuing (<code class="literal">Type=oneshot</code>).</p><p>Here's the unit in the <code class="literal">cloud-config.yml</code> file:</p><div class="informalexample"><pre class="programlisting">coreos:
  units:
  - name: settimezone.service
    command: start
    content: |
      [Unit]
      Description=Setting the timezone

      [Service]
      ExecStart=/usr/bin/timedatectl set-timezone America/New_York
      RemainAfterExit=yes
      Type=oneshot</pre></div></div><div class="section" title="Enabling Docker TCP socket for network access"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec109"/>Enabling Docker TCP socket for network access</h3></div></div></div><p>Our final <a id="id582" class="indexterm"/>objective is to be <a id="id583" class="indexterm"/>able to use a Docker Engine remotely from our workstation. The default Docker configuration is to listen to the Unix socket (<code class="literal">/var/run/docker.sock</code>)—and we want it to listen to a TCP socket on port 2375 (the default unencrypted port, it's highly recommended to configure TLS encryption; this will use the TCP/2376 by convention). To configure this, we'll use a systemd feature—socket activation. To make it short, this creates a systemd service that listens on port 2375, and spawns the regular <code class="literal">docker.service</code> unit along with the socket description. This way, this particular Docker Engine will answer to requests on the TCP socket and not on the Unix socket (while keeping the possibility to activate more TCP sockets, or keeping the default <code class="literal">docker.service</code> clean). Here's how it looks:</p><div class="informalexample"><pre class="programlisting">coreos:
  units:
  - name: docker-tcp.socket
    command: start
    enable: true
    content: |
      [Unit]
      Description=Docker Socket for the API

      [Socket]
      ListenStream=2375
      BindIPv6Only=both
      Service=docker.service

      [Install]
      WantedBy=sockets.target</pre></div><p>Let's start <a id="id584" class="indexterm"/>a remote server <a id="id585" class="indexterm"/>with this whole configuration and use it a little for the demonstration (in this example, the Docker remote host is <code class="literal">52.211.117.98</code>, and we'll launch an <code class="literal">nginx</code> container with HTTP port forwarding). Refer to the Docker section of this book for more information on the command-line options used:</p><div class="informalexample"><pre class="programlisting">user@workstation $ docker -H 52.211.117.98 run -it --rm -p 80:80 nginx
Unable to find image 'nginx:latest' locally
latest: Pulling from library/nginx
6a5a5368e0c2: Pull complete
4aceccff346f: Pull complete
c8967f302193: Pull complete
Digest: sha256:1ebfe348d131e9657872de9881fe736612b2e8e1630e0508c354acb0350a4566
Status: Downloaded newer image for nginx:latest  
1.2.3.4 - - [25/Sep/2016:16:06:30 +0000] "GET / HTTP/1.1" 200 612 "-" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36" "-"</pre></div><p>Make some requests on the remote Docker host HTTP port and it will answer. We now have a full on-demand CoreOS host, capable of giving us control over a Docker Engine remotely, using a nifty systemd configuration feature!</p></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec152"/>There's more...</h2></div></div></div><p>When <a id="id586" class="indexterm"/>connecting to various remote Docker Engines, we will sooner or later connect to a server not using the same <a id="id587" class="indexterm"/>version of the server as our client. In this case, we'll get the following error:</p><div class="informalexample"><pre class="programlisting">Error response from daemon: client is newer than server (client API version: 1.24, server API version: 1.22)</pre></div><p>The easy workaround is to override the <code class="literal">DOCKER_API_VERSION</code> environment variable and set it <a id="id588" class="indexterm"/>to the same value as the server (1.22 in this example):</p><div class="informalexample"><pre class="programlisting">$ DOCKER_API_VERSION=1.22 docker -H 52.211.117.98 ps</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note36"/>Note</h3><p>Docker 1.13 greatly improved this situation, by managing the version/feature negotiation between the client and the server directly in the CLI.</p></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec153"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For more information about systemd socket activation refer to <a class="ulink" href="http://0pointer.de/blog/projects/socket-activation.html">http://0pointer.de/blog/projects/socket-activation.html</a>.</li></ul></div></div></div></body></html>