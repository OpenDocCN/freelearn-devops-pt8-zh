<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Authoring Modules</h1>
                </header>
            
            <article>
                
<p>Authoring Puppet modules and manifests is the real heart of the work for your Puppet ecosystem.</p>
<p>So, you've perhaps already written at least a few modules for software components in your infrastructure, and there's already a great guide to getting started writing modules in the Puppet documentation at <a href="https://puppet.com/docs/pe/2017.3/quick_start_guides/writing_modules_nix_getting_started_guide.html">https://puppet.com/docs/pe/2017.3/quick_start_guides/writing_modules_nix_getting_started_guide.html</a>, so I won't waste any time going over that material again. But I'm sure that, in pursuit of mastering Puppet v5, what you would really like to do is to write those modules correctly.</p>
<p>Let's take that step together toward better quality modules in this chapter. I've spent a lot of time in the trenches over the last few years, gathering together best practices from some of the best projects across Europe and applying practices and software principles I've learned from both my university education and 15+ years in the industry. I hope I can introduce you to some shortcuts and make your life easier!</p>
<p>The following are a set of recommendations that I feel will really get you on the right path to higher quality Puppet modules and manifests:</p>
<ul>
<li>Using a decent IDE and plugins</li>
<li class="mce-root">Using a good module class structure:
<ul>
<li class="mce-root">Following the class-naming conventions</li>
<li class="mce-root">Having a single point of entry to the module</li>
<li class="mce-root">Using high cohesion and loose coupling principles</li>
<li class="mce-root">Using the encapsulation principle</li>
<li class="mce-root">Strongly typing your module variables</li>
</ul>
</li>
</ul>
<p class="mce-root"/>
<ul>
<li class="mce-root">Using the new Puppet Development Kit commands:
<ul>
<li class="mce-root">Creating the module framework and metadata</li>
<li class="mce-root">Creating the <kbd>init.pp</kbd></li>
<li class="mce-root">Creating further classes</li>
<li class="mce-root">Validating your module</li>
<li class="mce-root">Unit testing your module</li>
</ul>
</li>
<li class="mce-root">Staying on the lookout for code smells</li>
<li class="mce-root">Making sure you are not working with dead code</li>
<li class="mce-root">Working with the community</li>
<li class="mce-root">Using Puppet Forge</li>
<li class="mce-root">Writing great documentation</li>
<li class="mce-root">Adding module dependencies</li>
<li class="mce-root">Adding compatibility data for your modules
<ul>
<li class="mce-root">Operating systems support</li>
<li class="mce-root">Puppet and PE version support</li>
</ul>
</li>
<li class="mce-root">Using the new Hiera 5 module level data</li>
<li class="mce-root">Upgrading your templates from ERB to ERP syntax</li>
</ul>
<p class="mce-root">Let's examine each of these best practices now in turn.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a decent IDE and plugins</h1>
                </header>
            
            <article>
                
<p>Using a decent text editor with the plugins that equip you to write well for Puppet is a really  good step toward better quality. There are quite a few options out there, and it's best to use whatever suits your own unique writing style. Personally, I have used Atom (<a href="https://atom.io">https://atom.io</a>) most successfully, and recently installed it locally on my workstation. I used Eclipse many years ago (this has also been known previously as Geppetto), which I in fact felt was unwieldy due to a large memory footprint. It's also nice to remain fairly handy with Vim, especially for working on the command line server-side, or if you use a Linux OS on your workstation. There's also TextMate, for an macOS X only editor that has all of Apple's look and feel.</p>
<p>Let's take a look at some of the various options for an <strong>Integrated Development Machine </strong>(<strong>IDE</strong>) available to us as Puppet developers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Vim</h1>
                </header>
            
            <article>
                
<p>Vim (<a href="http://www.vim.org">http://www.vim.org</a>) is, of course, still a mainstay for text file editing. It has a very long history in the Unix world, and it's a very lightweight command-line text editor. Vim is just about as raw a text editor as you can get. It can be used as a lightning fast and efficient IDE if you have the memory and patience to learn the myriad keyboard commands. My advice is to start out with a few basic commands, and make an effort to pick up a few more each time you use Vim.</p>
<p>You can pimp your Vim and make it better suited for editing Puppet manifests. Let's take a look at that, assuming you've just grabbed a fresh Vim installation, and you have Git installed.</p>
<p>Move to your home directory and clone the given repository with the following commands:</p>
<pre><strong>cd ~</strong><br/><strong>git clone https://github.com/ricciocri/vimrc .vim</strong><br/><strong>cd .vim</strong><br/><strong>git pull &amp;&amp; git submodule init &amp;&amp; git submodule update &amp;&amp; git submodule status</strong><br/><strong>cd ~</strong><br/><strong>ln -s .vim/.vimrc</strong> </pre>
<p>Cloning the repository into your home directory's <kbd>.vim</kbd> directory will configure your Vim settings for you. The repository contains several submodules containing the following:</p>
<ul>
<li><strong>Pathogen</strong> (<a href="https://github.com/tpope/vim-pathogen">https://github.com/tpope/vim-pathogen</a>) is Vim guru Tim Pope's general-purpose add-on that allows you to manage your Vim <em>runtimepath</em> with ease and install Vim plugins and runtime files each in their own private directories, rather than having file collisions.</li>
<li><strong>Vim-puppet</strong> (<a href="https://github.com/rodjek/vim-puppet">https://github.com/rodjek/vim-puppet</a>) is the original Vim plugin written by Tim Sharpe, making Vim much more Puppet-friendly.</li>
<li><strong>snipmate.vim</strong> (<a href="https://github.com/msanders/snipmate.vim">https://github.com/msanders/snipmate.vim</a>) is a Vim script that implements some of TextMate's snippet features for Vim.</li>
<li><strong>Syntastic</strong> (<a href="https://github.com/vim-syntastic/syntastic">https://github.com/vim-syntastic/syntastic</a>) is a syntax-checking plugin that runs files through external syntax checkers and displays any resulting errors. This can be done from the command line with the <kbd>pdk validate</kbd> command, or automatically as files are saved.</li>
<li><strong>Tabular</strong> (<a href="https://github.com/godlygeek/tabular">https://github.com/godlygeek/tabular</a>) is used to line up your fat arrows (=&gt;) according to the <em>Puppet Style Guide</em>, so that it will pass running the <kbd>pdk validate</kbd> command. (We will cover the <kbd>pdk validate</kbd> command in full later.)</li>
<li><strong>vim-fugitive</strong> (<a href="https://github.com/tpope/vim-fugitive">https://github.com/tpope/vim-fugitive</a>) provides deep Git integration for Vim.</li>
</ul>
<p>I can't promise this will be a perfect Vim setup for your own personal Vim style, but it will certainly get you on the right path, and you will have Pathogen installed, so you can further tweak your Vim settings until you have it just how you like it.</p>
<p> You might also want to fork this repository in GitHub, so you can keep all your settings and share them with your team.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TextMate</h1>
                </header>
            
            <article>
                
<p>TextMate (<a href="http://macromates.com">http://macromates.com</a>) is an macOS X only editor, and there's a TextMate bundle available (<a href="https://github.com/masterzen/puppet-textmate-bundle">https://github.com/masterzen/puppet-textmate-bundle</a>) for editing Puppet manifests. First, install TextMate and Git (available with the command-line developer tools), and follow these commands to set up the Puppet bundle:</p>
<pre><strong>$ mkdir ~/temp</strong><br/><strong>$ cd ~/temp</strong><br/><strong>$ git clone https://github.com/masterzen/puppet-textmate-bundle.git Puppet.tmbundle</strong><br/><strong>$ mv ~/temp/Puppet.tmbundle ~/Library/Application\ Support/TextMate/Bundles/</strong><br/><strong>$ rm -fr ~/temp</strong></pre>
<p>Now select a manifest and open it with TextMate. In the <span class="packt_screen">TextMate</span> dialog, select <span class="packt_screen">Puppet</span> and <span class="packt_screen">Install Bundle</span>, and you are all ready to rock.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Atom</h1>
                </header>
            
            <article>
                
<p>Here's the IDE that I would recommend based on my own personal style, using my MacBook as the host OS. Atom (<a href="https://atom.io">https://atom.io</a>) is a fully featured IDE described as, <em>A hackable text editor for the 21st Century</em> and contains all the functionality you'd expect: cross-platform, package (that is, plugin) manager, auto-completion, file browser, multiple panes, find and replace, and so on.</p>
<p>GitHub has developed Atom, and they have built it with the goal of combining the convenience of a fully fledged IDE with the deep configurability of a classic but complex editor such as Vim.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>There are literally thousands of open source packages that add new features and functionality to Atom, and here are the ones I recommend specifically for Puppet development:</p>
<ul>
<li><kbd>language-puppet</kbd> (adds syntax highlighting and snippets to Puppet files)</li>
<li><kbd>linter-puppet-lint</kbd> (provides linter support to your Puppet manifests)</li>
<li><kbd>aligner-puppet</kbd> (aligns the fat arrows according to the Puppet Style Guide)</li>
<li><kbd>erb-snippets</kbd> (snippets and hotkeys for writing Puppet ERB templates)</li>
<li><kbd>linter-js-yaml</kbd> (parses your YAML files with JS-YAML)</li>
<li><kbd>tree-view-git-status</kbd> (displays the Git status of files in the tree view)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Visual Studio</h1>
                </header>
            
            <article>
                
<p>If you're a developer in the Windows and .NET world, then look no further than the Puppet language support for Visual Studio Code extension (<a href="https://marketplace.visualstudio.com/items?itemName=jpogran.puppet-vscode">https://marketplace.visualstudio.com/items?itemName=jpogran.puppet-vscode</a>).</p>
<p>It contains all the features you would expect for Puppet development in the Visual Studio IDE: syntax highlighting, code snippets, file validation, linting according to the Puppet Style Guide, IntelliSense for resources and parameters, importing from the <kbd>puppet resource</kbd> command, node graph previewing, and now, <strong>Puppet Development Kit</strong> (<strong>PDK</strong>) integration.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using good module and class structure</h1>
                </header>
            
            <article>
                
<p>This section contains a set of recommendations surrounding good module and class design. Bear in mind that Puppet development is, in principle, just like any other type of software development, and we've learned over many years in software development, and especially at O&amp;O software, that certain modular and class design principles make our development better. I also feel that part of our journey toward <em>infrastructure as code</em> is making our Puppet code just as well-designed, structured, and tested as any other application code.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Following the class-naming conventions</h1>
                </header>
            
            <article>
                
<p>There's a certain class-naming convention that has developed over time within the Puppet community, and it's really worth taking these into account when structuring your classes:</p>
<ul>
<li><kbd>init.pp</kbd>: <kbd>init.pp</kbd> contains the class named the same as the module, and is the main entry point for the module.</li>
<li><kbd>params.pp</kbd>: The <kbd>params.pp</kbd> pattern (more on this later in the chapter) is an elegant little hack, taking advantage of Puppet's class inheritance behavior. Any of the other classes in the module inherit from the <kbd>params</kbd> class, so have their parameters set appropriately.</li>
<li><kbd>install.pp</kbd>: The resources related to installing the software should be placed in an <kbd>install</kbd> class. The install class must be named <kbd>&lt;modulename&gt;::install</kbd> and must be located in the <kbd>install.pp</kbd> file.</li>
<li><kbd>config.pp</kbd>: The resources related to configuring the installed software should be placed in a <kbd>config</kbd> class. The <kbd>config</kbd> class must be named <kbd>&lt;modulename&gt;::config</kbd> and must be located in the <kbd>config.pp</kbd> file.</li>
<li><kbd>service.pp</kbd>: The resources related to managing the service for the software should be placed in a <kbd>service</kbd> class. The service class must be named <kbd>&lt;modulename&gt;::service</kbd> and must be located in the <kbd>service.pp</kbd> file.</li>
</ul>
<p>For software that is configured in a client/server style, see the following:</p>
<ul>
<li><kbd>&lt;modulename&gt;::client::install</kbd> and <kbd>&lt;modulename&gt;::server::install</kbd> would be the class names for the <kbd>install.pp</kbd> file placed in the <kbd>client</kbd> and <kbd>server</kbd> directories accordingly</li>
<li><kbd>&lt;modulename&gt;::client::config</kbd> and <kbd>&lt;modulename&gt;::server::install</kbd> would be the class names for the <kbd>config.pp</kbd> file placed in the <kbd>client</kbd> and <kbd>server</kbd> directories accordingly</li>
<li><kbd>&lt;modulename&gt;::client::service</kbd> and <kbd>&lt;modulename&gt;::server::service</kbd> would be the class names for the <kbd>service.pp</kbd> files placed in the <kbd>client</kbd> and <kbd>server</kbd> directories accordingly</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Having a single point of entry to the module</h1>
                </header>
            
            <article>
                
<p><kbd>init.pp</kbd> should be the single entry point for the module. In this way, someone reviewing the documentation in particular, as well as the code in <kbd>init.pp</kbd>, can have a complete overview of the module's behavior.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>If you've used encapsulation effectively and used descriptive class names, you can get a very good sense just by looking at <kbd>init.pp</kbd> of how the module actually manages the software.</p>
<div class="packt_infobox">Modules that have configurable parameters should be configurable in a single way and in this single place. The only exception to this would be, for example, a module such as the Apache module, where one or more virtual directories are also configurable.</div>
<p>Ideally, you can use your module with a simple include statement, as follows:</p>
<pre>include mymodule</pre>
<p>You can also use it with the use of a class declaration, as follows:</p>
<pre>class {'mymodule':<br/>  myparam =&gt; false,<br/>}</pre>
<p>The <em>Apache virtual directory</em> style of configuring a number of defined types would be the third way to use your new module:</p>
<pre>mymodule::mydefine {‘define1':<br/>  myotherparam =&gt; false,<br/>}</pre>
<p>The anti-pattern to this recommendation would be to have a number of classes other than <kbd>init.pp</kbd> and your defined types with parameters expecting to be set.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using high cohesion and loose coupling principles</h1>
                </header>
            
            <article>
                
<p>As far as possible, Puppet modules should be made up of classes with a single responsibility. In software engineering, we call this high, functional cohesion. Cohesion in software engineering is the degree to which the elements of a certain module belong together. Try to make each class have a single responsibility, and don't <span>arbitrarily </span>mix together unrelated functionalities in your classes.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the encapsulation principle</h1>
                </header>
            
            <article>
                
<p>As far as possible, these classes should use encapsulation to hide the implementation details from the user; for example, users of your module don't need to be aware of individual resource names. In software engineering, we call this encapsulation. For example, in a <kbd>config</kbd> class, we can use several resources, but the user doesn't need to know all about them. Rather, they just simply know that they should use the <kbd>config</kbd> class for the configuration of the software to work correctly.</p>
<p class="mce-root">Having classes contain other classes can be very useful, especially in larger modules where you want to improve code readability. You can move chunks of functionality into separate files, and then use the contain keyword to refer to these separated chunks of functionality.</p>
<div class="mce-root packt_infobox">See <a href="https://puppet.com/docs/puppet/5.3/lang_containment.html">https://puppet.com/docs/puppet/5.3/lang_containment.html</a> website for a reminder about the contain keyword.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Providing sensible, well-thought-out parameter defaults</h1>
                </header>
            
            <article>
                
<p>If the vast majority of the people using your module will use the module with a certain parameter set, then of course it makes sense to set that parameter with a default.</p>
<p>Carefully think through how your module is used, and put yourself in the position of a nonexpert user of your own module.</p>
<p>Present the available module parameters in a sensible order, with more often accessed settings before least accessed settings, as opposed to some arbitrary order, such as alphabetical order.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Strongly typing your module variables</h1>
                </header>
            
            <article>
                
<p>In versions of Puppet proper to the new language features which came out in version 4, we would create <kbd>class</kbd> parameters with undefined data types, and then, if we were being very nice, we would use the <kbd>stdlib validate_&lt;datatype&gt;</kbd> functions to check appropriate values for those variables:</p>
<pre>class vhost (<br/>  $servername,<br/>  $serveraliases,<br/>  $port<br/>)<br/>{ ...</pre>
<p>Puppet 4 and 5 have an in-built way of defining the data type that a parameterized class accepts. See the following example:</p>
<pre>class vhost (<br/>  String  $servername,<br/>  Array   $serveraliases,<br/>  Integer $port<br/>)<br/>{ ...</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the new Puppet Development Kit commands</h1>
                </header>
            
            <article>
                
<p>Some features to improve quality in your Puppet development, such as <kbd>puppet-lint</kbd>, <kbd>puppet-rspec</kbd>, and commands such as <kbd>puppet module create</kbd> have been around for some time, but previously, you had to discover these tools out there in the wild, install them, and figure out how to use them effectively yourself.</p>
<p>Puppet decided back in August 2017 to bring these things all together on the client side and make them a breeze to use with the new Puppet Development Kit version 1.0. I can certainly recall <kbd>puppet-rspec</kbd> always took some time to set up and get working correctly. Now it's all really easy.</p>
<p>Let's take a whistle-stop tour of the module development process using the new PDK 1.0.</p>
<ul>
<li><strong>Creating the module framework and metadata</strong>: The <kbd>pdk new module</kbd>  <span>command runs in the same way as the old <kbd>puppet module create</kbd> command, as follows:</span></li>
</ul>
<pre style="padding-left: 60px"><strong>$ pdk new module zope –-skip-interview</strong></pre>
<ul>
<li><strong>Creating the</strong> <kbd>init.pp</kbd>: There is now a set of creation commands for manifests inside modules, as follows:
<ul>
<li><kbd>pdk new class</kbd> (<a href="https://puppet.com/docs/pdk/1.0/pdk_reference.html#pdk-new-class-command">https://puppet.com/docs/pdk/1.0/pdk_reference.html#pdk-new-class-command</a>)</li>
<li><kbd>pdk new defined_type</kbd> (<a href="https://puppet.com/docs/pdk/1.0/pdk_reference.html#pdk-new-definedtype-command">https://puppet.com/docs/pdk/1.0/pdk_reference.html#pdk-new-definedtype-command</a>)</li>
<li><kbd>pdk new task</kbd> (<a href="https://puppet.com/docs/pdk/1.0/pdk_reference.html#pdk-new-task-command">https://puppet.com/docs/pdk/1.0/pdk_reference.html#pdk-new-task-command</a>)—see <a href="0d435242-d7ac-4727-b632-71957c064919.xhtml">Chapter 6</a>, <em>Workflow</em>, for more details on the new Puppet task functionality.</li>
</ul>
</li>
</ul>
<p style="padding-left: 60px">So, just use the name of the module to create <kbd>init.pp</kbd>:</p>
<pre style="padding-left: 60px"><strong>$ pdk new class zope</strong></pre>
<p style="padding-left: 60px">These commands now negate any need for snippets in your text editor to create the comments, declarations, and other boilerplate code.</p>
<ul>
<li><strong>Creating further classes</strong>: Create any further classes using the same command. See the following example:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ pdk new class params</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Validating your module</h1>
                </header>
            
            <article>
                
<p>As you are working, you can use the new <kbd>pdk validate</kbd> command (<a href="https://puppet.com/docs/pdk/1.0/pdk_reference.html#pdk-validate-command">https://puppet.com/docs/pdk/1.0/pdk_reference.html#pdk-validate-command</a>) to assist with checking that the module compiles, conforms to the Puppet Style Guide, and has valid metadata:</p>
<pre><strong>$ pdk validate</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unit testing your module</h1>
                </header>
            
            <article>
                
<p>The number one most important thing you can do to bring quality to your modules is to test them! Testing really is one of the most important aspects of software quality assurance in any field of software development. In the agile development community, we've been banging on the table about automated testing for more than 10 years!</p>
<p>Puppet RSpec (<a href="http://rspec-puppet.com/tutorial">http://rspec-puppet.com/tutorial</a>) has been allowing the Puppet community to unit test their modules for quite some time, but it's even easier now with the new PDK 1.0, as everything is set up ready, and you can just add your testing code and run the tests.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>From a Puppet perspective, unit testing means <em>checking the output from the compiler</em>. Are the resources contained in the compiled relationship resource catalog, and is their order as expected, given the parameters passed and/or facts present?</p>
<p>When you begin to write tests in Puppet-RSpec, it seems at first like all you are doing is rewriting the Puppet manifests in another Ruby-like language. There is, however, really more to it than that. If there is some reasonable complexity to the module's functionality, for example, testing the dynamic content produced by Puppet templates, support for multiple operating systems, and different actions according to the passed parameters, then these tests actually form a safety net when editing or adding new functionality to your modules, protecting against regressions when refactoring, or upgrading to a new Puppet release.</p>
<p>Let's carry on from the previous two sections and use the development kit to unit test our module. Whenever you generate a class using the <kbd>pdk new class</kbd> command, PDK creates a corresponding unit test file. This file, located in your module's <kbd>/spec/classes</kbd> folder, already includes a template for writing your unit tests (see <a href="http://rspec-puppet.com/tutorial">http://rspec-puppet.com/tutorial</a>). You can then run the tests using the following command:</p>
<pre><strong>$ pdk test unit</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Staying on the lookout for code smells</h1>
                </header>
            
            <article>
                
<p>Be on the lookout for code smells, especially as your Puppet code base ages! The following link is a research project that describes a bunch of Puppet <em>code smells</em>, which is an XP (extreme programming) term meaning code issues—usually meaning either a poor design or implementation: <a href="http://www.tusharma.in/wp-content/uploads/2016/03/ConfigurationSmells_preprint.pdf">http://www.tusharma.in/wp-content/uploads/2016/03/ConfigurationSmells_preprint.pdf</a></p>
<p>Let's quickly run through using the <kbd>Puppeteer</kbd> Python-based tool used in the preceding research project:</p>
<ol>
<li>Ensure you have the latest Java SDK installed.</li>
<li>Move to your <kbd>workspace</kbd> directory <kbd>~/workspace</kbd>, and clone the following Git repository:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git clone https://github.com/tushartushar/Puppeteer</strong><br/><strong>$ cd Puppeteer</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="3">
<li>Download the PMD tool (<a href="https://github.com/pmd/pmd">https://github.com/pmd/pmd</a> ) and update the path in the shell script. PMD is an extensible static code analyzer with <strong>copy-paste-detector</strong> (<strong>CPD</strong>) built-in.</li>
<li>Update the folder path where all the Puppet repositories are placed.</li>
<li>Execute the <kbd>cpdRunner.sh</kbd> shell script to carry out clone detection using the PMD-CPD tool.</li>
<li>Update the <kbd>REPO_ROOT</kbd> <span>constant </span>in <kbd>SmellDetector/Constants.py</kbd>, which represents the folder path where all the Puppet repositories are placed.</li>
<li>Execute <kbd>Puppeteer.py</kbd>.</li>
<li>Analyze Puppet repository with <kbd>puppet-lint</kbd> (o<span>ptional</span>).</li>
<li>Execute <kbd>puppet-lintRunner.py</kbd> after setting the repository root.</li>
<li>Set the repository root in <kbd>Puppet-lint_aggregator/PLConstants.py</kbd>.</li>
<li>Execute <kbd>PuppetLintRules.py</kbd>, it will generate a consolidated summary of the analysis for all the analyzed projects.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with dead code</h1>
                </header>
            
            <article>
                
<p>Another issue that can often hit you as your Puppet code base ages is unused code in your codebase. But, there's a tool out there in the wild we can use to keep on top of this issue.</p>
<p><kbd>puppet-ghostbuster</kbd> essentially compares what is actually being used (stored in PuppetDB) to what you think you are using (in your code base directory). This give you the opportunity to slash and burn anything that's really unused. This is great from the point of view of software maintainability. A smaller code base is simply cheaper to maintain!</p>
<p>Let's quickly run through using this Ruby gem.</p>
<p>Make the following settings in your environment variables:</p>
<ul>
<li><kbd>HIERA_YAML_PATH</kbd>: The location of the <kbd>hiera.yaml</kbd> file. It defaults to <kbd>/etc/puppetlabs/code/hiera.yaml</kbd>.</li>
<li><kbd>PUPPETDB_URL</kbd>: The URL or the PuppetDB. It defaults to <kbd>http://puppetdb:8080</kbd>.</li>
<li><kbd>PUPPETDB_CACERT_FILE</kbd>: Your site's CA certificate.</li>
<li><kbd>PUPPETDB_CERT_FILE</kbd>: A SSL certificate signed by your site's Puppet CA.</li>
<li><kbd>PUPPETDB_KEY_FILE</kbd>: The private key for that certificate.</li>
</ul>
<p class="mce-root"/>
<p>Run the command as follows:</p>
<pre><strong>$ find . -type f -exec puppet-lint --only-checks ghostbuster_classes,ghostbuster_defines,ghostbuster_facts,ghostbuster_files,ghostbuster_functions,ghostbuster_hiera_files,ghostbuster_templates,ghostbuster_types {} \+</strong></pre>
<p>You can add to and remove from the comma-delimited items to check for unused classes, defined types, facts, files, functions, Hiera files, templates, and types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Puppet Forge</h1>
                </header>
            
            <article>
                
<p>It maybe goes without saying that there's no reason to reinvent the wheel when you are authoring your Puppet modules. A few minutes in Puppet Forge (<a href="https://forge.puppet.com/">https://forge.puppet.com</a>) can really save you days and days of editing. There are, at the time of writing, more than 5,000 Forge modules, so it makes a great deal of sense to leverage all that hard work done by the Puppet community. Search the Forge first for that bit of software; it's more than likely that something already exists.</p>
<p>In my experience, I have found there is often something that <em>almost</em> does the job. Maybe there's a module (usually an unsupported and unapproved one) that maybe, for example, performs the management for the software you require, but it's only for Ubuntu, and you're using Red Hat. It's usually a better approach to fork that module, whatever shape it's in, and work on that, rather than start from scratch.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with the community</h1>
                </header>
            
            <article>
                
<p>The best way for me to describe this best practice is to use an anti-pattern as an example.</p>
<p>I once came across a Puppet developer who would start a module completely from scratch, and then copy and paste lines of code from a Forge module into the new module. From then on, that module exists entirely outside the community! It's not a fork even, so to integrate changes that have been made over time from the community becomes a real pain. You would have to cherry-pick those changes to get the functionality into your own, and you will probably still be left with regression problems. Generally, a best practice is to always at the very least fork the Forge module! This means you get the Git history, which often contains the thoughts that have gone into producing that module.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>You see, if you were ever a reader of the great book <em>The Cathedral &amp; the Bazaar: Musings on Linux and Open Source by an Accidental Revolutionary</em> (<a href="https://www.amazon.com/Cathedral-Bazaar-Musings-Accidental-Revolutionary/dp/0596001088">https://www.amazon.com/Cathedral-Bazaar-Musings-Accidental-Revolutionary/dp/0596001088</a>), then you will understand that the Linux-orientated philosophy of software development through a <em>bazaar</em>, collaborative working style trumps spinning off development into a cathedral, independent working style. Well, that's my take on this developer's working style. He was working cathedral-ly, as opposed to bazaar-ly. Effectively, you are making the decision to pit your cathedral team against the multitude of the bazaar, and to my mind, that's simply not wise project management when it comes to giving you a competitive advantage in the internet age.</p>
<p>Sometimes, modules on the Forge get a bit out of date. If the metadata for the module is out of date, you can always produce that again using the PDK <kbd>new module</kbd> command (<a href="https://puppet.com/docs/pdk/1.0/pdk_generating_modules.html">https://puppet.com/docs/pdk/1.0/pdk_generating_modules.html#create-a-module-with-pdk</a>) and commit the new metadata.</p>
<p>Of course, to be a great Puppet community member, it would be an even better practice to make pull requests for the changes you have made and contribute to the work of the community.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing great documentation</h1>
                </header>
            
            <article>
                
<p>Another important recommendation is to simply write great documentation. There's nothing worse, I feel, as a developer, than to have to dig into the code to understand how a module works; it's like having to lift the hood of the car to understand how to drive a vehicle!</p>
<p>Get good at writing English to convey technical ideas! I really think it's a skill that every good developer really needs to master.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Grabbing yourself a Markdown editor</h1>
                </header>
            
            <article>
                
<p>Puppet modules use markdown for their documentation formatting. So it makes sense to use either a standalone Markdown editor, or some plugins for your IDE, so that you can create your quality documentation appropriately. Following on from our selection of code IDEs that we considered earlier in the chapter, the corresponding markdown plugins follow.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Vim</h1>
                </header>
            
            <article>
                
<p>You can use the vim-instant-markdown plugin (<a href="https://github.com/suan/vim-instant-markdown">https://github.com/suan/vim-instant-markdown</a>) if you're a vim fan.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TextMate</h1>
                </header>
            
            <article>
                
<p>You can use the TextMate markdown bundle (<a href="https://github.com/textmate/markdown.tmbundle">https://github.com/textmate/markdown.tmbundle</a>) if you enjoy the Apple look and feel of TextMate.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Atom</h1>
                </header>
            
            <article>
                
<p>If, like me, you enjoy using Atom, you can use the Markdown Preview Plus package (<a href="https://atom.io/packages/markdown-preview-plus">https://atom.io/packages/markdown-preview-plus</a><span>).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Visual Studio</h1>
                </header>
            
            <article>
                
<p>If you're a developer in the Windows and .NET world, then look no further than the Markdown editor extension (<a href="https://marketplace.visualstudio.com/items?itemName=MadsKristensen.MarkdownEditor">https://marketplace.visualstudio.com/items?itemName=MadsKristensen.MarkdownEditor</a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Standalone Markdown editors</h1>
                </header>
            
            <article>
                
<p>If you would rather use a standalone Markdown editor, I can recommend personally MacDown for macOS X. My (very) short list of standalone Markdown editors for various operating systems follows.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Remarkable</h1>
                </header>
            
            <article>
                
<p>If you're using Linux, then Remarkable is probably the best standalone editor. It also works on Windows. Some of its features include live preview, exporting to PDF and HTML, GitHub markdown, custom CSS, syntax highlighting, and keyboard shortcuts.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">MacDown</h1>
                </header>
            
            <article>
                
<p>If you would rather use a standalone Markdown editor, I can recommend MacDown for macOS X, which is free (open source). It's heavily inspired by Mou, and is designed with web developers in mind. It has configurable syntax highlighting, live preview, and auto-completion. If you're looking for a lean, fast, configurable standalone Markdown editor, this might be the one for you.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding module dependencies</h1>
                </header>
            
            <article>
                
<p>Edit the module's <kbd>metadata.json</kbd> file to add module dependencies. See the following example:</p>
<pre>"dependencies": [<br/>    { "name":" stankevich/python",<br/>       "version_requirement":"&gt;= 1.18.x"<br/>     }<br/>  ]</pre>
<p>The <kbd>name</kbd> key is the name of the requirement, namely, <kbd>"pe"</kbd> or <kbd>"puppet"</kbd>. The <kbd>version_requirement</kbd> key is a semver (<a href="http://semver.org">http://semver.org</a>) value or range. See the following examples:</p>
<ul>
<li><kbd>1.18.0</kbd></li>
<li><kbd>1.18.x</kbd></li>
<li><kbd>&gt;= 1.18.x</kbd></li>
<li><kbd>&gt;=1.18.x &lt;2.x.x</kbd></li>
</ul>
<p>These would all be valid values for <kbd>version_requirement</kbd>.</p>
<p>Check the <kbd>metadata.json</kbd> file <span>for validity </span>afterwards using the new PDK command, as follows:</p>
<pre><strong>$ pdk validate metadata</strong></pre>
<p>The great thing about adding module dependencies is the fact that, when you run the <kbd>puppet module download</kbd> command, Puppet will download all the module dependencies <span>accordingly</span>.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding compatibility data for your modules</h1>
                </header>
            
            <article>
                
<p>This section introduces you to adding compatibility data for the module designed for your version of Puppet or Puppet Enterprise and the operating system you want to work with. To begin with, Edit the module's <kbd>metadata.json</kbd> file to add compatibility data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Operating systems support</h1>
                </header>
            
            <article>
                
<p>Express the operating systems your module supports in the module's <kbd>metadata.json</kbd>, as shown in the following example:</p>
<pre>"operatingsystem_support": [<br/>       { "operatingsystem": "RedHat", },<br/>       { "operatingsystem": "Ubuntu", },<br/>]</pre>
<p>The Facter facts <kbd>operatingsystem</kbd> and <kbd>operatingsystemrelease</kbd> are expected. Here's a more complete example:</p>
<pre>"operatingsystem_support": [<br/>       {<br/>           "operatingsystem":"RedHat",<br/>           "operatingsystemrelease":[ "5.0", "6.0" ]<br/>       },<br/>       {<br/>           "operatingsystem": "Ubuntu",<br/>           "operatingsystemrelease": [<br/>               "12.04",<br/>               "10.04"<br/>           ]<br/>       }<br/>   ]</pre>
<p>Check the <kbd>metadata.json</kbd> file <span>for validity </span>afterwards using the new <kbd>pdk</kbd> command:</p>
<pre><strong>$ pdk validate metadata</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Puppet and PE version support</h1>
                </header>
            
            <article>
                
<p>The <kbd>requirements</kbd> key in the <kbd>metadata.json</kbd> file is a list of external requirements for the module in the following format:</p>
<pre>"requirements": [ {“name”: “pe”, “version_requirement”: “5.x”}]</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p><kbd>name</kbd> is the name of the requirement, for example <kbd>"pe"</kbd> or <kbd>"puppet"</kbd>. <kbd>version_requirement</kbd> can be a semver (<a href="http://semver.org">http://semver.org</a>) version range, similar to dependencies.</p>
<p>Again, you can check the <kbd>metadata.json</kbd> file <span>for validity </span>afterwards using the new PDK command, as follows:</p>
<pre><strong>$ pdk validate metadata</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the new Hiera 5 module level data</h1>
                </header>
            
            <article>
                
<p>For quite some time when module writing, we've been using the <kbd>params.pp</kbd> pattern. One class in the module, by convention called <kbd>&lt;MODULENAME&gt;::params</kbd>, sets the variables for any of the other classes:</p>
<pre>class zope::params {<br/>  $autoupdate = false,<br/>  $default_service_name = 'ntpd',<br/><br/><br/>  case $facts['os']['family'] {<br/>    'AIX': {<br/>      $service_name = 'xntpd'<br/>    }<br/>    'Debian': {<br/>      $service_name = 'ntp'<br/>    }<br/>    'RedHat': {<br/>      $service_name = $default_service_name<br/>    }<br/>  }<br/>}</pre>
<p>So, you can see here that we are using some conditional logic depending on the <kbd>os::family</kbd> fact, so that the <kbd>service_name</kbd> variable can be set appropriately. We are also exposing the <kbd>autoupdate</kbd> variable, and giving it a default value.</p>
<p>This <kbd>params.pp</kbd> pattern is an elegant little hack, which takes advantage of Puppet's idiosyncratic class inheritance behavior (using inheritance is generally not recommended in Puppet). Then, any of the other classes in the module inherit from the <kbd>params</kbd> class, to have their parameters set appropriately, as shown in the following example:</p>
<pre>class zope (<br/>  $autoupdate   = $zope::params::autoupdate,<br/>  $service_name = $zope::params::service_name,<br/>) inherits zope::params {<br/> ...<br/>}</pre>
<p>Since the release of Hiera 5, we are able to simplify our module complexity considerably. By using Hiera-based defaults, we can simplify our module's main classes, and they no longer need to inherit from <kbd>params.pp</kbd>. Additionally, you no longer need to explicitly set a default value with the <kbd>=</kbd> operator in the parameter declaration.</p>
<p>Let's look at the equivalent configuration to the <kbd>params.pp</kbd> pattern using Hiera 5.</p>
<p>First of all, in order to use this new functionality, the <kbd>data_provider</kbd> key needs to be set to the <kbd>heira</kbd> <span>value </span>in the module's <kbd>metadata.json</kbd> file:</p>
<pre>...<br/>"data_provider": "hiera",<br/>...</pre>
<p>Next, we need to add a <kbd>hiera.yaml</kbd> file to the root directory of the module:</p>
<pre>---<br/>version: 5<br/>defaults:<br/>  datadir: data<br/>  data_hash: yaml_data<br/>hierarchy:<br/>  - name: "OS family"<br/>    path: "os/%{facts.os.family}.yaml"<br/><br/><br/>  - name: "common"<br/>    path: "common.yaml"</pre>
<p>We can then add three files to the <kbd>/data</kbd> directory (note that the <kbd>datadir</kbd> setting in the <kbd>hiera.yaml</kbd> file). The first file of these three is used to set the AIX <kbd>service_name</kbd> variable:</p>
<pre># zope/data/os/AIX.yaml<br/>---<br/>zope::service_name: xntpd</pre>
<p>The second file is used to set the Debian <kbd>service_name</kbd> variable:</p>
<pre># zope/data/os/Debian.yaml<br/>zope::service_name: ntp</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>And finally, there is the common file, and Hiera will fall through to this file to find its values if it doesn't find a corresponding operating system file when looking for the <kbd>service_name</kbd> setting, or a value for <kbd>autoupdate</kbd> when searching the previous two files:</p>
<pre># ntp/data/common.yaml<br/>---<br/>ntp::autoupdate: false<br/>ntp::service_name: ntpd</pre>
<p>We will look at Hiera 5 in much more detail in <a href="cea19359-3ab3-4ee7-99d5-be2e4cd1f992.xhtml">Chapter 4</a>, <em>Hiera 5</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have covered a lot of ground, and I've introduced a bunch of best practices you can use to produce better quality component modules.</p>
<p>In the next chapter, we'll still be covering development in Puppet DSL, and turn our attention to two special modules: role and profile, which can help us to build reusable, configurable, and refactorable site-wide configuration code.</p>


            </article>

            
        </section>
    </body></html>