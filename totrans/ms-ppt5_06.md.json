["```\n# Clone the remote git repository for the module. You can skip this step if the\n# repository is already present on your local system\ngit clone git@gitserver.com:puppet/module.git\n\n# If the repository is already local on the system, we'll just want to update our\n# local master branch\ngit pull origin master\n\n# Check out a new environment based on the existing master branch, which is the\n# default branch of a git repository, and the branch we should start on on a clone.\ngit checkout -b new_feature\n\n# We'll edit some files to add new features\n\n# Adding new paramters to init\nvim manifests/init.pp - Adding new parameters to init\n# Adding a new feature to config\nvim manifests/config.pp\n# Ensuring the new feature is represented in the deployed template\nvim templates/file.epp\n\n# Add all edited files to git staging, assuming you're at the base of the repository\ngit add .\n\n# Add an atomic commit, not only describing what the commit is, but why it was done\ngit commit -m 'Added new code to support feature requested by client'\n\n# Push this code back to the origin repository as the new branch\ngit push origin new_feature\n```", "```\n# This step is not needed if the repository is already on the local file system\ngit clone git@gitserver.com:puppet/control-repo.git\n\n# We'll assume integration is the pre-production branch used by the organization\n# to stage changes before moving into production-like branches\n# Remember, there usually is no master branch in a control repository, so we want\n# to target a specific branch to work against.\ngit checkout integration\n\n# If this repo has been freshly cloned, git pull shouldn't provide any new updates,\n# but it's safe to run either way. If the repository has already been cloned in the\n# past, you definitely want to run this command to pull the latest commits from \n# upstream.\ngit pull origin integration\n\n# We'll perform a second checkout, with the -b flag to indicate a new branch based on the existing branch\ngit checkout -b new_feature\n\n```", "```\n# Edit our files\n\n# Change the branch of the component module to new_feature\nvim Puppetfile\n\nmod 'module',\n git => git@gitserver.com:puppet/module.git,\n branch => 'new_feature'\n\n# Make a change in the profile that utilizes the component modules\nvim site/profiles/manifests/baseline.pp\n\n# Add our new changes, to be staged for a commit\ngit add .\n\n# Commit our changes\ngit commit -m 'Supporting new Feature to support <effort>'\n```", "```\n\n# Push our code back to the control repository as a new branch intended to be\n# realized as a new environment on the Puppet Master\ngit push origin new_feature\n```", "```\n# If PE Client Tools are not installed locally, the Puppet Master comes with them\n# installed by default. We'll assume that the PE client tools are not already\n# installed and log in to the Puppet Master\nssh user@puppet.org.net\n\n# Generate an authorization token to allow your PE Console user to deploy code\npuppet-access login\n\n# Use our access token to deploy our new environment. Notice the -w flag, which\n# triggers the client tools to wait and give you a pass or fail message on the\n# status of the deployment.\npuppet-code deploy new_feature -w\n```", "```\nnode 'test.node' {\n  include relevant_role_or_profile\n  include new_feature\n}\n```", "```\n# data/host/test.node.yaml\n---\nclassification:\n  - relevant_role_or_profile\n  - new_feature\n\n# manifests/site.pp\n\n# Notice the lack of a node group around the include statement\ninclude $::classification\n```", "```\n# Start in the repository with the change. This could be a component module\n# or the control repository. We're assuming each repository is still on the\n# branch from the last step, and no pulls or branch changes are necessary.\n\n# Edit the file with the targeted changes\nvim manifests/manifest.pp\n\n# Add the file to the git staging area\ngit add manifests/manifest.pp\n\n# Commit the file to the repository\ngit commit -m 'Fixing specific bug'\n\n# Push the repository back to upstream origin\ngit push origin new_feature\n\n# From the Puppet Master, or a workstation with PE Client Tools\n\n# Log in with RBAC\npuppet-access login\n\n# Deploy the environment\npuppet-code deploy new_feature -w\n\n# On the test node\n\n# Run the agent, observe the results\npuppet agent -t\n\n# Repeat as necessary until issues are solved\n```", "```\n# Many Enterprise-focused git repositories have built in merge features, that ar\n# likely more robust and easier to use than a simple git merge. If you have an in\n# house git solution, follow the program documentation on a merge request\n\n# On Module\n# We'll change to target branch, in this case master\n$ git checkout master\n\n$ git merge feature_branch\nUpdating 0b3d899..227a02e\nFast-forward\n README.md | 1 +\n 1 file changed, 1 insertion(+)\n create mode 100644 README.md\n```", "```\n\n# Push the branch to upstream repository so Puppet can find it.\n$ git push origin master\n```", "```\nrary at Ryans-MBP in ~/workspace/packt/module (master)\n$ git tag 'v1.4'\n\n$ git tag -l\nv1.4\n\n$ git push origin v1.4\n```", "```\n# Production-like branch, tagged with a solid version number\nforge https://forge.puppetlabs.com\n\nmod 'module',\n git => 'git@gitserver.com:puppet/module.git',\n tag => 'v1.4'\n```", "```\n# From directory pdk new module was run in, enter the module, create a\n# git repository and add all files to staging\n$ cd module\n$ git init\n$ git add .\n\n# Initial Commit is a good common message as a starting point\n$ git commit -m 'Initial Commit'\n\n# Add the upstream remote\n$ git remote add origin git@gitserver.com:puppet/module.git\n\n# Push to master and begin regular module development workflow\n$ git push origin master\n```", "```\n$ pdk new class config\npdk (INFO): Creating '/Users/rary/workspace/packt/module/manifests/config.pp' from template.\npdk (INFO): Creating '/Users/rary/workspace/packt/module/spec/classes/config_spec.rb' from template\n\n# Sample with folders\n$ pdk new class server::main\npdk (INFO): Creating '/Users/rary/workspace/packt/module/manifests/server/main.pp' from template.\npdk (INFO): Creating '/Users/rary/workspace/packt/module/spec/classes/server/main_spec.rb' from template.\n```", "```\n$ pdk validate\npdk (INFO): Running all available validators...\npdk (INFO): Using Ruby 2.4.4\npdk (INFO): Using Puppet 5.5.1 [![](img/eb51e960-235c-4a31-90ab-ed603c863429.png)] Checking metadata syntax (metadata.json tasks/*.json).\n[![](img/eb51e960-235c-4a31-90ab-ed603c863429.png)] Checking module metadata style (metadata.json).\n[![](img/eb51e960-235c-4a31-90ab-ed603c863429.png)] Checking task metadata style (tasks/*.json).\n[![](img/eb51e960-235c-4a31-90ab-ed603c863429.png)] Checking Puppet manifest syntax (**/**.pp).\n[![](img/eb51e960-235c-4a31-90ab-ed603c863429.png)] Checking Puppet manifest style (**/*.pp).\n[![](img/eb51e960-235c-4a31-90ab-ed603c863429.png)] Checking Ruby code style (**/**.rb).\n\n```", "```\n#Invalid Metadata.json\n\n$ pdk validate\n/opt/puppetlabs/pdk/private/ruby/2.4.4/lib/ruby/gems/2.4.0/gems/pdk-1.5.0/lib/pdk/module/metadata.rb:142:in `validate_name': Invalid 'name' field in metadata.json: Field must be a dash-separated user name and module name. (ArgumentError)\n```", "```\n# Failed Parser Validation\n# Can be ran alone with puppet parser validate\n\n$ pdk validate\npdk (INFO): Running all available validators...\npdk (INFO): Using Ruby 2.4.4\npdk (INFO): Using Puppet 5.5.1\n[![](img/eb51e960-235c-4a31-90ab-ed603c863429.png)] Checking metadata syntax (metadata.json tasks/*.json).\n[![](img/eb51e960-235c-4a31-90ab-ed603c863429.png)] Checking module metadata style (metadata.json).\n[![](img/eb51e960-235c-4a31-90ab-ed603c863429.png)] Checking Puppet manifest syntax (**/**.pp).\n[![](img/eb51e960-235c-4a31-90ab-ed603c863429.png)] Checking Ruby code style (**/**.rb).\ninfo: task-metadata-lint: ./: Target does not contain any files to validate (tasks/*.json).\nError: puppet-syntax: manifests/init.pp:9:1: Could not parse for environment production: Syntax error at '}'\n```", "```\n$ pdk validate\npdk (INFO): Running all available validators...\npdk (INFO): Using Ruby 2.4.4\npdk (INFO): Using Puppet 5.5.1\n[![](img/eb51e960-235c-4a31-90ab-ed603c863429.png)] Checking metadata syntax (metadata.json tasks/*.json).\n[![](img/eb51e960-235c-4a31-90ab-ed603c863429.png)] Checking module metadata style (metadata.json). [![](img/eb51e960-235c-4a31-90ab-ed603c863429.png)]Checking Puppet manifest syntax (**/**.pp).\n[![](img/eb51e960-235c-4a31-90ab-ed603c863429.png)] Checking Puppet manifest style (**/*.pp).\n[![](img/eb51e960-235c-4a31-90ab-ed603c863429.png)] Checking Ruby code style (**/**.rb).\ninfo: task-metadata-lint: ./: Target does not contain any files to validate (tasks/*.json).\nwarning: puppet-lint: manifests/init.pp:10:140: line has more than 140 characters\nerror: puppet-lint: manifests/init.pp:9:28: trailing whitespace found\n```", "```\n# A description of what this class does\n#\n# @summary A short summary of the purpose of this class\n#\n# @example\n# include module\nclass module {\n\n  notify {'String-trigger':\n    message =>'This is the string that never ends. Yes it goes on and on my friends. Some developer just started writing without line breaks not knowing what they do, so this string will go on forever just because...' # lint:ignore:140chars\n  }\n\n}\n```", "```\nclass module::strings {\n\n# lint:ignore:140chars\n  notify {'Long String A':\n    message =>'This is the string that never ends. Yes it goes on and on my friends. Some developer just started writing without line breaks not knowing what they do, so this string will go on forever just because this is the string that never ends...'\n  }\n\n  notify {'Long String B':\n    message =>'This is another string that never ends. Yes it goes on and on my friends. Some developer just started writing without line breaks not knowing what they do, so this string will go on forever just because this is the string that never ends...'\n  }\n\n# lint:endignore\n\n}\n```", "```\n# Permanently ignore ALL 140 character checks\n$ cat puppet-lint.rc\n--no-140chars-check\n```", "```\n$ pdk validate\npdk (INFO): Running all available validators...\npdk (INFO): Using Ruby 2.4.4\npdk (INFO): Using Puppet 5.5.1\n[![](img/eb51e960-235c-4a31-90ab-ed603c863429.png)] Checking metadata syntax (metadata.json tasks/*.json).\n[![](img/eb51e960-235c-4a31-90ab-ed603c863429.png)] Checking module metadata style (metadata.json).\n[![](img/eb51e960-235c-4a31-90ab-ed603c863429.png)] Checking Puppet manifest syntax (**/**.pp).\n[![](img/eb51e960-235c-4a31-90ab-ed603c863429.png)] Checking Puppet manifest style (**/*.pp).\n[![](img/eb51e960-235c-4a31-90ab-ed603c863429.png)] Checking Ruby code style (**/**.rb).\ninfo: task-metadata-lint: ./: Target does not contain any files to validate (tasks/*.json).\nerror: rubocop: spec/classes/config_spec.rb:8:38: unexpected token tRCURLY\n(Using Ruby 2.1 parser; configure using `TargetRubyVersion` parameter, under `AllCops`)\n```", "```\n$ pdk test unit\npdk (INFO): Using Ruby 2.4.4\npdk (INFO): Using Puppet 5.5.1\n[![](img/44e8371e-c57d-4389-a19e-b575881608ba.png)] Preparing to run the unit tests.\n[![](img/44e8371e-c57d-4389-a19e-b575881608ba.png)] Running unit tests.\n Evaluated 45 tests in 2.461011 seconds: 9 failures, 0 pending.\n[![](img/44e8371e-c57d-4389-a19e-b575881608ba.png)] Cleaning up after running unit tests.\nfailed: rspec: ./spec/classes/module_spec.rb:9: expected that the catalogue would contain File[test]\n module on centos-7-x86_64 should contain File[test]\n Failure/Error:\n\n it { is_expected.to compile }\n it { is_expected.to contain_file('/etc/example') }\n end\n end\n```"]