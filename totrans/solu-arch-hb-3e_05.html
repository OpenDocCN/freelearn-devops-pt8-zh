<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer106">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 class="chapterTitle" id="_idParaDest-152"><span class="koboSpan" id="kobo.2.1">Cloud-Native Architecture Design Patterns</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">In an era of rapid digital transformation, businesses increasingly turn to the cloud to deliver scalable, resilient, and cost-effective solutions. </span><span class="koboSpan" id="kobo.3.2">Adopting cloud-native architectures is becoming a strategic necessity for organizations seeking agility, innovation, and operational efficiency. </span><span class="koboSpan" id="kobo.3.3">This chapter will guide you through the journey of designing and implementing cloud-native architectures, focusing on patterns, designs, and best practices.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4.1">The chapter will comprehensively cover various cloud-native design patterns, including design principles and real-world examples. </span><span class="koboSpan" id="kobo.4.2">In addition to architecture design patterns, you’ll also acquire knowledge on the anti-patterns of cloud-native architecture design, providing you with insights into the practices to avoid.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5.1">You will learn about the following topics in this chapter.</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.6.1">What is cloud-native architecture?</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.7.1">Building serverless architecture</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.8.1">Building stateless and stateful architectural designs </span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.9.1">Creating a microservice architecture</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.10.1">Reactive architecture</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.11.1">Building queue-based architecture </span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.12.1">Pipes-and-Filters Architecture</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.13.1">Creating Event-Driven Architecture</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.14.1">Backend for Frontend (BFF)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.15.1">Cloud-native architecture anti-patterns</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.16.1">By the end of this chapter, you will have a solid understanding of cloud-native architecture patterns and be well equipped to design, build, and optimize your cloud-native solutions.</span></p>
<h1 class="heading-1" id="_idParaDest-153"><span class="koboSpan" id="kobo.17.1">What is cloud-native architecture?</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.18.1">In </span><em class="chapterRef"><span class="koboSpan" id="kobo.19.1">Chapter 3</span></em><span class="koboSpan" id="kobo.20.1">, </span><em class="italic"><span class="koboSpan" id="kobo.21.1">Cloud Migration and Hybrid Cloud Architecture Design</span></em><span class="koboSpan" id="kobo.22.1">, you were introduced to different strategies for cloud migration, including lift and shift, replatform, repurchase, retire, and others. </span><span class="koboSpan" id="kobo.22.2">To fully leverage the advantages and pricing models of the cloud, it’s crucial </span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.23.1">to adopt cloud-native architecture. </span><span class="koboSpan" id="kobo.23.2">Cloud-native architecture refers to a design approach for building and running applications that harness the benefits and capabilities of cloud computing to their fullest extent. </span><span class="koboSpan" id="kobo.23.3">It involves crafting applications to be efficient, scalable, and resilient in dynamic cloud environments.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.24.1">Cloud-native applications are developed with principles that tap into cloud services, automation, and modern development practices. </span><span class="koboSpan" id="kobo.24.2">The key characteristics of cloud-native architecture include:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.25.1">Microservices</span></strong><span class="koboSpan" id="kobo.26.1">: Cloud-native applications are often composed of smaller, loosely </span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.27.1">coupled services </span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.28.1">known as microservices. </span><span class="koboSpan" id="kobo.28.2">Each microservice handles a specific business capability and can be developed, deployed, and scaled independently.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.29.1">Serverless computing</span></strong><span class="koboSpan" id="kobo.30.1">: Cloud-native applications frequently leverage serverless </span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.31.1">computing to achieve seamless scalability and cost reduction. </span><span class="koboSpan" id="kobo.31.2">This approach allows developers to focus on their code and application logic without worrying about managing servers, enabling automatic scaling and efficient resource use, which can significantly lower operational costs. </span><span class="koboSpan" id="kobo.31.3">Serverless architecture packages applications and their dependencies, ensuring consistency across different environments. </span><span class="koboSpan" id="kobo.31.4">It facilitates seamless deployment, scaling, and portability of applications. </span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.32.1">Elasticity and scalability</span></strong><span class="koboSpan" id="kobo.33.1">: Cloud-native applications can scale up or down based </span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.34.1">on demand, enabling efficient resource utilization and cost savings. </span><span class="koboSpan" id="kobo.34.2">This is achieved through automatic scaling and load balancing.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.35.1">Resilience and fault tolerance</span></strong><span class="koboSpan" id="kobo.36.1">: Cloud-native applications are designed to be resilient </span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.37.1">to failures. </span><span class="koboSpan" id="kobo.37.2">They incorporate practices such as redundancy, automated recovery, and fault tolerance mechanisms to ensure continuous operation even in the face of failures.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.38.1">Automation</span></strong><span class="koboSpan" id="kobo.39.1">: Cloud-native architectures emphasize automation for various processes, including </span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.40.1">deployment, scaling, monitoring, and recovery. </span><span class="koboSpan" id="kobo.40.2">Automation reduces manual intervention, increases efficiency, and reduces the risk of human errors.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.41.1">DevOps practices</span></strong><span class="koboSpan" id="kobo.42.1">: Cloud-native development encourages close collaboration </span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.43.1">between development and operations teams, promoting a culture of continuous integration, continuous delivery, and rapid iteration.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.44.1">Statelessness</span></strong><span class="koboSpan" id="kobo.45.1">: Cloud-native applications are designed to be stateless, meaning </span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.46.1">that each component does not rely on the local state of a server. </span><span class="koboSpan" id="kobo.46.2">This enhances scalability and allows for easier horizontal scaling.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.47.1">API-first</span></strong><span class="koboSpan" id="kobo.48.1">: </span><strong class="keyWord"><span class="koboSpan" id="kobo.49.1">APIs</span></strong><span class="koboSpan" id="kobo.50.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.51.1">application programming interfaces</span></strong><span class="koboSpan" id="kobo.52.1">) are crucial in cloud-native </span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.53.1">architecture. </span><span class="koboSpan" id="kobo.53.2">Applications are designed with clear and well-documented APIs, enabling communication between microservices and promoting integration with other services.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.54.1">Continuous monitoring and improvement</span></strong><span class="koboSpan" id="kobo.55.1">: Cloud-native applications are continuously </span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.56.1">monitored to ensure optimal performance and reliability. </span><span class="koboSpan" id="kobo.56.2">Data-driven insights are used to identify areas for improvement and optimization.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.57.1">When transitioning applications to the cloud, it’s not merely about moving them as they are. </span><span class="koboSpan" id="kobo.57.2">Instead, it’s an opportunity to optimize and utilize the cloud’s features for maximum </span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.58.1">advantage. </span><span class="koboSpan" id="kobo.58.2">First and foremost, the pay-as-you-go model in the cloud is a game-changer. </span><span class="koboSpan" id="kobo.58.3">It means you pay only for the resources you use, aligning costs directly with your actual consumption. </span><span class="koboSpan" id="kobo.58.4">This provides elasticity and cost efficiency, as you can scale up or down based on demand without investing in fixed infrastructure. </span><span class="koboSpan" id="kobo.58.5">Planning resource provisioning carefully is essential to avoid over-provisioning and unnecessary costs.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.59.1">The global infrastructure available in the cloud is another significant benefit. </span><span class="koboSpan" id="kobo.59.2">You can deploy your application closer to your users in various regions, reducing latency and improving user experience. </span><span class="koboSpan" id="kobo.59.3">This global reach empowers you to cater to a broader audience without investing in physical data centers worldwide.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.60.1">The shift </span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.61.1">from </span><strong class="keyWord"><span class="koboSpan" id="kobo.62.1">capital expenditure</span></strong><span class="koboSpan" id="kobo.63.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.64.1">CapEx</span></strong><span class="koboSpan" id="kobo.65.1">) to </span><strong class="keyWord"><span class="koboSpan" id="kobo.66.1">operational expenditure</span></strong><span class="koboSpan" id="kobo.67.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.68.1">OpEx</span></strong><span class="koboSpan" id="kobo.69.1">) is a significant financial advantage in the cloud. </span><span class="koboSpan" id="kobo.69.2">Rather than upfront </span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.70.1">investments in hardware and maintenance, costs are spread out over time. </span><span class="koboSpan" id="kobo.70.2">This aligns better with budget planning and allows you to allocate resources more efficiently. </span><span class="koboSpan" id="kobo.70.3">However, with distributed teams and applications, cost management becomes a challenge. </span><span class="koboSpan" id="kobo.70.4">It’s crucial to establish effective cost-control measures across different teams.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.71.1">Cloud-native architecture </span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.72.1">allows organizations to fully harness the benefits of cloud computing, including scalability, flexibility, and cost-effectiveness. </span><span class="koboSpan" id="kobo.72.2">Consider an example of a media streaming application to highlight the distinctions and advantages of cloud-native architecture with a serverless approach compared to an on-premises architecture.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.73.1">In a cloud-native architecture, the media streaming application is designed using microservices and serverless computing. </span><span class="koboSpan" id="kobo.73.2">Different aspects of the application, such as user authentication, content recommendation, video encoding, and storage, are each developed as separate microservices. </span><span class="koboSpan" id="kobo.73.3">These microservices are encapsulated in serverless functions, allowing them to execute in response to specific events or triggers. </span><span class="koboSpan" id="kobo.73.4">For instance, video encoding functions can be automatically invoked when a new video is uploaded, and content recommendation functions can respond to user interactions. </span><span class="koboSpan" id="kobo.73.5">Managed cloud services handle databases, storage, authentication, and even the execution of serverless functions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.74.1">The media streaming application is hosted on the company’s servers and infrastructure in an on-premises architecture. </span><span class="koboSpan" id="kobo.74.2">The monolithic application handles all tasks, including authentication, content serving, and video processing. </span><span class="koboSpan" id="kobo.74.3">Scaling requires manual intervention and additional hardware procurement.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.75.1">When adopting cloud-native development, it’s important to be aware of the potential for provider lock-in. </span><span class="koboSpan" id="kobo.75.2">This means that designing your architecture with the native tools and services of a specific cloud provider, such as AWS, might not seamlessly transfer to another provider due to the unique, proprietary nature of each platform’s offerings. </span><span class="koboSpan" id="kobo.75.3">Services across platforms may have different names, and the methods for invoking these services can vary significantly. </span><span class="koboSpan" id="kobo.75.4">While cloud-native features offer powerful capabilities tailored to optimize your operations on a specific platform, they can also introduce challenges if you later decide to migrate to a different cloud provider. </span><span class="koboSpan" id="kobo.75.5">Carefully consider the balance between leveraging these advanced features and maintaining some level of platform independence.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.76.1">Embracing a cloud-native architecture with a serverless approach offers numerous advantages over </span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.77.1">traditional on-premises setups. </span><span class="koboSpan" id="kobo.77.2">The combination of microservices and serverless computing enables applications to deliver exceptional performance, scalability, cost efficiency, and rapid innovation while ensuring resilience and real-time responsiveness to users’ dynamic demands. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.78.1">Let’s look into serverless architecture in more detail.</span></p>
<h1 class="heading-1" id="_idParaDest-154"><span class="koboSpan" id="kobo.79.1">Building serverless architecture</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.80.1">In a traditional scenario, if you want to develop an application, you need to have a server where your desired operating system and required software can be installed. </span><span class="koboSpan" id="kobo.80.2">While writing </span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.81.1">your code, you need to ensure your server is up and running. </span><span class="koboSpan" id="kobo.81.2">During deployment, you need to add more servers to keep up with user demand and add </span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.82.1">scaling mechanisms such as </span><strong class="keyWord"><span class="koboSpan" id="kobo.83.1">auto-scaling</span></strong><span class="koboSpan" id="kobo.84.1"> to manage the desired number of servers to fulfill users’ requests. </span><span class="koboSpan" id="kobo.84.2">In this situation, much effort goes into infrastructure management and maintenance, which has nothing to do with your business problem.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.85.1">Serverless means no server is required to host your code, freeing you from auto-scaling and decoupling overheads while providing a low-cost model. </span><span class="koboSpan" id="kobo.85.2">Going serverless lets you focus on your application and write code for feature implementation without worrying about underlying infrastructure maintenance.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.86.1">In relation to AWS, when you talk about serverless, the first thing that comes to mind is AWS </span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.87.1">Lambda functions, a </span><strong class="keyWord"><span class="koboSpan" id="kobo.88.1">Function as a Service</span></strong><span class="koboSpan" id="kobo.89.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.90.1">FaaS</span></strong><span class="koboSpan" id="kobo.91.1">) provided by the AWS cloud. </span><span class="koboSpan" id="kobo.91.2">To make your application service-oriented, Amazon API Gateway offers you the ability to put RESTful endpoints in front of your AWS Lambda functions, helping you to expose them as microservices. </span><span class="koboSpan" id="kobo.91.3">Amazon DynamoDB provides a highly scalable NoSQL database, an </span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.92.1">entirely serverless NoSQL data store, and Amazon </span><strong class="keyWord"><span class="koboSpan" id="kobo.93.1">Simple Storage Service</span></strong><span class="koboSpan" id="kobo.94.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.95.1">S3</span></strong><span class="koboSpan" id="kobo.96.1">) provides serverless object data storage.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.97.1">Let’s take a look at an example of serverless architecture for the delivery of a secure survey with AWS in the following diagram:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.98.1"><img alt="" role="presentation" src="../Images/B21336_05_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.99.1">Figure 5.1: AWS Serverless architecture example for a secure survey delivery</span></p>
<p class="normal"><span class="koboSpan" id="kobo.100.1">The preceding </span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.101.1">diagram illustrates the flow of a secure serverless architecture used for a customer survey application hosted on AWS:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.102.1">A customer makes a secure HTTPS request for the survey website. </span><span class="koboSpan" id="kobo.102.2">The static web page, including any client-side scripts for AJAX calls, is served directly from an Amazon S3 bucket, which is configured for web hosting.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.103.1">Upon completing the survey, the customer submits their responses. </span><span class="koboSpan" id="kobo.103.2">This triggers an AJAX call from the client’s browser to Amazon API Gateway. </span><span class="koboSpan" id="kobo.103.3">API Gateway is configured to expose the necessary endpoints for receiving survey data and is secured to ensure only authorized calls are processed.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.104.1">Amazon API Gateway has built-in integration with AWS CloudTrail, which logs all requests made to the API. </span><span class="koboSpan" id="kobo.104.2">This means every survey submission is recorded, providing an audit trail that can be useful for troubleshooting lost data or investigating suspicious activities.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.105.1">API Gateway converts the incoming AJAX call into an event that triggers an AWS Lambda function. </span><span class="koboSpan" id="kobo.105.2">This serverless function is responsible for processing the survey data, which may include validation, transformation, and applying business logic specific to the survey’s requirements.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.106.1">After processing the data, the Lambda function securely sends the survey results to another Amazon S3 bucket dedicated to storing these submissions. </span><span class="koboSpan" id="kobo.106.2">The results are encrypted using server-side encryption, ensuring that the data at rest is protected against unauthorized access.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.107.1">Alongside the encrypted survey results, any non-sensitive metadata (excluding personally identifiable information) is concurrently stored in an Amazon DynamoDB table. </span><span class="koboSpan" id="kobo.107.2">This metadata could include timestamps, survey version information, or other contextual data relevant for future queries, reporting, or analytical purposes.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.108.1">Due to the </span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.109.1">increasing popularity of serverless architecture, you will see more example architectures using serverless services as we move forward </span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.110.1">with this book. </span><span class="koboSpan" id="kobo.110.2">Now AWS </span><strong class="keyWord"><span class="koboSpan" id="kobo.111.1">SAM</span></strong><span class="koboSpan" id="kobo.112.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.113.1">Serverless Application Model</span></strong><span class="koboSpan" id="kobo.114.1">) offers straightforward syntax for creating functions, APIs, and databases tailored for serverless environments. </span><span class="koboSpan" id="kobo.114.2">Let’s learn more about design considerations for serverless architecture.</span></p>
<h2 class="heading-2" id="_idParaDest-155"><span class="koboSpan" id="kobo.115.1">Considerations for serverless architecture</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.116.1">When crafting a serverless architecture, it’s crucial to account for key factors that ensure the </span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.117.1">successful deployment and functioning of your application. </span><span class="koboSpan" id="kobo.117.2">Serverless architecture is highly suitable for designs that can be broken down into more modular components. </span><span class="koboSpan" id="kobo.117.3">This approach shines when you can delineate your application into discrete, independently scalable services. </span><span class="koboSpan" id="kobo.117.4">However, if your project involves constructing a large, complex logic within a single, monolithic module, it might be more advantageous to opt for a traditional server-based approach.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.118.1">Serverless architecture, while offering numerous benefits, often encounters the challenge of cold starts, which can affect application start latency. </span><span class="koboSpan" id="kobo.118.2">Although the infrastructure appears serverless to the user, cloud providers like AWS operate by creating an abstraction layer in the background, dynamically spinning up servers as needed. </span><span class="koboSpan" id="kobo.118.3">This process can sometimes take time, leading to a delay—or “cold start”—when the function is invoked after being idle. </span><span class="koboSpan" id="kobo.118.4">It’s important to be mindful of cold start issues when designing with serverless architecture and to implement strategies to mitigate this, ensuring that your application remains responsive and performs efficiently.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.119.1">Let’s explore this through an example: developing a real-time notification system for a social media platform. </span><span class="koboSpan" id="kobo.119.2">The system must send instant notifications to their devices whenever users receive likes, comments, or new friend requests. </span><span class="koboSpan" id="kobo.119.3">Here are some critical considerations </span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.120.1">for serverless architecture for our notification system:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.121.1">Granular function design</span></strong><span class="koboSpan" id="kobo.122.1">: Break down your application logic into small, discrete </span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.123.1">functions. </span><span class="koboSpan" id="kobo.123.2">Each function should perform a specific task or handle a particular event. </span><span class="koboSpan" id="kobo.123.3">This granularity ensures efficient resource usage and better scalability. </span><span class="koboSpan" id="kobo.123.4">You might have separate functions for sending likes, comments, and friend requests.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.124.1">Statelessness</span></strong><span class="koboSpan" id="kobo.125.1">: Serverless functions are designed to be stateless. </span><span class="koboSpan" id="kobo.125.2">Any required </span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.126.1">state should be managed externally, such as in a database or storage service. </span><span class="koboSpan" id="kobo.126.2">This ensures that functions can scale and be easily replaced without affecting application behavior. </span><span class="koboSpan" id="kobo.126.3">Ensure that each function is stateless and doesn’t rely on local memory. </span><span class="koboSpan" id="kobo.126.4">All necessary data, such as user preferences or notification history, should be stored in a database.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.127.1">Event-driven design</span></strong><span class="koboSpan" id="kobo.128.1">: Serverless architecture is well suited for event-driven applications. </span><span class="koboSpan" id="kobo.128.2">Design </span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.129.1">your functions to trigger in response to specific events, such as user actions or changes in data. </span><span class="koboSpan" id="kobo.129.2">For instance, when a user receives a new friend request, an event should trigger the corresponding function.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.130.1">Cold starts</span></strong><span class="koboSpan" id="kobo.131.1">: Serverless functions can experience a delay when invoked for the first </span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.132.1">time, known as a “cold start.” </span><span class="koboSpan" id="kobo.132.2">This </span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.133.1">could delay the delivery of notifications, so the architecture should be designed to minimize the impact of cold starts, such as by using provisioned concurrency to keep a certain number of function instances warm and ready to handle incoming requests.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.134.1">Scalability</span></strong><span class="koboSpan" id="kobo.135.1">: Serverless </span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.136.1">platforms automatically scale functions based on demand. </span><span class="koboSpan" id="kobo.136.2">This allows your application to handle sudden spikes in traffic without manual intervention. </span><span class="koboSpan" id="kobo.136.3">The system will handle more notifications without manual intervention as user activity increases.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.137.1">Performance considerations</span></strong><span class="koboSpan" id="kobo.138.1">: Understand </span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.139.1">the limitations of serverless platforms, such as execution time limits and memory constraints. </span><span class="koboSpan" id="kobo.139.2">Optimize your functions for performance to ensure your notification system remains responsive, even during high-traffic periods.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.140.1">Distributed tracing and monitoring</span></strong><span class="koboSpan" id="kobo.141.1">: Implement monitoring and distributed tracing </span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.142.1">to gain visibility into the </span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.143.1">performance of your serverless functions. </span><span class="koboSpan" id="kobo.143.2">This will be crucial for identifying bottlenecks and diagnosing issues in delivering notifications.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.144.1">Security</span></strong><span class="koboSpan" id="kobo.145.1">: Implement </span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.146.1">security best practices for serverless applications to avoid unauthorized access to notifications. </span><span class="koboSpan" id="kobo.146.2">This includes proper authentication, authorization, and data encryption at rest and in transit. </span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.147.1">Cost management</span></strong><span class="koboSpan" id="kobo.148.1">: While serverless can be cost-effective, monitoring usage and costs </span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.149.1">is essential. </span><span class="koboSpan" id="kobo.149.2">Set up budget alerts and use cloud provider tools to analyze spending patterns. </span><span class="koboSpan" id="kobo.149.3">With serverless, you pay for execution time, so optimize code to reduce this and consider using cost analysis tools to monitor usage.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.150.1">Data storage and persistence</span></strong><span class="koboSpan" id="kobo.151.1">: Choose appropriate storage solutions for your </span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.152.1">data, such as managed databases, object storage, or data warehouses. </span><span class="koboSpan" id="kobo.152.2">Ensure data persistence across function invocations. </span><span class="koboSpan" id="kobo.152.3">For our notification system, we’ll store user preferences and notification history in a managed database, ensuring data persistence across function invocations.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.153.1">Dependencies</span></strong><span class="koboSpan" id="kobo.154.1">: Be mindful of dependencies in your functions. </span><span class="koboSpan" id="kobo.154.2">Including unnecessary </span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.155.1">libraries or components can increase the size of your deployment package and impact performance. </span><span class="koboSpan" id="kobo.155.2">Minimize dependencies to keep the function deployment package small and efficient.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.156.1">Testing and debugging</span></strong><span class="koboSpan" id="kobo.157.1">: Develop effective testing strategies for your serverless </span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.158.1">functions. </span><span class="koboSpan" id="kobo.158.2">Use local emulators and debugging tools provided by the cloud provider.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.159.1">Leveraging managed services</span></strong><span class="koboSpan" id="kobo.160.1">: Serverless doesn’t mean every component must </span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.161.1">be a function. </span><span class="koboSpan" id="kobo.161.2">Use managed services for other parts of your application architecture, such as databases, queues, and authentication.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.162.1">Compliance and regulations</span></strong><span class="koboSpan" id="kobo.163.1">: Consider any compliance or regulatory requirements </span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.164.1">that apply to your application, especially when dealing with sensitive data or industries with strict regulations. </span><span class="koboSpan" id="kobo.164.2">Ensure the architecture complies with data protection regulations, especially when handling personal information.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.165.1">By carefully addressing these considerations, you can create a well-architected serverless application that benefits from auto-scaling, cost efficiency, and simplified management. </span><span class="koboSpan" id="kobo.165.2">The serverless architecture ensures scalable, cost-effective, and responsive notification delivery without worrying about managing infrastructure.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.166.1">When developing a serverless architecture, emphasizing statelessness is crucial. </span><span class="koboSpan" id="kobo.166.2">By designing stateless applications, you reduce the dependency on server-managed session states, which in turn aids scalability. </span><span class="koboSpan" id="kobo.166.3">Stateless architecture is key to scaling cloud-native architecture. </span><span class="koboSpan" id="kobo.166.4">Let’s learn more about it.</span></p>
<h1 class="heading-1" id="_idParaDest-156"><span class="koboSpan" id="kobo.167.1">Building stateless and stateful architectural designs</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.168.1">Stateless and stateful architectural designs represent two different approaches to managing </span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.169.1">client-server interactions within software applications. </span><span class="koboSpan" id="kobo.169.2">Stateless architectures treat each client request as a separate, independent </span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.170.1">transaction, requiring no knowledge of previous interactions; this simplifies design and enhances scalability, as any server can respond to any request without needing to maintain session information. </span><span class="koboSpan" id="kobo.170.2">On the other hand, stateful architectures retain client session information across multiple requests, allowing for more personalized and context-aware interactions but at the cost of increased complexity in managing session data and challenges in scaling, as the state must be consistently available and synchronized across server instances.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.171.1">While designing a complex application such as an e-commerce website, you need to handle the user state to maintain activity flow, where users may be performing a chain of activities such as adding to the cart, placing an order, selecting a shipping method, and making a payment. </span><span class="koboSpan" id="kobo.171.2">Users can use various channels to access an application, so there is a strong possibility that they will be switching between devices—for example, adding items to the cart from their mobile and then completing checkout and payment from a laptop. </span><span class="koboSpan" id="kobo.171.3">To cater to this situation, you should persist user activity across devices and maintain their state until the transaction is complete. </span><span class="koboSpan" id="kobo.171.4">Therefore, your architecture design and application implementation must plan for user session management to fulfill this requirement.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.172.1">To persist user states and make applications stateless, user session information needs to be stored in persistent database layers such as the NoSQL database. </span><span class="koboSpan" id="kobo.172.2">This user state can be shared between multiple web servers or microservices.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.173.1">Traditionally, a monolithic application uses stateful architecture, storing user session information in the server rather than via any external persistence database storage.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.174.1">The key distinction between stateless and stateful application designs lies in how they handle </span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.175.1">session storage. </span><span class="koboSpan" id="kobo.175.2">In stateful applications, session information is stored locally on the server, which means it cannot be easily </span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.176.1">shared with other servers. </span><span class="koboSpan" id="kobo.176.2">This setup poses a challenge for scalability and is not well suited for modern microservice architectures, as it requires all subsequent requests from the same user to be routed to the original server that handled the first request. </span><span class="koboSpan" id="kobo.176.3">This can significantly restrict the application’s ability to scale across multiple servers or instances. </span><span class="koboSpan" id="kobo.176.4">On the other hand, stateless designs do not store session data on the server, allowing any server to handle any request, which enhances the application’s scalability and flexibility. </span><span class="koboSpan" id="kobo.176.5">The choice between adopting a stateless or stateful approach hinges on the application’s requirements, specifically how it balances the need for scalability with the desire for a continuous, personalized user experience.</span></p>
<h2 class="heading-2" id="_idParaDest-157"><span class="koboSpan" id="kobo.177.1">Stateful architecture</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.178.1">In a stateful application, state information is handled by the server, so once users establish </span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.179.1">a connection with a particular server, they have to stick with it until the transaction completes. </span><span class="koboSpan" id="kobo.179.2">You can put a load balancer in front of the stateful application, but to do that, you have to enable sticky sessions in a load balancer.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.180.1">Sticky sessions are a technique used to ensure that all requests from a particular user session are directed to the same server that handled the initial request. </span><span class="koboSpan" id="kobo.180.2">This approach is necessary in stateful applications to maintain session consistency, as it prevents session data from being lost when subsequent requests are routed to different servers. </span><span class="koboSpan" id="kobo.180.3">By using sticky sessions, the load balancer deviates from its standard practice of distributing requests evenly among servers, typically done via a round-robin method, and instead, routes a user’s requests to a specific server where their session information resides. </span><span class="koboSpan" id="kobo.180.4">While this method supports session persistence, it introduces challenges, such as the potential for overloading a single server with too many persistent connections. </span><span class="koboSpan" id="kobo.180.5">To mitigate this, implementing a session timeout mechanism becomes essential, ensuring that sessions do not indefinitely consume server resources.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.181.1">Often, a stateful application doesn’t support horizontal scaling very well, as the application </span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.182.1">state persists in the server, which cannot be replaced. </span><span class="koboSpan" id="kobo.182.2">The stateful application works well early on when the user base is small. </span><span class="koboSpan" id="kobo.182.3">However, as the internet becomes increasingly widespread, it is reasonable to assume that you will have millions of users active on a web application. </span><span class="koboSpan" id="kobo.182.4">Therefore, efficient horizontal scaling is essential for handling a large user base and achieving low application latency. </span></p>
<h2 class="heading-2" id="_idParaDest-158"><span class="koboSpan" id="kobo.183.1">Stateless architecture</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.184.1">Using the stateless method, your design approach should focus more on the shared session </span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.185.1">state, as it allows horizontal scaling.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.186.1">The following diagram shows an architecture that depicts a stateless application for an example web application with AWS:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.187.1"><img alt="" role="presentation" src="../Images/B21336_05_02.png"/></span></figure>
<figure class="mediaobject"><span class="koboSpan" id="kobo.188.1">Figure 5.2: A stateless application architecture</span></figure>
<p class="normal"><span class="koboSpan" id="kobo.189.1">The depicted AWS architecture provides a secure, highly available, and scalable environment for a three-tier application across two Availability Zones for fault tolerance. </span><span class="koboSpan" id="kobo.189.2">It uses Elastic Load Balancing to distribute traffic across EC2 server clusters, which are dynamically scaled with Auto Scaling to meet changing demands. </span><span class="koboSpan" id="kobo.189.3">The database layer, powered by Amazon RDS, includes a read replica for query scaling and a standby instance for failover, ensuring data durability and high availability. </span><span class="koboSpan" id="kobo.189.4">Static content is served through Amazon S3 and delivered efficiently via Amazon CloudFront, with AWS Route 53 managing DNS services to optimize user traffic routing. </span><span class="koboSpan" id="kobo.189.5">This setup ensures operational resilience, cost-efficiency, and performance optimization for the application. </span><span class="koboSpan" id="kobo.189.6">To make applications loosely coupled and scalable, all user sessions are stored persistently in the NoSQL database, for example, Amazon DynamoDB. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.190.1">For the session ID, you should use client-side storage, such as cookies. </span><span class="koboSpan" id="kobo.190.2">This architecture lets you scale </span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.191.1">the application horizontally by adding more servers without worrying about losing user state information. </span><span class="koboSpan" id="kobo.191.2">A stateless architecture removes the overhead of creating and maintaining user sessions and allows consistency across the application’s modules. </span><span class="koboSpan" id="kobo.191.3">A stateless application has performance benefits, too, as it reduces memory usage from the server side and eliminates the session timeout issue.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.192.1">Implementing a stateless architecture involves complexities such as integrating additional database components for storing user sessions and creating a supplementary layer to retrieve the correct user session across servers. </span><span class="koboSpan" id="kobo.192.2">However, with the right approach, you can achieve a rewarding experience for your user base. </span><span class="koboSpan" id="kobo.192.3">You can develop applications using the microservice approach with REST design patterns and deploy them in containers. </span><span class="koboSpan" id="kobo.192.4">For this, use authentication and authorization to connect users to the server.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.193.1">In the following sections, you will learn more about microservices and REST design patterns. </span><span class="koboSpan" id="kobo.193.2">As access to user session information from multiple web servers focuses on a single data storage location, you must use caution to prevent the performance of the data store from becoming a bottleneck.</span></p>
<h1 class="heading-1" id="_idParaDest-159"><span class="koboSpan" id="kobo.194.1">Creating a microservice architecture</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.195.1">In cloud-native </span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.196.1">architecture, microservices play a vital role in breaking down extensive features into smaller, manageable chunks that can scale independently. </span><span class="koboSpan" id="kobo.196.2">This approach allows for specific components to be scaled up or down as needed without affecting the entire system. </span><span class="koboSpan" id="kobo.196.3">By using microservices, a system is designed to be fault-tolerant, meaning it’s constructed with potential failures in mind, allowing for the graceful degradation of application availability and preventing widespread system failures.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.197.1">The clear advantage of microservices is that you have to maintain a smaller code surface area. </span><span class="koboSpan" id="kobo.197.2">Microservices should always be independent. </span><span class="koboSpan" id="kobo.197.3">You can build each service with no external dependencies where all prerequisites are included, which reduces the inter-dependency between application modules and enables loose coupling.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.198.1">The other </span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.199.1">overarching concept of microservices is </span><strong class="keyWord"><span class="koboSpan" id="kobo.200.1">bounded contexts</span></strong><span class="koboSpan" id="kobo.201.1">, which are the blocks that </span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.202.1">combine to make a single business domain. </span><span class="koboSpan" id="kobo.202.2">A business domain could be retail, car manufacturing, bookselling, or social network interactions involving a complete business process. </span><span class="koboSpan" id="kobo.202.3">An individual microservice defines boundaries in which all the details are encapsulated. </span><span class="koboSpan" id="kobo.202.4">For example, let’s consider an e-commerce platform. </span><span class="koboSpan" id="kobo.202.5">In such a system, you would have several microservices handling different aspects of the business. </span><span class="koboSpan" id="kobo.202.6">Here are a few bounded contexts within this platform:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><strong class="keyWord"><span class="koboSpan" id="kobo.203.1">User account context</span></strong><span class="koboSpan" id="kobo.204.1">: This microservice handles everything related to user accounts, including </span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.205.1">user registration, profile management, login, and authentication. </span><span class="koboSpan" id="kobo.205.2">Its boundary encompasses user information and the operations that can be performed on this data, such as updating a profile or resetting a password. </span><span class="koboSpan" id="kobo.205.3">No other microservice will manage these operations.</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.206.1">Product catalog context</span></strong><span class="koboSpan" id="kobo.207.1">: This microservice is responsible for managing the product </span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.208.1">listings, categories, and product details. </span><span class="koboSpan" id="kobo.208.2">It operates independently of the user account context, focusing solely on the products, their organization, and their presentation to the user.</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.209.1">Order processing context</span></strong><span class="koboSpan" id="kobo.210.1">: This microservice handles the checkout process, order </span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.211.1">tracking, and payment processing. </span><span class="koboSpan" id="kobo.211.2">It uses information from the product catalog context (e.g., product IDs, prices) and the user account context (e.g., customer details) to fulfill its functions but maintains its separate operations, such as updating order status or processing returns.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.212.1">Each bounded context is a self-contained system with its own domain logic and database, communicating with others via well-defined APIs. </span><span class="koboSpan" id="kobo.212.2">These boundaries allow each microservice to be developed, deployed, scaled, and updated independently, making the overall system more resilient and adaptable to change.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.213.1">By defining these boundaries, the e-commerce platform can ensure that changes in one context, such as adding new payment methods in the order processing context, do not affect the user account or product catalog contexts, leading to a more maintainable and scalable system.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.214.1">Scaling each </span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.215.1">service is essential while dealing with the large-scale access of applications, where different workloads have different scaling demands.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.216.1">Let’s learn </span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.217.1">about some best practices for designing microservice architecture:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.218.1">Create a separate data store</span></strong><span class="koboSpan" id="kobo.219.1">: Adopting a separate data store for each microservice allows the individual team to choose the best database for their service. </span><span class="koboSpan" id="kobo.219.2">For example, the website traffic team can use a scalable NoSQL database to store semi-structured data. </span><span class="koboSpan" id="kobo.219.3">The team handling order services can use a relational database to ensure data integrity and the consistency of transactions. </span><span class="koboSpan" id="kobo.219.4">This also helps to achieve loose coupling where changes in one database do not impact other services.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.220.1">Keep servers stateless</span></strong><span class="koboSpan" id="kobo.221.1">: As you learned in the previous section, </span><em class="italic"><span class="koboSpan" id="kobo.222.1">Building stateless and stateful architecture designs</span></em><span class="koboSpan" id="kobo.223.1">, keeping your server stateless helps in scaling. </span><span class="koboSpan" id="kobo.223.2">Servers should be able to go down and be replaced easily, with minimal or no need for storing state on the servers.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.224.1">Create a separate build</span></strong><span class="koboSpan" id="kobo.225.1">: Creating a separate build for each microservice makes it easier for the development team to introduce new changes and improve the agility of the new feature release. </span><span class="koboSpan" id="kobo.225.2">This helps to ensure that the development team is only building code required for a particular microservice and not impacting other services.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.226.1">Deploy in a container</span></strong><span class="koboSpan" id="kobo.227.1">: Deploying in a container gives you the tool to deploy everything in the same standard way. </span><span class="koboSpan" id="kobo.227.2">Using containers, you can choose to deploy all microservices in the same way, regardless of their nature. </span><span class="koboSpan" id="kobo.227.3">You can use serverless container deployment services like Amazon Fargate to manage your container without worrying about infrastructure. </span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.228.1">Go serverless</span></strong><span class="koboSpan" id="kobo.229.1">: Try to use a serverless platform or a leveraging function with service capability, such as AWS Lambda, when your microservices are simple enough. </span><span class="koboSpan" id="kobo.229.2">Serverless architecture helps you to avoid infrastructure management overhead.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.230.1">Blue-green deployment</span></strong><span class="koboSpan" id="kobo.231.1">: For application deployment, the best approach is to create a copy of the production environment. </span><span class="koboSpan" id="kobo.231.2">Deploy the new feature and route a small percentage of the user traffic to ensure the new feature is working as expected in a new environment. </span><span class="koboSpan" id="kobo.231.3">After that, increase the traffic in the new environment until the entire user base can see the new feature. </span><span class="koboSpan" id="kobo.231.4">You will learn more about blue-green deployment in </span><em class="chapterRef"><span class="koboSpan" id="kobo.232.1">Chapter 11</span></em><span class="koboSpan" id="kobo.233.1">, </span><em class="italic"><span class="koboSpan" id="kobo.234.1">DevOps and Solution Architecture Framework</span></em><span class="koboSpan" id="kobo.235.1">.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.236.1">Monitor your environment</span></strong><span class="koboSpan" id="kobo.237.1">: Good monitoring is the difference between reacting to </span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.238.1">an outage and proactively preventing an outage with proper rerouting, scaling, and managed degradation. </span><span class="koboSpan" id="kobo.238.2">To prevent application downtime, you want services to offer and push their health status to the monitoring layer because what knows more about status than the service itself? </span><span class="koboSpan" id="kobo.238.3">Monitoring can be done in many ways, such as with plugins or by writing to a monitoring API.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.239.1">While microservice architectures have various advantages, a modular approach comes with the overhead of managing more infrastructure. </span><span class="koboSpan" id="kobo.239.2">You must carefully choose the tools to help you </span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.240.1">manage and scale multiple modules in parallel. </span><span class="koboSpan" id="kobo.240.2">While designing microservice architecture, try to use serverless platforms wherever possible, which will help mitigate the infrastructure and operation overhead. </span><span class="koboSpan" id="kobo.240.3">Let’s look at a microservice-based example architecture for a real-time voting application.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.241.1">In the diagram below, we show a design that uses microservices for a live voting app. </span><span class="koboSpan" id="kobo.241.2">This app works by having small, separate services that handle and count votes from users. </span><span class="koboSpan" id="kobo.241.3">When someone votes using their mobile device, the app records each vote and then saves all these votes together in a NoSQL database, Amazon DynamoDB.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.242.1">There is application logic in the AWS Lambda function, which aggregates all of the voting data cast by users to their favorite actor and returns the final results:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.243.1"><img alt="" role="presentation" src="../Images/B21336_05_03.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.244.1">Figure 5.3: Microservice-based real-time voting application architecture with AWS</span></p>
<p class="normal"><span class="koboSpan" id="kobo.245.1">In the </span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.246.1">preceding architecture, the following things are happening:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.247.1">Users text a vote to a phone number or a short code provided by a third party such as </span><em class="italic"><span class="koboSpan" id="kobo.248.1">Twilio</span></em><span class="koboSpan" id="kobo.249.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.250.1">The third party is configured to send the content of the message to an endpoint created by Amazon API Gateway, which then forwards the response to a function built in AWS Lambda.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.251.1">This function extracts the vote from the message content and writes the result and any metadata into a table in Amazon DynamoDB.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.252.1">This table has DynamoDB Streams enabled, which tracks changes to your tables on a rolling basis.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.253.1">After the update, DynamoDB Streams notifies a second AWS Lambda function with the application logic to aggregate the votes (to every second) and write them back to another DynamoDB table. </span><span class="koboSpan" id="kobo.253.2">The second table only stores the sum of the votes for each category.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.254.1">A dashboard to display a summary of votes is created using HTML and JavaScript and hosted as a static website in Amazon S3. </span><span class="koboSpan" id="kobo.254.2">This page uses the AWS JavaScript SDK to query the aggregate Amazon DynamoDB table and display the voting results in real time.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.255.1">Finally, Amazon Route 53 is a DNS provider for creating a hosted zone pointing to a custom domain name in the Amazon S3 bucket. </span><span class="koboSpan" id="kobo.255.2">This allows you to host static websites in S3 buckets in a cost-effective serverless manner.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.256.1">This architecture </span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.257.1">is not only microservice-based but also serverless. </span><span class="koboSpan" id="kobo.257.2">Using microservices, you can create applications made of small independent components, which constitute smaller parts to iterate. </span><span class="koboSpan" id="kobo.257.3">Microservice-based architecture means that the cost, size, and risk of change are reduced, increasing the rate of change.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.258.1">Coordinating between multiple services becomes critical if your system is distributed using microservices. </span><span class="koboSpan" id="kobo.258.2">Let’s learn how to orchestrate multiple microservices next.</span></p>
<h2 class="heading-2" id="_idParaDest-160"><span class="koboSpan" id="kobo.259.1">Saga pattern</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.260.1">The Saga pattern is a </span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.261.1">design pattern used to manage long-running, complex business transactions. </span><span class="koboSpan" id="kobo.261.2">It’s beneficial in microservice architectures, where a single business transaction </span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.262.1">might involve multiple microservices. </span><span class="koboSpan" id="kobo.262.2">Instead of using a traditional two-phase commit, the Saga pattern divides the transaction into multiple smaller, isolated transactions. </span><span class="koboSpan" id="kobo.262.3">A different service handles each of these smaller transactions, and they are coordinated to ensure data consistency across services. </span><span class="koboSpan" id="kobo.262.4">If one of the smaller transactions fails, compensating transactions are executed to undo the previous steps.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.263.1">In complex systems where multiple services need to work together to fulfill a single operation, such as processing an order or booking a flight, the Saga pattern helps ensure that if something goes wrong at any point, the entire operation can be either fully completed or rolled back.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.264.1">Here’s how </span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.265.1">the Saga pattern works:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.266.1">Decomposition</span></strong><span class="koboSpan" id="kobo.267.1">: The operation that needs to be performed is broken down into smaller, isolated steps or transactions. </span><span class="koboSpan" id="kobo.267.2">Each step corresponds to an action performed by a specific microservice.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.268.1">Compensation actions</span></strong><span class="koboSpan" id="kobo.269.1">: For every step, a corresponding compensation action is defined. </span><span class="koboSpan" id="kobo.269.2">If a step fails or an error occurs, the compensation action is executed to reverse the effects of the previous steps. </span><span class="koboSpan" id="kobo.269.3">This brings the system back to a consistent state.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.270.1">Coordinator</span></strong><span class="koboSpan" id="kobo.271.1">: A coordinator is responsible for orchestrating the sequence of steps and their corresponding compensation actions. </span><span class="koboSpan" id="kobo.271.2">It initiates the saga, monitors </span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.272.1">its progress, and ensures that all steps are completed or the necessary compensation actions are taken.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.273.1">Local transactions</span></strong><span class="koboSpan" id="kobo.274.1">: Each step and its compensation action are encapsulated within a local transaction within their respective microservices. </span><span class="koboSpan" id="kobo.274.2">This allows for the atomicity of operations within each microservice.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.275.1">Eventual consistency</span></strong><span class="koboSpan" id="kobo.276.1">: The Saga pattern embraces eventual consistency, which means that even if a failure occurs, the system will eventually reach a consistent state by either completing the entire operation successfully or rolling back to a consistent state.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.277.1">Imagine an e-commerce application where a customer places an order. </span><span class="koboSpan" id="kobo.277.2">The Saga pattern could be </span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.278.1">used to handle the entire order processing flow:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><strong class="keyWord"><span class="koboSpan" id="kobo.279.1">Initiation</span></strong><span class="koboSpan" id="kobo.280.1">: The order service starts a new saga for order processing.</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.281.1">Steps</span></strong><span class="koboSpan" id="kobo.282.1">: The saga involves multiple steps performed by different microservices: check product availability, charge the customer, update inventory, and notify the customer, for example.</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.283.1">Compensation actions</span></strong><span class="koboSpan" id="kobo.284.1">: Corresponding compensation actions are defined, for example, if the item is out of stock: release the charged amount, restock the product, and send an apology email to the customer.</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.285.1">Coordinator</span></strong><span class="koboSpan" id="kobo.286.1">: A coordinator oversees the saga, ensuring that each step is successfully executed or compensated. </span><span class="koboSpan" id="kobo.286.2">For example, steps flow from checking product availability to placing an order, charging the customer, and fulfilling the order for delivery. </span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.287.1">Eventual consistency</span></strong><span class="koboSpan" id="kobo.288.1">: If a step fails at any point (for example, if charging the customer fails), the compensation actions are triggered to bring the system back to a consistent state.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.289.1">Each service involved in the Saga produces and listens for events, as shown in the following diagram:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.290.1"><img alt="" role="presentation" src="../Images/B21336_05_04.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.291.1">Figure 5.4: Saga pattern sequence diagram for e-commerce application architecture </span></p>
<p class="normal"><span class="koboSpan" id="kobo.292.1">As depicted </span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.293.1">in the preceding diagram, when a service completes its part of the transaction, it produces an event that triggers the next service in the saga. </span><span class="koboSpan" id="kobo.293.2">For example:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.294.1">The </span><strong class="screenText"><span class="koboSpan" id="kobo.295.1">Order Service</span></strong><span class="koboSpan" id="kobo.296.1"> receives a request to create an order.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.297.1">The </span><strong class="screenText"><span class="koboSpan" id="kobo.298.1">Order Service</span></strong><span class="koboSpan" id="kobo.299.1"> starts the saga by creating the order in a </span><strong class="screenText"><span class="koboSpan" id="kobo.300.1">pending</span></strong><span class="koboSpan" id="kobo.301.1"> state and publishing an </span><strong class="screenText"><span class="koboSpan" id="kobo.302.1">OrderCreated</span></strong><span class="koboSpan" id="kobo.303.1"> event.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.304.1">The </span><strong class="screenText"><span class="koboSpan" id="kobo.305.1">Payment Service</span></strong><span class="koboSpan" id="kobo.306.1"> listens for the </span><strong class="screenText"><span class="koboSpan" id="kobo.307.1">OrderCreated</span></strong><span class="koboSpan" id="kobo.308.1"> event, processes the payment, and publishes a </span><strong class="screenText"><span class="koboSpan" id="kobo.309.1">PaymentProcessed</span></strong><span class="koboSpan" id="kobo.310.1"> event.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.311.1">The </span><strong class="screenText"><span class="koboSpan" id="kobo.312.1">Stock Service</span></strong><span class="koboSpan" id="kobo.313.1"> listens for the </span><strong class="screenText"><span class="koboSpan" id="kobo.314.1">PaymentProcessed</span></strong><span class="koboSpan" id="kobo.315.1"> event, verifies that the items are in stock, reserves the stock, and publishes a </span><strong class="screenText"><span class="koboSpan" id="kobo.316.1">StockReserved</span></strong><span class="koboSpan" id="kobo.317.1"> event.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.318.1">The </span><strong class="screenText"><span class="koboSpan" id="kobo.319.1">Shipping Service</span></strong><span class="koboSpan" id="kobo.320.1"> listens for the </span><strong class="screenText"><span class="koboSpan" id="kobo.321.1">StockReserved</span></strong><span class="koboSpan" id="kobo.322.1"> event, schedules the delivery, and publishes a </span><strong class="screenText"><span class="koboSpan" id="kobo.323.1">ShipmentScheduled</span></strong><span class="koboSpan" id="kobo.324.1"> event.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.325.1">The </span><strong class="screenText"><span class="koboSpan" id="kobo.326.1">Order Service</span></strong><span class="koboSpan" id="kobo.327.1"> listens for the </span><strong class="screenText"><span class="koboSpan" id="kobo.328.1">ShipmentScheduled</span></strong><span class="koboSpan" id="kobo.329.1"> event and updates the order to a </span><strong class="screenText"><span class="koboSpan" id="kobo.330.1">completed</span></strong><span class="koboSpan" id="kobo.331.1"> state.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.332.1">If any of the services fail to complete its part of the transaction, it publishes a compensating event to trigger the rollback of the previous steps. </span><span class="koboSpan" id="kobo.332.2">For example, if the </span><strong class="screenText"><span class="koboSpan" id="kobo.333.1">Stock Service</span></strong><span class="koboSpan" id="kobo.334.1"> finds out there’s insufficient stock, it could publish a </span><strong class="screenText"><span class="koboSpan" id="kobo.335.1">StockInsufficient</span></strong><span class="koboSpan" id="kobo.336.1"> event. </span><span class="koboSpan" id="kobo.336.2">The </span><strong class="screenText"><span class="koboSpan" id="kobo.337.1">Payment Service</span></strong><span class="koboSpan" id="kobo.338.1"> would listen for this event and initiate a refund. </span><span class="koboSpan" id="kobo.338.2">The </span><strong class="screenText"><span class="koboSpan" id="kobo.339.1">Order Service</span></strong><span class="koboSpan" id="kobo.340.1"> would listen for the </span><strong class="screenText"><span class="koboSpan" id="kobo.341.1">StockInsufficient</span></strong><span class="koboSpan" id="kobo.342.1"> event and update the order to a </span><strong class="screenText"><span class="koboSpan" id="kobo.343.1">failed</span></strong><span class="koboSpan" id="kobo.344.1"> state.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.345.1">The Saga pattern </span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.346.1">is a design solution that addresses the challenge of data consistency in distributed systems, particularly when working with microservices. </span><span class="koboSpan" id="kobo.346.2">Instead of relying on a single, large-scale transaction to ensure data consistency across different services, the Saga pattern breaks the transaction into a series of local transactions for each service. </span><span class="koboSpan" id="kobo.346.3">Each local transaction updates the database and publishes </span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.347.1">an event or message indicating the transaction’s success or failure. </span><span class="koboSpan" id="kobo.347.2">However, the Saga pattern introduces the concept of eventual consistency, which means the system’s state will become consistent over time, but not necessarily immediately. </span><span class="koboSpan" id="kobo.347.3">Additionally, implementing the Saga pattern can be complex because it requires handling failure scenarios and ensuring that compensating transactions correctly undo previous operations. </span><span class="koboSpan" id="kobo.347.4">This often involves intricate coordination and robust messaging systems to manage the asynchronous communication between services.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.348.1">The Saga pattern allows complex operations to be broken down into manageable steps, with a safety net to handle failures and maintain data integrity. </span><span class="koboSpan" id="kobo.348.2">It promotes better resilience in distributed systems by ensuring that the system remains coherent and eventually consistent even if failures occur. </span><span class="koboSpan" id="kobo.348.3">However, implementing the Saga pattern requires careful design and coordination to handle various failure scenarios effectively. </span><span class="koboSpan" id="kobo.348.4">What if you have extensive information that needs to be processed by multiple microservices, but it needs to be consolidated to create meaningful insights? </span><span class="koboSpan" id="kobo.348.5">In such scenarios, the fan-out/fan-in pattern can rescue you. </span><span class="koboSpan" id="kobo.348.6">Let’s learn more about it.</span></p>
<h2 class="heading-2" id="_idParaDest-161"><span class="koboSpan" id="kobo.349.1">Fan-out/fan-in pattern</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.350.1">The fan-out/fan-in </span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.351.1">pattern is a design pattern </span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.352.1">commonly used in distributed systems to process requests efficiently and aggregate data from multiple sources. </span><span class="koboSpan" id="kobo.352.2">It’s beneficial for scenarios where data must be collected, processed, and consolidated from various input streams or sources. </span><span class="koboSpan" id="kobo.352.3">The pattern gets its name from how data fans out from multiple sources and then fans back in for aggregation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.353.1">Consider a </span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.354.1">real-time analytics system for a social media platform. </span><span class="koboSpan" id="kobo.354.2">The </span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.355.1">fan-out/fan-in pattern can be applied to collect and process data from various user activities. </span><span class="koboSpan" id="kobo.355.2">Let’s see how the fan-out/fan-in pattern works:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.356.1">Fan-out phase</span></strong><span class="koboSpan" id="kobo.357.1">:</span><ul>
<li class="bulletList"><span class="koboSpan" id="kobo.358.1">In the </span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.359.1">fan-out phase, data is collected from multiple sources, including different microservices, APIs, or data streams. </span><span class="koboSpan" id="kobo.359.2">Each source sends its data to a separate processing component. </span><span class="koboSpan" id="kobo.359.3">User posts, comments, likes, shares, and followers generate real-time data streams.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.360.1">The processing component for each source operates independently and simultaneously. </span><span class="koboSpan" id="kobo.360.2">This allows for efficient parallel processing, reducing the time to gather data from various sources. </span><span class="koboSpan" id="kobo.360.3">Each type of activity has a dedicated processing component that calculates statistics such as engagement rates, popular content, and trending topics.</span></li>
</ul>
</li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.361.1">Fan-in phase</span></strong><span class="koboSpan" id="kobo.362.1">: Once </span><a id="_idIndexMarker599"/><span class="koboSpan" id="kobo.363.1">individual processing is complete, the results from each processing component are aggregated or combined, in this case to calculate overall platform engagement metrics. </span><span class="koboSpan" id="kobo.363.2">This aggregation can involve calculations, summarizations, or any other operation needed for the final result. </span><span class="koboSpan" id="kobo.363.3">The aggregated data generates the desired outcome or final report. </span><span class="koboSpan" id="kobo.363.4">This could be a single report, a summarized analysis, or any other form of consolidated data. </span><span class="koboSpan" id="kobo.363.5">For our example, this is presented to administrators as a dashboard that displays real-time engagement insights.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.364.1">In this example, the fan-out/fan-in pattern allows the analytics system to process and consolidate data from multiple user activities efficiently, providing administrators with real-time insights into platform engagement.</span></p>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.365.1">Benefits of the fan-out/fan-in pattern</span></strong></p>
<p class="normal"><span class="koboSpan" id="kobo.366.1">The fan-out/fan-in pattern is a strategic approach in distributed systems that significantly </span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.367.1">enhances the way data is managed and processed. </span><span class="koboSpan" id="kobo.367.2">Here are the key benefits of employing this pattern:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.368.1">Parallelism</span></strong><span class="koboSpan" id="kobo.369.1">: The pattern leverages parallel processing, allowing faster data collection and aggregation from multiple sources.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.370.1">Efficiency</span></strong><span class="koboSpan" id="kobo.371.1">: Instead of processing data sequentially from each source, the pattern optimizes processing time by working on multiple sources concurrently.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.372.1">Scalability</span></strong><span class="koboSpan" id="kobo.373.1">: Each source can be processed independently, enabling the system to scale efficiently as the number of sources increases.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.374.1">Modularity</span></strong><span class="koboSpan" id="kobo.375.1">: The pattern encourages modular design by separating the data collection (fan-out) phase from the aggregation (fan-in) phase. </span><span class="koboSpan" id="kobo.375.2">This makes it easier to maintain and extend the system.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.376.1">The fan-out/fan-in pattern, while beneficial for parallel processing and enhancing efficiency in distributed systems, introduces specific challenges that must be navigated carefully. </span><span class="koboSpan" id="kobo.376.2">Implementing this pattern adds complexity due to the need for meticulous coordination between the numerous parallel tasks it initiates and their subsequent aggregation. </span><span class="koboSpan" id="kobo.376.3">Error handling becomes more intricate, as the system must account for potential failures </span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.377.1">in any of the fan-out tasks and ensure robust mechanisms for recovery to maintain data consistency.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.378.1">This pattern </span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.379.1">can also be resource-intensive, as it may require significant computational power to manage the parallel processes, potentially leading to higher operational costs and necessitating advanced scaling strategies. </span><span class="koboSpan" id="kobo.379.2">Moreover, the aggregation stage can become a bottleneck, particularly if it involves processing large volumes of data, which may delay the overall data processing timeline. </span><span class="koboSpan" id="kobo.379.3">Additionally, the system might only achieve eventual consistency, posing challenges for applications that require real-time processing. </span><span class="koboSpan" id="kobo.379.4">Finally, the distributed nature of this pattern complicates debugging and monitoring, requiring comprehensive tools to ensure visibility across all tasks. </span><span class="koboSpan" id="kobo.379.5">Despite these challenges, with careful design and management, the fan-out/fan-in pattern remains a potent strategy for improving data processing efficiency in distributed architectures.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.380.1">Overall, the fan-out/fan-in pattern is valuable for managing and processing data from various sources in distributed systems, enabling efficient parallel processing and streamlined aggregation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.381.1">Increasing the number of microservices requires careful orchestration, which is where the service mesh comes into the picture. </span><span class="koboSpan" id="kobo.381.2">Let’s learn more about it.</span></p>
<h2 class="heading-2" id="_idParaDest-162"><span class="koboSpan" id="kobo.382.1">Service mesh pattern</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.383.1">In modern software development, microservices have become a go-to approach for building flexible </span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.384.1">and scalable applications. </span><span class="koboSpan" id="kobo.384.2">However, as the number of microservices increases, managing their communication and reliability can become more challenging than navigating a busy road intersection. </span><span class="koboSpan" id="kobo.384.3">This is where the concept of the </span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.385.1">service mesh enters the picture, simplifying microservices’ communication while enhancing their robustness.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.386.1">Imagine you’re at a bustling city intersection with multiple lanes of traffic. </span><span class="koboSpan" id="kobo.386.2">Each vehicle represents a microservice, serving a specific purpose. </span><span class="koboSpan" id="kobo.386.3">To ensure smooth traffic flow and prevent collisions, traffic lights, signs, and road rules are essential. </span><span class="koboSpan" id="kobo.386.4">Similarly, a service mesh acts as the traffic controller for microservices, regulating their interactions and ensuring they work harmoniously.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.387.1">A service mesh is a layer of the infrastructure that manages communication between different services in a cloud application. </span><span class="koboSpan" id="kobo.387.2">It ensures reliable message delivery among these services. </span><span class="koboSpan" id="kobo.387.3">Builders can focus on core application programming, while the service mesh takes care of networking and security in the system’s infrastructure.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.388.1">The following diagram illustrates a service mesh infrastructure with AWS services as an example.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.389.1"><img alt="" role="presentation" src="../Images/B21336_05_05.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.390.1">Figure 5.5: Service mesh pattern architecture in AWS cloud</span></p>
<p class="normal"><span class="koboSpan" id="kobo.391.1">Let’s walk </span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.392.1">through each step illustrated in </span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.393.1">the service mesh diagram:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><strong class="screenText"><span class="koboSpan" id="kobo.394.1">EC2 Service A</span></strong><span class="koboSpan" id="kobo.395.1">: This represents an Amazon EC2 instance running a service (</span><strong class="keyWord"><span class="koboSpan" id="kobo.396.1">Service A)</span></strong><span class="koboSpan" id="kobo.397.1">. </span><span class="koboSpan" id="kobo.397.2">EC2 instances </span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.398.1">provide scalable computing capacity in the </span><strong class="keyWord"><span class="koboSpan" id="kobo.399.1">Amazon Web Services</span></strong><span class="koboSpan" id="kobo.400.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.401.1">AWS</span></strong><span class="koboSpan" id="kobo.402.1">) cloud.</span></li>
<li class="numberedList"><strong class="screenText"><span class="koboSpan" id="kobo.403.1">Calls Service B</span></strong><span class="koboSpan" id="kobo.404.1">: Service A initiates a call to </span><strong class="keyWord"><span class="koboSpan" id="kobo.405.1">Service B</span></strong><span class="koboSpan" id="kobo.406.1">. </span><span class="koboSpan" id="kobo.406.2">This is the beginning of an inter-service communication process.</span></li>
<li class="numberedList"><strong class="screenText"><span class="koboSpan" id="kobo.407.1">Communication</span></strong><span class="koboSpan" id="kobo.408.1">: This block represents the communication layer where Service A’s request is captured to be routed through the service mesh.</span></li>
<li class="numberedList"><strong class="screenText"><span class="koboSpan" id="kobo.409.1">Through App Mesh</span></strong><span class="koboSpan" id="kobo.410.1">: The request from Service A goes through AWS App Mesh, which is a service mesh that provides application-level networking. </span><span class="koboSpan" id="kobo.410.2">App Mesh standardizes how services communicate, giving end-to-end visibility and ensuring high availability for applications.</span></li>
<li class="numberedList"><strong class="screenText"><span class="koboSpan" id="kobo.411.1">Routes to Service B</span></strong><span class="koboSpan" id="kobo.412.1">: AWS App Mesh routes the request to the appropriate service, in this case, Service B.</span></li>
<li class="numberedList"><strong class="screenText"><span class="koboSpan" id="kobo.413.1">ECS Service B</span></strong><span class="koboSpan" id="kobo.414.1">: This represents an Amazon </span><strong class="keyWord"><span class="koboSpan" id="kobo.415.1">Elastic Container Service</span></strong><span class="koboSpan" id="kobo.416.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.417.1">ECS</span></strong><span class="koboSpan" id="kobo.418.1">) task running Service B. </span><span class="koboSpan" id="kobo.418.2">ECS is a highly scalable, high-performance container management service that supports Docker containers.</span></li>
<li class="numberedList"><strong class="screenText"><span class="koboSpan" id="kobo.419.1">Calls Service C</span></strong><span class="koboSpan" id="kobo.420.1">: After Service B completes its processing, it calls</span><strong class="keyWord"><span class="koboSpan" id="kobo.421.1"> Service C</span></strong><span class="koboSpan" id="kobo.422.1">. </span><span class="koboSpan" id="kobo.422.2">This could be part of a larger transaction that involves multiple microservices.</span></li>
<li class="numberedList"><strong class="screenText"><span class="koboSpan" id="kobo.423.1">Routes to Service C</span></strong><span class="koboSpan" id="kobo.424.1">: Again, AWS App Mesh routes the call from Service B to Service C.</span></li>
<li class="numberedList"><strong class="screenText"><span class="koboSpan" id="kobo.425.1">Lambda Service C</span></strong><span class="koboSpan" id="kobo.426.1">: This represents an AWS Lambda function for Service C. </span><span class="koboSpan" id="kobo.426.2">AWS Lambda lets you run code without provisioning or managing servers. </span><span class="koboSpan" id="kobo.426.3">It executes your code only when needed and scales automatically.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.427.1">The architecture </span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.428.1">abstracts the complex </span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.429.1">interplay of services within a service mesh, illustrating the role of AWS App Mesh in managing, routing, and controlling the communication between different services.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.430.1">Here are the </span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.431.1">primary features provided by a service mesh:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.432.1">Traffic management</span></strong><span class="koboSpan" id="kobo.433.1">: Service meshes provide detailed control over traffic behavior with rich routing rules, retries, failovers, and fault injection.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.434.1">Observability</span></strong><span class="koboSpan" id="kobo.435.1">: They give you deep insights into your applications through visualizations, tracing, monitoring, and logging traffic between services.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.436.1">Security</span></strong><span class="koboSpan" id="kobo.437.1">: Service meshes offer automated </span><strong class="keyWord"><span class="koboSpan" id="kobo.438.1">mutual TLS</span></strong><span class="koboSpan" id="kobo.439.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.440.1">mTLS</span></strong><span class="koboSpan" id="kobo.441.1">) traffic encryption between your services.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.442.1">Policy enforcement</span></strong><span class="koboSpan" id="kobo.443.1">: They allow you to define and enforce policies consistently across all your services, regardless of where they run.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.444.1">Resilience</span></strong><span class="koboSpan" id="kobo.445.1">: Service meshes enable advanced load balancing, timeouts, and retries, helping you create more resilient applications.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.446.1">A popular way to implement a service mesh is by using sidecar proxies. </span><span class="koboSpan" id="kobo.446.2">Each service instance in a microservices application is paired with a sidecar proxy, which handles all the network communication to and from the service. </span><span class="koboSpan" id="kobo.446.3">All these proxies are networked into a mesh, hence the name “service mesh.”</span></p>
<p class="normal"><span class="koboSpan" id="kobo.447.1">Service meshes are becoming an essential part of modern, cloud-native application architectures, offering a variety of implementations tailored to different needs and environments. </span><span class="koboSpan" id="kobo.447.2">Among the most popular service mesh implementations are:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.448.1">Istio</span></strong><span class="koboSpan" id="kobo.449.1">: This comprehensive service mesh solution provides a robust way to control </span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.450.1">service-to-service communication within a microservice architecture. </span><span class="koboSpan" id="kobo.450.2">It allows developers to define detailed routing rules and policies, implement </span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.451.1">resilience patterns like retries and circuit breakers, and gather insights into application traffic flows. </span><span class="koboSpan" id="kobo.451.2">Istio’s ability to enforce policies and collect metrics helps in securing and observing communications between services, thereby enhancing the network’s reliability and performance.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.452.1">Linkerd</span></strong><span class="koboSpan" id="kobo.453.1">: Known for </span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.454.1">its focus on simplicity </span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.455.1">and performance, Linkerd is an open-source service mesh that provides critical features such as service discovery, routing, failure handling, and visibility to modern application infrastructures. </span><span class="koboSpan" id="kobo.455.2">It’s designed to be lightweight and easy to install, with a minimal footprint that makes it an attractive choice for teams looking to adopt service mesh technology without significant overhead.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.456.1">AWS App Mesh</span></strong><span class="koboSpan" id="kobo.457.1">: Specifically designed for AWS users, App Mesh is a managed </span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.458.1">service mesh service that makes it easy to manage and control communications between microservices across AWS services. </span><span class="koboSpan" id="kobo.458.2">It supports application-level networking, enabling the application services to </span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.459.1">communicate over the network with more visibility and control. </span><span class="koboSpan" id="kobo.459.2">AWS App Mesh simplifies the configuration of service communication, providing application-level insights and ensuring high availability for your applications.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.460.1">Consul Connect</span></strong><span class="koboSpan" id="kobo.461.1">: Part of HashiCorp Consul, Consul Connect focuses on securing </span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.462.1">service-to-service communication with automatic TLS encryption and identity-based authorization. </span><span class="koboSpan" id="kobo.462.2">It’s built to be platform-agnostic, providing a consistent, unified method </span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.463.1">of securing and configuring communication across services, regardless of the underlying platform. </span><span class="koboSpan" id="kobo.463.2">With its emphasis on security, Consul Connect ensures that only authorized services can communicate with each other, thereby reducing the risk of internal threats.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.464.1">While service meshes offer a range of benefits for microservice architecture, such as improved service-to-service communication, enhanced security, and better observability, it’s crucial to consider the complexity they introduce to your infrastructure. </span><span class="koboSpan" id="kobo.464.2">Incorporating a service mesh involves additional components to manage, monitor, and maintain, which could increase the operational overhead for your team. </span><span class="koboSpan" id="kobo.464.3">This added layer of infrastructure requires careful planning, skilled personnel to manage it, and a clear understanding of its impact on your system’s performance and complexity. </span><span class="koboSpan" id="kobo.464.4">Therefore, evaluating the specific needs of your application and weighing the advantages against the potential increase in infrastructure complexity is essential before deciding to implement a service mesh. </span><span class="koboSpan" id="kobo.464.5">This cautious approach ensures that the benefits of adopting a service mesh align with your application’s requirements and your team’s capacity to manage the additional complexity.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.465.1">AWS App Mesh </span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.466.1">is a service that normalizes communication across your </span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.467.1">services, offering comprehensive monitoring and promoting consistent availability. </span><span class="koboSpan" id="kobo.467.2">The following architecture diagram depicts the implementation of the service mesh pattern using AWS cloud services:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.468.1"><img alt="" role="presentation" src="../Images/B21336_05_06.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.469.1">Figure 5.6 – An e-commerce application managed by App Mesh in AWS</span></p>
<p class="normal"><span class="koboSpan" id="kobo.470.1">As shown in the preceding diagram, Amazon Fargate operates as a serverless engine for container computing, compatible </span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.471.1">with Amazon </span><strong class="keyWord"><span class="koboSpan" id="kobo.472.1">Elastic Container Service</span></strong><span class="koboSpan" id="kobo.473.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.474.1">ECS</span></strong><span class="koboSpan" id="kobo.475.1">) and Amazon </span><strong class="keyWord"><span class="koboSpan" id="kobo.476.1">Elastic Kubernetes Service</span></strong><span class="koboSpan" id="kobo.477.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.478.1">EKS</span></strong><span class="koboSpan" id="kobo.479.1">). </span><span class="koboSpan" id="kobo.479.2">The following are </span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.480.1">the steps to implement an e-commerce </span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.481.1">application managed by App Mesh:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><strong class="keyWord"><span class="koboSpan" id="kobo.482.1">Create Fargate services</span></strong><span class="koboSpan" id="kobo.483.1">: Define each microservice (User, Order, Payment, Product Catalog, and Authentication) as an Amazon Fargate on EKS with the required task definitions.</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.484.1">Set up AWS App Mesh</span></strong><span class="koboSpan" id="kobo.485.1">: Create a mesh that serves as a logical boundary for the network traffic between services.</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.486.1">Define virtual nodes</span></strong><span class="koboSpan" id="kobo.487.1">: Create a virtual node for each ECS service in App Mesh. </span><span class="koboSpan" id="kobo.487.2">A virtual node acts as a logical pointer to a particular ECS service.</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.488.1">Create virtual routers and routes</span></strong><span class="koboSpan" id="kobo.489.1">: Define virtual routers and routes to control the traffic flow between virtual nodes.</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.490.1">Configure virtual services</span></strong><span class="koboSpan" id="kobo.491.1">: Virtual services route traffic to virtual nodes, enabling the discovery of services within the mesh.</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.492.1">Deploy sidecar proxies</span></strong><span class="koboSpan" id="kobo.493.1">: Attach an Envoy proxy to each ECS task definition as a sidecar container. </span><span class="koboSpan" id="kobo.493.2">Envoy proxies intercept and manage the traffic between microservices.</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.494.1">Monitor and log</span></strong><span class="koboSpan" id="kobo.495.1">: Use AWS CloudWatch and AWS X-Ray to monitor and log the traffic flowing through the mesh.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.496.1">Implementing a service mesh can enhance service-to-service communication, security, and observability. </span><span class="koboSpan" id="kobo.496.2">This approach allows you to manage a microservice architecture more efficiently and effectively, providing a robust and scalable solution for complex applications. </span><span class="koboSpan" id="kobo.496.3">Recovery from failure is an important aspect of building large-scale architecture. </span><span class="koboSpan" id="kobo.496.4">Let’s learn about reactive architecture to solve this problem.</span></p>
<h1 class="heading-1" id="_idParaDest-163"><span class="koboSpan" id="kobo.497.1">Reactive architecture</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.498.1">As cloud-native architecture can have various moving parts due to multiple microservices </span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.499.1">and small modules, they need to be protected from failure. </span><span class="koboSpan" id="kobo.499.2">Reactive architecture is a design approach for building software that can efficiently handle changes and stay responsive under various conditions. </span><span class="koboSpan" id="kobo.499.3">It benefits large-scale and distributed systems that must maintain high availability and responsiveness, even in the face of failures or high demand.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.500.1">The principles of reactive architecture are based on the Reactive Manifesto, a document that outlines the core traits of reactive systems: responsive, resilient, elastic, and message-driven. </span><span class="koboSpan" id="kobo.500.2">You can </span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.501.1">find details on the Reactive Manifesto by visiting: </span><a href="https://www.reactivemanifesto.org/"><span class="url"><span class="koboSpan" id="kobo.502.1">https://www.reactivemanifesto.org/</span></span></a><span class="koboSpan" id="kobo.503.1">:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.504.1">Responsive</span></strong><span class="koboSpan" id="kobo.505.1">: Reactive systems prioritize responsiveness, ensuring they respond to user requests promptly regardless of the system’s load or state.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.506.1">Resilient</span></strong><span class="koboSpan" id="kobo.507.1">: Reactive systems are designed to handle failures gracefully. </span><span class="koboSpan" id="kobo.507.2">They can recover quickly and operate, even when some components fail.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.508.1">Elastic</span></strong><span class="koboSpan" id="kobo.509.1">: Reactive systems can scale up or down based on demand, efficiently utilizing resources and maintaining responsiveness under varying workloads.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.510.1">Message-driven</span></strong><span class="koboSpan" id="kobo.511.1">: In reactive systems, components communicate using messages that are passed asynchronously. </span><span class="koboSpan" id="kobo.511.2">This approach allows for components to be loosely connected, independently isolated, and accessible from different locations.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.512.1">The reactive architecture style leans heavily on microservices, which segment functionality into smaller, independently scalable services for improved scalability, maintainability, and </span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.513.1">faster deployment cycles. </span><span class="koboSpan" id="kobo.513.2">Communication within reactive systems is event-driven, meaning components interact and react through asynchronous events, leading to more efficient use of resources and better system performance.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.514.1">To manage data, reactive architectures adopt a decentralized approach, where each microservice manages its own data, minimizing dependency and contention over shared data resources. </span><span class="koboSpan" id="kobo.514.2">This not only bolsters the system’s resilience but also its ability to recover swiftly from failures. </span><span class="koboSpan" id="kobo.514.3">Isolation and autonomy are central to reactive systems, ensuring that components can fail independently without impacting the overall system’s availability, thus enhancing fault tolerance.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.515.1">Scalability is achieved through horizontal scaling, where the system can grow to accommodate increased loads by adding more instances of services rather than upgrading the capacity of existing instances. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.516.1">Additionally, reactive architectures implement resilience patterns such as circuit breakers, timeouts, and retries. </span><span class="koboSpan" id="kobo.516.2">These mechanisms help in managing and recovering from failures, preventing one component’s issues from cascading into system-wide disruptions. </span><span class="koboSpan" id="kobo.516.3">Together, these principles facilitate the creation of systems that are more responsive to user demands, resilient to failures, and capable of graceful degradation under load.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.517.1">Reactive architecture benefits large-scale, distributed systems that need to handle varying workloads, recover from failures quickly, and provide a responsive user experience.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.518.1">Imagine an online gaming platform with thousands of players simultaneously interacting in virtual worlds. </span><span class="koboSpan" id="kobo.518.2">Reactive architecture can be applied here to ensure a seamless and responsive gaming experience:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.519.1">Responsive</span></strong><span class="koboSpan" id="kobo.520.1">: The system quickly responds to players’ actions, allowing characters to move, cast spells, and interact with objects in real time.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.521.1">Resilient</span></strong><span class="koboSpan" id="kobo.522.1">: If a server experiences a sudden crash due to a technical glitch, the architecture automatically redistributes the load to healthy servers, ensuring uninterrupted gameplay for other players.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.523.1">Elastic</span></strong><span class="koboSpan" id="kobo.524.1">: As more players join the game during peak hours, the architecture dynamically allocates additional server resources to handle the increased load. </span><span class="koboSpan" id="kobo.524.2">When player numbers decrease, surplus resources are released to save costs.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.525.1">Message-driven</span></strong><span class="koboSpan" id="kobo.526.1">: Player actions, such as casting spells or trading items, are communicated through messages. </span><span class="koboSpan" id="kobo.526.2">This asynchronous communication minimizes bottlenecks and ensures smooth gameplay despite many concurrent actions.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.527.1">To implement </span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.528.1">the reactive architecture, you can take the following steps:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.529.1">Design components to communicate asynchronously using message queues. </span><span class="koboSpan" id="kobo.529.2">This prevents blocking and enhances responsiveness.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.530.1">Implement the Actor model, where components (actors) communicate through messages. </span><span class="koboSpan" id="kobo.530.2">Each actor processes messages sequentially, avoiding concurrency issues.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.531.1">Integrate resilience patterns like Circuit Breaker and Bulkhead to handle failures and prevent cascading errors. </span><span class="koboSpan" id="kobo.531.2">You learned about these patterns in </span><em class="chapterRef"><span class="koboSpan" id="kobo.532.1">Chapter 4</span></em><span class="koboSpan" id="kobo.533.1">, </span><em class="italic"><span class="koboSpan" id="kobo.534.1">Solution Architecture Design Patterns</span></em><span class="koboSpan" id="kobo.535.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.536.1">Utilize auto-scaling mechanisms to allocate resources based on load dynamically. </span><span class="koboSpan" id="kobo.536.2">Cloud platforms like AWS provide tools for this purpose.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.537.1">Leverage reactive libraries or frameworks like Akka, Spring WebFlux, or ReactiveX, which offer abstractions for building reactive systems.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.538.1">Let’s explore how to implement reactive architecture using AWS services for an ad-tracking use case. </span><span class="koboSpan" id="kobo.538.2">The following diagram demonstrates reactive architecture for an ad tech company:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.539.1"><img alt="" role="presentation" src="../Images/B21336_05_07.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.540.1">Figure 5.7 – Reference architecture for an ad-tracking application </span></p>
<p class="normal"><span class="koboSpan" id="kobo.541.1">The architecture depicted in the preceding diagram demonstrates an ad-tracking application using AWS’s architecture for both real-time and batch processing.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.542.1">In the given </span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.543.1">architectural layout, when a user views or clicks an ad, the application load balancer captures this request and forwards it to the appropriate service within the primary application. </span><span class="koboSpan" id="kobo.543.2">The application independently processes each request in a timely and robust manner, avoiding immediate database writes. </span><span class="koboSpan" id="kobo.543.3">Instead, Amazon Kinesis Data Streams collects these events, and an AWS Lambda function is then responsible for recording the information into an Amazon DynamoDB table. </span><span class="koboSpan" id="kobo.543.4">Amazon Kinesis Data Streams is a highly scalable and durable real-time data streaming service designed to collect, process, and analyze streaming data. </span><span class="koboSpan" id="kobo.543.5">This setup of data streams serves as a protective intermediary, ensuring no data is lost during high-traffic periods.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.544.1">To optimize access speed to essential data, Amazon ElastiCache for Redis acts as the primary cache. </span><span class="koboSpan" id="kobo.544.2">Core data updates are synchronized through a message-passing architecture, using event streams to capture and communicate changes from all contributing systems. </span><span class="koboSpan" id="kobo.544.3">This arrangement allows the handling of varying request volumes, with Lambda functions processing stream data and refreshing the primary cache to ensure system integrity and performance.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.545.1">Integrating these </span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.546.1">AWS services allows you to build a reactive architecture for your online ad platform. </span><span class="koboSpan" id="kobo.546.2">The services provided by AWS align with the core principles of responsiveness, resilience, elasticity, and message-driven communication that define a reactive system. </span><span class="koboSpan" id="kobo.546.3">Loosely coupled architecture plays a key role in building highly scalable cloud-native architecture, and message queues play a pivotal role in that, so let’s learn about some queue-based architectural patterns.</span></p>
<h1 class="heading-1" id="_idParaDest-164"><span class="koboSpan" id="kobo.547.1">Building queue-based architecture</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.548.1">In the previous sections, you learned about microservice design using RESTful architecture. </span><span class="koboSpan" id="kobo.548.2">The RESTful architecture helps your microservice to be easily discoverable, but what </span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.549.1">happens if your service goes down? </span><span class="koboSpan" id="kobo.549.2">RESTful is a contemporary architecture where your client service waits for a response from the host service, which means that the HTTP request blocks the API. </span><span class="koboSpan" id="kobo.549.3">Sometimes, your information may be lost due to the unavailability of a downstream service. </span><span class="koboSpan" id="kobo.549.4">You must implement some retry logic to retain your information in such cases.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.550.1">A queue-based architecture solves this problem by adding message queues between services, which hold information on behalf of services. </span><span class="koboSpan" id="kobo.550.2">The queue-based architecture provides fully asynchronous communication and a loosely coupled architecture. </span><span class="koboSpan" id="kobo.550.3">In a queue-based architecture, your information is still available in the message. </span><span class="koboSpan" id="kobo.550.4">If a service crashes, the message can get the process as soon as the service becomes available. </span><span class="koboSpan" id="kobo.550.5">Let’s learn some </span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.551.1">of the terminology of a queue-based architecture:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.552.1">Message</span></strong><span class="koboSpan" id="kobo.553.1">: A message has two parts—the header and the body. </span><span class="koboSpan" id="kobo.553.2">The header contains metadata about the message, while the body contains the actual message.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.554.1">Queue</span></strong><span class="koboSpan" id="kobo.555.1">: The queue holds the messages that can be used when required.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.556.1">Producer</span></strong><span class="koboSpan" id="kobo.557.1">: A service that produces and publishes a message to the queue.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.558.1">Consumer</span></strong><span class="koboSpan" id="kobo.559.1">: A service that consumes and utilizes the message.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.560.1">Message broker</span></strong><span class="koboSpan" id="kobo.561.1">: This helps to gather, route, and distribute messages between </span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.562.1">the producer and consumer.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.563.1">Let’s explore some typical queue-based architecture patterns to understand how they work.</span></p>
<h2 class="heading-2" id="_idParaDest-165"><span class="koboSpan" id="kobo.564.1">Queuing chain pattern</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.565.1">A queuing chain pattern is applied when sequential processing needs to run on multiple linked systems. </span><span class="koboSpan" id="kobo.565.2">Let’s understand the queuing chain pattern using the example of an image-processing </span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.566.1">application. </span><span class="koboSpan" id="kobo.566.2">In an image-processing pipeline, sequential operations of capturing the image and storing it on </span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.567.1">a server, running a job to create different-resolution copies of the image, watermarking the image, and thumbnail generation are tightly linked to each other. </span><span class="koboSpan" id="kobo.567.2">A failure in one part can cause the entire operation to be disrupted.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.568.1">You can use queues between various systems and jobs to remove a single point of failure and design true loosely coupled systems. </span><span class="koboSpan" id="kobo.568.2">The queuing chain pattern helps you to link different systems together and increases the number of servers that can process the messages in parallel. </span><span class="koboSpan" id="kobo.568.3">You can </span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.569.1">configure </span><strong class="keyWord"><span class="koboSpan" id="kobo.570.1">auto-scaling</span></strong><span class="koboSpan" id="kobo.571.1"> to terminate the excess servers if there is no image to process.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.572.1">The following diagram shows the queuing chain pattern architecture for our image-processing </span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.573.1">application. </span><span class="koboSpan" id="kobo.573.2">Here, the queue provided by AWS is called Amazon </span><strong class="keyWord"><span class="koboSpan" id="kobo.574.1">Simple Queue Service</span></strong><span class="koboSpan" id="kobo.575.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.576.1">SQS</span></strong><span class="koboSpan" id="kobo.577.1">):</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.578.1"><img alt="" role="presentation" src="../Images/B21336_05_08.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.579.1">Figure 5.8: Queuing chain pattern architecture</span></p>
<p class="normal"><span class="koboSpan" id="kobo.580.1">The preceding </span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.581.1">architecture has the </span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.582.1">following steps:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.583.1">When the raw image is uploaded to the server, the application must watermark all images </span><a id="_idIndexMarker639"/><span class="koboSpan" id="kobo.584.1">with the company’s logo. </span><span class="koboSpan" id="kobo.584.2">A fleet of Amazon </span><strong class="keyWord"><span class="koboSpan" id="kobo.585.1">EC2</span></strong><span class="koboSpan" id="kobo.586.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.587.1">Elastic Cloud Compute</span></strong><span class="koboSpan" id="kobo.588.1">) servers runs batch jobs to watermark all the images and push the processed image into the Amazon SQS queue.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.589.1">The second fleet of Amazon EC2 servers pulls the watermarked images from the Amazon SQS queue.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.590.1">The second fleet of EC2 workers processes the image and creates variations with different resolutions.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.591.1">After encoding the images, the EC2 workers push the message into another Amazon SQS queue for thumbnail creation.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.592.1">As the image is processed, the job deletes the message from the previous queue to make space.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.593.1">The final fleet of EC2 servers gets encoded messages from the queue and creates thumbnails along with the copyright.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.594.1">The benefits </span><a id="_idIndexMarker640"/><span class="koboSpan" id="kobo.595.1">of this architecture are as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.596.1">You can use loosely coupled asynchronous processing to return responses quickly without waiting for another service acknowledgment.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.597.1">You can structure the system by loosely coupling Amazon EC2 instances or containers using Amazon SQS.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.598.1">A message in the queue service remains intact even if there’s a failure with the Amazon EC2 instance. </span><span class="koboSpan" id="kobo.598.2">This is crucial for maintaining data integrity and system robustness, as it ensures that processing can resume once the server is back online. </span><span class="koboSpan" id="kobo.598.3">This design creates a resilient system that can withstand and recover from server failures without losing critical data.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.599.1">You may get </span><a id="_idIndexMarker641"/><span class="koboSpan" id="kobo.600.1">fluctuations in application </span><a id="_idIndexMarker642"/><span class="koboSpan" id="kobo.601.1">demand that can cause unexpected message loads. </span><span class="koboSpan" id="kobo.601.2">Automating your workload using the queuing chain pattern will help you handle any fluctuations. </span><span class="koboSpan" id="kobo.601.3">Let’s learn more about using the job observer pattern to handle sudden workload fluctuations.</span></p>
<h2 class="heading-2" id="_idParaDest-166"><span class="koboSpan" id="kobo.602.1">Job observer pattern</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.603.1">Queuing chain patterns help you design a loosely coupled architecture, but how will you handle workload spikes? </span><span class="koboSpan" id="kobo.603.2">In the case of request fluctuation, you need to adjust your processing </span><a id="_idIndexMarker643"/><span class="koboSpan" id="kobo.604.1">power based on user demand, which the job observer </span><a id="_idIndexMarker644"/><span class="koboSpan" id="kobo.605.1">pattern can address.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.606.1">In the job observer pattern, you can create an auto-scaling group based on the number of messages in the queue to process. </span><span class="koboSpan" id="kobo.606.2">The job observer pattern helps you to maintain performance by increasing or decreasing the number of server instances used in job processing.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.607.1">The following diagram depicts the job observer pattern:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.608.1"><img alt="" role="presentation" src="../Images/B21336_05_09.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.609.1">Figure 5.9: Job observer pattern architecture</span></p>
<p class="normal"><span class="koboSpan" id="kobo.610.1">In the preceding architecture, the first fleet of Amazon </span><strong class="keyWord"><span class="koboSpan" id="kobo.611.1">EC2</span></strong><span class="koboSpan" id="kobo.612.1"> servers, which is the virtual server of AWS, is on the left-hand side, running batch jobs and putting messages in the queue, such as </span><a id="_idIndexMarker645"/><span class="koboSpan" id="kobo.613.1">image metadata. </span><span class="koboSpan" id="kobo.613.2">The second </span><a id="_idIndexMarker646"/><span class="koboSpan" id="kobo.614.1">fleet of EC2 servers on the right-hand side is consuming and processing those messages, for example, image encoding. </span><span class="koboSpan" id="kobo.614.2">As the message reaches a certain threshold, Amazon CloudWatch triggers auto-scaling to add the additional server in the consumer fleet to speed up the job processing. </span><span class="koboSpan" id="kobo.614.3">Auto-scaling also removes additional servers when the queue depth goes below the threshold.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.615.1">The job observer pattern computes scale with job size, providing efficiency and cost savings. </span><span class="koboSpan" id="kobo.615.2">The job observer pattern architecture allows the job to be completed quickly. </span><span class="koboSpan" id="kobo.615.3">The process is resilient, which means job processing doesn’t stop if a server fails.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.616.1">While queue-based </span><a id="_idIndexMarker647"/><span class="koboSpan" id="kobo.617.1">architecture provides loose coupling, it works mainly on the </span><strong class="keyWord"><span class="koboSpan" id="kobo.618.1">asynchronous p</span></strong><strong class="keyWord"><span class="koboSpan" id="kobo.619.1">ull</span></strong><span class="koboSpan" id="kobo.620.1"> method, where the consumer can pull messages from the queue when they are available.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.621.1">In cloud-native architecture, it often helps if you build smaller independent steps between various architecture components, where one event should trigger other events. </span><span class="koboSpan" id="kobo.621.2">To implement this, let’s learn more about the Pipes-and-Filters architecture in the next section.</span></p>
<h1 class="heading-1" id="_idParaDest-167"><span class="koboSpan" id="kobo.622.1">Pipes-and-Filters Architecture</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.623.1">Pipes-and-Filters architecture is a software design pattern that divides complex tasks into a sequence </span><a id="_idIndexMarker648"/><span class="koboSpan" id="kobo.624.1">of smaller, independent processing steps or stages. </span><span class="koboSpan" id="kobo.624.2">Each stage performs a specific operation on the input data and passes the transformed data to the next stage through a “pipe.” </span><span class="koboSpan" id="kobo.624.3">The stages are called “filters,” and the connectors are called “pipes.” </span><span class="koboSpan" id="kobo.624.4">Let’s take a closer look at the primary components </span><a id="_idIndexMarker649"/><span class="koboSpan" id="kobo.625.1">of this architecture:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.626.1">Filters</span></strong><span class="koboSpan" id="kobo.627.1">: These processing units perform specific operations on the data. </span><span class="koboSpan" id="kobo.627.2">Filters read input data, process it, and produce output data. </span><span class="koboSpan" id="kobo.627.3">Each filter works independently and can be implemented and tested separately.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.628.1">Pipes</span></strong><span class="koboSpan" id="kobo.629.1">: Pipes are the connectors that transport data between filters. </span><span class="koboSpan" id="kobo.629.2">They can be simple data streams or more complex mechanisms, such as message queues, that provide buffering, synchronization, and data format conversion.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.630.1">The primary advantage of this architectural pattern is that it is a robust structure that promotes separation of concerns and modularity, making it easier to understand, modify, and maintain complex systems. </span><span class="koboSpan" id="kobo.630.2">It is favored for its reusability, composability, sequential processing, and scalability. </span><span class="koboSpan" id="kobo.630.3">Individual filters, which perform discrete processing tasks, can be reused across various applications, ensuring consistency and reducing development time. </span><span class="koboSpan" id="kobo.630.4">The composability of these filters allows for the construction of complex processing chains that can be easily modified by rearranging the filters as needed. </span><span class="koboSpan" id="kobo.630.5">Data flows through the pipeline in a clear, sequential manner, allowing each filter to transform the data step by step, which simplifies understanding and maintaining the system. </span><span class="koboSpan" id="kobo.630.6">Moreover, this pattern supports scalability as filters can run in parallel and be distributed across multiple computational nodes, enabling the system to handle increasing workloads effectively.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.631.1">Let’s understand this by taking an example. </span><span class="koboSpan" id="kobo.631.2">Imagine a text processing pipeline that reads a text file, removes stop words, performs stemming (reducing words to their root form), and counts the occurrences of each word. </span><span class="koboSpan" id="kobo.631.3">This can be implemented using the Pipes-and-Filters architecture:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><strong class="keyWord"><span class="koboSpan" id="kobo.632.1">Filter 1—Read File</span></strong><span class="koboSpan" id="kobo.633.1">: Reads the text file and outputs lines of text</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.634.1">Filter 2—Tokenize</span></strong><span class="koboSpan" id="kobo.635.1">: Splits lines into individual words</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.636.1">Filter 3—Remove Stop Words</span></strong><span class="koboSpan" id="kobo.637.1">: Removes common words like “and,” “the,” “is,” etc.</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.638.1">Filter 4—Stemming</span></strong><span class="koboSpan" id="kobo.639.1">: Reduces words to their root form (e.g., “walking” to “walk”)</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.640.1">Filter 5—Count Words</span></strong><span class="koboSpan" id="kobo.641.1">: Counts the occurrences of each word</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.642.1">The filters are connected with pipes that transport data between them. </span><span class="koboSpan" id="kobo.642.2">The pipeline reads the text file, processes it step by step, and outputs the word frequencies.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.643.1">The Pipes-and-Filters </span><a id="_idIndexMarker650"/><span class="koboSpan" id="kobo.644.1">architecture is a powerful design pattern for building modular and easily extensible systems. </span><span class="koboSpan" id="kobo.644.2">Architects can create flexible, maintainable, scalable applications by dividing complex tasks into a sequence of smaller, independent filters connected by pipes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.645.1">Next, let’s learn more about </span><strong class="keyWord"><span class="koboSpan" id="kobo.646.1">Event-Driven Architecture</span></strong><span class="koboSpan" id="kobo.647.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.648.1">EDA</span></strong><span class="koboSpan" id="kobo.649.1">), a design paradigm in which the flow of the program is determined by events such as user actions or messages from other programs. </span><span class="koboSpan" id="kobo.649.2">These events are processed asynchronously by independent components, allowing systems to be highly responsive and adaptable to changes or fluctuations in workload.</span></p>
<h1 class="heading-1" id="_idParaDest-168"><span class="koboSpan" id="kobo.650.1">Creating Event-Driven Architecture</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.651.1">When EDA is implemented into a cloud-native architecture, it enhances the system’s ability to react </span><a id="_idIndexMarker651"/><span class="koboSpan" id="kobo.652.1">to real-time data and events. </span><span class="koboSpan" id="kobo.652.2">This combination can lead to highly efficient, scalable systems that can respond quickly to changes. </span><span class="koboSpan" id="kobo.652.3">The cloud-native environment supports the dynamic allocation of resources to handle the variable loads of event-driven systems, while the EDA provides the mechanism for immediate and reactive processing.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.653.1">EDA helps you chain a series of events to complete a functional flow. </span><span class="koboSpan" id="kobo.653.2">For example, when you are making a payment to buy something on a website, you expect to get your order invoice generated and an email as soon as the payment is complete. </span><span class="koboSpan" id="kobo.653.3">Event-driven architecture helps to rope in all of these events so that making a payment can trigger another task to complete the order flow. </span><span class="koboSpan" id="kobo.653.4">Often, you will see message queues, which you learned about in the previous section, as the central point while talking about EDA. </span><span class="koboSpan" id="kobo.653.5">EDA can also be based on the publisher/subscriber or event stream models.</span></p>
<h2 class="heading-2" id="_idParaDest-169"><span class="koboSpan" id="kobo.654.1">Publisher/subscriber model</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.655.1">In the </span><strong class="keyWord"><span class="koboSpan" id="kobo.656.1">publisher</span></strong><span class="koboSpan" id="kobo.657.1">/</span><strong class="keyWord"><span class="koboSpan" id="kobo.658.1">subscriber</span></strong><span class="koboSpan" id="kobo.659.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.660.1">pub</span></strong><span class="koboSpan" id="kobo.661.1">/</span><strong class="keyWord"><span class="koboSpan" id="kobo.662.1">sub</span></strong><span class="koboSpan" id="kobo.663.1">) model, when an event is published, a notification is sent </span><a id="_idIndexMarker652"/><span class="koboSpan" id="kobo.664.1">to all subscribers, and each subscriber can take the necessary action as per their requirements for data processing.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.665.1">Let’s look </span><a id="_idIndexMarker653"/><span class="koboSpan" id="kobo.666.1">at an example of a photo studio application, which enriches a photo with different filters and sends a notification to the user. </span><span class="koboSpan" id="kobo.666.2">The following architecture depicts this pub/sub model:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.667.1"><img alt="" role="presentation" src="../Images/B21336_05_10.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.668.1">Figure 5.10: Photo studio application pub/sub event-driven architecture</span></p>
<p class="normal"><span class="koboSpan" id="kobo.669.1">In the preceding diagram, you will notice the following things:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.670.1">The user first uploads the picture to an </span><strong class="screenText"><span class="koboSpan" id="kobo.671.1">Amazon S3</span></strong><span class="koboSpan" id="kobo.672.1"> bucket using a web/mobile application.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.673.1">The </span><strong class="screenText"><span class="koboSpan" id="kobo.674.1">Amazon S3</span></strong><span class="koboSpan" id="kobo.675.1"> bucket </span><a id="_idIndexMarker654"/><span class="koboSpan" id="kobo.676.1">then sends a notification to Amazon </span><strong class="keyWord"><span class="koboSpan" id="kobo.677.1">Simple Notification Service</span></strong><span class="koboSpan" id="kobo.678.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.679.1">SNS</span></strong><span class="koboSpan" id="kobo.680.1">). </span><strong class="screenText"><span class="koboSpan" id="kobo.681.1">Amazon SNS</span></strong><span class="koboSpan" id="kobo.682.1"> is a message topic with the following subscribers:</span><ul>
<li class="bulletList"><span class="koboSpan" id="kobo.683.1">Here, the first subscriber is using the email service, and as soon as the photo upload is complete, an email is sent to the user.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.684.1">The second subscriber uses an </span><strong class="screenText"><span class="koboSpan" id="kobo.685.1">Amazon SQS</span></strong><span class="koboSpan" id="kobo.686.1"> queue, which gets the message from the </span><strong class="screenText"><span class="koboSpan" id="kobo.687.1">Amazon SNS</span></strong><span class="koboSpan" id="kobo.688.1"> topic and applies various filters in code written in AWS Lambda to improve the image quality.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.689.1">The third subscriber uses the direct </span><strong class="screenText"><span class="koboSpan" id="kobo.690.1">AWS Lambda</span></strong><span class="koboSpan" id="kobo.691.1"> function, which creates the image thumbnail.</span></li>
</ul>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.692.1">In this architecture, Amazon S3 publishes the message to the SNS topic as a producer, which multiple subscribers consume. </span><span class="koboSpan" id="kobo.692.2">Additionally, as soon as the message comes to SQS, it triggers an event for the Lambda function to process images.</span></p>
<h2 class="heading-2" id="_idParaDest-170"><span class="koboSpan" id="kobo.693.1">Event stream model</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.694.1">In the event stream model, the consumer can read the continuous flow of events from the producer. </span><span class="koboSpan" id="kobo.694.2">For </span><a id="_idIndexMarker655"/><span class="koboSpan" id="kobo.695.1">example, you can use </span><a id="_idIndexMarker656"/><span class="koboSpan" id="kobo.696.1">the event stream to capture the continuous flow of a clickstream log and also send an alert if there are any anomalies detected, as shown in the following architecture diagram:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.697.1"><img alt="" role="presentation" src="../Images/B21336_05_11.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.698.1">Figure 5.11: Clickstream analysis event stream architecture</span></p>
<p class="normal"><span class="koboSpan" id="kobo.699.1">Amazon Kinesis is a service used to ingest, process, and store continuous streaming data. </span><span class="koboSpan" id="kobo.699.2">In the preceding diagram, various customers clicking on e-commerce applications from web and mobile applications produce a stream of click events.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.700.1">These clickstreams are sent to analytics applications using </span><strong class="screenText"><span class="koboSpan" id="kobo.701.1">Amazon API Gateway</span></strong><span class="koboSpan" id="kobo.702.1"> for real-time analytics. </span><span class="koboSpan" id="kobo.702.2">In this analytics application, </span><strong class="screenText"><span class="koboSpan" id="kobo.703.1">Amazon Kinesis Data Analytics</span></strong><span class="koboSpan" id="kobo.704.1"> calculates </span><strong class="screenText"><span class="koboSpan" id="kobo.705.1">conversion rates</span></strong><span class="koboSpan" id="kobo.706.1"> over a certain period, for example, the number of people that made a purchase in the last five minutes. </span><span class="koboSpan" id="kobo.706.2">After aggregating data in real time, </span><strong class="screenText"><span class="koboSpan" id="kobo.707.1">Amazon Kinesis Data Analytics</span></strong><span class="koboSpan" id="kobo.708.1"> sends the results to </span><strong class="screenText"><span class="koboSpan" id="kobo.709.1">Amazon Kinesis Data Firehose</span></strong><span class="koboSpan" id="kobo.710.1">, which stores all the data files in </span><strong class="screenText"><span class="koboSpan" id="kobo.711.1">Amazon S3</span></strong><span class="koboSpan" id="kobo.712.1"> storage for further processing as needed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.713.1">A Lambda function reads from the event stream and starts examining the data for </span><strong class="screenText"><span class="koboSpan" id="kobo.714.1">anomalies</span></strong><span class="koboSpan" id="kobo.715.1">. </span><span class="koboSpan" id="kobo.715.2">As anomalies in the conversion rates are detected, the </span><strong class="screenText"><span class="koboSpan" id="kobo.716.1">AWS Lambda</span></strong><span class="koboSpan" id="kobo.717.1"> function sends a notification via email for the campaign team to be notified. </span><span class="koboSpan" id="kobo.717.2">In this architecture, the event stream occurs continuously, and </span><strong class="screenText"><span class="koboSpan" id="kobo.718.1">AWS Lambda</span></strong><span class="koboSpan" id="kobo.719.1"> reads from the stream for a specific event.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.720.1">In EDA, producers and consumers operate independently, with events acting as the communication medium. </span><span class="koboSpan" id="kobo.720.2">This decoupling means that producers can send events without </span><a id="_idIndexMarker657"/><span class="koboSpan" id="kobo.721.1">knowing which consumers will process them, and consumers </span><a id="_idIndexMarker658"/><span class="koboSpan" id="kobo.722.1">can listen for events they are interested in without knowing who produced them. </span><span class="koboSpan" id="kobo.722.2">This leads to a flexible and extendable system where new consumers can be added to process events without modifying existing producers, facilitating scalability and adaptability. </span><span class="koboSpan" id="kobo.722.3">However, with the benefits </span><a id="_idIndexMarker659"/><span class="koboSpan" id="kobo.723.1">of EDA, there are also challenges that need to be addressed:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.724.1">Avoiding duplicate processing</span></strong><span class="koboSpan" id="kobo.725.1">: In distributed systems, the same event might be delivered more than once due to network retries or service outages. </span><span class="koboSpan" id="kobo.725.2">Implementing idempotency within event consumers ensures that processing an event multiple times does not lead to incorrect behavior or data inconsistencies.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.726.1">Error message handling</span></strong><span class="koboSpan" id="kobo.727.1">: A robust EDA must have a mechanism to handle errors effectively. </span><span class="koboSpan" id="kobo.727.2">This can include dead-letter queues where events that cannot be processed are stored for later inspection or retried, and error handling logic within consumers to manage exceptions without disrupting the entire system.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.728.1">Event ordering</span></strong><span class="koboSpan" id="kobo.729.1">: Ensuring that events are processed in the correct order can be critical. </span><span class="koboSpan" id="kobo.729.2">This might involve sequencing patterns or using event sourcing to maintain the order of events for each entity.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.730.1">Event tracking and monitoring</span></strong><span class="koboSpan" id="kobo.731.1">: As the system scales, tracking the flow of events and monitoring the health of the system become essential. </span><span class="koboSpan" id="kobo.731.2">Implementing proper logging, tracing, and alerting mechanisms ensures visibility into the system’s operation and quick diagnosis of issues.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.732.1">Event schema management</span></strong><span class="koboSpan" id="kobo.733.1">: As systems evolve, event schemas may change. </span><span class="koboSpan" id="kobo.733.2">Managing these changes without disrupting the system requires a schema registry and versioning strategy, allowing consumers to understand different versions of an event.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.734.1">While EDA fosters a highly scalable and extendable cloud-native architecture, it necessitates meticulous design and operational considerations to ensure that the system is resilient, consistent, and maintainable.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.735.1">When discussing </span><a id="_idIndexMarker660"/><span class="koboSpan" id="kobo.736.1">modular architecture, it’s essential that modularity </span><a id="_idIndexMarker661"/><span class="koboSpan" id="kobo.737.1">extends across all architectural layers to truly achieve scalability. </span><span class="koboSpan" id="kobo.737.2">Let’s explore the BFF design pattern, which champions this approach.</span></p>
<h1 class="heading-1" id="_idParaDest-171"><span class="koboSpan" id="kobo.738.1">Backend for Frontend pattern</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.739.1">The BFF pattern is a cloud-native architectural approach that tailors backend services for each specific </span><a id="_idIndexMarker662"/><span class="koboSpan" id="kobo.740.1">type of frontend application. </span><span class="koboSpan" id="kobo.740.2">BFF is a design pattern that emerged as a response to the growing complexity of modern web and mobile applications. </span><span class="koboSpan" id="kobo.740.3">It involves creating separate backend services tailored to each frontend or user experience. </span><span class="koboSpan" id="kobo.740.4">By doing so, BFF aims to simplify frontend development and optimize backend responses according to each frontend’s unique requirements.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.741.1">Here’s an </span><a id="_idIndexMarker663"/><span class="koboSpan" id="kobo.742.1">overview of the key aspects of the BFF pattern:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.743.1">Tailored APIs</span></strong><span class="koboSpan" id="kobo.744.1">: Each frontend (e.g., web, mobile, or smart TV) has its own backend service (</span><strong class="keyWord"><span class="koboSpan" id="kobo.745.1">BFF</span></strong><span class="koboSpan" id="kobo.746.1">) tailored to its specific needs. </span><span class="koboSpan" id="kobo.746.2">BFFs provide APIs that deliver only the data the frontend requires in a suitable format. </span><span class="koboSpan" id="kobo.746.3">This approach reduces the need for data transformation on the frontend and results in optimized API responses.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.747.1">Simplified frontend development</span></strong><span class="koboSpan" id="kobo.748.1">: Frontend developers can work closely with BFF, enabling better collaboration and faster development cycles. </span><span class="koboSpan" id="kobo.748.2">BFFs can be written in the same language as the frontend, making it easier for frontend developers to understand and modify the backend.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.749.1">Delegated complexity</span></strong><span class="koboSpan" id="kobo.750.1">: BFFs can handle tasks that would otherwise burden the frontend, such as authentication, data aggregation, and error handling. </span><span class="koboSpan" id="kobo.750.2">This delegation of complexity reduces the frontend’s workload and leads to a smoother user experience.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.751.1">Independent evolution</span></strong><span class="koboSpan" id="kobo.752.1">: Each BFF can evolve independently, making it easier to roll out updates and features for specific frontends without affecting others. </span><span class="koboSpan" id="kobo.752.2">BFFs act as adapters between frontends and core backend services, minimizing the impact of changes in either layer.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.753.1">Let’s consider an e-commerce application with web, mobile, and intelligent TV frontends:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.754.1">Web BFF</span></strong><span class="koboSpan" id="kobo.755.1">: Provides </span><a id="_idIndexMarker664"/><span class="koboSpan" id="kobo.756.1">product details, user reviews, and recommendations for the web frontend. </span><span class="koboSpan" id="kobo.756.2">Aggregates data from multiple backend services, such as product information, user profiles, and recommendation engines. </span><span class="koboSpan" id="kobo.756.3">Transforms the data into a format suitable for web display.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.757.1">Mobile BFF</span></strong><span class="koboSpan" id="kobo.758.1">: Offers a </span><a id="_idIndexMarker665"/><span class="koboSpan" id="kobo.759.1">simplified product view, user reviews, and recommendations optimized for mobile devices. </span><span class="koboSpan" id="kobo.759.2">Handles tasks like image resizing to fit smaller screens. </span><span class="koboSpan" id="kobo.759.3">Aggregates data and adapts it for the mobile frontend’s specific needs.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.760.1">Smart TV BFF</span></strong><span class="koboSpan" id="kobo.761.1">: Delivers </span><a id="_idIndexMarker666"/><span class="koboSpan" id="kobo.762.1">product information, user reviews, and recommendations tailored for smart TV display. </span><span class="koboSpan" id="kobo.762.2">Transforms data to fit the larger screen and simpler navigation options of smart TVs. </span><span class="koboSpan" id="kobo.762.3">Aggregates data and adapts it for the smart TV frontend’s requirements.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.763.1">By having separate BFFs for each frontend, the e-commerce application can provide optimized user experiences across different platforms while simplifying frontend development and reducing the complexity of backend services. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.764.1">The BFF design </span><a id="_idIndexMarker667"/><span class="koboSpan" id="kobo.765.1">pattern is powerful for building modern web and mobile applications, offering tailored APIs, simplified frontend development, delegated complexity, and independent evolution. </span><span class="koboSpan" id="kobo.765.2">Architects use BFFs to create more efficient, responsive, and user-friendly applications across multiple platforms.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.766.1">So far in this chapter, you’ve learned about various cloud-native architecture design patterns. </span><span class="koboSpan" id="kobo.766.2">Now, let’s learn about some anti-patterns to avoid.</span></p>
<h1 class="heading-1" id="_idParaDest-172"><span class="koboSpan" id="kobo.767.1">Cloud-native architecture anti-patterns</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.768.1">In cloud-native </span><a id="_idIndexMarker668"/><span class="koboSpan" id="kobo.769.1">architecture, as with any system design, certain practices are considered anti-patterns. </span><span class="koboSpan" id="kobo.769.2">An anti-pattern is a method that seems beneficial but typically falls short and can even be detrimental to your application. </span><span class="koboSpan" id="kobo.769.3">Here are some common anti-patterns to avoid in cloud-native architecture.</span></p>
<h2 class="heading-2" id="_idParaDest-173"><span class="koboSpan" id="kobo.770.1">Single point of failure</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.771.1">A single point of failure occurs when a single component’s failure can bring down the entire </span><a id="_idIndexMarker669"/><span class="koboSpan" id="kobo.772.1">system. </span><span class="koboSpan" id="kobo.772.2">Design your cloud-native architecture with redundancy and failover mechanisms to handle such </span><a id="_idIndexMarker670"/><span class="koboSpan" id="kobo.773.1">failures gracefully. </span><span class="koboSpan" id="kobo.773.2">A cloud application relying on a single database instance without any backup or replication is vulnerable to system-wide failure if that database instance goes down. </span><span class="koboSpan" id="kobo.773.3">Implementing a redundant database setup with replication and automatic failover prevents this scenario.</span></p>
<h2 class="heading-2" id="_idParaDest-174"><span class="koboSpan" id="kobo.774.1">Manual scaling</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.775.1">Manual scaling involves manually adding or removing resources to accommodate changes </span><a id="_idIndexMarker671"/><span class="koboSpan" id="kobo.776.1">in demand. </span><span class="koboSpan" id="kobo.776.2">It can be time-consuming, error-prone, and inefficient. </span><span class="koboSpan" id="kobo.776.3">Use a serverless service and auto-scaling features </span><a id="_idIndexMarker672"/><span class="koboSpan" id="kobo.777.1">that automatically adjust the number of running instances based on demand. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.778.1">If a streaming service experiences a sudden surge in viewers during a popular event, for example, manually scaling up the infrastructure might not be fast enough. </span><span class="koboSpan" id="kobo.778.2">Using serverless services or autoscaling allows the service to quickly scale up resources to meet demand and scale down once the demand subsides.</span></p>
<h2 class="heading-2" id="_idParaDest-175"><span class="koboSpan" id="kobo.779.1">Tightly coupled services</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.780.1">In a microservice architecture, services should be loosely coupled to operate independently. </span><span class="koboSpan" id="kobo.780.2">Tightly coupled services can lead to a fragile system that’s hard to maintain </span><a id="_idIndexMarker673"/><span class="koboSpan" id="kobo.781.1">and evolve. </span><span class="koboSpan" id="kobo.781.2">For </span><a id="_idIndexMarker674"/><span class="koboSpan" id="kobo.782.1">example, if a payment service and a shipping service in an e-commerce platform are tightly coupled, changes to one service can unintentionally impact the other. </span><span class="koboSpan" id="kobo.782.2">Designing these services with clear boundaries and APIs allows them to evolve independently.</span></p>
<h2 class="heading-2" id="_idParaDest-176"><span class="koboSpan" id="kobo.783.1">Ignoring security best practices</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.784.1">Security should be a top priority in any cloud-native architecture. </span><span class="koboSpan" id="kobo.784.2">Ignoring security best practices </span><a id="_idIndexMarker675"/><span class="koboSpan" id="kobo.785.1">can result in data breaches, unauthorized access, and other security incidents. </span><span class="koboSpan" id="kobo.785.2">An application that stores user passwords in plain text is vulnerable to data breaches. </span><span class="koboSpan" id="kobo.785.3">Implementing proper password hashing, salting, and other security measures can prevent such incidents.</span></p>
<h2 class="heading-2" id="_idParaDest-177"><span class="koboSpan" id="kobo.786.1">Not monitoring or logging</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.787.1">Monitoring and logging are necessary to diagnose issues, optimize performance, and understand </span><a id="_idIndexMarker676"/><span class="koboSpan" id="kobo.788.1">system behavior. </span><span class="koboSpan" id="kobo.788.2">Implement monitoring tools to track application health and logs to diagnose problems. </span><span class="koboSpan" id="kobo.788.3">If a cloud application experiences performance issues, detailed monitoring and logging can help identify the cause, such as increased network latency, resource constraints, or application errors.</span></p>
<h2 class="heading-2" id="_idParaDest-178"><span class="koboSpan" id="kobo.789.1">Ignoring network latency</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.790.1">Network latency can impact application performance in a distributed system. </span><span class="koboSpan" id="kobo.790.2">Design your system </span><a id="_idIndexMarker677"/><span class="koboSpan" id="kobo.791.1">to handle network latency gracefully. </span><span class="koboSpan" id="kobo.791.2">For example, in a microservices-based e-commerce platform, network latency between services can slow down user interactions like browsing products or checking out. </span><span class="koboSpan" id="kobo.791.3">Implementing techniques like caching, data replication, and asynchronous communication can mitigate these effects.</span></p>
<h2 class="heading-2" id="_idParaDest-179"><span class="koboSpan" id="kobo.792.1">Lack of testing</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.793.1">Proper testing ensures your application functions as expected and helps identify issues before they </span><a id="_idIndexMarker678"/><span class="koboSpan" id="kobo.794.1">reach production. </span><span class="koboSpan" id="kobo.794.2">A cloud-native application that processes user data should have comprehensive unit, integration, and end-to-end tests to ensure data processing works correctly, prevent data loss or corruption, and verify proper integration between services.</span></p>
<h2 class="heading-2" id="_idParaDest-180"><span class="koboSpan" id="kobo.795.1">Over-optimization</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.796.1">Over-optimizing </span><a id="_idIndexMarker679"/><span class="koboSpan" id="kobo.797.1">your applications prematurely can make the code complex and hard to maintain. </span><span class="koboSpan" id="kobo.797.2">Implementing a highly optimized, custom data structure for a cloud application may improve performance slightly but can also make the code harder to understand, maintain, and adapt to future changes.</span></p>
<h2 class="heading-2" id="_idParaDest-181"><span class="koboSpan" id="kobo.798.1">Not considering costs</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.799.1">Cloud services can be expensive if not managed properly. </span><span class="koboSpan" id="kobo.799.2">Monitor and optimize your cloud resource </span><a id="_idIndexMarker680"/><span class="koboSpan" id="kobo.800.1">usage to avoid unexpected costs. </span><span class="koboSpan" id="kobo.800.2">Running large virtual machine instances 24/7 for an application with fluctuating demand, for example, is costly. </span><span class="koboSpan" id="kobo.800.3">Implementing auto-scaling and using serverless services can optimize costs by adjusting to demand.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.801.1">You can create a robust, scalable, and maintainable cloud-native architecture by avoiding these anti-patterns. </span><span class="koboSpan" id="kobo.801.2">By adhering to best practices, avoiding anti-patterns such as these, and utilizing a microservices approach, you can ensure your cloud applications are scalable, robust, and secure. </span><span class="koboSpan" id="kobo.801.3">As you continue to build and evolve your applications, remain vigilant about potential challenges and strive to improve your designs, operations, and monitoring strategies continuously.</span></p>
<h1 class="heading-1" id="_idParaDest-182"><span class="koboSpan" id="kobo.802.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.803.1">In this chapter, you explored cloud-native architectures comprehensively, uncovering the essential concepts, patterns, and practices vital for designing resilient, scalable, and efficient systems.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.804.1">You started by unraveling the essence of cloud-native architecture and gaining an appreciation for its transformative potential in modern software development. </span><span class="koboSpan" id="kobo.804.2">You learned about its core benefits, including scalability, resiliency, and agility, which have made it indispensable in today’s dynamic software landscape.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.805.1">You delved deep into serverless architecture, discovering how it offers cost savings, seamless scalability, and operational simplicity. </span><span class="koboSpan" id="kobo.805.2">You learned about the contrasts and nuances between stateless and stateful designs, understanding their respective use cases, challenges, and implementation strategies. </span><span class="koboSpan" id="kobo.805.3">You ventured into the microservice architecture domain, grasping its inherent advantages of scalability, fault tolerance, and ease of deployment.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.806.1">You encountered the Saga pattern, gained insights into its use for managing long-running transactions, and learned about the considerations for its effective implementation. </span><span class="koboSpan" id="kobo.806.2">You explored the fan-out/fan-in pattern, understanding its power in parallel data processing and subsequent aggregation. </span><span class="koboSpan" id="kobo.806.3">You learned about the service mesh pattern, appreciating its contributions to decentralized service management, enhanced observability, and traffic management.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.807.1">You immersed yourself in reactive architecture, grasping its asynchronous and event-driven nature and recognizing its potential for improving responsiveness and scalability. </span><span class="koboSpan" id="kobo.807.2">You explored the territory of queue-based architectures, learning about their benefits in decoupling and asynchronous processing. </span><span class="koboSpan" id="kobo.807.3">You studied the queuing chain pattern, gaining insights into its applications and strategies for crafting robust sequential workflows.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.808.1">You were introduced to the job observer pattern, understanding its utility in efficiently monitoring and managing jobs. </span><span class="koboSpan" id="kobo.808.2">You discovered the Pipes-and-Filters architecture, appreciating its flexibility and composability for processing data streams. </span><span class="koboSpan" id="kobo.808.3">You ventured into event-driven architectures, learning about their scalability, responsiveness, and decoupling benefits. </span><span class="koboSpan" id="kobo.808.4">You explored the publisher/subscriber model, understanding its potential for scalable and loosely coupled event distribution, and you delved into the event stream model, recognizing its advantages in handling continuous event streams. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.809.1">You explored the BFF pattern, learning about its ability to tailor backends to specific user interfaces for greater flexibility and performance. </span><span class="koboSpan" id="kobo.809.2">Lastly, you uncovered common cloud-native architecture anti-patterns, learning how to avoid these pitfalls and following best practices.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.810.1">With this newfound understanding of cloud-native architecture, you are better equipped to design robust, scalable, and efficient cloud-native systems that align with your unique requirements and objectives.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.811.1">While you learned about various architecture patterns in this chapter, you will learn about architecture design principles for performance optimization in the next chapter. </span><span class="koboSpan" id="kobo.811.2">Additionally, you will deep dive into technology selection in computing, storage, databases, and networking, which can help improve your application’s performance.</span></p>
<h1 class="heading-1" id="_idParaDest-183"><span class="koboSpan" id="kobo.812.1">Join our book’s Discord space</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.813.1">Join the book’s Discord workspace to ask questions and interact with the authors and other solution architecture professionals: </span><a href="Chapter_5.xhtml"><span class="url"><span class="koboSpan" id="kobo.814.1">https://packt.link/SAHandbook</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.815.1"><img alt="" role="presentation" src="../Images/QR_Code930022060277868125.png"/></span></p>
</div>
</body></html>