- en: Chapter 8. OpenShift for Python Developers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter presents a number of recipes that will help you to get started
    with Python web application development on OpenShift. This chapter contains the
    following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first Python application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing Python application dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and deploying Flask web applications using Python and PostgreSQL cartridges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling hot deployment for Python applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forcing a clean Python virtual environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing an application's Python virtual environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Gevent with Python applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing a custom Python package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the .htaccess file to configure Apache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is a general-purpose, high-level, easy-to-use, popular programming language.
    It is an interpreted language that emphasizes source code readability using strict
    indentation to determine code blocks. Python is very commonly used as a scripting
    language, but it is also very popular in the web application development and scientific
    computing world. There are various powerful web application frameworks, such as
    Django, Flask, Bottle, and Tornado, available to help developers build awesome
    web applications using the Python programming language.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenShift provides Python web developers with a hosting platform to deploy
    their web applications. At the time of writing this book, it supports three versions
    of Python—2.6, 2.7, and 3.3\. You can view all the available Python versions by
    running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The *Creating your first Python application* recipe will help you take your
    first steps toward developing Python applications on OpenShift. OpenShift supports
    Apache with the `mode_wsgi` HTTP server module ([https://code.google.com/p/modwsgi/](https://code.google.com/p/modwsgi/))
    to run your Python web applications. Python applications can choose any of the
    supported versions and run within a virtualenv tool. A virtualenv tool is an isolated
    and private copy of your Python installation, which will be only used for that
    project without affecting the system's global Python installation. The *Accessing
    an application's Python virtual environment* recipe will show you how to access
    the virtual environment by connecting to the application gear using SSH.
  prefs: []
  type: TYPE_NORMAL
- en: We will also cover various ways in which you can manage application dependencies
    in Python applications. You can use `requirements.txt` or `setup.py` or both to
    manage application dependencies. This will be covered in the *Managing Python
    application dependencies* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The example application in this chapter will be developed using the Flask web
    framework and PostgreSQL database. I choose Flask because of its popularity and
    ease of use. You can use any other web framework, such as Bottle, web2py, and
    Django. The *Creating and deploying Flask web applications using Python and PostgreSQL
    cartridges* recipe will cover step-by-step how to write Flask web applications
    on OpenShift. All the source code is available on the OpenShift-Cookbook GitHub
    organization ([https://github.com/OpenShift-Cookbook](https://github.com/OpenShift-Cookbook)).
  prefs: []
  type: TYPE_NORMAL
- en: It is also feasible to use a standalone WSGI server, such as Gevent or Gunicorn,
    with OpenShift Python applications. The *Using Gevent with Python applications*
    recipe will cover this in detail.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to run the examples on your local machine, please install Python,
    pip, and virtualenv. pip is a command-line tool to install and manage Python packages.
    The instructions to install Python for your operating system can be found at [http://docs.python-guide.org/en/latest/index.html](http://docs.python-guide.org/en/latest/index.html).
    Instructions to install pip can be found at [http://pip.readthedocs.org/en/latest/installing.html](http://pip.readthedocs.org/en/latest/installing.html).
    Finally, you can install virtualenv on your machine by following the instructions
    mentioned at [http://docs.python-guide.org/en/latest/dev/virtualenvs/](http://docs.python-guide.org/en/latest/dev/virtualenvs/).
  prefs: []
  type: TYPE_NORMAL
- en: This chapter assumes that you are comfortable with the Python web development
    basics, OpenShift application basics, and how to work with OpenShift database
    cartridges. In case you are not comfortable with these topics, I recommend that
    you first read [Chapter 3](part0041_split_000.html#page "Chapter 3. Creating and
    Managing Applications"), *Creating and Managing Applications*, through [Chapter
    6](part0079_split_000.html#page "Chapter 6. Using MongoDB and Third-party Database
    Cartridges with OpenShift Applications"), *Using MongoDB and Third-party Database
    Cartridges with OpenShift Applications*, before continuing with this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first Python application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to create an OpenShift Python application
    using the rhc command-line tool. We will create a Python 3.3 application and then
    understand the template application created by OpenShift.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To walk through this recipe, you will need the rhc command-line client installed
    on your machine. Please refer to the *Installing the OpenShift rhc command-line
    client* recipe in [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting
    Started with OpenShift"), *Getting Started with OpenShift*, for details.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to create your first Python application:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new command-line terminal, and change the directory to a convenient location
    where you want to create the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To create a new Python 3.3 application, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can replace Python 3.3 with Python 2.6 or Python 2.7 to create applications
    that use the respective Python versions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open your favorite web browser, and go to `http://myapp-{domain-name}.rhcloud.com`
    to view the application. Please replace `{domain-name}` with your OpenShift account
    domain name. You will see the OpenShift template application in your browser as
    follows:![How to do it…](img/00103.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you run the `rhc create-app` command, OpenShift broker will receive the
    request and will initiate the application creation process. The application creation
    process was explained in detail in the *Creating an OpenShift application using
    the rhc command-line client* recipe in [Chapter 3](part0041_split_000.html#page
    "Chapter 3. Creating and Managing Applications"), *Creating and Managing Applications*.
    To run your Python applications, OpenShift needs to know the Python version you
    want to use. In step 2, you specified that OpenShift should create a Python 3.3
    application with `myapp` as the application name. OpenShift will use these details
    along with a few defaults to create the `myapp` application. The defaults include
    a small gear size, non-scalable application, and the use of the current directory
    to clone the Git repository. To run Python-3.3-based web applications, OpenShift
    will install Python 3.3 language runtime and configure the Apache server with
    the `mod_wsgi` module. The `mod_wsgi` module provides an implementation of the
    **Web Server Gateway Interface** (**WSGI**) specification, allowing the Apache
    web server to host Python web applications that support the Python WSGI interface.
    The WSGI specification describes a simple interface between web servers and web
    applications or frameworks for the Python programming language. Most of the popular
    web frameworks ([http://wsgi.readthedocs.org/en/latest/frameworks.html](http://wsgi.readthedocs.org/en/latest/frameworks.html))
    in the Python community support the WSGI interface. This makes it very easy for
    developers to run their choice of framework on OpenShift, as it provides the Apache
    `mod_wsgi` deployment environment.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also run Python web applications on alternative Python web servers,
    such as Gevent. This will be covered in the *Using Gevent with Python applications*
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from installing Python and configuring Apache with `mod_wsgi`, every OpenShift
    application uses virtualenv and pip to manage application dependencies. A virtualenv
    tool is an isolated and private copy of your Python installation, which will be
    only used for that project without affecting the system's global Python installation.
    You can install packages in a virtualenv tool using pip, and virtualenv will ensure
    the application has access only to the package that it needs. Another advantage
    of virtual environments is that they don't require administrative rights.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the template application created by OpenShift as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The template application has three files—`requirements.txt`, `wsgi.py`, and
    `setup.py`—apart from the `.openshift` and `.git` directories. We have already
    talked about `.openshift` and `.git` in the *Creating an OpenShift application
    using the rhc command-line client* recipe in [Chapter 3](part0041_split_000.html#page
    "Chapter 3. Creating and Managing Applications"), *Creating and Managing Applications*,
    so I will not cover them here. Let''s talk about the three application files one
    by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '`requirements.txt`: The `requirements.txt` file is used to specify libraries
    that your application depends on. The pip package manager will install all the
    application dependencies mentioned in `requirements.txt`. This is a regular text
    file with one dependency per line. The format is `[package name]==[package version]`.
    The sample `requirements.txt` file is shown as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`setup.py`: The `setup.py` file allows developers to more easily build and
    distribute python packages that will be imported as dependencies by other projects.
    It allows you to specify project-specific metadata, such as name and description,
    as well as specify dependencies. The sample `setup.py` file is shown as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`wsgi.py`: The `wsgi.py` file is a WSGI-compatible application created by OpenShift.
    This file is mandatory if you want to use the Apache `mod_wsgi` server to host
    your Python web application. This file contains the code `mod_wsgi` module, which
    will execute on startup to get the application object. The application object
    is a callable that takes two parameters—`environ` and `start_response`. The `environ`
    parameter is a dictionary containing environment variables, and `start_response`
    is a callable that takes two required parameters: `status` and `response_headers`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can check the exact version of Python running inside the application gear
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, a Python application expects `wsgi.py` to be available at the application's
    root directory. If you want to change the directory layout and use a different
    location for `wsgi.py`, you can set the `OPENSHIFT_PYTHON_WSGI_APPLICATION` environment
    variable to specify a different location, as shown in the following command. You
    can view the list of available environment variables for a Python application
    at [https://access.redhat.com/documentation/en-US/OpenShift_Online/2.0/html/User_Guide/Python_Environment_Variables.html](https://access.redhat.com/documentation/en-US/OpenShift_Online/2.0/html/User_Guide/Python_Environment_Variables.html).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Managing Python application dependencies* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Enabling hot deployment for Python applications* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating and deploying Flask web applications using Python and PostgreSQL
    cartridges* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing Python application dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenShift gives the Python developer two options to specify their application
    dependencies. You can specify application dependencies either in the `install_requires`
    element in `setup.py`, in `requirements.txt`, or both. When dependencies are specified
    in both the `setup.py` and `requirements.txt` files, OpenShift will install all
    the libraries mentioned in both the files. The `setup.py` file is required when
    you want to distribute your library as a package that others can use. All the
    packages listed on PyPi need to have the `setup.py` script in their root directory.
    As you do not want to distribute your web applications as a package, there is
    no need to use the `setup.py` file. I recommend that you use `requirements.txt`
    for your OpenShift applications. The reason why `setup.py` exists is that OpenShift
    initially only supported `setup.py` and later added support for the `requirements.txt`
    file. So to make sure that the existing application continues to work on OpenShift,
    we need to support both the options. In this recipe, you will learn how to use
    `requirements.txt` to specify application dependencies. The source code of the
    application created in this recipe is available on GitHub ([https://github.com/OpenShift-Cookbook/chapter8-recipe2](https://github.com/OpenShift-Cookbook/chapter8-recipe2)).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is based on the assumption that you have read the *Creating your
    first Python application* recipe. To walk through this recipe, you will need the
    rhc command-line client installed on your machine. Please refer to the *Installing
    the OpenShift rhc command-line client* recipe in [Chapter 1](part0014_split_000.html#page
    "Chapter 1. Getting Started with OpenShift"), *Getting Started with OpenShift*,
    for details. This recipe will require you to have virtualenv installed on your
    machine. You can install virtualenv on your machine by following the instructions
    mentioned at [http://docs.python-guide.org/en/latest/dev/virtualenvs/](http://docs.python-guide.org/en/latest/dev/virtualenvs/).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to build a `Hello World` Flask web application
    that will demonstrate how you can work with application dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new command-line terminal, and run the following command to create a
    new Python application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you want to create Python 2.6 or Python 2.7 applications, use `python-2.6`
    or `python-2.7` as the web cartridge name instead of `python-3.3`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Change the directory to `myapp`, and delete the `setup.py` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new virtual environment by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before you can work with the virtual environment, you have to activate it.
    To activate the virtual environment, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you have activated virtualenv, you can begin installing modules without
    affecting the system''s default Python interpreter. Install the Flask module by
    running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new Python file named `hello.py` in the `myapp` directory, and populate
    it with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run this application on your local machine, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, open your favorite web browser, and go to `http://127.0.0.1:5000`. You
    will see **Hello World!** displayed in the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To deploy this application on OpenShift, we have to declare all the dependencies
    in `requirements.txt`. The following command will write all of your application
    dependencies in `requirements.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding command will populate `requirements.txt` with all the application
    dependencies. This includes transitive dependencies as well. The `requirements.txt`
    file will look as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Please make sure that the distribute version is 0.7.3, as earlier versions do
    not work with Python 3.3\. Earlier versions of the distribute are not compatible
    with Python 3.3, so you might face trouble if you use them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Also, we have to update the `wsgi.py` file to load the Flask application instead
    of the default one created by OpenShift. Delete all the content in the `wsgi.py`
    file, and replace it with the one shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new file named `.gitignore` in the `myapp` directory, and add the
    `venv` directory to be ignored. We do not want to push the virtual environment
    to OpenShift; OpenShift will create the virtual environment based on the dependencies
    mentioned in the `requirements.txt` file. The `.gitignore` file is created as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now commit the code to the local repository, and then push changes to application
    gear. OpenShift will install all the packages specified in the `requirements.txt`
    file and make them available to the application via the virtual environment as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, you can see the application running at `http://myapp-{domain-name}.rhcloud.com`.
    Please replace `{domain-name}` with your application domain name. You will see
    **Hello World** in your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous steps, you created a simple Flask framework web application
    that uses `requirements.txt` to specify application dependencies. Flask is a micro
    web framework for the Python programming language. It is an easy-to-learn framework
    with extensive documentation, which can be found at [http://flask.pocoo.org/docs](http://flask.pocoo.org/docs).
  prefs: []
  type: TYPE_NORMAL
- en: In step 1, you created a Python 3.3 application with the name `myapp`. Read
    the *Creating your first Python application* recipe to understand the Python application
    created by OpenShift. As you will use `requirement.txt` to specify application
    dependencies, you deleted the `setup.py` file in step 2\. If you wish, you can
    keep the `setup.py` file and specify your application metadata in it. The application
    metadata includes the name, description, version, and so on, of the application.
    I recommend that you specify application dependencies in only one file to avoid
    dependency hell ([http://en.wikipedia.org/wiki/Dependency_hell](http://en.wikipedia.org/wiki/Dependency_hell)).
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 created a new virtual environment using the Python 3.3 interpreter. To
    use a virtual environment, you have to first activate it using the command shown
    in step 4\. The virtual environment is the ideal way to work with Python applications,
    as it avoids polluting the system global Python installation.
  prefs: []
  type: TYPE_NORMAL
- en: You installed the Flask web framework using pip in step 5, as we are going to
    develop a web application that uses this framework. The Flask framework will be
    installed in the virtual environment and will become available to your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 6, you created a new Python file named `hello.py` and added the source
    code for the `Hello World` application. The code shown in step 6 does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In line 1, you imported the `Flask` class from the `flask` module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line 2, you created an instance of the `Flask` class. This instance will
    be that of the WSGI application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, you defined a route for the root (`/`) URL. The route tells the Flask
    framework that it should invoke the `index()` function when a request is made
    to the root URL. The `index()` function will simply render **Hello World!** in
    the browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, if the name of the application module is equal to `'__main__`', the
    development server will be launched. The `__name__ == '__main__'` expression is
    used to ensure the development server is started only when the script is executed
    directly using the `python hello.py` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 7 started the development web server by executing the `hello.py` script.
    This will start the development server and launch the Flask application.
  prefs: []
  type: TYPE_NORMAL
- en: In step 8, you used the `pip freeze` command to add all the dependencies to
    the `requirements.txt` file. OpenShift will download all the dependencies mentioned
    in this file and populate the application virtual environment with them. OpenShift
    uses Apache `mod_wsgi` to run your Python applications. The entry point of `mod_wsgi`
    is the `wsgi.py` file. This file should contain the code that will provide the
    application object on startup. In step 9, you replaced the content of the `wsgi.py`
    file so that it uses the Flask application object instead of the application object
    created by the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you committed the code to the local Git repository and pushed the
    code to the OpenShift application gear. OpenShift will first stop the Apache server,
    download all the dependencies mentioned in the `requirements.txt` file inside
    a virtual environment, and then finally start the Apache server. The part of the
    `git push` output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to use `setup.py` instead of `requirements.txt`, you can delete
    `requirement.txt` or keep it empty and specify all the requirements under the
    `install_requires` element, as shown in the following code. The full source code
    of the application is available on GitHub at [https://github.com/OpenShift-Cookbook/chapter8-recipe2-setup.py](https://github.com/OpenShift-Cookbook/chapter8-recipe2-setup.py).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating your first Python application* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Enabling hot deployment for Python applications* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating and deploying Flask web applications using Python and PostgreSQL
    cartridges* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and deploying Flask web applications using Python and PostgreSQL cartridges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will develop a simple job portal application using the Python
    Flask web framework ([http://flask.pocoo.org/](http://flask.pocoo.org/)) and the
    PostgreSQL database. I have chosen Flask because it is a very easy-to-use and
    popular web framework. You can run any web framework, such as Django, Bottle,
    Zope, and Tornado, on OpenShift. The example application will allow users to post
    job openings and view a list of all the persisted jobs in the system. These two
    functionalities will be exposed using the two REST endpoints. The source code
    for this recipe is available on GitHub at [https://github.com/OpenShift-Cookbook/chapter8-jobstore-simple](https://github.com/OpenShift-Cookbook/chapter8-jobstore-simple).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is based on the assumption that you have read previous recipes in
    this chapter. To walk through this recipe, you will need the rhc command-line
    client installed on your machine. Please refer to the *Installing the OpenShift
    rhc command-line client* recipe in [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting
    Started with OpenShift"), *Getting Started with OpenShift*, for details. Also,
    if you want to run the application on your local machine, you will need to have
    Python, pip, and virtualenv installed on your machine. Please refer to the introduction
    section for links to installation instructions for respective software.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create the application, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new command-line terminal, and navigate to a convenient location where
    you want to create the application. Create a new Python 2.7 and PostgreSQL 9.2
    OpenShift application, and type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the application is created, change the directory to `jobstore`, and delete
    the `setup.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, create a `.gitignore` file, and add the following to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new virtual environment for the `jobstore` application. Run the following
    command to create the virtual environment, and then activate it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that the virtual environment is activated, you can install the application
    dependencies. This application uses the Flask web framework. To install the dependencies
    in the virtual environment, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new file named `jobstore.py`, which will house the application source
    code. The following code is a simple Flask application that renders an `index.html`
    file when a request is made to the root URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the previous code, the index route will render `index.html` when a request
    is made to the root URL. By default, Flask looks for templates in the `templates`
    directory inside the application folder. The `render_template()` function provided
    by the Flask framework integrates the Jinja 2 template engine with the application.
    To make sure this code works, create a new directory named `templates` in the
    application source code repository as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a new `index.html` file inside the `templates` directory, and add
    the following content to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can test the application when you start the Python server by running the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To view the application, go to `http://127.0.0.1:5000/` in your favorite browser.
    You will see `index.html` rendered in your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The main responsibility of this application is to store the job data in the
    database. Python has support functionalities for various database frameworks that
    makes it very easy to work with a variety of databases. Among them, SQLAlchemy
    is the most popular and powerful relational database framework that supports various
    RDBMS backends. To use SQLAlchemy with Flask applications, you have to first install
    the Flask SQLAlchemy extension. The Flask SQLAlchemy extension simplifies working
    with SQLAlchemy inside Flask applications. To install Flask SQLAlchemy, run the
    following `pip` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that you have installed the Flask SQLAlchemy extension, the next task is
    to write the configuration code so that the `jobstore` application can connect
    to the PostgreSQL database. Add the following content to `jobstore.py`. You can
    view the full source code on GitHub at [https://github.com/OpenShift-Cookbook/chapter8-jobstore-simple/blob/master/jobstore.py](https://github.com/OpenShift-Cookbook/chapter8-jobstore-simple/blob/master/jobstore.py).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, you added two configuration options to the Flask application
    configuration object. `SQLALCHEMY_DATABASE_URI` points to the database connection
    URL. OpenShift exposes the PostgreSQL database connection URL using the `OPENSHIFT_POSTGRESQL_DB_URL`
    environment variable. The `SQLALCHEMY_COMMIT_ON_TEARDOWN` option enables automatic
    commits of database changes at the end of each request. Finally, you instantiated
    the `db` object from the `SQLAlchemy` class, passing it the application object.
    This `db` object provides access to all the database-related functionalities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, you will write a model class to represent the `Job` table in the PostgreSQL
    database. The model represents a persistent entity stored in the database. The
    `db` instance that we got in step 7 provides a base class that a model can extend.
    Apart from this, the `db` object also provides helper functions to define the
    structure of a model class. The `Job` model is shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `__tablename__` variable is used to define the name of the table in the
    database. The `db.Column()` function is used to define the class variables that
    will be mapped to columns in the database table. You also defined a couple of
    helper functions that will help convert to and from JSON. These methods will be
    useful when we build the REST API.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now you will write a couple of REST endpoints that will expose a couple of
    functionalities. The first endpoint will allow users to list all the jobs inside
    the database, and the second endpoint will allow users to create a new job. The
    REST endpoints are shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the previous code, the `all_jobs()` function queries the database for all
    the `Job` rows. The result from the database is converted to JSON and returned
    to the user. The `jsonify()` function is provided by Flask and creates a response
    with the JSON representation and the `application/json` MIME type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `post_job()` function first converts the JSON request to the `Job` object
    and then writes it to the database. Finally, it returns the persisted job to the
    user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As discussed in the *Managing Python application dependencies* recipe, you
    have to update the `wsgi.py` file to load the Flask application instead of the
    default created by OpenShift. Delete all the content in the `wsgi.py` file, and
    replace it with the one shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last thing to do before we can deploy the application is specify the dependencies
    in `requirements.txt`. Run the following command to populate the application `requirements.txt`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, commit the code and push the application changes to the application gear
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The application will be up and running at `http://jobstore-{domain-name}.rhcloud.com`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To test the REST endpoints, you could use cURL. To create a new `Job` instance,
    run the following cURL command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To view all the jobs, you can run the following cURL command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous steps, you created a Python web application and deployed it
    on OpenShift. From steps 1 through 4, you first created a new Python 2.7 OpenShift
    application, created a virtual environment for the project, and finally activated
    the virtual environment. The application uses the Python Flask framework, so you
    installed it using pip in step 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'In steps 6 through 8, you created a Flask web application that renders the
    `index.html` file. The code shown in step 4 does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You imported all the required classes and functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, you created an instance of the `Flask` class. The only required argument
    is the name of the main module or package of the application. The correct value
    is `__name__` in most cases.     Then, you defined a route for the root URL using the `app.route` decorator. A
    route allows you to bind HTTP requests to function calls based on the URL requested.
    The index function will render `index.html` in the browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, if the name of the application module is equal to `'_ _main_ _`', the
    development server is launched. The `__name__ == '__main__'` expression is used
    to ensure the development server is started only when the script is executed directly
    using the `python jobstore.py` command. You tested the application on your local
    machine in step 10.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In steps 11 through 14, you first installed the Flask SQLAlchemy extension
    and then did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you imported the `SQLAlchemy` class from the `Flask-SQLAlchemy` extension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, you configured the URL of the application database using `SQLALCHEMY_DATABASE_URI`
    in the Flask configuration object. You also used another useful option, `SQLALCHEMY_COMMIT_ON_TEARDOWN`,
    to configure the automatic commits of the database changes at the end of each
    request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, you created an instance of the `SQLAlchemy` class that provides access
    to all the SQLAlchemy APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, you defined the `Job` model class using the SQLAlchemy API. The `company`
    class extends the `db.Model` base class and uses the `db.Column` constructor to
    define the structure of the model class. The `__tablename__` variable is used
    to define the name of the table in the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, you defined a couple of helper functions that will help convert to
    and from JSON. These methods will be useful when we build the REST API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In step 15, you defined REST endpoints for the `Job` model class. The code
    listing shown in step 15 does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: When a user makes a `GET` request to `/api/v1/jobs`, the `all_jobs()` function
    is invoked. The function finds all the jobs using the SQLAlchemy API, iterates
    over the result set, and then converts it into JSON.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a user makes a `POST` request to `/api/v1/jobs`, a new job is created.
    The JSON data is exposed as the `request.json` Python dictionary. Then, the `request.json`
    dictionary is converted into the `Job` object using the `from_json` method. The
    data is then persisted into the database using the `db.session` API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In step 16, you replaced the content of the `wsgi.py` file so that it uses the
    Flask application object instead of the application object created by the template.
    Finally, you committed the code to your local Git repository and then pushed the
    changes to the OpenShift application gear. Once deployed, you can go to `http://jobstore-{domain-name}.rhcloud.com`
    and work with the application.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can do all the previously performed steps with just a single command. The
    Git repository mentioned in the command contains the source code for this recipe
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating your first Python application* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Enabling hot deployment for Python applications* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling hot deployment for Python applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every time you make a change to your application source code and push the changes
    to the OpenShift application gear Git repository, OpenShift first stops your gear
    (which stops all the cartridges installed on the gear), copies the source code
    from your application Git repository to `app-root/runtime/repo`, performs a build,
    prepares the artifact, and finally starts your gear (which starts all the cartridges).
    This process takes time and does not suit rapid development and deployment. To
    enable rapid development and faster deployments, OpenShift supports hot deployment.
    Hot deployment means that you can deploy your changes without the need to restart
    all the application cartridges.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how you can enable hot deployment for Python
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recipe will work with all the three supported Python versions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to enable hot deployment for your application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Python application using the source code developed in the previous
    recipe as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `hello.py` file, and update `Hello World!` to `Hello from OpenShift`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To enable hot deployment, create an empty file named `hot_deploy` under the
    `.openshift/markers` directory. This file is called the marker file, as this does
    not contain any content. On the *nix machine, you can create a new file by executing
    the following command. On a Windows machine, you can use file explorer to create
    a new file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the file to the Git repository, and then commit and push changes to the
    application gear as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `git push` logs, you will see a message that cartridges are not stopped
    because hot deployment is enabled as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now open the application URL in your favorite web browser, and you will see
    the change deployed without a restart.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The presence of the `hot_deploy` marker file informs OpenShift that you want
    to do hot deployment. Before stopping and starting the application cartridges,
    OpenShift checks for the existence of the `hot_deploy` marker file. If the `hot_deploy`
    marker file exists, OpenShift will not stop the cartridges, and changes will be
    deployed without cartridge restart. Hot deployment is ideal for development, and
    I recommend that you should always use it during development.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you set new environment variables with hot deployment enabled or install
    new cartridges, you have to restart the application to allow the server to pick
    the new environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Forcing a clean Python virtual environment* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Accessing an application's Python virtual environment* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forcing a clean Python virtual environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first time you push your changes to the application gear, pip will download
    all the dependencies mentioned in `setup.py` or `requirements.txt` and populate
    the virtual environment with these dependencies. On every successive push, OpenShift
    will reuse the dependencies and will only download new dependencies mentioned
    in `setup.py` or `requirements.txt`. This makes the application build faster,
    as it does not have to download dependencies on every `git push`. There are scenarios,
    such as a corrupt virtual environment, where you will like to recreate the virtual
    environment and download all the dependencies again. In this recipe, you will
    learn how you can force OpenShift to recreate the virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is based on the assumption that you have read the previous recipes
    in this chapter. To step through this recipe, you will need the rhc command-line
    client installed on your machine. Please refer to the *Installing the OpenShift
    rhc command-line client* recipe in [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting
    Started with OpenShift"), *Getting Started with OpenShift*, for details.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recreate the application you developed in the *Creating and deploying Flask
    web applications using Python and PostgreSQL cartridges* recipe by running the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a marker file named `force_clean_build` in the application''s `.openshift/markers`
    directory. On *nix machines, you can use the `touch` command as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Commit the file, and push the changes to the OpenShift application gear. From
    now on, every `git push` will do a clean deployment. This is demonstrated using
    the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The presence of the `force_clean_build` marker file informs OpenShift that
    you want to do a clean build. When you do a `git push`, OpenShift will first recreate
    the virtual environment, activate the environment, and finally download all the
    dependencies using the pip package manager. You will see the following log message
    in the `git push` logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Enabling hot deployment for Python applications* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Forcing a clean Python virtual environment* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing an application's Python virtual environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you will be aware that every OpenShift Python application has a virtual
    environment associated with it. Your application will only be able to use the
    dependencies available in the virtual environment. In this recipe, you will learn
    how to access the virtual environment of your OpenShift Python application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is based on the assumption that you have read previous recipes in
    this chapter. To walk through this recipe, you will need the rhc command-line
    client installed on your machine. Please refer to the *Installing the OpenShift
    rhc command-line client* recipe in [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting
    Started with OpenShift"), *Getting Started with OpenShift*, for details. Also,
    if you want to run the application on your local machine, you will need to have
    Python, pip, and virtualenv installed on your machine. Please refer to the introduction
    section for links to installation instructions for the respective software.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to access the Python application virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recreate the application you developed in the *Creating and deploying Flask
    web applications using Python and PostgreSQL cartridges* recipe by running the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Change the directory to `jobstore`, and then SSH into the application gear by
    executing the `rhc ssh` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To access the virtual environment, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once you are inside the virtual environment, you can manually download the new
    dependencies using pip. To install a command-line utility called **Yolk**, run
    the following command. Yolk can list packages installed within an environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To list all the installed packages in this virtual environment, run the following
    command. Only part of the output is shown here for brevity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You created a new Python application in step 1 and then connected to the application
    gear using SSH in step 2 when you used the `rhc ssh` command. The location of
    the virtual environment is available as an environment variable, `$VIRTUAL_ENV`.
    You activated the virtual environment in step 3 so that you can use it. Finally,
    in step 4, you installed a package using the `pip` command manually. After installation,
    the package becomes available to the application.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Enabling hot deployment for Python applications* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Forcing a clean Python virtual environment* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Gevent with Python applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, you have used Apache with `mod_wsgi` to run your Python
    applications. It is also possible to run other standalone WSGI servers, such as
    Gevent and Gunicorn, with OpenShift. In this recipe, you will learn how to use
    Gevent to run your Python applications. Gevent is a coroutine-based Python networking
    library that uses greenlet to provide a high-level, synchronous API on top of
    the libevent event loop. The source code for this repository is on GitHub at [https://github.com/OpenShift-Cookbook/chapter8-gevent-recipe](https://github.com/OpenShift-Cookbook/chapter8-gevent-recipe).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is based on the assumption that you have read the previous recipes
    in this chapter. To step through this recipe, you will need the rhc command-line
    client installed on your machine. Please refer to the *Installing the OpenShift
    rhc command-line client* recipe in [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting
    Started with OpenShift"), *Getting Started with OpenShift*, for details. Also,
    if you want to run the application on your local machine, you will need to have
    Python, pip, and virtualenv installed on your machine. Please refer to the introduction
    section for links to installation instructions for the respective software.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to use Gevent''s standalone WSGI server to run
    OpenShift Python applications:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new command-line terminal, and run the following command to create a
    new Python 2.7 application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you want to create Python 2.6 or Python 3.3 applications, use Python 2.6
    and Python 3.3 respectively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Change the directory to `myapp`, and delete the `setup.py` and `wsgi.py` files
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new virtual environment by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before you can work with the virtual environment, you have to activate it.
    To activate the virtual environment, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you have activated virtualenv, you can begin installing modules without
    affecting the system''s default Python interpreter. Install the Flask module by
    running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new Python file named `hello.py` in the `myapp` directory, and populate
    it with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, install the Gevent library, as we want to use it to run our application,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new file named `app.py`, and add the following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To deploy this application on OpenShift, we have to declare all the dependencies
    in `requirements.txt`. The following command will write all of your application
    dependencies in `requirements.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The previous command will populate `requirements.txt` with all the application
    dependencies. This includes transitive dependencies as well. The `requirements.txt`
    file is shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new file named `.gitignore` in the `myapp` directory, and add the
    `venv` directory to be ignored. We do not want to push the virtual environment
    to OpenShift, as OpenShift will create the one based on the dependencies mentioned
    in the `requirements.txt` file. The `.gitignore` file is shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now commit the code to the local repository, and then push changes to the application
    gear. OpenShift will install all the packages specified in `requirements.txt`
    and make them available to the application via the virtual environment, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, open the web application URL in your favorite browser to see the application
    in action. You will be greeted by the **Hello World** text in your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In steps 1 through 6, you created a simple Flask web application as explained
    in the *Managing Python application dependencies* recipe. As we will use Gevent
    to run this application, you installed the Gevent library in step 7\. In step
    8, you created a new Python file, `app.py`. If the user does not use the default
    `wsgi.py` file or WSGI endpoint configured using the `OPENSHIFT_PYTHON_WSGI_APPLICATION`
    environment variable, OpenShift uses the server configured in the `app.py` file
    to serve your application. This Python file should have the name `app` and exist
    under the `app` root directory. The code in `app.py` first activates the virtual
    environment and then starts the Gevent WSGI server at `$OPENSHIFT_PYTHON_IP` and
    `$OPENSHIFT_PYTHON_PORT`.
  prefs: []
  type: TYPE_NORMAL
- en: In step 9, you used the `pip freeze` command to add all the dependencies in
    the `requirements.txt` file. OpenShift will download all the dependencies mentioned
    in this file and populate the application's virtual environment with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you committed the code to the local Git repository and pushed the
    code to the OpenShift application gear. OpenShift will use the Gevent WSGI server
    to run your application. You will see a line, as shown in the following command-line
    output, in the `git push` logs. The following line clearly tells you that OpenShift
    is using the server configured in `app.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similarly, you can use the Tornado web server to serve your Python web applications.
    Uninstall the Gevent and greenlet libraries, and then install the Tornado library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Update the `requirements.txt` file with dependencies by running the `pip freeze
    > requirements.txt` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `app.py` file, replace the Gevent code with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Now your application will use the Tornado web server.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating your first Python application* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating and deploying Flask web applications using Python and PostgreSQL
    cartridges* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing a custom Python package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the time, your application dependencies can be downloaded from PyPi
    using pip, but there are times when your application needs to depend on custom
    libraries that do not exist in the PyPi index. In this recipe, you will learn
    how to use custom Python packages with your OpenShift Python applications. The
    source code for this recipe is on GitHub at [https://github.com/OpenShift-Cookbook/chapter8-custom-package-recipe](https://github.com/OpenShift-Cookbook/chapter8-custom-package-recipe).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is based on the assumption that you have read the previous recipes
    in this chapter. To walk through this recipe, you will need the rhc command-line
    client installed on your machine. Please refer to the *Installing the OpenShift
    rhc command-line client* recipe in [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting
    Started with OpenShift"), *Getting Started with OpenShift*, for details. Also,
    if you want to run the application on your local machine, you will need to have
    Python, pip, and virtualenv installed on your machine. Please refer to the introduction
    section for links to installation instructions for the respective software.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open a new command-line terminal, and run the following command to create a
    new Python 2.7 application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you want to create Python 2.6 or Python 3.3 applications, use Python 2.6
    and Python 3.3 respectively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Change the directory to `myapp`, and delete the `setup.py` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, create a `.gitignore` file to ignore the virtual environment artifacts
    and Python-compiled files as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following lines to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new virtual environment and activate it by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you have activated virtualenv, you can begin installing modules without
    affecting the system''s default Python interpreter. Install the Flask module by
    running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new directory named `libs` in the application root, as shown in the
    following code. The `libs` directory will be used to store your custom packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will create a custom package named `msgs` in the `libs` directory.
    To create a custom package, perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an `msgs` directory inside the `libs` directory.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an empty file named `__init__.py` inside the `msgs` directory.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create another file named `hello.py` inside the `msgs` directory, and place
    the following code inside it:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a new Python file named `myapp.py` in the `myapp` directory, and
    populate it with the following code. This simple Flask application will use the
    `msgs` package. Have a look at the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you need to update the `wsgi.py` file to load the Flask application instead
    of the default created by OpenShift. Delete all the content in the `wsgi.py` file,
    and replace it with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To deploy this application on OpenShift, we have to declare all the dependencies
    in `requirements.txt`. The following command will write all of your application
    dependencies in `requirements.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, commit the code to the local repository, and then push changes to the
    application gear. OpenShift will install all the packages specified in `requirements.txt`
    and make them available to the application via the virtual environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, open the web application URL in your favorite browser to see the application
    in action. You will be greeted by the **Hello World** text in your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding steps, you learned how to use the `libs` directory to store
    your custom packages. The `libs` directory is an example of how OpenShift uses
    convention over configuration. The phrase *convention over configuration* means
    that if you follow certain conventions, you do not have to write the configuration
    code. OpenShift follows a convention that all the packages in the `libs` directory
    should be placed in the path so that your application can use them. In step 6,
    you created a custom package named `msgs` in the `libs` directory, and without
    any configuration, your application could access the package.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s suppose that you want to use the `mydeps` directory to store your
    custom packages. For your application to work, you have to write code in your
    application to add the `mydeps` directory to the system path. Adding two lines
    in the application''s `wsgi.py` file can solve this problem. The full application
    source code is on GitHub at [https://github.com/OpenShift-Cookbook/chapter8-custom-package-mydeps-recipe](https://github.com/OpenShift-Cookbook/chapter8-custom-package-mydeps-recipe).
    Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The previous two lines will add the `mydeps` directory to the application's
    system path.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating your first Python application* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating and deploying Flask web applications using Python and PostgreSQL
    cartridges* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the .htaccess file to configure Apache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you will be aware that OpenShift uses Apache with `mod_wsgi` to serve
    your web applications. In this recipe, you will learn to use the `.htaccess` and
    `.htpasswd` files to configure the Apache web server for the HTTP basic authentication.
    The GitHub repository for this recipe is [https://github.com/OpenShift-Cookbook/chapter8-htaccess-recipe](https://github.com/OpenShift-Cookbook/chapter8-htaccess-recipe).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is based on the assumption that you have read the previous recipes
    in this chapter. To walk through this recipe, you will need the rhc command-line
    client installed on your machine. Please refer to the *Installing the OpenShift
    rhc command-line client* recipe in [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting
    Started with OpenShift"), *Getting Started with OpenShift*, for details.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to enable the HTTP basic authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Python 2.7 application using the rhc command-line tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the directory to `myapp`, and create two files, `.htaccess` and `.htpasswd`,
    in the `myapp` directory. If you are using a *nix machine, you can use the `touch`
    command. On a Windows machine, you can use file explorer to create files. Have
    a look at the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `.htaccess`, copy and paste the content as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace `$OPENSHIFT_REPO_DIR` with the `$OPENSHIFT_REPO_DIR` location of your
    application. To get the value of `$OPENSHIFT_REPO_DIR`, run the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `.htpasswd` file is used to store username and password credentials. To
    generate a new username and password, you can use the online generator at [http://www.htaccesstools.com/htpasswd-generator/](http://www.htaccesstools.com/htpasswd-generator/).
    For this recipe, the username and password combination is `admin` and `password`
    respectively. Place the content generated by the online tool in the `.htpasswd`
    file. My `.htpasswd` file looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Commit the code, and push the changes to the application gear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After the application is deployed, open the application URL in your favorite
    web browser. This time, you will be greeted by a pop up asking you to enter the
    username and password, as shown in the following screenshot:![How to do it…](img/00104.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After entering the `admin`/`password` combination, you will be able to enter
    your web application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is another example of the flexibility that OpenShift offers to the
    application developers. There are a couple of ways you can configure the Apache
    web server. One way to configure the Apache web server is to update the main configuration
    file, usually named `httpd.conf`. OpenShift does not allow users to update the
    `httpd.conf` file. OpenShift allows users to configure the Apache web server via
    the `.htaccess` file. The `.htaccess` file provides a way to make configuration
    changes on a per-directory basis. This file can contain one or more configuration
    directives. These directives will then be applied to the directory in which the
    `.htaccess` file exists and all its subdirectories.
  prefs: []
  type: TYPE_NORMAL
- en: In step 1, you created a new Python 2.7 application with the name `myapp`. Then,
    in step 2, you created a couple of files—`.htaccess` and `.htpasswd`—in the `myapp`
    directory. In step 3, you updated the content of the `.htaccess` file with the
    HTTP basic authentication configuration. You can learn more from the documentation
    at [http://httpd.apache.org/docs/2.2/howto/auth.html](http://httpd.apache.org/docs/2.2/howto/auth.html).
  prefs: []
  type: TYPE_NORMAL
- en: Next, in step 4, you generated content for the `.htpasswd` file using an online
    `.htpasswd` generator. You placed the content generated by generator in the `.htpasswd`
    file and then committed all the changes in step 5\. On successful deployment,
    you opened the application URL in the browser in step 6\. You were asked to enter
    the `admin`/`password` username/password credentials. On entering the valid username/password
    combination, you were allowed to enter the application in step 7.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating your first Python application* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating and deploying Flask web applications using Python and PostgreSQL
    cartridges* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
