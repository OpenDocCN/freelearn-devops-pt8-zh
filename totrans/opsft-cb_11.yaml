- en: Chapter 11. Logging and Scaling Your OpenShift Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The specific recipes of this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Viewing application logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with JBoss application logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling JBoss access logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Tomcat application logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Python application logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating scalable applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring a different health check URL for HAProxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring HAProxy to use a different balance algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating scalable apps from nonscalable apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling manual scaling with marker files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter consists of recipes that will help you to work with the application
    logs and create scalable applications. The logging recipes will help you to access
    your application logs and debug any problems you might encounter while running
    your applications. You will learn how OpenShift uses a component called `logshifter`
    to store all application- and cartridge-specific logs in `OPENSHIFT_LOG_DIR`.
    This chapter will go into application logging in detail and cover various aspects
    of logging the JBoss, Tomcat, and Python applications. The logging concepts covered
    in this chapter will help you work with any web cartridge logs.
  prefs: []
  type: TYPE_NORMAL
- en: The *Viewing application logs* recipe will give you a general introduction to
    application logging, with the PHP web cartridge as an example. You will learn
    how to access application logs using the `rhc` command-line tool, and understand
    the log format used by Apache-based cartridges. Next, you will learn how to access
    JBoss application logs in the *Working with JBoss application logs* and *Enabling
    JBoss access logs* recipes. The *Working with Python application logs* recipe
    will cover how to effectively work with Python application logs.
  prefs: []
  type: TYPE_NORMAL
- en: The second section of this chapter will discuss application scaling in detail.
    You will learn how to create autoscalable applications in the *Creating scalable
    applications* recipe. Autoscaling is not always desired, and at times you need
    manual control over application scaling. In the *Enabling manual scaling with
    marker files* recipe, you will learn how to disable autoscaling and manually scale
    OpenShift applications using the `rhc` command-line tool.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing application logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logs are important data generated by your application that can help you understand
    user heuristics, monitor application performance, and debug problems. They are
    the first place you look when something goes wrong in your application. OpenShift
    uses a service called `logshifter`, which collects logs from all the different
    pieces of your application and makes them accessible at a single location. These
    logs can then be fed to your favorite log management solution, such as Splunk,
    to gain more useful insights. In this recipe, you will learn how easily you can
    view all the logs of your application using a single command. This recipe covers
    logging in a cartridge-agnostic manner. The language-specific aspects of logging
    will be covered later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will need `rhc` installed on your machine. Also,
    we will make use of the OpenShift application created in the *Creating an OpenShift
    application using the rhc command-line client* recipe in [Chapter 3](part0041_split_000.html#page
    "Chapter 3. Creating and Managing Applications"), *Creating and Managing Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To recreate the application, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To view the logfiles of your application, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a command-line terminal and run the following command, either from within
    the application directory or by passing the application name using the `--app`
    option. Have a look at the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also use the app name, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open your favorite browser and go to `http://myapp-{domain-name}.rhcloud.com`.
    You will notice new logs being tailed on your command-line terminal. A small snippet
    of logs is shown in the following command-line output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every OpenShift application uses one or more cartridges to do its work. Each
    cartridge is configured to log messages to `stdout` or `stderr`. An OpenShift
    service called `logshifter` captures all the messages sent to `stdout` as well
    as `stderr` and logs them properly. In OpenShift Online, all the messages captured
    by `logshifter` are written to the `$OPENSHIFT_LOGS_DIR` directory. You can SSH
    into your application gear using the `rhc ssh` command and look into the `$OPENSHIFT_LOGS_DIR`
    directory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding command line, the `$OPENSHIFT_LOGS_DIR` directory
    contains one logfile called `php.log`. All the application and Apache logs (both
    access and error) will be written to this logfile. The name of the logfile depends
    on the tag name passed to `logshifter` during the cartridge startup. For example,
    the `php` cartridge is started using the `nohup /usr/sbin/httpd $HTTPD_CMD_CONF
    -D FOREGROUND |& /usr/bin/logshifter -tag php &` command. This command ensures
    that the Apache logs are piped to the `logshifter` service and uses `php` as the
    tag name. The tag name serves two purposes: first, it identifies the program that
    generated the log message, and second, it is used as the name of the logfile.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 1, you ran the `rhc tail` command; this command opened an SSH tunnel
    behind the scenes and ran the `tail –f */log*/*` command on your application gear.
    The `-f` option allows a file to be monitored continuously. As new lines are added
    to the logfile, `tail` will update the display. The `rhc tail` command will tail
    all the logs in your application gear''s `$OPENSHIFT_LOG_DIR` directory, as shown
    in step 2\. The sample output is shown in the following command. All the Apache-based
    cartridges (PHP, Python, Perl, and Ruby) will have similar output in the logs.
    Have a look at the following command output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'At first glance, the output might look a bit cryptic; on closer inspection,
    it is no different from most application logs. The log follows Apache Combined
    Log Format ([https://httpd.apache.org/docs/trunk/logs.html#combined](https://httpd.apache.org/docs/trunk/logs.html#combined)).
    The format used is `"%{X-Forwarded-For}i %l %u %t \"%r\" %>s %b \"%{Referer}i\"
    \"%{User-Agent}i\""`. Let''s look at all these options one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '`%{X-Forwarded-For}i`: This is the HTTP request `X-Forwarded-For` header. It
    contains the IP address of the original client. In the log line shown in the preceding
    command, it corresponds to `117.212.42.145`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%l`: This is the user identity determined by `identd`. This will return `-`
    when the value is not present. In the log line shown in the preceding command,
    the value is `-`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%u`: This is the remote user determined by HTTP authentication. This will
    return `-` when the value is not present. In the log line shown in the preceding
    command, the value is `-`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%t`: This is the time when the HTTP request is received. In the log line shown
    in the preceding command, the value is `[22/Jun/2014:15:28:03 -0400]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\"%r\"`: This is the first line of the HTTP request. In the log line shown
    in the preceding command, the value is `GET / HTTP/1.1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%>s`: This is the HTTP status code. In the log line shown in the preceding
    command, the value is `200`, which means the request was successful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%b`: This is the response from the server in bytes. In the log line shown
    in the preceding section, the value is `39627`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\"%{Referer}i\"`: This is the referrer URL that is linked to this URL. In
    the log line shown in the preceding section, the value is `-`, which means it
    was not present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\"%{User-Agent}i\"`: This is the user agent taken from the HTTP request header.
    In the log line shown in the preceding section, the value is `Mozilla/5.0 (Macintosh;
    Intel Mac OS X 10_8_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153
    Safari/537.36`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As mentioned in the preceding section, `logshifter` will write one logfile
    per cartridge. So, if you add the MySQL cartridge to your application, then `logshifter`
    will create another logfile with the name `mysql.log` and write all the MySQL-specific
    logs to it. The `rhc tail` command will tail all the files present inside `$OPENSHIFT_LOG_DIR`.
    Make sure to run the `tail` command again so it can read the new logfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `mysql.log` logfile will contain all the MySQL logs. If you want to tail
    only a specific cartridge log, then you can use the `-f` or `--files` option of
    the `rhc tail` command, as shown in the following command. This will tail only
    the `mysql.log` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can view all the `rhc tail` command options by looking at its help, as
    shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Another responsibility `logshifter` performs is rolling logfiles based on the
    file size when they reach a configurable threshold. It also allows you to retain
    a configurable number of rolled files before removing the oldest prior to the
    next roll. You can configure the file size and the number of rolled files using
    the `LOGSHIFTER_$TAG_MAX_FILESIZE` and `LOGSHIFTER_$TAG_MAX_FILES` environment
    variables, where `$TAG` is replaced by an uppercase string equal to the value
    of the `-tag` argument. The default values used by `logshifter` are `10M` (`M`
    for megabytes) for file size and `10` for the number of rolled files. Let''s suppose
    you want to configure values as `20M` for file size and `5` for the number of
    rolled files. To configure these new values, you have to first use the `rhc env`
    command to set new environment variables and then restart the application, as
    shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can specify the file size in kilobytes (for example, `100K`), megabytes
    (for example, `20M`), gigabytes (for example, `10G`), or terabytes (for example,
    `2T`). The value of `0` for the file size will effectively disable the file rolling.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also ask the `rhc tail` command to output the last `n` lines using
    `--opts` or `-o`. To output the last 100 lines, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can pass other `tail` command options, as well, using the `--opts` option.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating an OpenShift application using the rhc command-line client* recipe
    in [Chapter 3](part0041_split_000.html#page "Chapter 3. Creating and Managing
    Applications"), *Creating and Managing Applications*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Working with JBoss application logs* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Working with Tomcat application logs* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Working with Python application logs* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with JBoss application logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the *Viewing application logs* recipe, logs are important data
    generated by your applications. This recipe will cover in detail how you can work
    with logs in OpenShift's JBoss cartridge applications. This recipe will start
    with viewing logs of an existing JBoss application, and then you will add application-specific
    logging using the `SLF4J` library. This recipe assumes you have already read the
    *Viewing application logs* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe will use the application created in the *Creating and deploying
    Java EE 6 applications using the JBoss EAP and PostgreSQL 9.2 cartridges* recipe
    in [Chapter 7](part0089_split_000.html#page "Chapter 7. OpenShift for Java Developers"),
    *OpenShift for Java Developers*. You can recreate the application using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view the JBoss cartridge logs by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You used the `--files` option to restrict the `rhc tail` command to only show
    JBoss-specific logs; otherwise, it will show all the logs in the `$OPENSHIFT_LOG_DIR`
    directory. This will print logs, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the application URL at `http://jobstore-{domain-name}.rhcloud.com` in
    your favorite browser, and you will see Hibernate-specific logs in your terminal.
    When you go to the application root, then an HTTP GET request is made to fetch
    all the companies in the database. The following query is the SQL statement that
    Hibernate executes to get data from the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'OpenShift''s JBoss cartridge is configured to log all the `INFO` and preceding
    messages to the console. As mentioned in the *Viewing application logs* recipe,
    any message written to `stdout` will be picked by `logshifter` and written to
    a logfile. For the JBoss EAP cartridge, the logfile name is `jbosseap.log`, and
    for the JBoss AS 7 cartridge, the logfile name will be `jbossas.log`. You can
    update the logging configuration to show all the `DEBUG` and preceding messages
    by updating the logging subsystem in the `standalone.xml` file inside the `.openshift/config`
    directory with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Commit the changes in your local Git repository, and then push them to the OpenShift
    application gear. OpenShift will now use the updated `standalone.xml` file, and
    you will see the `DEBUG` logs in the output of the `rhc tail` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As the application is not logging anything, the output of the `rhc tail` command
    either shows the application server logs or the logs of the different libraries
    used by your application. You can use any of the Java logging libraries to add
    application-specific logs. In this recipe, you will use `SLF4J` with `java.util.logging`
    binding to log the application logs, but you can use any other `SLF4J` binding,
    such as `log4j` or `logback`, as well. Open the Maven `pom.xml` file, and add
    the following dependencies to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `CompanyResource.java` file inside the `org.osbook.jobstore.rest`
    package in an editor, and add a couple of statements to import the `SLF4J` classes,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After adding the `import` statements, update the `createNewCompany()` and `showAll()`
    methods in `CompanyResource.java` with log messages, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Revert the changes you made to the `standalone.xml` file in step 3 to view
    only the `INFO` messages. Change the `root-logger` level to `INFO`, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Commit the changes to the local Git repository, and then push them to the application
    gear using the `git push` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the changes are deployed, make another request to the web application,
    and this time you will see your application logs in the `rhc tail` command output,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you try to create a new company, then you see that only the `INFO` messages
    are getting logged. This is because the logging configuration in the `standalone.xml`
    file is configured to only log `INFO` and preceding messages to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To view the debug messages of your application, you have to update the `standalone.xml`
    logging subsystem configuration with the one shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you will also see the application-specific `DEBUG` logs in the output
    of the `rhc tail` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding steps, you learned how you can view the logs of a JBoss application
    and add application-specific logging using the `SLF4J` library. In step 1, you
    ran the `rhc tail` command to view all the JBoss-specific logs. All the JBoss
    EAP-specific logs are written to the `jbosseap.log` file. This file contains both
    the JBoss `server.log` and `boot.log` content. As discussed in the *Viewing application
    logs* recipe, `logshifter` will collect all the logs written to `stdout` or `stderr`
    and write them to the cartridge-specific logfile. Logging the subsystem configuration
    in the `standalone.xml` configuration file controls the logging in JBoss cartridges.
    The `standalone.xml` file is present inside the `.openshift/config` directory,
    and you can override it to meet your needs. The logging subsystem consists of
    three parts: one or more handler configurations, such as `console-handle` or `file-handler`,
    one or more loggers to define a logger category, such as `com.arjuna` shown in
    the next code, and a `root-logger` declaration. You can read more about the JBoss
    logging configuration in the official documentation at [https://docs.jboss.org/author/display/AS71/Logging+Configuration](https://docs.jboss.org/author/display/AS71/Logging+Configuration).
    Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In step 3, you updated the `root-logger` level to `DEBUG`. This enables the
    JBoss server to generate `DEBUG` and preceding-level logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'From step 5 through step 11, you first added the application logs using the
    `SLF4J` library and then updated `standalone.xml` logger subsystem configuration
    to allow JBoss to log the application `DEBUG` and preceding messages. This was
    done by adding an application-specific `logger category` at the `DEBUG` level.
    Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After reading through this recipe, you might be wondering if there is a way
    to update the logging configuration at runtime. Yes, you can do so using the JBoss
    admin console. To use the JBoss admin console, first run the `rhc port-forward`
    command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, go to the admin console at `http://127.0.0.1:9990/`. Navigate to **Configuration**
    | **Core** | **Logging**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/00145.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, go to **LOG CATEGORIES**, and you will see a category for `org.osbook.jobstore`,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/00146.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Change the **Log Level** value to **INFO**, and click on the **Save** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/00147.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, if you try to create a new company, you will not see the `DEBUG` messages.
    You will only see the `INFO` and preceding messages.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Viewing application logs* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Enabling JBoss access logs* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling JBoss access logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Access logs are very useful when you want to see a list of all the requests
    processed by a server. For Apache-based cartridges, access logs are enabled by
    default, but you will have to enable it manually in JBoss-based cartridges. In
    this recipe, you will learn how to enable the access logs for JBoss cartridges.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe will pick up where we left off in the *Working with JBoss application
    logs* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to enable the access logs:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `standalone.xml` file inside the `.openshift/config` directory in your
    favorite editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `urn:jboss:domain:web:1.5` subsystem with the one shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Commit the changes to the local Git repository, and then push them to the application
    gear using the `git push` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the `rhc tail` command again, and you will see the access logs in the `tail`
    command output, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An access log stores all the user requests for individual resources. These
    include requests to fetch HTML files, JavaScript files, CSS files, REST calls,
    and so on. The data stored in this file can then be analyzed by another application
    to get meaningful information out of it. An access log can help you with following:'
  prefs: []
  type: TYPE_NORMAL
- en: It can help to calculate the number of unique visitors to your website.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can help to calculate the number of successful and failed requests. The requests
    with the `2XX` code are considered successful, and the requests with `4xx` and
    `5xx` are considered errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can help basic performance analysis. Each access log line contains the time
    taken to process the request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can help to analyze your web application usage pattern in terms of the time
    of the day, the day of the week, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the preceding steps, you updated the `urn:jboss:domain:web:1.5` subsystem
    configuration to enable the access logs. Adding the following two lines to the
    configuration enables the access logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `access-log` element enables the access logs, and the `directory` element
    is used to specify the directory that should be used to generate the logs. The
    preceding `directory` element configures JBoss to write the access logs to `$OPENSHIFT_LOG_DIR`
    as it looks for the `app-root/logs` directory relative to the user home. The `app-root/logs`
    directory relative to the user home is `$OPENSHIFT_LOG_DIR`. We have used this
    value so that the `rhc tail` command can read this file along with other JBoss
    logs. The `access-log` element takes one mandatory attribute called `pattern`.
    The `pattern` element defines the logs format. The following pattern codes are
    supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '`%a`: Remote IP address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%A`: Local IP address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%b`: Bytes sent, excluding HTTP headers, or `-` if zero'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%B`: Bytes sent, excluding HTTP headers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%h`: Remote hostname (or IP address if `resolveHosts` is `false`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%H`: Request protocol'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%l`: Remote logical username from `identd` (always returns `-`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%m`: Request method (GET, POST, and so on)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%p`: Local port on which this request was received'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%q`: Query string (prepended with a `?` if it exists)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%r`: First line of the request (method and request URI)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%s`: HTTP status code of the response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%S`: User session ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%t`: Date and time in Common Log Format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%u`: Remote user that was authenticated (if any), else `-`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%U`: Requested URL path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%v`: Local server name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%D`: Time taken to process the request in milliseconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%T`: Time taken to process the request in seconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%I`: Current request thread name (can compare later with stacktraces)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Working with JBoss application logs* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Viewing application logs* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Tomcat application logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to work with logs in Tomcat cartridges. You
    will start with tailing the logs of an existing Tomcat application, and then you
    will learn how to add application-specific logging using the `SLF4J` library.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe will use the application created in the *Creating and Deploying
    Spring Applications using the Tomcat 7 cartridge* recipe in [Chapter 7](part0089_split_000.html#page
    "Chapter 7. OpenShift for Java Developers"), *OpenShift for Java Developers*.
    You can recreate the application using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view the logs of a Tomcat application using the `rhc tail` command.
    Tomcat logs are written to a file named `jbossews.log` inside the `$OPENSHIFT_LOG_DIR`
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `jbossews.log` file will contain logs of both Tomcat-specific and application-specific
    logs, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before you can add application-specific logging, you will have to add the following
    dependencies to your Maven `pom.xml` file. In this recipe, you will use `SLF4J`
    along with `logback` binding to add application logging:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `CompanyResource.java` file inside the `org.osbook.jobstore.rest`
    package in an editor, and add a couple of statements to import the `SLF4J` classes,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, update the `CompanyResource` Java class under the `org.jobstore.rest`
    package to add application-specific logging, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Commit the changes to the local Git repository, and then push them to the application
    gear using the `git push` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the application restarts, you will start seeing various log messages.
    A short snippet is shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can use the `logback` configuration file to enable the logging of specific
    packages. Create a new file with the name `logback.xml` inside the `src/main/resources`
    directory, and add the following contents to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Commit the changes to the local Git repository, and push them to the application
    gear using the `git push` command. After the app restarts, you will only see the
    application-specific `DEBUG` and preceding messages. Have a look at the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding steps, you learned how to view the logs of a Tomcat application
    and add application-specific logging using the `SLF4J` library. In step 1, you
    ran the `rhc tail` command to view all the Tomcat-specific logs. All the Tomcat-specific
    logs are written to the `jbossews.log` file. As discussed in the *Viewing application
    logs* recipe, `logshifter` will collect all the logs written to `stdout` or `stderr`
    and write them to the cartridge-specific logfile.
  prefs: []
  type: TYPE_NORMAL
- en: From step 2 through step 5, you added log statements to the `CompanyResource.java`
    file using the `SLF4J` library. The `SLF4J` library underneath uses the `Logback`
    library that has a default log level of `DEBUG`. This means if you don't specify
    any `Logback` configuration, then all the `DEBUG` and preceding messages will
    be logged to `jbossews.log`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Logback` can be configured using the `logback.xml` file. In step 6, you created
    a `logback.xml` file and added configuration to only the log application `DEBUG`
    messages. All other messages will be logged at `WARN` level. Then, finally, in
    step 7, you committed the changes and pushed them to the application gear.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can enable the access logs for the Tomcat cartridge by performing the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Tomcat `server.xml` configuration file inside the `.openshift/config`
    directory in your favorite editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `AccessLogValve` configuration to the `server.xml` file''s `Host` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Commit the changes to the local Git repository, and push them to the application
    gear using the `git push` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the `rhc tail` command again, and this time, you will see the access logs,
    as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Viewing application logs* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Working with JBoss application logs* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Enabling JBoss access logs* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Python application logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to add view and logging to your Python applications.
    As discussed in [Chapter 8](part0105_split_000.html#page "Chapter 8. OpenShift
    for Python Developers"), *OpenShift for Python Developers*, OpenShift Python applications
    use Apache with `mod_wsgi`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe will use the application created in the *Creating and deploying
    Flask web applications using Python and PostgreSQL cartridges* recipe in [Chapter
    8](part0105_split_000.html#page "Chapter 8. OpenShift for Python Developers"),
    *OpenShift for Python Developers*. You can recreate the application using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new command-line terminal, and navigate to the directory where you have
    created the Python application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To view the logs of a Python application, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By visiting the application URL, you will see the following logs in the `rhc
    tail` command output when you make a request to the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `jobstore.py` file inside the application directory, and add the following
    lines just above the `index()` function. The following lines import the `logging`
    module and then create a new `logger` object with the `INFO` log level. This logger
    will be used in the next step for logging.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, update the `index()` function with a log statement, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Commit the change to the local Git repository, and then push the changes to
    the application gear. After the app has started successfully, visit the application
    URL and you will see the log message you added to `jobstore.py`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are times when you will prefer to use a different file to store your
    application logs. This can be done using `TimedRotatingFileHandler`. Open `jobstore.py`
    in the application root directory and replace the logging lines added in step
    3 with the ones shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Commit the change, and push the changes to the application gear. After the
    app restarts, you will see a new file, `jobstore.log`, with all the application-specific
    logs, as shown in the following command lines. You will have to run the `rhc tail`
    command so that the `tail` command can find the new file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python application logs are logged in the `python.log` file inside `$OPENSHIFT_LOG_DIR`.
    This file will contain both Apache access logs and error logs, as well as any
    application-specific logs. The log follows Apache Combined Log Format discussed
    in the *Viewing application logs* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: To add application-level logging, you used the Python standard logging module
    in step 3\. After pushing these changes to the application gear, you will start
    seeing your application-specific log messages. You will only see the log messages
    with the level `INFO` or above. This is because you have configured the default
    logging level to `logging.INFO`.
  prefs: []
  type: TYPE_NORMAL
- en: OpenShift, by default, will log all the messages written to `stdout` or `stderr`
    to the `python.log` file. If you want to use a different logfile for application-specific
    logs, then you can use `TimedRotaingFileHandler` to log messages to the `jobstore.log`
    file inside `$OPENSHIFT_LOG_DIR`, as shown in step 5\. In step 6, you pushed the
    changes to the OpenShift application gear, and after running the `rhc tail` command
    again, you will start seeing messages written to `jobstore.log` in the output.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Viewing application logs* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating scalable applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As your application becomes popular and more users start using it, you will
    have to scale your application to meet the increased usage. Application scaling
    can be done in either of the following two ways: vertical scaling (or scaling
    up) and horizontal scaling (scaling out). Vertical scaling is about adding more
    power to a single machine, that is, faster CPU, more RAM and SSD, and so on. Vertical
    scalability has a limit and the cost increases exponentially. Horizontal scaling,
    on the other hand, is about handling more requests and load by adding more machines.'
  prefs: []
  type: TYPE_NORMAL
- en: With most PaaS solutions such as OpenShift, you will soon hit the vertical scaling
    limit. Currently, in OpenShift, you can't get a bigger gear size than 2 GB of
    RAM space (that is, large gear), so it is recommended that you design your application
    for horizontal scalability. There are many good books, such as *Scalability Rules*,
    *Martin L. Abbott and Michael T. Fisher*, *Addison-Wesley Professional*, written
    on this subject, and you can refer to them for more information. I have also written
    an article on best practices to create scalable web applications ([https://www.openshift.com/blogs/best-practices-for-horizontal-application-scaling](https://www.openshift.com/blogs/best-practices-for-horizontal-application-scaling))
    that you can refer to, as well.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to create scalable applications in OpenShift.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will need `rhc` installed on your machine. This
    recipe will require all three available gears, so please make sure to delete any
    existing applications.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a scalable application, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a command-line terminal and change the directory to a convenient location
    where you want to create the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, execute the following command to create the scalable application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `rhc create-app` command used in the preceding steps instructs OpenShift
    to create an application named `jobstore` with the JBoss EAP and PostgreSQL 9.2
    cartridges. The `--scaling` option tells OpenShift to create a horizontally scalable
    application instead of a nonscalable application. The `--from-code` option tells
    OpenShift to use the specified Git repository as the reference application. You
    can also use `-s` instead of `--scaling`. The `-s` option is a shorthand notation
    of the `--scaling` option.
  prefs: []
  type: TYPE_NORMAL
- en: This command will create two OpenShift gears. The HAProxy load balancer and
    JBoss EAP application server will share the first gear, and the PostgreSQL database
    will use the second gear. The gear that has the HAProxy cartridge installed is
    called the `main` gear. All the commands that work against a gear will apply to
    this gear. For example, when you run the `rhc ssh` command, you will be logged
    in to the HAProxy gear. Similarly, the `rhc tail` command will tail the logs in
    the `app-root/logs` directory of this gear.
  prefs: []
  type: TYPE_NORMAL
- en: HAProxy is a software-based load balancer that sits in front of your web application
    and accepts all the incoming requests. It then parses the HTTP request and, depending
    on its configuration, will route the incoming request to a backend. The backend
    here means one or more JBoss EAP instances. OpenShift helps you scale your application
    by adding new application instances (in our example, JBoss EAP instances) as the
    number of concurrent HTTP connections reaches a threshold. The current threshold
    is 16 concurrent HTTP connections. This behavior is called autoscaling, as OpenShift
    manages the application scaling without any user intervention. You can also configure
    your application to use manual scaling, which will give you more control over
    application scaling. This will be covered in the *Enable manual scaling with marker
    files* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: OpenShift currently does not support database scaling. You can use services
    such as Amazon RDS (covered in the *Using an Amazon RDS MySQL DB instance with
    OpenShift* recipe in [Chapter 4](part0061_split_000.html#page "Chapter 4. Using
    MySQL with OpenShift Applications"), *Using MySQL with OpenShift Applications*),
    Enterprise DB PostgreSQL Cloud Database (covered in the *Using EnterpriseDB PostgreSQL
    cloud database with OpenShift* recipe in [Chapter 5](part0070_split_000.html#page
    "Chapter 5. Using PostgreSQL with OpenShift Applications"), *Using PostgreSQL
    with OpenShift Applications*), or MongoLab (covered in the *Using MongoLab MongoDB-as-a-Service
    with OpenShift* recipe in [Chapter 6](part0079_split_000.html#page "Chapter 6. Using
    MongoDB and Third-party Database Cartridges with OpenShift Applications"), *Using
    MongoDB and Third-party Database Cartridges with OpenShift Applications*) to get
    database scaling.
  prefs: []
  type: TYPE_NORMAL
- en: Every OpenShift scalable application has a daemon running called `haproxy_ctld`.
    This daemon controls the autoscaling behavior by polling the HAProxy Unix socket
    status port every five seconds to collect the basic HAProxy statistics. By default,
    it is configured to use the HTTP concurrent connection of autoscaling, but users
    can customize it to autoscale applications based on other factors such as CPU
    usage, as well ([https://www.openshift.com/blogs/customizing-autoscale-functionality-in-openshift](https://www.openshift.com/blogs/customizing-autoscale-functionality-in-openshift)).
  prefs: []
  type: TYPE_NORMAL
- en: The daemon checks the current concurrent HTTP connections, and if the number
    of concurrent connections is more than 90 percent of the allocated, that is, 16,
    then it fires the scale-up event. When a scale-up event happens, the daemon will
    make an HTTP request to the OpenShift broker to add a new gear to the application.
    The broker will spin up a new gear with the same configuration as the existing
    application gear, attach the new gear with HAProxy, use the `rsync` command to
    copy the contents of the `~/app-root/repo` directory on the main gear to the new
    gear, and finally start the new gear. From now on, HAProxy will start sending
    requests to both the gears based on the configured algorithm. By default, OpenShift
    uses sticky sessions along with the least connection balance algorithm to make
    sure that the request from a user ends up on the same gear always, and the server
    with the least connection gets the request from the new client. Users can override
    the default HAProxy configuration according to their needs. We will cover that
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Applications will scale down when your application web traffic falls below 50
    percent of the allocated HTTP connections for several minutes. Then, the new gear
    will be removed, and it will also be removed from the HAProxy configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'An OpenShift application developer can see the HAProxy stats on the HAProxy
    status page. This page is located at `http://jobstore-{domain-name}.rhcloud.com/haproxy-status`,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/00148.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The HAProxy status page is divided into two sections: **stats** and **express**.
    The **stats** section is configured to listen to all the requests made to the
    HAProxy status page. Every time you refresh the `http://jobstore-domainname.rhcloud.com/haproxy-status
    page` page, the total number of sessions under the **Sessions** tab will increment.
    This is shown under the **Total** column. The **Cur** column is the number of
    users currently accessing the status page. The **Max** column is the maximum number
    of concurrent users. All these numbers are calculated since HAProxy was started;
    if you restart HAProxy, the stats will reset.'
  prefs: []
  type: TYPE_NORMAL
- en: The **express** section is more interesting from the application point of view.
    The **local-gear** row corresponds to the requests handled by JBoss EAP. The total
    number of sessions handled by the application is shown in the **Total** column.
    The **Cur** column is the number of users currently accessing the application.
    The **Max** column is the maximum number of concurrent users. All these figures
    pertain to the time period since HAProxy was started; if you restart HAProxy,
    the stats will reset. In the preceding screenshot, we can see that **local-gear**
    has handled seven requests, one at a time. When the application scales, it will
    add more rows for the new gears.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can define the minimum and maximum values for application scaling. By default,
    a scalable application will consume at least one gear and, at peak traffic, can
    consume all the gears in your OpenShift account. You can set the minimum and maximum
    values using the `rhc scale-cartridge` command, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will make sure that the `jobstore` application will at
    least have two instances of the JBoss EAP cartridge, and at maximum, four instances.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Configuring a different health check URL for HAProxy* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Configuring HAProxy to use a different balance algorithm* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Enabling manual scaling with marker files* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring a different health check URL for HAProxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to update the HAProxy configuration file
    to configure a different heath check URL.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will need `rhc` installed on your machine. This
    recipe will utilize the application created in the *Creating scalable applications*
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a command-line terminal and navigate to the application directory created
    in the *Creating scalable applications* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'SSH into the main application gear using the `rhc ssh` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the directory to the `haproxy` configuration directory, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, open the `haproxy.cfg` file using VIM, and remove the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In its place, insert the following content:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, restart the HAProxy cartridge from your local machine using the `rhc`
    command-line client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HAProxy performs periodic health checks to determine the health of the application
    gears. The default configuration pings the root URL `/` every two seconds. If
    HAProxy receives an HTTP code other than `2xx` or `3xx`, then it considers it
    a server failure, and your application will give a `Service Unavailable` error.
    One scenario where you will see this behavior is when you use OpenShift to host
    your REST backend at a nonroot URL, such as `/api/v1/`. In the preceding steps,
    you updated the `haproxy.cfg` file to use a different health check URL.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Configuring HAProxy to use a different balance algorithm* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Enabling manual scaling with marker files* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring HAProxy to use a different balance algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HAProxy load balancer can work with several load-balancing algorithms. The
    configuration used by HAProxy in OpenShift applications uses the **leastconn**
    load-balancing algorithm. This algorithm is useful when you have long-lived connections,
    but is not recommended for short connections. For short connections, as in the
    case of our application, it is more suitable to use the **roundrobin** algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to configure HAProxy to use the **roundrobin
    balance** algorithm instead of the leastconn algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will need `rhc` installed on your machine. This
    recipe will utilize the application created in the *Creating scalable applications*
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to configure HAProxy to use the roundrobin balance
    algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a command-line terminal and navigate to the application directory created
    in the *Creating scalable applications* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Scale the JBoss EAP cartridge to use two JBoss EAP instances by running the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'SSH into the main application gear using the `rhc ssh` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you are inside the application gear, change the directory to the `haproxy/conf`
    directory, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is always a good idea to make a backup of the configuration files before
    making any changes to them. Use the `copy` command to create a copy of the `haproxy.cfg`
    file in `$OPENSHIFT_DATA_DIR`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, open the `haproxy.cfg` file using VIM, and update the section under `balance
    leastconn` to the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Replace `gear-2` with your application's second gear name. Also, replace `host1`
    and `host2` and `port1` and `port2` with the gear 1 and gear 2 host and port values.
    You can get the values from the copy of `haproxy.cfg` saved in step 5.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can ask HAProxy to reload the configuration by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run Apache Benchmark to see the new configuration in action, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding test, `ab` will make a total of `1000` requests with `20` concurrent
    requests at a time. As we are using the roundrobin algorithm, both the gears should
    handle 500 requests each. You can verify the number of requests by looking at
    the following HAProxy status page (screenshot):![How to do it…](img/00149.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HAProxy supports various load-balance algorithms. The algorithm you choose will
    determine which backend server will be used to serve the request. The default
    load-balance algorithm used by OpenShift's scalable applications is leastconn.
    This algorithm selects the server with the least number of active connections.
    HAProxy is also configured to use persistent cookies to achieve sticky session
    behavior. Session stickiness ensures that a user request is served from the same
    gear that served their first request.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding steps, you overrode the default configuration to use the roundrobin
    algorithm. The algorithm to use can be set using the `balance` parameter. The
    roundrobin algorithm selects servers in turn to make sure requests are balanced
    fairly. You can assign weights to the servers to manipulate how frequently a server
    is selected compared to others. In step 6, you used `roundrobin` as the value
    of the balance parameter and assigned a weight of `1` to both the servers. Because
    we gave both servers the same weight, both will serve an equal number of requests.
    Then, you asked HAProxy to reload the configuration using the `rhc reload-cartridge`
    command in step 7.
  prefs: []
  type: TYPE_NORMAL
- en: In step 8, you ran a load test on the application using Apache Benchmark, to
    see if your changes were working as expected. Because both servers had a weight
    of `1`, they both handled 500 requests each.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s update the HAProxy configuration to use different weights for different
    servers. Update the `haproxy.cfg` roundrobin section with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, reload the configuration by running the `rhc reload-cartridge` command,
    and then run the Apache Benchmark test performed in step 8\. Because `gear-2`
    has a weight of `1` and `gear-1` has a weight of `2`, gear 1 will serve twice
    as many requests as gear 2\. You can verify that by looking at the following HAProxy
    status page (screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/00150.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Configuring a different health check URL for HAProxy* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Enabling manual scaling with marker files* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating scalable apps from nonscalable apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenShift currently does not support the conversion of an existing nonscalable
    application to a scalable application. In this recipe, you will learn how to create
    a new scalable application using an existing nonscalable application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will need `rhc` installed on your machine. This
    recipe will require all three available gears, so please make sure to delete any
    existing applications.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to covert a nonscalable application to a scalable
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new command-line terminal and navigate to a convenient location where
    you want to create the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a nonscalable application with JBoss EAP 6 using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To create a scalable application using the application created in step 2, run
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using another application as a template, you can create a new application using
    the `--from-app` option. When you specify the `--from-app` option, OpenShift will
    use the template application configuration to create the new application. The
    configuration includes existing cartridges, storage configuration, gear sizes,
    scaling configuration, deployment configuration, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding steps, you created a scalable application from a nonscalable
    application. Because you want to create a scalable application, you have to provide
    the `--scaling` option; otherwise, a nonscalable application will be created.
    You can also specify different gear sizes using the `--gear-size` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Apart from `--scaling` and `--gear-size`, you can also provide the `--env`,
    `--no-git`, and `--enable-jenkins` options.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `--from-app` option makes use of application snapshots to transfer the
    template application data and Git repository. It first takes the `jobstore` application
    snapshot, transfers it to the `jobstorescalable` application, and then restores
    it. This can be seen in the application creation logs as shown in the following
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The cartridge data is not transferred when you create an application using `--from-app`,
    but any data stored in `$OPENSHIFT_DATA_DIR` is transferred to the new application.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating scalable applications* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Enabling manual scaling with marker files* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling manual scaling with marker files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how you can disable autoscaling and add gears
    manually to a scalable application using the `rhc` command-line tool.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will need `rhc` installed on your machine. This
    recipe will utilize the application created in the *Creating scalable applications*
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to manually add a new gear to a scalable application:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a command-line terminal and navigate to the application directory created
    in the *Creating scalable applications* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new marker file with the name `disable_auto_scaling` in the `.openshift/marker`
    directory inside your application director. On Mac and Linux machines, you can
    use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On Windows machines, you can create a new file using the **File** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Commit the file to the local Git repository, and push the changes to the OpenShift
    application gear Git repository using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Restart the HAProxy cartridge so that it does not run the `haproxy_ctld` process.
    The `haproxy_ctld` process is responsible for publishing scale-up and scale-down
    events. Have a look at the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, to add a new gear to your application, you can use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To remove a gear from your application, you can use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenShift scalable applications are by default autoscalable in nature, which
    means they can add or remove web cartridge gears based on the number of concurrent
    users. While autoscaling is useful in most cases, there are times when you will
    prefer to control the scaling behavior yourself. You will enable manual scaling
    in situations where you can anticipate web traffic on your application well in
    advance. Examples are a holiday season or a promotion, where you know in advance
    that you can expect more visitors to your applications. For such situations, you
    can enable manual scaling to have a bunch of gears available to serve the web
    traffic.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenShift allows users to manually add or remove gears using the `rhc scale-up-app`
    or `rhc scale-down-app` commands. These commands add or remove one gear at a time.
    Under the covers, these commands use the OpenShift REST API to publish scale-up
    and scale-down events to the broker. OpenShift Broker consumes these requests
    and acts accordingly. After running the `rhc scale-up-app` command in step 5,
    you should see that the `jobstore` application is consuming three gears. You can
    also see the new gear in the HAProxy status page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned in the preceding section, the `rhc scale-up-app` or `scale-down-app`
    commands use the REST API to add or remove a gear. So, if you don't want to use
    OpenShift tooling to perform manual scaling, then you can call the REST API yourself
    to add or remove gears from the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To scale up using `curl`, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Replace `domain_name`, `app_name`, `openshift_login`, and `openshift_login_password`
    with their respective values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To scale down using `curl`, you can run the wfollowing command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating scalable applications* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Enabling manual scaling with marker files* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Appendix A. Running OpenShift on a Virtual Machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenShift Origin is the free and open source flavor of OpenShift PaaS. It is
    the upstream project to both OpenShift Online and Enterprise. You will learn how
    to run OpenShift Origin in a **Virtual Machine** (**VM**) running on your machine.
    This will help you work with OpenShift even when you are not connected to the
    Internet. You can use the OpenShift Origin VM as your development environment
    to test your changes, and then when you are ready for deployment, you can push
    the source code to OpenShift Online. To use the OpenShift Origin VM as your development
    environment, run the `rhc setup --server` command. The `--server` option should
    point to the OpenShift Origin VM broker. You can refer to the *Specifying a different
    OpenShift server hostname* recipe in [Chapter 1](part0014_split_000.html#page
    "Chapter 1. Getting Started with OpenShift"), *Getting Started with OpenShift*,
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: To prepare yourself, you will need to have VirtualBox installed on your machine.
    If you do not have it installed, please download it from the official website
    at [https://www.virtualbox.org/](https://www.virtualbox.org/). Also, install the
    7-Zip software for your operating system, which you can download from its official
    website at [http://www.7-zip.org/download.html](http://www.7-zip.org/download.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to run OpenShift on a VM:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the OpenShift Origin Version 3 VM image. The VM is over 2 GB in size.
    You can run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Windows users can download either via the browser, or they can first download
    the `wget` software for Windows at [http://gnuwin32.sourceforge.net/packages/wget.htm](http://gnuwin32.sourceforge.net/packages/wget.htm),
    and then use it to download the OpenShift Origin VM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The advantage of using `wget` is that you can resume the partial download using
    the `-c` option. This will help if you are at a location where the Internet connection
    is not stable, so you can resume the download using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, unpack the zip archive using the 7-Zip file archiver:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Typing in this command will result in three additional files, as shown in the
    next command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These are `OpenShift Origin Release 3.vmx`, `OpenShift Origin Release 3.vbox`,
    and `origin-rel3.vmdk`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Start the VirtualBox manager, and click on the **New** button. Have a look at
    the following screenshot:![Running OpenShift on a Virtual Machine](img/00151.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the details required for the OpenShift Origin VM. You can keep whatever
    name you like, but you have to use **Type** as **Linux** and **Version** as **Fedora
    (64 bit)**. Have a look at the following screenshot:![Running OpenShift on a Virtual
    Machine](img/00152.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, set the memory size to 1 GB, as this will give the VM a reasonable amount
    of memory to work well with. Have a look at the following screenshot:![Running
    OpenShift on a Virtual Machine](img/00153.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will add a virtual hard drive to the new machine. Please select the
    **Use an existing virtual hard drive file** option, and click on the **Choose
    a virtual hard drive file upload** button. Have a look at the following screenshot:![Running
    OpenShift on a Virtual Machine](img/00154.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: VirtualBox will present a file selection dialog. Browse to find the `origin-rel3.vmdk`
    file, and select it. Click on the button labeled **Open**. Have a look at the
    following screenshot:![Running OpenShift on a Virtual Machine](img/00155.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After selecting the file, click on **Create** to create a new VM. You will see
    a new VM in the virtual manager display. Have a look at the following screenshot:![Running
    OpenShift on a Virtual Machine](img/00156.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will set up a bridged network adapter, which will allow you to work
    with the OpenShift Origin VM from your local machine. Select the VM, and right-click
    on it. Then, click on the **Settings** icon:![Running OpenShift on a Virtual Machine](img/00157.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the **Network** settings, and select **Adapter 2**. Check the **Enable
    Network Adapter** checkbox, and then set the **Attached to** drop-down menu to
    **Bridged Adapter**. Finally, set the name to the network adapter you want to
    bridge. Have a look at the following screenshot:![Running OpenShift on a Virtual
    Machine](img/00158.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each system may have different names for their physical network adaptors. Click
    on **OK** after making the preceding changes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Start the VM by clicking on the **Start** button. Have a look at the following
    screenshot:![Running OpenShift on a Virtual Machine](img/00159.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the VM has finished booting, it will present you with a tutorial that will
    help you understand how to work with the OpenShift Origin VM, as shown in the
    following screenshot:![Running OpenShift on a Virtual Machine](img/00160.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After you enter `yes`, the tutorial will walk you through the features of the
    OpenShift Origin VM from an administrator's perspective.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After finishing the admin tutorial, you will be shown a menu where you can select
    options to interact with the OpenShift Origin VM. Choose the second option to
    connect with the web console. You will be shown the web console details, as shown
    in the following screenshot:![Running OpenShift on a Virtual Machine](img/00161.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the URL and paste it into your browser. The default username/password combination
    is `demo`/`changeme`. Have a look at the following screenshot:![Running OpenShift
    on a Virtual Machine](img/00162.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log in to the web console using the default username and password. You will
    be directed to the application creation page. You can create the WordPress application
    by following the steps mentioned in the *Creating a WordPress application using
    the web console* recipe in [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting
    Started with OpenShift"), *Getting Started with OpenShift*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
