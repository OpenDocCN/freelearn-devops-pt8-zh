- en: Chapter 8. Using LXC with OpenStack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we looked at examples of common design patterns that help
    autoscale services running inside LXC containers by leveraging tools such as Jenkins,
    custom REST-based APIs, and monitoring tools. In this chapter, we'll explore a
    fully automated way of provisioning LXC containers on a set of servers, using
    OpenStack.
  prefs: []
  type: TYPE_NORMAL
- en: OpenStack is a cloud operating system that allows for the provisioning of virtual
    machines, LXC containers, load balancers, databases, and storage and network resources
    in a centralized, yet modular and extensible way. It's ideal for managing a set
    of compute resources (servers) and selecting the best candidate target to provision
    services on, based on criteria such as CPU load, memory utilization, and VM/container
    density, to name just a few.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following OpenStack components and services:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the Keystone identity service, which will provide a central directory
    of users and services, and a simple way to authenticate using tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the Nova compute controller, which will manage a pool of servers
    and provision LXC containers on them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the Glance image repository, which will store the LXC images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provisioning the Neutron networking service that will manage DHCP, DNS, and
    the network bridging on the compute hosts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we'll provision an LXC container using the libvirt OpenStack driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying OpenStack with LXC support on Ubuntu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An OpenStack deployment may consist of multiple components that interact with
    each other through exposed APIs, or a message bus such as RabbitMQ, as shown in
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying OpenStack with LXC support on Ubuntu](img/image_08_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we'll deploy a minimum set of those components - Keystone,
    Glance, Nova, and Neutron - which will be sufficient to provision LXC containers
    and still take advantage of the scheduler logic and scalable networking that OpenStack
    provides.
  prefs: []
  type: TYPE_NORMAL
- en: For this tutorial, we are going to be using Ubuntu Xenial, and as of the time
    of this writing, the latest Newton OpenStack release. What is the name of that
    OpenStack release?
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the host
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To simplify things, we are going to use a single server to host all services
    with a minimum of 16 GB of RAM. In production environments, it's a common approach
    to separate each service into its own set of servers, for scalability and high
    availability. By following the steps in this chapter, you can easily deploy on
    multiple hosts by replacing the IP addresses and hostnames as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If using multiple servers, you need to make sure the time is synchronized on
    all hosts using services such as `ntpd`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by ensuring we have the latest packages, and installing the repository
    that contains the Newton OpenStack release:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Make sure to add the name of the server, in this example, `controller`, to `/etc/hosts`.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the database service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The services we are going to deploy use a MariaDB database as their backend
    store. Install it by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A minimal configuration file should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the IP address the service binds to with whatever is on your server,
    then start the service and run the script that will secure the installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will prompt for a new root password. For simplicity, we'll
    use `lxcpassword` as a password for all services, for the rest of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify that MySQL is set up correctly and that you can connect to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Installing the message queue service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'OpenStack supports the following message queues - RabbitMQ, Qpid, and ZeroMQ -
    which facilitate interprocess communication between services. We are going to
    use RabbitMQ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new user and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, grant permissions for that user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Installing the caching service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The identity service Keystone caches authentication tokens using Memcached.
    To install it, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the localhost address with the IP address of your server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The config file should look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Installing and configuring the identity service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Keystone identity service provides a centralized point for managing authentication
    and authorization for the rest of the OpenStack components. Keystone also keeps
    a catalog of services and the endpoints they provide, which the user can locate
    by querying it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To deploy Keystone, first create a database and grant permissions to the `keystone`
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, install the identity service components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a minimal working configuration for Keystone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you are using the same hostname and password as in this tutorial, no changes
    are required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, populate the `keystone` database by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Keystone uses tokens to authenticate and authorize users and services. There
    are different token formats available, such as UUID, PKI, and Fernet tokens. For
    this example deployment, we are going to use the Fernet tokens, which, unlike
    the other types, do not need to be persisted in a backend. To initialize the Fernet
    key repositories, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on the available identity tokens, refer to [http://docs.openstack.org/admin-guide/identity-tokens.html](http://docs.openstack.org/admin-guide/identity-tokens.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the basic bootstrap process by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to use Apache with the WSGI module to drive Keystone. Add the
    following stanza in the Apache config file and restart it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete the default SQLite database that Keystone ships with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create the administrative account by defining the following environment
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Time to create our first project in Keystone. Projects represent a unit of
    ownership, where all resources are owned by a project. The `service` project we
    are going to create next will be used by all the services we are going to deploy
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To list the available projects, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create an unprivileged project and user, which can be used by regular
    users instead of the OpenStack services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a `user` role, and associate it with the `lxc` project and the
    user we created in the previous two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following file to configure  the **Web Service Gateway Interface**
    (**WSGI**) middleware pipeline for Keystone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test the configuration so far, by requesting a token for the `admin`
    and the `lxc` users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create two files, which will contain the `admin` and `user` credentials
    we configured earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the `admin` user, for example, source the file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the new environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'With the admin credentials loaded, let''s request an authentication token that
    we can use later with the other OpenStack services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Installing and configuring the image service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The image service provides an API for users to discover, register, and obtain
    images for virtual machines, or images that can be used as the root filesystem
    for LXC containers. Glance supports multiple storage backends, but for simplicity
    we are going to use the file store that will keep the LXC image directly on the
    filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'To deploy Glance, first create a database and a user, like we did for Keystone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create the `glance` user and add it to the `admin` role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to create the `glance` service record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the Glance API endpoints in Keystone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'OpenStack supports multiregion deployments for achieving high availability;
    however, for simplicity, we are going to deploy all services in the same region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that Keystone knows about the `glance` service, let''s install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following two minimal configuration files, replacing the password and
    hostname as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Populate the `glance` database by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the Glance services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can build an image for the LXC containers by hand, as we saw in [Chapter
    2](ch02.html "Chapter 2. Installing and Running LXC on Linux Systems"), *Installing
    and Running LXC on Linux Systems*, or download a prebuilt image from an Ubuntu
    repository. Let''s download an image and extract it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The file that contains the root filesystem has the `.img` extension. Let''s
    add it to the image service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that LXC uses the `raw` disk and `bare` container formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'The image is now stored at the location defined in the `glance-api.conf` as
    the `filesystem_store_datadir` parameter, as we saw in the preceding configuration
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s list the available images in Glance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Installing and configuring the compute service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OpenStack compute service manages a pool of compute resources (servers)
    and various virtual machines, or containers running on said resources. It provides
    a scheduler service that takes a request for a new VM or container from the queue
    and decides on which compute host to create and start it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information on the various Nova services, refer to: [http://docs.openstack.org/developer/nova/](http://docs.openstack.org/developer/nova/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by creating the `nova` database and user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the database is created and the user permissions granted, create the `nova`
    user and add it to the `admin` role in the identity service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create the `nova` service and endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s time to install the Nova packages that will provide the API, the conductor,
    the console, and the scheduler services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The Nova packages we just installed provide the following services:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nova-api`: This service accepts and responds to user requests through a RESTful
    API. We use that for creating, running, and stopping instances, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nova-conductor`: This service sits between the `nova` database we created
    earlier and the `nova-compute` service, which runs on the compute nodes and creates
    the VMs and containers. We are going to install that service later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nova-consoleauth`: This service authorizes tokens for users that want to use
    various consoles to connect to the VMs or containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nova-novncproxy`: This service grants access to instances running VNC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nova-scheduler`: This service, as mentioned previously, makes decisions on
    where to provision a VM or LXC container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a minimal functioning Nova configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'With the config file in place, we can now populate the `nova` database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, start the compute services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Since we are going to use a single node for this OpenStack deployment, we need
    to install the `nova-compute` service. In production, we usually have a pool of
    compute servers that only run that service.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following minimal configuration file, which will allow running `nova-compute`
    and the rest of the Nova services on the same server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice under the `libvirt` section how we specify LXC as the default virtualization
    type we are going to use. To enable LXC support in Nova, install the following
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The package provides the following configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the `nova-compute` service and list all available Nova services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to verify that all four services are `enabled` and `up`. With all the
    Nova services configured and running, now it's time to move to the networking
    part of the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring the networking service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The networking component of OpenStack, codenamed Neutron, manages networks,
    IP addresses, software bridging, and routing. In the previous chapters, we had
    to create the Linux bridge, add ports to it, configure DHCP to assign IPs to the
    containers, and so on. Neutron exposes all of these functionalities through a
    convenient API and libraries that we can use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating the database, user, and permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create the `neutron` user and add it to the `admin` role in Keystone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `neutron` service and endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'With all the services and endpoints defined in the identity service, install
    the following packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The Neutron packages that we installed earlier provide the following services:'
  prefs: []
  type: TYPE_NORMAL
- en: '`neutron-server`: This package provides API to dynamically request and configure
    virtual networks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`neutron-plugin-ml2`: This is a framework that enables the use of various network
    technologies, such as the Linux bridge, Open vSwitch, GRE, and VXLAN, which we
    saw in earlier chapters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`neutron-linuxbridge-agent`: This provides the Linux bridge plugin agent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`neutron-l3-agent`: This performs forwarding and NAT functionality between
    software-defined networks by creating virtual routers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`neutron-dhcp-agent`: This controls the DHCP service that assigns IP addresses
    to the instances running on the compute nodes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`neutron-metadata-agent`: This is a service that passes instance metadata to
    Neutron'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a minimal working configuration file for Neutron:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to define what network extension we are going to support and the type
    of network. All this information is going to be used when creating the LXC container
    and its configuration file, as we''ll see later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the interface that will be added to the software bridge and that the
    IP the bridge will be bound to. In this case, we are using the `eth1` interface
    and its IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We specify the bridge driver for the L3 agent as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration file for the DHCP agent should look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the configuration for the metadata agent is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to update the configuration file for the Nova services. The new complete
    files should look as follows this; replace the IP address as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Populate the `neutron` database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, start all networking services and restart `nova-compute`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s verify the Neutron services are running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Defining the LXC instance flavor, generating a key pair, and creating security
    groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can create an LXC instance, we need to define its flavour - CPU,
    memory, and disk size. The following creates a flavor named `lxc.medium` with
    one virtual CPU, 1 GB RAM, and 5 GB disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to SSH to the LXC containers, we can have the SSH keys managed and
    installed during the instance provisioning, if we don''t want them to be baked
    inside the actual image. To generate the SSH key pair and add it to OpenStack,
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the file in which to save the key (`/root/.ssh/id_rsa`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'To list the new key pair we just added, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, once a new LXC container is provisioned, iptables will disallow
    access to it. Let''s create two security groups that will allow ICMP and SSH,
    so we can test connectivity and connect to the instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Creating the networks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new network called `nat` in Neutron:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, define the DNS server, the default gateway, and the subnet range that
    will be assigned to the LXC container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the subnet''s information in Neutron:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'As the `lxc` user, create a new software router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'As the admin user, add the subnet we created earlier as an interface to the
    router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s list the network namespaces that were created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'To show the ports on the software router and the default gateway for the LXC
    containers, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Provisioning LXC container with OpenStack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we launch our LXC container with OpenStack, let's double-check we have
    all the requirements in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by listing the available networks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Display the compute flavors we can choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, list the available images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, display the default security group we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Now load the **Network Block Device** (**NBD**) kernel module, as Nova expects
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to provision LXC container with OpenStack, we execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we specified the instance flavor, the image name, the ID of the network,
    the security group, the key-pair name, and the name of the instance.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to replace the IDs with the output returned on your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'To list the LXC container, its status, and assigned IP address, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'As we saw earlier in this chapter, OpenStack uses the libvirt driver to provision
    LXC containers. We can use the `virsh` command we used in [Chapter 2](ch02.html
    "Chapter 2. Installing and Running LXC on Linux Systems")*, Installing and Running
    LXC on Linux Systems*, to list the LXC containers on the host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'If we list the processes on the host, we can see that the `libvirt_lxc` parent
    process spawned the init process for the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The location of the container''s configuration file and disk is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s examine the container''s configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: We've seen similar configuration files for the libvirt containers we built in
    earlier chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the networking managed by Neutron, we should see the bridge and the container''s
    interface added as a port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s configure an IP address on the bridge interface and allow NAT connectivity
    to the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'To connect to the LXC container using SSH and the key pair we generated earlier,
    execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to delete the LXC container using OpenStack, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at an example of a basic OpenStack deployment using
    only the identity service Keystone for storing a catalog of services, and authentication
    and authorization, the Nova compute services for provisioning the LXC instance,
    the image service Glance, which stores the LXC container images, and the networking
    services with Neutron that created the bridge and assigned the IP address to our
    container.
  prefs: []
  type: TYPE_NORMAL
- en: A full production-ready deployment would consist of multiple controller nodes
    that run the aforementioned services, along with a pool of compute servers to
    provision the containers on.
  prefs: []
  type: TYPE_NORMAL
- en: OpenStack with LXC is a great way to create and manage multitenant cloud environments,
    running various software applications in a centralized and highly scalable way.
  prefs: []
  type: TYPE_NORMAL
