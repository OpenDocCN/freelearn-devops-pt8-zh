<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer230">
<h1 class="chapter-number" id="_idParaDest-103"><a id="_idTextAnchor103"/>8</h1>
<h1 id="_idParaDest-104"><a id="_idTextAnchor104"/>Provisioning Infrastructure Using Infrastructure as Code</h1>
<p>Previously we covered CI/CD topics related to building, testing, packaging, and deploying applications. In this chapter, we will learn how to provision and configure the destination where deployment will be taking place using automation, the benefits of such a process, and a few tips and tricks while we’re at it. You will understand why this is important, and even required, in these times when we need to deliver fast and <span class="No-Break">with quality.</span></p>
<p>In this chapter, we will dive into this by covering the <span class="No-Break">following topics:</span></p>
<ul>
<li>Understanding <strong class="bold">Infrastructure as </strong><span class="No-Break"><strong class="bold">Code</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">IaC</strong></span><span class="No-Break">)</span></li>
<li>Working with <strong class="bold">Azure Resource Manager</strong> (<span class="No-Break"><strong class="bold">ARM</strong></span><span class="No-Break">) </span><span class="No-Break"><strong class="bold">templates</strong></span></li>
<li>Working with <span class="No-Break"><strong class="bold">AWS CloudFormation</strong></span></li>
<li>Working <span class="No-Break">with </span><span class="No-Break"><strong class="bold">Terraform</strong></span></li>
</ul>
<p>Let’s take care of the technical <span class="No-Break">requirements first.</span></p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor105"/>Technical requirements</h1>
<p>Depending on which section you are interested in completing in this chapter, you will need the following software installed on your workstation. You will find the code for this chapter in the GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines/tree/main/ch08"><span class="No-Break">https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines/tree/main/ch08</span></a><span class="No-Break">.</span></p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor106"/>Installing Azure tools</h2>
<p>The Azure CLI<a id="_idIndexMarker333"/> is a cross-platform <a id="_idIndexMarker334"/>command-line tool to connect to Microsoft Azure and execute commands to create, update, or destroy resources. Depending on the <strong class="bold">operating system</strong> (<strong class="bold">OS</strong>) of your workstation, you can choose <a id="_idIndexMarker335"/>the appropriate installation method at <a href="https://learn.microsoft.com/en-us/cli/azure/install-azure-cli">https://learn.microsoft.com/en-us/cli/azure/install-azure-cli</a>. Since the instructions for each OS are different, it’s up to you to complete <span class="No-Break">the installation.</span></p>
<p>Once installed, run the <strong class="source-inline">az version</strong> command and you’ll see a response <span class="No-Break">like this:</span></p>
<pre class="console">
PS C:\Users\user&gt; az version
{
  "azure-cli": "2.48.1",
  "azure-cli-core": "2.48.1",
  "azure-cli-telemetry": "1.0.8",
  "extensions": {}
}</pre> <p>You can choose any text editor<a id="_idIndexMarker336"/> you wish to work with. However, we recommend <strong class="bold">Visual Studio Code</strong> (<strong class="bold">VS Code</strong> for short), as it is one of the most popular editors in the<a id="_idIndexMarker337"/> community; it’s free and provides a large number of community-supported extensions for many programming languages and<a id="_idIndexMarker338"/> other tools, especially supporting <strong class="bold">ARM templates</strong>, <strong class="bold">AWS CloudFormation</strong>, and <strong class="bold">Terraform</strong>, as we will <a id="_idIndexMarker339"/>see in the <span class="No-Break">following sections.</span></p>
<p>To install VS Code, proceed<a id="_idIndexMarker340"/> to <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>. From there, you will see options to install it based on your <span class="No-Break">workstation’s OS.</span></p>
<p>Additionally, you must install <a id="_idIndexMarker341"/>the ARM Tools VS Code extension <span class="No-Break">from </span><a href="https://marketplace.visualstudio.com/items?itemName=msazurermtools.azurerm-vscode-tools"><span class="No-Break">https://marketplace.visualstudio.com/items?itemName=msazurermtools.azurerm-vscode-tools</span></a><span class="No-Break">.</span></p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor107"/>Installing AWS tools</h2>
<p>The AWS CLI is a<a id="_idIndexMarker342"/> cross-platform command-line tool to connect to <strong class="bold">Amazon Web Services</strong> (<strong class="bold">AWS</strong>) and <a id="_idIndexMarker343"/>execute commands to create, update, or destroy resources. Instructions to install it based on your OS can be found <span class="No-Break">at </span><a href="https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.xhtml"><span class="No-Break">https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.xhtml</span></a><span class="No-Break">.</span></p>
<p>Once installed, run the <strong class="source-inline">aws --version</strong> command in a shell and you’ll see a response <span class="No-Break">like this:</span></p>
<pre class="console">
PS C:\Users\user&gt; aws --version
aws-cli/2.11.18 Python/3.11.3 Windows/10 exe/AMD64 prompt/off</pre> <p>Additionally, you must install <a id="_idIndexMarker344"/>the <strong class="bold">AWS Toolkit</strong> VS Code extension <span class="No-Break">from</span><span class="No-Break"><strong class="bold"> </strong></span><a href="https://marketplace.visualstudio.com/items?itemName=AmazonWebServices.aws-toolkit-vscode"><span class="No-Break">https://marketplace.visualstudio.com/items?itemName=AmazonWebServices.aws-toolkit-vscode</span></a><span class="No-Break">.</span></p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor108"/>Installing Terraform tools</h2>
<p>The Terraform CLI<a id="_idIndexMarker345"/> is a cross-platform<a id="_idIndexMarker346"/> command-line tool to execute a variety of subcommands such as <strong class="source-inline">plan</strong>, <strong class="source-inline">apply</strong>, or <strong class="source-inline">destroy</strong>, which we will cover later in this chapter. You can install it using the instructions provided at <a href="https://developer.hashicorp.com/terraform/tutorials/azure-get-started/install-cli#install-terraform">https://developer.hashicorp.com/terraform/tutorials/azure-get-started/install-cli#install-terraform</a>. Once installed, run <strong class="source-inline">terraform version</strong> in a shell and you’ll see a response like <span class="No-Break">the following:</span></p>
<pre class="console">
PS C:\Users\user&gt; terraform version
Terraform v1.4.6
on windows_amd64</pre> <p>Additionally, you can install the HashiCorp Terraform VS Code extension<a id="_idIndexMarker347"/> <span class="No-Break">from </span><a href="https://marketplace.visualstudio.com/items?itemName=HashiCorp.terraform"><span class="No-Break">https://marketplace.visualstudio.com/items?itemName=HashiCorp.terraform</span></a><span class="No-Break">.</span></p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor109"/>Installing the Terraform Marketplace extension</h2>
<p>The <strong class="bold">Terraform Marketplace extension</strong> for Azure <a id="_idIndexMarker348"/>DevOps must be installed. You can find it <span class="No-Break">at </span><a href="https://marketplace.visualstudio.com/items?itemName=ms-devlabs.custom-terraform-tasks"><span class="No-Break">https://marketplace.visualstudio.com/items?itemName=ms-devlabs.custom-terraform-tasks</span></a><span class="No-Break">.</span></p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor110"/>Access to an Azure account</h2>
<p>You must have access to an <a id="_idIndexMarker349"/>Azure account to complete the steps in this chapter. If you don’t have one, you can create a free one <span class="No-Break">at </span><a href="https://azure.microsoft.com/en-us/free/"><span class="No-Break">https://azure.microsoft.com/en-us/free/</span></a><span class="No-Break">.</span></p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor111"/>Access to an AWS account</h2>
<p>You must have access to an <a id="_idIndexMarker350"/>AWS account to complete the steps in this chapter. If you don’t have one, you can create a free one <span class="No-Break">at </span><a href="https://aws.amazon.com/free"><span class="No-Break">https://aws.amazon.com/free</span></a><span class="No-Break">.</span></p>
<p>Now that we have taken care of all the technical requirements, let’s walk through what it means to automate infrastructure <span class="No-Break">using code.</span></p>
<h1 id="_idParaDest-112"><a id="_idTextAnchor112"/>Understanding IaC</h1>
<p>In the past, infrastructure was typically provisioned and configured manually with manually documented steps and/or a combination of scripts. This made the whole process error-prone <span class="No-Break">and slow.</span></p>
<p>In the same way that you use a rigorous process for your application code, you should practice that for your infrastructure. The purpose of this approach is to make deployments repeatable and immutable, reduce the chances of error, and accelerate the deployment process by avoiding/eliminating any human interaction <span class="No-Break">whenever possible.</span></p>
<p>IaC is the <a id="_idIndexMarker351"/>practice of codifying and storing in source control a descriptive model that defines and deploys all the infrastructure needed to run your applications and any supporting dependencies. It can encompass network configuration, load balancers, virtual machines, and any other application or data services your application architecture requires to operate and is applicable to on-premises data centers and cloud <span class="No-Break">provider platforms.</span></p>
<p>The best way to picture all this working together is <span class="No-Break">as follows:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer213">
<img alt="Figure 8.1 – CI/CD incorporating IaC" height="776" src="image/B18875_08_1.jpg" width="1629"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – CI/CD incorporating IaC</p>
<p>Let’s jump into working with ARM templates now and see how we can do this on the Microsoft Azure <span class="No-Break">cloud platform.</span></p>
<h1 id="_idParaDest-113"><a id="_idTextAnchor113"/>Working with ARM templates</h1>
<p>ARM templates are one of the IaC options available to<a id="_idIndexMarker352"/> deploy infrastructure in Azure, Microsoft’s cloud platform available in many regions around <span class="No-Break">the world.</span></p>
<p>Microsoft also provides other tools such as the Azure CLI, Azure PowerShell, and a newer, domain-specific language called Bicep that uses a declarative syntax to deploy resources. You can also use the Azure portal, a web-based UI that provides access to all your resources in Azure and the ability to create, update, and <span class="No-Break">delete resources.</span></p>
<p>ARM templates are JSON files with the <span class="No-Break">following structure:</span></p>
<pre class="source-code">
{
  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
  "contentVersion": "",
  "apiProfile": "",
  "parameters": {  },
  "variables": {  },
  "functions": [  ],
  "resources": [  ],
  "outputs": {  }
}</pre> <p>ARM templates <a id="_idIndexMarker353"/>can define required and optional input <strong class="bold">parameters</strong>, <strong class="bold">variables</strong> that can be calculated for use within the template, user-defined <strong class="bold">functions</strong> that you can use within the template in addition to built-in ones, <strong class="bold">resources</strong> that define all properties to configure for one or more resources, and <strong class="bold">outputs</strong> that can contain properties or values calculated from the deployed resources. ARM templates can also be nested to logically separate <span class="No-Break">your services.</span></p>
<p>In this section, we will focus on how to deploy ARM templates using Azure Pipelines, without getting into the details of how to create them, as that is outside the scope of <span class="No-Break">this book.</span></p>
<p>Deploying <a id="_idIndexMarker354"/>ARM templates comes down to the <span class="No-Break">following steps:</span></p>
<ol>
<li>Creating a service principal <span class="No-Break">in Azure</span></li>
<li>Creating a service connection <span class="No-Break">to Azure</span></li>
<li>Creating an <span class="No-Break">ARM template</span></li>
<li>Validating the <span class="No-Break">ARM template</span></li>
<li>Deploying the <span class="No-Break">ARM template</span></li>
</ol>
<p>Let’s start by creating a service principal <span class="No-Break">in Azure.</span></p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor114"/>Creating a service principal in Azure</h2>
<p>A <strong class="bold">service principal</strong> is <a id="_idIndexMarker355"/>a type of identity in Azure used by applications, services, and automation tools to provide fine-grained control <a id="_idIndexMarker356"/>to access resources <a id="_idIndexMarker357"/>and perform actions based <span class="No-Break">on roles.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">This section assumes that you are logged in to Azure using the <strong class="source-inline">az </strong><span class="No-Break"><strong class="source-inline">login</strong></span><span class="No-Break"> command.</span></p>
<p>We can create a service principal with the following Azure <span class="No-Break">CLI command:</span></p>
<pre class="console">
az ad sp create-for-rbac -n azure-pipelines --role Contributor --scopes /subscriptions/&lt;subscription-id&gt;</pre> <p>You would replace <strong class="source-inline">&lt;subscription-id&gt;</strong>, which should be a GUID-like value from the Azure portal. Setting the scope at the subscription level is fine for testing purposes, but in your ideal setup, you will want to restrict it further – say, to a <span class="No-Break">resource group:</span></p>
<pre class="console">
/subscriptions/&lt;subscription-id&gt;/resourceGroups/&lt;name&gt;</pre> <p>Once you execute this command, you should get a response similar to <span class="No-Break">the following:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer214">
<img alt="Figure 8.2 – Service principal details" height="114" src="image/B18875_08_2.jpg" width="522"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Service principal details</p>
<p>You must handle the service principal details as a secret. This is sensitive information that provides access to your Azure environment. You will need this for the <span class="No-Break">next steps.</span></p>
<p>Now let’s see how to create the service connection to Azure using the <span class="No-Break">service principal.</span></p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor115"/>Creating a service connection to Azure</h2>
<p>As seen in previous <a id="_idIndexMarker358"/>chapters, integrating with external services in <a id="_idIndexMarker359"/>Azure Pipelines requires a service connection. This can be done by following <span class="No-Break">these steps:</span></p>
<ol>
<li>Navigate to <strong class="bold">Project Settings</strong> | <strong class="bold">Pipelines </strong>| <strong class="bold">Service connections</strong>, where you will click on the <strong class="bold">New service </strong><span class="No-Break"><strong class="bold">connection</strong></span><span class="No-Break"> button:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer215">
<img alt="Figure 8.3 – New service connection" height="211" src="image/B18875_08_3.jpg" width="622"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – New service connection</p>
<ol>
<li value="2">From here, you <a id="_idIndexMarker360"/>will select the <strong class="bold">Azure Resource Manager</strong> option<a id="_idIndexMarker361"/> and click the <span class="No-Break"><strong class="bold">Next</strong></span><span class="No-Break"> button:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer216">
<img alt="Figure 8.4 – Selecting the service connection type" height="276" src="image/B18875_08_4.jpg" width="473"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – Selecting the service connection type</p>
<ol>
<li value="3">Next, select an authentication method, using the <strong class="bold">Service principal (manual)</strong> option, and click the <span class="No-Break"><strong class="bold">Next</strong></span><span class="No-Break"> button:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer217">
<img alt="Figure 8.5 – Select an authentication method for the Azure service connection" height="338" src="image/B18875_08_5.jpg" width="448"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – Select an authentication method for the Azure service connection</p>
<p class="list-inset">Although the <a id="_idIndexMarker362"/>preceding screenshot shows <strong class="bold">Service principal (automatic)</strong> as <strong class="bold">Recommended</strong>, this is only from the standpoint of a<a id="_idIndexMarker363"/> user just getting started with Azure and Azure Pipelines. When you have many Azure subscriptions and resource groups, that authentication method makes it difficult to complete <span class="No-Break">the setup.</span></p>
<ol>
<li value="4">The next step allows you to enter the details for the <span class="No-Break">following parameters:</span><ul><li><strong class="bold">Subscription Id</strong>: You can obtain this from the <span class="No-Break">Azure portal</span></li><li><strong class="bold">Subscription Name</strong>: Also obtained from the <span class="No-Break">Azure portal</span></li><li><strong class="bold">Service Principal Id</strong>: <strong class="source-inline">appId</strong> from the previous section, as shown in <span class="No-Break"><em class="italic">Figure 8.2</em></span></li><li><strong class="bold">Service principal key</strong>: <strong class="source-inline">password</strong> from the previous section, as shown in <span class="No-Break"><em class="italic">Figure 8.2</em></span></li><li><strong class="bold">Tenant ID</strong>: <strong class="source-inline">tenant</strong> from the previous section, as shown in <span class="No-Break"><em class="italic">Figure 8.2</em></span></li><li><strong class="bold">Service connection name</strong>: <span class="No-Break">Use </span><span class="No-Break"><strong class="source-inline">azure-packt-rg</strong></span></li></ul><p class="list-inset">Once you have entered all these values, you have the option to click on the <strong class="bold">Verify and save</strong> button, which will test that a connection to Azure can be established and <a id="_idIndexMarker364"/>store the service <span class="No-Break">connection </span><span class="No-Break"><a id="_idIndexMarker365"/></span><span class="No-Break">details.</span></p></li>
</ol>
<p>Now that we have a service connection, let’s move on to creating an <span class="No-Break">ARM template.</span></p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor116"/>Creating an ARM template</h2>
<p>There are many ways to <a id="_idIndexMarker366"/>create <span class="No-Break">ARM templates:</span></p>
<ul>
<li>From scratch, by<a id="_idIndexMarker367"/> following the reference documentation <span class="No-Break">at </span><a href="https://learn.microsoft.com/en-us/azure/azure-resource-manager/templates/quickstart-create-templates-use-visual-studio-code"><span class="No-Break">https://learn.microsoft.com/en-us/azure/azure-resource-manager/templates/quickstart-create-templates-use-visual-studio-code</span></a></li>
<li>From the Azure portal, by downloading a template before deployment from the Marketplace or an existing resource group, as described <span class="No-Break">at </span><a href="https://learn.microsoft.com/en-us/azure/azure-resource-manager/templates/export-template-portal"><span class="No-Break">https://learn.microsoft.com/en-us/azure/azure-resource-manager/templates/export-template-portal</span></a></li>
<li>Modifying an existing sample template <span class="No-Break">at </span><a href="https://learn.microsoft.com/en-us/samples/browse/?expanded=azure&amp;products=azure-resource-manager"><span class="No-Break">https://learn.microsoft.com/en-us/samples/browse/?expanded=azure&amp;products=azure-resource-manager</span></a></li>
</ul>
<p>In this chapter, for simplicity, we will use a modified version of an existing sample that deploys an Azure App Service resource. You can find the template <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines/blob/main/ch08/azure/azuredeploy.json"><span class="No-Break">https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines/blob/main/ch08/azure/azuredeploy.json</span></a></p>
<p>This ARM template will deploy <span class="No-Break">two resources:</span></p>
<ul>
<li>An <strong class="bold">Azure App Service plan</strong>, which <a id="_idIndexMarker368"/>defines the pricing tier, OS, and other <span class="No-Break">platform-level capabilities</span></li>
<li>An <strong class="bold">Azure App Service web app</strong>, which <a id="_idIndexMarker369"/>defines the application-level stack, such as the PHP runtime <span class="No-Break">and version</span></li>
</ul>
<p>Now let’s see how we can validate this template using <span class="No-Break">Azure Pipelines.</span></p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor117"/>Validating the ARM template</h2>
<p>In your build or CI <a id="_idIndexMarker370"/>pipelines, you should consider validating your templates to ensure the format is correct. For this purpose, the <strong class="bold">ARM</strong> template deployment task is available, as shown in the following <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
# ARM Template Validation
trigger:
- main
pool:
  vmImage: ubuntu-latest
steps:
- task: AzureResourceManagerTemplateDeployment@3
  inputs:
    deploymentScope: 'Resource Group'
    azureResourceManagerConnection: 'azure-packt-rg'
    subscriptionId: $(AzureSubscriptionId)
    action: 'Create Or Update Resource Group'
    resourceGroupName: 'packt'
    location: 'East US'
    templateLocation: 'Linked artifact'
    csmFile: 'azure/azuredeploy.json'
    deploymentMode: 'Validation'</pre> <p class="callout-heading">Important note</p>
<p class="callout">YAML is a very strict language that is whitespace-sensitive and case-sensitive. When working with YAML files, make sure that you are using an editor that properly handles these requirements and make sure you are aware of any issues when formatting <span class="No-Break">the content.</span></p>
<p>Let’s break this down to the <span class="No-Break">different parameters:</span></p>
<ul>
<li><strong class="source-inline">deploymentScope</strong> dictates the layer to which this will be applied. Possible values are <strong class="source-inline">Management Group</strong>, <strong class="source-inline">Resource Group</strong>, and <strong class="source-inline">Subscription</strong>. These are different types of governance layers within the Azure platform and the templates follow <span class="No-Break">different schemas.</span></li>
<li><strong class="source-inline">azureResourceManagerConnection</strong> is a reference to an existing service connection of type <strong class="source-inline">Azure </strong><span class="No-Break"><strong class="source-inline">Resource Manager</strong></span><span class="No-Break">.</span></li>
<li><strong class="source-inline">subscriptionId</strong> is the GUID value for the Azure subscription ID. In this case, you can see it as being a<a id="_idIndexMarker371"/> reference from a variable using the <strong class="source-inline">$(AzureSubscriptionId)</strong> notation. We will see how to create this in the next section, <em class="italic">Creating a </em><span class="No-Break"><em class="italic">pipeline variable</em></span><span class="No-Break">.</span></li>
<li><strong class="source-inline">action</strong> indicates whether a resource group will be created, updated, <span class="No-Break">or deleted.</span></li>
<li><strong class="source-inline">resourceGroupName</strong> is the name of the resource group in the Azure target for the deployment. If the action is set to <strong class="source-inline">create</strong> or <strong class="source-inline">update</strong> and the resource group does not exist, it will be created by <span class="No-Break">the task.</span></li>
<li><strong class="source-inline">location</strong> is any of the existing Azure regions available <span class="No-Break">for deployment.</span></li>
<li><strong class="source-inline">templateLocation</strong> indicates whether the ARM template file will be available as <strong class="source-inline">Linked artifact</strong> or <strong class="source-inline">URL of the file</strong>. In the latter case, it must be a fully <span class="No-Break">qualified URL.</span></li>
<li><strong class="source-inline">csmFile</strong> is the path to the ARM template file, required when <strong class="source-inline">templateLocation = 'Linked artifact'</strong> is set. Otherwise, you would <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">csmFileLink</strong></span><span class="No-Break">.</span></li>
<li>Finally, <strong class="source-inline">deploymentMode</strong> indicates <a id="_idIndexMarker372"/>how to treat the deployment. In this case, the <strong class="source-inline">Validation</strong> value will only perform validation of the file format. We will talk about the other values this accepts in the <span class="No-Break">next section.</span></li>
</ul>
<h2 id="_idParaDest-118"><a id="_idTextAnchor118"/>Creating a pipeline variable</h2>
<p>To create the variable used in<a id="_idIndexMarker373"/> this task, perform the <span class="No-Break">following tasks:</span></p>
<ol>
<li>Click on the <strong class="bold">Variables</strong> button on the Azure Pipelines <span class="No-Break">edit screen:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer218">
<img alt="Figure 8.6 – Accessing pipeline variables" height="643" src="image/B18875_08_6.jpg" width="905"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – Accessing pipeline variables</p>
<ol>
<li value="2">Click on the <strong class="bold">New variable</strong> button to define your <span class="No-Break">first variable:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer219">
<img alt="Figure 8.7 – Adding a new variable" height="800" src="image/B18875_08_7.jpg" width="1047"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – Adding a new variable</p>
<ol>
<li value="3">You then proceed<a id="_idIndexMarker374"/> to fill in <strong class="bold">Name</strong> and <strong class="bold">Value</strong>. In our case, this is <strong class="source-inline">AzureSubscriptionId</strong> and the subscription ID you obtained from the Azure portal, respectively. Also make sure to check the <strong class="bold">Keep this value secret</strong> option, to store it securely and make it impossible for it to be visible during pipeline execution. Clicking <strong class="bold">OK</strong> on this screen stores the <span class="No-Break">value temporarily:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer220">
<img alt="Figure 8.8 – New variable with secret value" height="662" src="image/B18875_08_8.jpg" width="464"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 – New variable with secret value</p>
<ol>
<li value="4">You must click <strong class="bold">Save</strong> on the<a id="_idIndexMarker375"/> next screen to ensure the variable is stored in <span class="No-Break">the pipeline:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer221">
<img alt="Figure 8.9 – Saving pipeline variables" height="856" src="image/B18875_08_9.jpg" width="1065"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.9 – Saving pipeline variables</p>
<p>Once you have all of<a id="_idIndexMarker376"/> this in place, the pipeline should run and validate the ARM <span class="No-Break">template successfully.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">When deploying ARM templates for the first time, you must ensure that the corresponding Azure resource providers have been registered in the subscription or you will get an error. For the template used in this section, you must have the <strong class="source-inline">Microsoft.Web</strong> resource provider registered. You can accomplish this by running the following Azure CLI command and waiting for it <span class="No-Break">to complete:</span></p>
<p class="callout"><strong class="source-inline">az provider register –namespace </strong><span class="No-Break"><strong class="source-inline">Microsoft.Web --wait</strong></span></p>
<p>Now that we have learned how to validate the template, let’s see how to <span class="No-Break">deploy it.</span></p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor119"/>Deploying ARM templates</h2>
<p>Switching from validation to <a id="_idIndexMarker377"/>deployment requires changing the value of the <strong class="source-inline">deploymentMode</strong> property to either <strong class="source-inline">Incremental</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">Complete</strong></span><span class="No-Break">.</span></p>
<p>The <strong class="source-inline">Incremental</strong> deployment mode tells ARM that the resources in the template will be created if they don’t exist or updated to match the template if already present. Any other resources in the resource group not defined in the template will <span class="No-Break">be ignored.</span></p>
<p>Likewise, if the <strong class="source-inline">Complete</strong> deployment mode is used, ARM will ensure that the resource group only contains the resources defined in the template, create those that don’t exist, update the existing ones to match, and delete any not defined in <span class="No-Break">the template.</span></p>
<p>Here is what that <span class="No-Break">looks like:</span></p>
<pre class="source-code">
# ARM Template Deployment
trigger:
- main
pool:
  vmImage: ubuntu-latest
steps:
- task: AzureResourceManagerTemplateDeployment@3
  inputs:
    deploymentScope: 'Resource Group'
    azureResourceManagerConnection: 'azure-packt-rg'
    subscriptionId: $(AzureSubscriptionId)
    action: 'Create Or Update Resource Group'
    resourceGroupName: 'packt'
    location: 'East US'
    templateLocation: 'Linked artifact'
    csmFile: 'azure/azuredeploy.json'
    deploymentMode: 'Incremental'</pre> <p class="callout-heading">Important note</p>
<p class="callout">The <strong class="source-inline">Complete</strong> deployment mode must be used with caution, and ensure you have a rigorous process where resources are only being created via templates. Otherwise, you could have destructive results that you were not expecting, such as services or applications not working anymore or loss <span class="No-Break">of data.</span></p>
<p>Once the pipeline has <a id="_idIndexMarker378"/>been executed, you can validate the resources in the <span class="No-Break">Azure portal:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer222">
<img alt="Figure 8.10 – Azure resources deployed via Azure Pipelines" height="527" src="image/B18875_08_10.jpg" width="1033"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.10 – Azure resources deployed via Azure Pipelines</p>
<p>If you want to learn more, head to <a href="https://aka.ms/arm-syntax">https://aka.ms/arm-syntax</a>. Now let’s see how we can do something similar <span class="No-Break">in AWS.</span></p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor120"/>Working with AWS CloudFormation</h1>
<p><strong class="bold">AWS Cloud Formation</strong> is <a id="_idIndexMarker379"/>a service that allows you to define a template that describes a set of resources to be deployed together using JSON or YAML syntax. The templates follow this structure in the <span class="No-Break">JSON format:</span></p>
<pre class="source-code">
{
  "AWSTemplateFormatVersion" : "version date",
  "Description" : "JSON string",
  "Metadata" : { template metadata },
  "Parameters" : { set of parameters },
  "Rules" : { set of rules },
  "Mappings" : { set of mappings },
  "Conditions" : { set of conditions },
  "Transform" : { set of transforms },
  "Resources" : { set of resources },
  "Outputs" : { set of outputs }
}</pre> <p>Deploying with<a id="_idIndexMarker380"/> AWS CloudFormation comes down to the <span class="No-Break">following steps:</span></p>
<ol>
<li>Creating an IAM user with the <span class="No-Break">AWS CLI</span></li>
<li>Creating a service connection <span class="No-Break">to AWS</span></li>
<li>Creating an AWS <span class="No-Break">CloudFormation template</span></li>
<li>Validating the AWS <span class="No-Break">CloudFormation template</span></li>
<li>Deploying the AWS <span class="No-Break">CloudFormation template</span></li>
</ol>
<p>Let’s start with discussing how to create an <span class="No-Break">IAM user.</span></p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor121"/>Creating an IAM user with the AWS CLI</h2>
<p>An <strong class="bold">IAM user</strong> is <a id="_idIndexMarker381"/>a user defined in the <strong class="bold">Identity and Access Management</strong> (<strong class="bold">IAM</strong>) service<a id="_idIndexMarker382"/> in AWS and provides fine-grained access control to create, update, or delete resources in AWS, but is<a id="_idIndexMarker383"/> also <a id="_idIndexMarker384"/>used to grant/deny permissions to interact with <span class="No-Break">other services.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">This section assumes you have already configured your AWS credentials using the <strong class="source-inline">aws </strong><span class="No-Break"><strong class="source-inline">configure</strong></span><span class="No-Break"> command.</span></p>
<p>Execute the <span class="No-Break">following commands:</span></p>
<pre class="source-code">
aws iam create-group --group-name resources-admin
aws iam attach-group-policy<a id="_idTextAnchor122"/> --group-name resources-admin --policy-arn arn:aws:iam::aws:policy/AdministratorAccess
aws iam create-user --user-name azure-pipelines
aws iam add-user-to-group --group-name resources-admin --user-name azure-pipelines
aws iam create-access-key --user-name azure-pipelines</pre> <p>These commands will do <span class="No-Break">the following:</span></p>
<ol>
<li>Create a user group <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">resources-admin</strong></span></li>
<li>Attach a security policy to the <span class="No-Break">user group</span></li>
<li>Create a user <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">azure-pipelines</strong></span></li>
<li>Add the <strong class="source-inline">azure-pipelines</strong> user to the <strong class="source-inline">resources-admin</strong> <span class="No-Break">user group</span></li>
<li>Create access keys for the <span class="No-Break"><strong class="source-inline">azure-pipelines</strong></span><span class="No-Break"> user</span></li>
</ol>
<p>After executing these commands, you should have an output like that shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer223">
<img alt="Figure 8.11 – AWS access keys for the azure-pipelines user" height="177" src="image/B18875_08_11.jpg" width="633"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.11 – AWS access keys for the azure-pipelines user</p>
<p>The <strong class="source-inline">AccessKeyId</strong> and <strong class="source-inline">SecretAccessKey</strong> values will be needed in the next step. Make sure<a id="_idIndexMarker385"/> to save them in a secure place as they provide<a id="_idIndexMarker386"/> programmatic access <span class="No-Break">to AWS.</span></p>
<p class="callout-heading">Important</p>
<p class="callout">The <strong class="source-inline">arn:aws:iam::aws:policy/AdministratorAccess</strong> policy used in this step is very permissive. It provides the highest level of access to the AWS console. This is not recommended for your environments. Instead, you should always provide access following a least-privilege approach and add more permissions <span class="No-Break">when needed.</span></p>
<p>Let’s now see how we create a service connection from Azure Pipelines <span class="No-Break">to AWS.</span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor123"/>Creating a service connection to AWS</h2>
<p>As seen in previous <a id="_idIndexMarker387"/>chapters, integrating with external services in <a id="_idIndexMarker388"/>Azure Pipelines requires a service connection, which is done within <strong class="bold">Project Settings</strong> | <strong class="bold">Pipelines</strong> | <strong class="bold">Service connections</strong>, where you will click on the <strong class="bold">New service connection</strong> button and select the <span class="No-Break"><strong class="bold">AWS</strong></span><span class="No-Break"> option:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer224">
<img alt="Figure 8.12 – AWS service connection type" height="222" src="image/B18875_08_12.jpg" width="474"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.12 – AWS service connection type</p>
<p>The next step allows you to enter the <span class="No-Break">following details:</span></p>
<ul>
<li><strong class="bold">Access Key ID</strong>: Use <strong class="source-inline">the AccessKeyId value</strong> from the <span class="No-Break">previous step</span></li>
<li><strong class="bold">Secret Access Key</strong>: Use <strong class="source-inline">the SecretAccessKey value</strong> from <a id="_idIndexMarker389"/>the <a id="_idIndexMarker390"/><span class="No-Break">previous step</span></li>
<li><strong class="bold">Service connection name</strong>: <span class="No-Break">Use </span><span class="No-Break"><strong class="source-inline">aws-packt</strong></span></li>
</ul>
<p>Now that we have a service connection, let’s proceed to define the AWS <span class="No-Break">CloudFormation template.</span></p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor124"/>Creating an AWS CloudFormation template</h2>
<p>You can create these templates<a id="_idIndexMarker391"/> from scratch following the reference documentation. Start from a sample template or use AWS CloudFormation Designer, a graphical tool that helps you create, visualize, and modify a template without worrying about all the formatting aspects. To learn more, go <span class="No-Break">to </span><a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-guide.xhtml"><span class="No-Break">https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-guide.xhtml</span></a><span class="No-Break">.</span></p>
<p>In this chapter, we will use a modified version of an<a id="_idIndexMarker392"/> existing sample that deploys a virtual machine using the <strong class="bold">Elastic Compute Cloud</strong> (<strong class="bold">EC2</strong>) service. You can find the template <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines/blob/main/ch08/aws/template.json"><span class="No-Break">https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines/blob/main/ch08/aws/template.json</span></a><span class="No-Break">:</span></p>
<ul>
<li>An EC2 key pair – a set of security credentials used to connect to <span class="No-Break">Linux instances</span></li>
<li>An<a id="_idIndexMarker393"/> EC2 instance, which depends on the key pair and uses an Amazon Linux OS <span class="No-Break">base image</span></li>
</ul>
<p>Now let’s see how we can validate <span class="No-Break">the template.</span></p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor125"/>Validating the AWS CloudFormation template</h2>
<p>In your build or CI pipelines, you should<a id="_idIndexMarker394"/> consider validating your templates to ensure the format is correct. For this purpose, the AWS CLI task <span class="No-Break">is available:</span></p>
<pre class="source-code">
# AWS Cloud Formation Validation
trigger:
- main
pool:
  vmImage: ubuntu-latest
steps:
- task: AWSCLI@1
  inputs:
    awsCredentials: 'aws-packt'
    regionName: 'us-east-1'
    awsCommand: 'cloudformation'
    awsSubCommand: 'validate-template'
    awsArguments: '--template-body file://template.json'</pre> <p>Let’s break down the parameters in <span class="No-Break">the code:</span></p>
<ul>
<li><strong class="source-inline">awsCredentials</strong> is a reference to the <span class="No-Break">service connection.</span></li>
<li><strong class="source-inline">regionName</strong> is any of the available AWS Regions. Typically, you want to set this to the same region where the template would be deployed, to ensure it validates correctly based on the availability of services in <span class="No-Break">that region.</span></li>
<li><strong class="source-inline">awsCommand</strong> is the top-level command in the AWS CLI that provides AWS <span class="No-Break">CloudFormation operations.</span></li>
<li><strong class="source-inline">awsSubcommand</strong> indicates that you want to perform a <span class="No-Break">template validation.</span></li>
<li><strong class="source-inline">awsArguments</strong> includes the options needed for the template validation to be completed. In this case, since the file was placed in the root folder of the repository, the template body is provided by passing the <strong class="source-inline">file:</strong> operator to read the contents of the file and perform <span class="No-Break">the validation.</span></li>
</ul>
<p>Once executed, the<a id="_idIndexMarker395"/> validation should show a message like that shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer225">
<img alt="Figure 8.13 – AWS CloudFormation template successful validation" height="578" src="image/B18875_08_13.jpg" width="679"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.13 – AWS CloudFormation template successful validation</p>
<p>If there were an error, you <a id="_idIndexMarker396"/>would see a different message and task failure, as shown in the following screenshot, where a resource type was <span class="No-Break">purposely mistyped:</span></p>
<pre class="console">
An error occurred (ValidationError) when calling the ValidateTemplate operation: Template format error: Unrecognized resource types: [AWS::EC2::KeyXXXPair]</pre> <p>Now that we know how to validate the template, let’s see how to <span class="No-Break">deploy it.</span></p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor126"/>Deploying the AWS CloudFormation template</h2>
<p>Deploying the AWS CloudFormation<a id="_idIndexMarker397"/> template is known as creating an <strong class="bold">AWS CloudFormation stack</strong>, which is a service in AWS that allows you to group all resources in the template logically and has some additional benefits such as tracking drift, implementing a rollback strategy in case of errors, and the ability to delete the stack and all <span class="No-Break">related resources.</span></p>
<p>In Azure Pipelines, you have two options to deploy <span class="No-Break">the template:</span></p>
<ul>
<li>An AWS CLI task with the <strong class="source-inline">aws cloudformation </strong><span class="No-Break"><strong class="source-inline">create-stack</strong></span><span class="No-Break"> command</span></li>
<li>Using the <strong class="source-inline">Cloud Formation Create or Update Stack</strong> task, as shown in this <span class="No-Break">code block:</span><pre class="source-code">
# AWS Cloud Formation Deployment
trigger:
- main
pool:
  vmImage: ubuntu-latest
steps:
- task: CloudFormationCreateOrUpdateStack@1
  inputs:
    awsCredentials: 'aws-packt'
    regionName: 'us-east-1'
    stackName: 'packt'
    templateSource: 'file'
    templateFile: 'template.json'
    capabilityIAM: false
    capabilityNamedIAM: false
    onFailure: 'DELETE'</pre></li> </ul>
<p>Let’s break the preceding <span class="No-Break">code down:</span></p>
<ul>
<li><strong class="source-inline">awsCredentials</strong> is a reference to the <span class="No-Break">service connection.</span></li>
<li><strong class="source-inline">regionName</strong> is any of the AWS <span class="No-Break">regions available.</span></li>
<li><strong class="source-inline">stackName</strong> is a name to identify this stack in the AWS console and must <span class="No-Break">be unique.</span></li>
<li><strong class="source-inline">templateSource</strong> in<a id="_idIndexMarker398"/> this case is <strong class="source-inline">file</strong>; however, it could also be a <strong class="source-inline">url</strong> to a template, perhaps outside of Azure Pipelines; <strong class="source-inline">s3</strong>, which refers to a storage service in AWS, and you would provide a bucket and object key; or <strong class="source-inline">usePrevious</strong>, which indicates you want to use the template in an <span class="No-Break">existing stack.</span></li>
<li><strong class="source-inline">templateFile</strong> is used to provide the location of the file with the template and is only needed because <strong class="source-inline">file</strong> has been set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">templateSource</strong></span><span class="No-Break">.</span></li>
<li>The <strong class="source-inline">capibilityIAM</strong> and <strong class="source-inline">capabilityNamedIAM</strong> parameters are set to <strong class="source-inline">false</strong>. These are additional properties needed for some type of deployment where IAM changes would be applied. In the case of the template used in this example, they are <span class="No-Break">not required.</span></li>
<li>Finally, the <strong class="source-inline">onFailure</strong> property indicates what to do with the stack if something goes wrong. With the <strong class="source-inline">DELETE</strong> value, it would be deleted and any resources that might have been deployed successfully would be deleted as well. The <strong class="source-inline">DO_NOTHING</strong> value would simply stop applying the template and you would be able to see in the AWS console what had happened so far. Lastly, the <strong class="source-inline">ROLLBACK</strong> value, which is the default, would revert any changes made prior to applying <span class="No-Break">the template.</span></li>
</ul>
<p>With the deployment <a id="_idIndexMarker399"/>completed successfully, you should be able to see the status in the AWS console, as shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer226">
<img alt="Figure 8.14 – AWS CloudFormation stack deployed successfully" height="236" src="image/B18875_08_14.jpg" width="929"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.14 – AWS CloudFormation stack deployed successfully</p>
<p>You will also be able to see the resources deployed as part of the CloudFormation stack, as shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer227">
<img alt="Figure 8.15 – AWS CloudFormation stack resources" height="418" src="image/B18875_08_15.jpg" width="1138"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.15 – AWS CloudFormation stack resources</p>
<p>So far, we have learned about Azure and AWS cloud platform-specific IaC capabilities; however, these only work for each of these platforms. If you want to do IaC in a generic way and aim for multiple types of targets – say, on-premises and other cloud providers, there are other tools on the market that can <span class="No-Break">accomplish this.</span></p>
<p>Some other IaC tools are Ansible, Chef, Pulumi, Puppet, SaltStack, and Terraform, to name a few. In this chapter, we will focus on <strong class="bold">Terraform</strong> because it is one of the most popular choices among the open source community due to its versatility and declarative nature. Let’s next learn how to use Terraform <span class="No-Break">for IaC.</span></p>
<h1 id="_idParaDest-126"><a id="_idTextAnchor127"/>Working with Terraform</h1>
<p>Let’s first learn about how Terraform works and then we will walk through using it within <span class="No-Break">Azure Pipelines.</span></p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor128"/>How does Terraform work?</h2>
<p>Terraform is<a id="_idIndexMarker400"/> a tool that allows you to write IaC and define resources for both cloud and on-premises resources using a domain-specific language. It uses providers as a means to encapsulate the resource definition for <span class="No-Break">supported targets.</span></p>
<p>The following diagram <a id="_idIndexMarker401"/>depicts the high-level architecture <span class="No-Break">of Terraform:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer228">
<img alt="Figure 8.16 – Terraform architecture" height="333" src="image/B18875_08_16.jpg" width="1266"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.16 – Terraform architecture</p>
<p>It works by way of the <a id="_idIndexMarker402"/>following <span class="No-Break">three steps:</span></p>
<ol>
<li><strong class="bold">Write</strong>: You define the resources in templates to deploy all the resources you need, across the targets required. There could be more <span class="No-Break">than one.</span></li>
<li><strong class="bold">Plan</strong>: Terraform creates an execution plan to determine the changes that need to be made to match the definition, calculating the sequential order of operations and understanding any resource dependencies. This could mean creating resources, updating them, or <span class="No-Break">destroying them.</span></li>
<li><strong class="bold">Apply</strong>: Once you agree with the plan, Terraform performs the necessary operations in the sequence calculated by <span class="No-Break">the plan.</span></li>
</ol>
<p>Part of the<a id="_idIndexMarker403"/> process Terraform follows involves calculating the state of the target in comparison to the plan. This is called<a id="_idIndexMarker404"/> the <strong class="bold">Terraform state file</strong>. This file will contain details about the resources, their metadata in the target destination, and <span class="No-Break">their dependencies.</span></p>
<p>Depending on the edition of Terraform you are using, you might be responsible for managing the location of this file or use built-in features to manage the state file <span class="No-Break">for you.</span></p>
<p>Managing the location of the state file is critical in Terraform. It can be stored locally or remotely via a <strong class="bold">backend</strong> configuration. When you are getting started, you will likely use the <strong class="bold">local backend</strong>; however, as you evolve your configuration to support multiple environments, you will switch to a <strong class="bold">remote backend</strong>. To read more about remote backends, go <span class="No-Break">to </span><a href="https://developer.hashicorp.com/terraform/language/settings/backends/remote"><span class="No-Break">https://developer.hashicorp.com/terraform/language/settings/backends/remote</span></a><span class="No-Break">.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Terraform works in absolutes, meaning it expects to control every resource defined in the templates you create by comparing them with the current state file every time. This means that no changes should be made without the use of Terraform in the environment. Otherwise, these changes will be lost the next time you run the <strong class="source-inline">terraform </strong><span class="No-Break"><strong class="source-inline">apply</strong></span><span class="No-Break"> command.</span></p>
<p>Terraform<a id="_idIndexMarker405"/> comes in <span class="No-Break">three editions:</span></p>
<ul>
<li><strong class="bold">Open source</strong>: Free, downloadable, and flexible to use with your existing source control and <a id="_idIndexMarker406"/><span class="No-Break">CI/CD tools</span></li>
<li><strong class="bold">Cloud</strong>: A SaaS<a id="_idIndexMarker407"/> application that allows you to run it in a stable and remote environment, with secure storage of the state files <span class="No-Break">and secrets</span></li>
<li><strong class="bold">Enterprise</strong>: Allows <a id="_idIndexMarker408"/>you to set up a private Terraform Cloud instance or self-hosted distribution with customizable resource limits and <span class="No-Break">tighten security.</span></li>
</ul>
<p>Let’s now look at how to create a simple <span class="No-Break">Terraform template.</span></p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor129"/>Creating a Terraform template</h2>
<p>Terraform templates are usually <a id="_idIndexMarker409"/>written in what is called configuration syntax, which is a pseudo-JSON format. All files have the <strong class="source-inline">.tf</strong> extension and typically you will have the <span class="No-Break">following files:</span></p>
<ul>
<li><strong class="source-inline">providers.tf</strong>: Defines the base configuration and providers <span class="No-Break">to use</span></li>
<li><strong class="source-inline">main.tf</strong>: The entry point of your template – say, your <span class="No-Break">starting point</span></li>
<li><strong class="source-inline">variables.tf</strong>: Defines values to be used throughout the templates that can be overridden when planning/applying <span class="No-Break">the configuration</span></li>
<li><strong class="source-inline">outputs.tf</strong>: Values to extract from the <span class="No-Break">resources deployed</span></li>
</ul>
<p>In this chapter, we will use a simple set of templates targeting the Azure cloud platform, creating a resource group, and using the <strong class="source-inline">azurerm</strong> backend. See the templates <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines/tree/main/ch08/terraform"><span class="No-Break">https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines/tree/main/ch08/terraform</span></a><span class="No-Break">.</span></p>
<p>For more details<a id="_idIndexMarker410"/> on the Terraform configuration language, head to <a href="https://developer.hashicorp.com/terraform/language">https://developer.hashicorp.com/terraform/language</a>. For tutorials and training material, head <span class="No-Break">to </span><a href="https://developer.hashicorp.com/tutorials/library?product=terraform"><span class="No-Break">https://developer.hashicorp.com/tutorials/library?product=terraform</span></a><span class="No-Break">.</span></p>
<p>Now that we have learned the Terraform basics for creating templates, let’s put together a pipeline to <span class="No-Break">validate them.</span></p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor130"/>Managing the Terraform state file</h2>
<p>Before we can put together a build <a id="_idIndexMarker411"/>pipeline, we need to ensure that the <strong class="bold">state file</strong> is managed accordingly – in this case, remotely. Since our template will target Azure, we will need to set up the corresponding backend <span class="No-Break">for it.</span></p>
<p>For this, you can execute the following Azure CLI commands, once <span class="No-Break">logged in:</span></p>
<pre class="source-code">
az group create --name tfstate --location eastus
az storage account create --name tfstate --resource-group tfstate --location eastus --sku Standard_LRS
az storage container create --name tfstate --account-name tfstate</pre> <p>These commands perform the <span class="No-Break">following operations:</span></p>
<ul>
<li>Create a resource group in Azure named <strong class="source-inline">tfstate</strong> in the <span class="No-Break"><strong class="source-inline">eastus</strong></span><span class="No-Break"> region</span></li>
<li>Create a storage account in Azure named <strong class="source-inline">tfstate</strong> in the <strong class="source-inline">tfstate</strong> resource group in the <strong class="source-inline">eastus</strong> region with the <strong class="source-inline">Standard_LRS</strong> <span class="No-Break">pricing tier</span></li>
<li>Create a blob<a id="_idIndexMarker412"/> container named <strong class="source-inline">tfstate</strong> in the <strong class="source-inline">tfstate</strong> <span class="No-Break">storage account</span></li>
</ul>
<p class="callout-heading">Important</p>
<p class="callout">The storage account name in the previous commands must be unique globally, so you will have to adjust the name in these commands and any following sections for everything to <span class="No-Break">work correctly.</span></p>
<p>Now that we have set up the state file management, let’s put together a pipeline to validate <span class="No-Break">the template.</span></p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor131"/>Validating a Terraform template</h2>
<p>In your build or CI pipelines, you<a id="_idIndexMarker413"/> should consider validating your templates to ensure the format is correct. For this purpose, tasks are available in the Terraform <span class="No-Break">Marketplace extension:</span></p>
<pre class="source-code">
# Terraform pipeline
trigger:
- main
pool:
  vmImage: ubuntu-latest
steps:
- task: TerraformInstaller@0
  displayName: 'install'
  inputs:
    terraformVersion: 'latest'
- task: TerraformTaskV4@4
  displayName: 'init'
  inputs:
    provider: 'azurerm'
    command: 'init'
    backendServiceArm: 'azure-packt-rg'
    backendAzureRmResourceGroupName: 'tfstate'
    backendAzureRmStorageAccountName: 'tfstate'
    backendAzureRmContainerName: 'tfstate'
    backendAzureRmKey: 'terraform.tfstate'
- task: TerraformTaskV4@4
  displayName: 'validate'
  inputs:
    provider: 'azurerm'
    command: 'validate'</pre> <p>Now let’s break this<a id="_idIndexMarker414"/> <span class="No-Break">code down:</span></p>
<ul>
<li>The <strong class="source-inline">TerraformInstaller@0</strong> task installs the Terraform CLI in the agent if necessary. This is required if you need to ensure a specific version of the tool is required for your templates. Microsoft-hosted agents typically have a version of Terraform installed, but if you want to use an older or newer version, this task will allow you to use the version of Terraform that <span class="No-Break">you need.</span></li>
<li>The <strong class="source-inline">TerraformTask@4</strong> task allows you to run any of the Terraform CLI commands. For the first task with <strong class="source-inline">displayName: init</strong>, it will correspondingly execute the <strong class="source-inline">terraform init</strong> command with the <span class="No-Break">following parameters:</span><ul><li><strong class="source-inline">backendServiceArm</strong> indicating the name of the ARM service connection <span class="No-Break">to use</span></li><li><strong class="source-inline">backendAzureRmResourceGroupName</strong> indicating the resource group in Azure where the state file will <span class="No-Break">be stored</span></li><li><strong class="source-inline">backendAzureRmStorageAccountName</strong> with the name of the Azure storage account where the state file will <span class="No-Break">be stored</span></li><li><strong class="source-inline">backendAzureRmContainerName</strong> with the blob container name in the Azure storage account where the state file will <span class="No-Break">be stored</span></li><li><strong class="source-inline">backendAzureRmKey</strong> indicating the name of the <span class="No-Break">state file</span></li></ul></li>
<li>Finally, the last task with <strong class="source-inline">displayName: validate</strong> will execute the <strong class="source-inline">terraform </strong><span class="No-Break"><strong class="source-inline">validate</strong></span><span class="No-Break"> command.</span></li>
</ul>
<p>Once the <a id="_idIndexMarker415"/>pipeline runs, the validation should complete successfully and you should see a message similar to the following for the <span class="No-Break">validation task:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer229">
<img alt="Figure 8.17 – Successful Terraform template validation" height="421" src="image/B18875_08_17.jpg" width="1264"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.17 – Successful Terraform template validation</p>
<p>Now that we’ve learned how to validate the template, let’s proceed to deploy resources <span class="No-Break">with Terraform.</span></p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor132"/>Deploying a Terraform template</h2>
<p>As mentioned <a id="_idIndexMarker416"/>previously, deploying resources with Terraform is a two-step process, requiring you to execute the <strong class="source-inline">plan</strong> and <span class="No-Break"><strong class="source-inline">apply</strong></span><span class="No-Break"> commands:</span></p>
<pre class="source-code">
# Terraform pipeline
trigger:
- main
pool:
  vmImage: ubuntu-latest
steps:
- task: TerraformInstaller@0
  displayName: 'install'
  inputs:
    terraformVersion: 'latest'
- task: TerraformTaskV4@4
  displayName: 'init'
  inputs:
    provider: 'azurerm'
    command: 'init'
    backendServiceArm: 'azure-packt-rg'
    backendAzureRmResourceGroupName: 'tfstate'
    backendAzureRmStorageAccountName: 'tfstate'
    backendAzureRmContainerName: 'tfstate'
    backendAzureRmKey: 'terraform.tfstate'
- task: TerraformTaskV4@4
  displayName: 'plan'
  inputs:
    provider: 'azurerm'
    command: 'plan'
    environmentServiceNameAzureRM: 'azure-packt-rg'
- task: TerraformTaskV4@4
  displayName: 'apply'
  inputs:
    provider: 'azurerm'
    command: 'apply'
    environmentServiceNameAzureRM: 'azure-packt-rg'</pre> <p>Let’s break <a id="_idIndexMarker417"/>this <span class="No-Break">code down:</span></p>
<ul>
<li>The <strong class="source-inline">TerraformInstaller@0</strong> task installs the Terraform CLI in the agent <span class="No-Break">if necessary</span></li>
<li>The <strong class="source-inline">TerraformTask@4</strong> task with <strong class="source-inline">displayName: init</strong> initializes Terraform as explained in the <span class="No-Break">previous section</span></li>
<li>The <strong class="source-inline">TerraformTask@4</strong> task with <strong class="source-inline">displayName: plan</strong> executes the <strong class="source-inline">terraform plan</strong> command, performing the comparison necessary and updating the state file accordingly with changes to <span class="No-Break">be made</span></li>
<li>The <strong class="source-inline">TerraformTask@4</strong> task with <strong class="source-inline">displayName: apply</strong> executes the <strong class="source-inline">terraform apply</strong> command<a id="_idIndexMarker418"/> and performs the changes necessary <span class="No-Break">in Azure</span></li>
</ul>
<p>We covered a lot of ground in this chapter. Let’s finish off with a summary of what <span class="No-Break">we learned.</span></p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor133"/>Summary</h1>
<p>In this chapter, we learned about different tools available to create, update, and delete resources on the Microsoft Azure and AWS <span class="No-Break">cloud platforms.</span></p>
<p>We learned how to create, validate, and deploy ARM templates, the role of service principals in Azure, and the security considerations of deploying <span class="No-Break">with automation.</span></p>
<p>We also learned about AWS CloudFormation templates and stacks, and how to create them and update them from Azure Pipelines. At the same time, we learned how AWS has a similar security model to Azure and about the security implications <span class="No-Break">of credentials.</span></p>
<p>Finally, we learned about Terraform as an abstraction language to define IaC for on-premises and cloud platforms such as Azure and AWS, and how to validate templates in Azure Pipelines and deploy resources <span class="No-Break">with it.</span></p>
<p>Regardless of which IaC tool you choose to use, they are important because they will allow you to do <span class="No-Break">the following:</span></p>
<ul>
<li>Have a repeatable and immutable process <span class="No-Break">for deployments</span></li>
<li><span class="No-Break">Accelerate deployments</span></li>
<li>Reduce or eliminate errors while deploying with <span class="No-Break">Azure Pipelines</span></li>
<li>Recover from <span class="No-Break">issues easily</span></li>
<li>Spend more time working on your <span class="No-Break">application code</span></li>
</ul>
<p>In the next chapter, we will be putting everything we have learned together for end-to-end pipeline building and packaging applications to deploy them on different Microsoft Azure cloud <span class="No-Break">platform services.</span></p>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer231">
<h1 id="_idParaDest-133" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor134"/>Part 3:CI/CD for Real-World Scenarios</h1>
<p>Finally, in the last part of this book, we will compile everything we’ve learned so far to create end-to-end scenarios typically found in the real world, using cloud platforms, and we will walk through some <span class="No-Break">best practices.</span></p>
<p>This part has the <span class="No-Break">following chapters:</span></p>
<ul>
<li><a href="B18875_09.xhtml#_idTextAnchor135"><em class="italic">Chapter 9</em></a>, <em class="italic">Implementing CI/CD for Azure Services</em></li>
<li><a href="B18875_10.xhtml#_idTextAnchor153"><em class="italic">Chapter 10</em></a>, <em class="italic">Implementing CI/CD for AWS</em></li>
<li><a href="B18875_11.xhtml#_idTextAnchor168"><em class="italic">Chapter 11</em></a>, <em class="italic">Automating CI/CD for Cross-Mobile Applications by Using Flutter</em></li>
<li><a href="B18875_12.xhtml#_idTextAnchor181"><em class="italic">Chapter 12</em></a>, <em class="italic">Navigating Common Pitfalls and Future Trends in Azure Pipelines</em></li>
</ul>
</div>
<div>
<div id="_idContainer232">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer233">
</div>
</div>
</div></body></html>