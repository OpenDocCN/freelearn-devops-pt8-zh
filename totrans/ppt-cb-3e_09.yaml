- en: Chapter 9. External Tools and the Puppet Ecosystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"By all means leave the road when you wish. That is precisely the use
    of a road: to reach individually chosen points of departure."* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Robert Bringhurst, The Elements of Typographic Style* |'
  prefs: []
  type: TYPE_TB
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom facts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding external facts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting facts as environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating manifests with the Puppet resource command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating manifests with other tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an external node classifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your own resource types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your own providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing your Puppet manifests with rspec-puppet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using librarian-puppet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using r10k
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Puppet is a useful tool by itself, but you can get much greater benefits by
    using Puppet in combination with other tools and frameworks. We'll look at some
    ways of getting data into Puppet, including custom Facter facts, external facts,
    and tools to generate Puppet manifests automatically from the existing configuration.
  prefs: []
  type: TYPE_NORMAL
- en: You'll also learn how to extend Puppet by creating your own custom functions,
    resource types, and providers; how to use an external node classifier script to
    integrate Puppet with other parts of your infrastructure; and how to test your
    code with rspec-puppet.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom facts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Facter's built-in facts are useful, it's actually quite easy to add your
    own facts. For example, if you have machines in different data centers or hosting
    providers, you could add a custom fact for this so that Puppet can determine whether
    any local settings need to be applied (for example, local DNS servers or network
    routes).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s an example of a simple custom fact:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the directory `modules/facts/lib/facter` and then create the file `modules/facts/lib/facter/hello.rb`
    with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify your `site.pp` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run Puppet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Facter facts are defined in Ruby files that are distributed with facter. Puppet
    can add additional facts to facter by creating files within the `lib/facter` subdirectory
    of a module. These files are then transferred to client nodes as we saw earlier
    with the `puppetlabs-stdlib` module. To have the command-line facter use these
    `puppet` facts, append the `-p` option to facter as shown in the following command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are using an older version of Puppet (older than 3.0), you will need
    to enable `pluginsync` in your `puppet.conf` file as shown in the following command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Facts can contain any Ruby code, and the last value evaluated inside the `setcode
    do ... end` block will be the value returned by the fact. For example, you could
    make a more useful fact that returns the number of users currently logged in to
    the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To reference the fact in your manifests, just use its name like a built-in
    fact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can add custom facts to any Puppet module. When creating facts that will
    be used by multiple modules, it may make sense to place them in a facts module.
    In most cases, the custom fact is related to a specific module and should be placed
    in that module.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The name of the Ruby file that holds the fact definition is irrelevant. You
    can name this file whatever you wish; the name of the fact comes from the `Facter.add()`
    function call. You may also call this function several times within a single Ruby
    file to define multiple facts as necessary. For instance, you could `grep` the
    `/proc/meminfo` file and return several facts based on memory information as shown
    in the `meminfo.rb` file in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After synchronizing this file to a node, the `memory_active` and `memory_inactive`
    facts would be available as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can extend the use of facts to build a completely nodeless Puppet configuration;
    in other words, Puppet can decide what resources to apply to a machine, based
    solely on the results of facts. Jordan Sissel has written about this approach
    at [http://www.semicomplete.com/blog/geekery/puppet-nodeless-configuration.html](http://www.semicomplete.com/blog/geekery/puppet-nodeless-configuration.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find out more about custom facts, including how to make sure that OS-specific
    facts work only on the relevant systems, and how to weigh facts so that they''re
    evaluated in a specific order at the puppetlabs website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.puppetlabs.com/guides/custom_facts.html](http://docs.puppetlabs.com/guides/custom_facts.html)'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Importing dynamic information* recipe in [Chapter 3](ch03.html "Chapter 3. Writing
    Better Manifests"), *Writing Better Manifests*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Configuring Hiera* recipe in [Chapter 2](ch02.html "Chapter 2. Puppet Infrastructure"),
    *Puppet Infrastructure*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding external facts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating custom facts* recipe describes how to add extra facts written
    in Ruby. You can also create facts from simple text files or scripts with external
    facts instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'External facts live in the `/etc/facter/facts.d` directory and have a simple
    `key=value` format like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s what you need to do to prepare your system to add external facts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll need Facter Version 1.7 or higher to use external facts, so look up
    the value of `facterversion` or use `facter -v`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You''ll also need to create the external facts directory, using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we''ll create a simple external fact that returns a message,
    as shown in the *Creating custom facts* recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the file `/etc/facter/facts.d/local.txt` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Well, that was easy! You can add more facts to the same file, or other files,
    of course, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: However, what if you need to compute a fact in some way, for example, the number
    of logged-in users? You can create executable facts to do this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the file `/etc/facter/facts.d/users.sh` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make this file executable with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now check the `users` value with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we'll create an external fact by creating files on the node.
    We'll also show how to override a previously defined fact.
  prefs: []
  type: TYPE_NORMAL
- en: 'Current versions of Facter will look into `/etc/facter/facts.d` for files of
    type `.txt`, `.json`, or `.yaml`. If facter finds a text file, it will parse the
    file for `key=value` pairs and add the key as a new fact:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the file is a YAML or JSON file, then facter will parse the file for `key=value`
    pairs in the respective format. For YAML, for instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The resulting output will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the case of executable files, Facter will assume that their output is a list
    of `key=value` pairs. It will execute all the files in the `facts.d` directory
    and add their output to the internal fact hash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In Windows, batch files or PowerShell scripts may be used in the same way that
    executable scripts are used in Linux.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `users` example, Facter will execute the `users.sh` script, which results
    in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It will then search this output for `users` and return the matching value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If there are multiple matches for the key you specified, Facter determines
    which fact to return based on a weight property. In my version of facter, the
    weight of external facts is 10,000 (defined in `facter/util/directory_loader.rb`
    as `EXTERNAL_FACT_WEIGHT`). This high value is to ensure that the facts you define
    can override the supplied facts. For example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since all external facts have a weight of 10,000, the order in which they are
    parsed within the `/etc/facter/facts.d` directory sets their precedence (with
    the last one encountered having the highest precedence). To create a fact that
    will be favored over another, you''ll need to have it created in a file that comes
    last alphabetically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Debugging external facts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you''re having trouble getting Facter to recognize your external facts,
    run Facter in debug mode to see what''s happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `X` JSON file was parsed but returned an empty data set error, which means
    Facter didn't find any `key=value` pairs in the file or (in the case of an executable
    fact) in its output.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that if you have external facts present, Facter parses or runs all the
    facts in the `/etc/facter/facts.d` directory every time you query Facter. If some
    of these scripts take a long time to run, that can significantly slow down anything
    that uses Facter (run Facter with the `--iming` switch to troubleshoot this).
    Unless a particular fact needs to be recomputed every time it's queried, consider
    replacing it with a cron job that computes it every so often and writes the result
    to a text file in the Facter directory.
  prefs: []
  type: TYPE_NORMAL
- en: Using external facts in Puppet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Any external facts you create will be available to both Facter and Puppet.
    To reference external facts in your Puppet manifests, just use the fact name in
    the same way you would for a built-in or custom fact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Unless you are specifically attempting to override a defined fact, you should
    avoid using the name of a predefined fact.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Importing dynamic information* recipe in [Chapter 3](ch03.html "Chapter 3. Writing
    Better Manifests"), *Writing Better Manifests*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Configuring Hiera* recipe in [Chapter 2](ch02.html "Chapter 2. Puppet Infrastructure"),
    *Puppet Infrastructure*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating custom facts* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting facts as environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another handy way to get information into Puppet and Facter is to pass it using
    environment variables. Any environment variable whose name starts with `FACTER_`
    will be interpreted as a fact. For example, ask facter the value of hello using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now override the value with an environment variable and ask again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It works just as well with Puppet, so let's run through an example.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example we''ll set a fact using an environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep the node definition for cookbook the same as our last example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Generating manifests with the Puppet resource command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have a server that is already configured as it needs to be, or nearly
    so, you can capture that configuration as a Puppet manifest. The Puppet resource
    command generates Puppet manifests from the existing configuration of a system.
    For example, you can have `puppet resource` generate a manifest that creates all
    the users found on the system. This is very useful to take a snapshot of a working
    system and get its configuration quickly into Puppet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some examples of using `puppet resource` to get data from a running
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate the manifest for a particular user, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For a particular service, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For a package, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use `puppet resource` to examine each of the resource types available
    in Puppet. In the preceding examples, we generated a manifest for a specific instance
    of the resource type, but you can also use `puppet resource` to dump all instances
    of the resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the state of each service on the system; this is because each
    service is an enumerable resource. When you try the same command with a resource
    that is not enumerable, you get an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Asking Puppet to describe each file on the system will not work; that's something
    best left to an audit tool such as `tripwire` (a system designed to look for changes
    on every file on the system, [http://www.tripwire.com](http://www.tripwire.com)).
  prefs: []
  type: TYPE_NORMAL
- en: Generating manifests with other tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to quickly capture the complete configuration of a running system
    as a Puppet manifest, there are a couple of tools available to help. In this example,
    we'll look at Blueprint, which is designed to examine a machine and dump its state
    as Puppet code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here's what you need to do to prepare your system to use Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to install Blueprint; we''ll use `puppet resource`
    here to change the state of the `python-pip` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may need to install Git on your cookbook node if it is not already installed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These steps will show you how to run Blueprint:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Read the `blueprint_test/manifests/init.pp` file to see the generated code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Blueprint just takes a snapshot of the system as it stands; it makes no intelligent
    decisions, and Blueprint captures all the files on the system and all the packages.
    It will generate a configuration much larger than you may actually require. For
    instance, when configuring a server, you may specify that you want the Apache
    package installed. The dependencies for the Apache package will be installed automatically
    and you need to specify them. When generating the configuration with a tool such
    as Blueprint, you will capture all those dependencies and lock the versions that
    are installed on your system currently. Looking at our generated Blueprint code,
    we can see that this is the case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If you were creating this manifest yourself, you would likely specify `ensure
    => installed` instead of a specific version.
  prefs: []
  type: TYPE_NORMAL
- en: Packages install default versions of files. Blueprint has no notion of this
    and will add all the files to the manifest, even those that have not changed.
    By default, Blueprint will indiscriminately capture all the files in `/etc` as
    file resources.
  prefs: []
  type: TYPE_NORMAL
- en: Blueprint and similar tools have a very small use case generally, but may help
    you to get familiar with the Puppet syntax and give you some ideas on how to specify
    your own manifests. I would not recommend blindly using this tool to create a
    system, however.
  prefs: []
  type: TYPE_NORMAL
- en: There's no shortcut to good configuration management, those who hope to save
    time and effort by cutting and pasting someone else's code as a whole (as with
    public modules) are likely to find that it saves neither.
  prefs: []
  type: TYPE_NORMAL
- en: Using an external node classifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When Puppet runs on a node, it needs to know which classes should be applied
    to that node. For example, if it is a web server node, it might need to include
    an `apache` class. The normal way to map nodes to classes is in the Puppet manifest
    itself, for example, in your `site.pp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can use an **External Node Classifier (ENC)** to do this
    job. An ENC is any executable program that can accept the fully-qualified domain
    name (FQDN) as the first command-line argument (`$1`). The script is expected
    to return a list of classes, parameters, and an optional environment to apply
    to the node. The output is expected to be in the standard YAML format. When using
    an ENC, you should keep in mind that the classes applied through the standard
    `site.pp` manifest are merged with those provided by the ENC.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Parameters returned by the ENC are available as top-scope variables to the node.
  prefs: []
  type: TYPE_NORMAL
- en: An ENC could be a simple shell script, for example, or a wrapper around a more
    complicated program or API that can decide how to map nodes to classes. The ENC
    provided by Puppet enterprise and The Foreman ([http://theforeman.org/](http://theforeman.org/))
    are both simple scripts, which connect to the web API of their respective systems.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we'll build the most simple of ENCs, a shell script that simply
    prints a list of classes to include. We'll start by including an `enc` class,
    which defines `notify` that will print a top-scope variable `$enc`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll start by creating our `enc` class to include with the `enc` script:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the file `modules/enc/manifests/init.pp` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s how to build a simple external node classifier. We''ll perform all
    these steps on our Puppet master server. If you are running masterless, then do
    these steps on a node:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the file `/etc/puppet/cookbook.sh` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify your `/etc/puppet/puppet.conf` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Restart Apache (restart the master) to make the change effective.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure your `site.pp` file has the following empty definition for the default
    node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run Puppet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an ENC is set in `puppet.conf`, Puppet will call the specified program
    with the node's fqdn (technically, the certname variable) as the first command-line
    argument. In our example script, this argument is ignored, and it just outputs
    a fixed list of classes (actually, just one class).
  prefs: []
  type: TYPE_NORMAL
- en: Obviously this script is not terribly useful; a more sophisticated script might
    check a database to find the class list, or look up the node in a hash, or an
    external text file or database (often an organization's configuration management
    database, **CMDB**). Hopefully, this example is enough to get you started with
    writing your own external node classifier. Remember that you can write your script
    in any language you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An ENC can supply a whole list of classes to be included in the node, in the
    following (YAML) format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'For classes that take parameters, you can use this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also produce top-scope variables using an ENC with this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Variables that you set in this way will be available in your manifest using
    the normal syntax for a top-scope variable, for example `$::message`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'See the puppetlabs ENC page for more information on writing and using ENCs:
    [http://docs.puppetlabs.com/guides/external_nodes.html](http://docs.puppetlabs.com/guides/external_nodes.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your own resource types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you know, Puppet has a bunch of useful built-in resource types: packages,
    files, users, and so on. Usually, you can do everything you need to do by using
    either combinations of these built-in resources, or `define`, which you can use
    more or less in the same way as a resource (see [Chapter 3](ch03.html "Chapter 3. Writing
    Better Manifests"), *Writing Better Manifests* for information on definitions).'
  prefs: []
  type: TYPE_NORMAL
- en: In the early days of Puppet, creating your own resource type was more common
    as the list of core resources was shorter than it is today. Before you consider
    creating your own resource type, I suggest searching the Forge for alternative
    solutions. Even if you can find a project that only partially solves your problem,
    you will be better served by extending and helping out that project, rather than
    trying to create your own. However, if you need to create your own resource type,
    Puppet makes it quite easy. The native types are written in Ruby, and you will
    need a basic familiarity with Ruby in order to create your own.
  prefs: []
  type: TYPE_NORMAL
- en: Let's refresh our memory on the distinction between types and providers. A type
    describes a resource and the parameters it can have (for example, the `package`
    type). A provider tells Puppet how to implement a resource type for a particular
    platform or situation (for example, the `apt/dpkg` providers implement the `package`
    type for Debian-like systems).
  prefs: []
  type: TYPE_NORMAL
- en: A single type (`package`) can have many providers (APT, YUM, Fink, and so on).
    If you don't specify a provider when declaring a resource, Puppet will choose
    the most appropriate one given the environment.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use Ruby in this section; if you are not familiar with Ruby try visiting
    [http://www.ruby-doc.org/docs/Tutorial/](http://www.ruby-doc.org/docs/Tutorial/)
    or [http://www.codecademy.com/tracks/ruby/](http://www.codecademy.com/tracks/ruby/).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we'll see how to create a custom type that we can use to manage
    Git repositories, and in the next section, we'll write a provider to implement
    this type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the file `modules/cookbook/lib/puppet/type/gitrepo.rb` with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Custom types can live in any module, in a `lib/puppet/type` subdirectory and
    in a file named for the type (in our example, that's `modules/cookbook/lib/puppet/type/gitrepo.rb`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line of `gitrepo.rb` tells Puppet to register a new type named `gitrepo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ensurable` line automatically gives the type an `ensure` property, such
    as Puppet''s built-in resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll now give the type some parameters. For the moment, all we need is a
    `source` parameter for the Git source URL, and a `path` parameter to tell Puppet
    where the repo should be created in the filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isnamevar` declaration tells Puppet that the `source` parameter is the
    type''s namevar. So when you declare an instance of this resource, whatever name
    you give, it will be the value of `source`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we tell Puppet that the type accepts the `path` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When deciding whether or not you should create a custom type, you should ask
    a few questions about the resource you are trying to describe such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the resource enumerable? Can you easily obtain a list of all the instances
    of the resource on the system?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the resource atomic? Can you ensure that only one copy of the resource exists
    on the system (this is particularly important when you want to use `ensure=>absent`
    on the resource)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is there any other resource that describes this resource? In such a case, a
    defined type based on the existing resource would, in most cases, be a simpler
    solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our example is deliberately simple, but when you move on to developing real
    custom types for your production environment, you should add documentation strings
    to describe what the type and its parameters do, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use parameter validation to generate useful error messages when someone
    tries to pass bad values to the resource. For example, you could validate that
    the directory where the repo is to be created actually exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specify the list of allowed values that the parameter can take:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Creating your own providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we created a new custom type called `gitrepo` and told
    Puppet that it takes two parameters, `source` and `path`. However, so far, we
    haven't told Puppet how to actually check out the repo; in other words, how to
    create a specific instance of this type. That's where the provider comes in.
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw that a type will often have several possible providers. In our example,
    there is only one sensible way to instantiate a Git repo, so we''ll only supply
    one provider: `git`. If you were to generalize this type—to just repo, say—it''s
    not hard to imagine creating several different providers depending on the type
    of repo, for example, `git`, `svn`, `cvs`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll add the `git` provider, and create an instance of a `gitrepo` resource
    to check that it all works. You'll need Git installed for this to work, but if
    you're using the Git-based manifest management setup described in [Chapter 2](ch02.html
    "Chapter 2. Puppet Infrastructure"), *Puppet Infrastructure*, we can safely assume
    that Git is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the file `modules/cookbook/lib/puppet/provider/gitrepo/git.rb` with
    the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify your `site.pp` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run Puppet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Custom providers can live in any module, in a `lib/puppet/provider/TYPE_NAME`
    subdirectory in a file named after the provider. (The provider is the actual program
    that is run on the system; in our example, the program is Git and the provider
    is in `modules/cookbook/lib/puppet/provider/gitrepo/git.rb`. Note that the name
    of the module is irrelevant.)
  prefs: []
  type: TYPE_NORMAL
- en: 'After an ntitial require line in `git.rb`, we tell Puppet to register a new
    provider for the `gitrepo` type with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'When you declare an instance of the `gitrepo` type in your manifest, Puppet
    will first of all check whether the instance already exists, by calling the `exists?`
    method on the provider. So we need to supply this method, complete with code to
    check whether an instance of the `gitrepo` type already exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This is not the most sophisticated implementation; it simply returns `true`
    if a directory exists matching the `path` parameter of the instance. A better
    implementation of `exists?` might check, for example, whether there is a `.git`
    subdirectory and that it contains valid Git metadata. But this will do for now.
  prefs: []
  type: TYPE_NORMAL
- en: If `exists?` returns `true`, then Puppet will take no further action because
    the specified resource exists (as far as Puppet knows). If it returns `false`,
    Puppet assumes the resource doesn't yet exist, and will try to create it by calling
    the provider's `create` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, we supply some code for the `create` method that calls the `git
    clone` command to create the repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The method has access to the instance's parameters, which we need to know where
    to check out the repo from, and which directory to create it in. We get this by
    looking at `resource[:source]` and `resource[:path]`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can see that custom types and providers in Puppet are very powerful. In
    fact, they can do anything—at least, anything that Ruby can do. If you are managing
    some parts of your infrastructure with complicated `define` statements and `exec`
    resources, you may want to consider replacing these with a custom type. However,
    as stated previously, it's worth looking around to see if someone else has already
    done this before implementing your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our example was very simple, and there is much more to learn about writing
    your own types. If you''re going to distribute your code for others to use, or
    even if you aren''t, it''s a good idea to include tests with it. puppetlabs has
    a useful page on the interface between custom types and providers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.puppetlabs.com/guides/custom_types.html](http://docs.puppetlabs.com/guides/custom_types.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'on implementing providers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.puppetlabs.com/guides/provider_development.html](http://docs.puppetlabs.com/guides/provider_development.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'and a complete worked example of developing a custom type and provider, a little
    more advanced than that presented in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.puppetlabs.com/guides/complete_resource_example.html](http://docs.puppetlabs.com/guides/complete_resource_example.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've read the recipe *Using GnuPG to encrypt secrets* in [Chapter 4](ch04.html
    "Chapter 4. Working with Files and Packages"), *Working with Files and Packages*,
    then you've already seen an example of a custom function (in that example, we
    created a `secret` function, which shelled out to GnuPG). Let's look at `custom`
    functions in a little more detail now and build an example.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you''ve read the recipe *Distributing cron jobs efficiently* in [Chapter
    6](ch06.html "Chapter 6. Managing Resources and Files"), *Managing Resources and
    Files*, you might remember that we used the `inline_template` function to set
    a random time for cron jobs to run, based on the hostname of the node. In this
    example, we''ll take that idea and turn it into a custom function called `random_minute`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the file `modules/cookbook/lib/puppet/parser/functions/random_minute.rb`
    with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify your `site.pp` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run Puppet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check `crontab` with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Custom functions can live in any module, in the `lib/puppet/parser/functions`
    subdirectory in a file named after the function (in our example, `random_minute.rb`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The function code goes inside a `module ... end` block like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We then call `newfunction` to declare our new function, passing the name (`:random_minute`)
    and the type of function (`:rvalue`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The `:rvalue` bit simply means that this function returns a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the function code itself is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The `lookupvar` function lets you access facts and variables by name; in this
    case, `hostname` to get the name of the node we're running on. We use the Ruby
    `sum` method to get the numeric sum of the characters in this string, and then
    perform integer division modulo 60 to make sure the result is in the range `0..59`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can, of course, do a lot more with custom functions. In fact, anything
    you can do in Ruby, you can do in a custom function. You also have access to all
    the facts and variables that are in scope at the point in the Puppet manifest
    where the function is called, by calling `lookupvar` as shown in the example.
    You can also work on arguments, for example, a general purpose hashing function
    that takes two arguments: the size of the hash table and optionally the thing
    to hash. Create `modules/cookbook/lib/puppet/parser/functions/hashtable.rb` with
    the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll create a test for our `hashtable` function and alter `site.pp` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run Puppet and observe the values that are returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Our simple definition quickly grew when we added the ability to add arguments.
    As with all programming, care should be taken when working with arguments to ensure
    that you do not have any error conditions. In the preceding code, we specifically
    looked for the situation where the size variable was 0, to avoid a divide by zero
    error.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out more about what you can do with custom functions, see the puppetlabs
    website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.puppetlabs.com/guides/custom_functions.html](http://docs.puppetlabs.com/guides/custom_functions.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Testing your puppet manifests with rspec-puppet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would be great if we could verify that our Puppet manifests satisfy certain
    expectations without even having to run Puppet. The `rspec-puppet` tool is a nifty
    tool to do this. Based on RSpec, a testing framework for Ruby programs, `rspec-puppet`
    lets you write test cases for your Puppet manifests that are especially useful
    to catch regressions (bugs introduced when fixing another bug), and refactoring
    problems (bugs introduced when reorganizing your code).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here's what you'll need to do to install `rspec-puppet`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create an example class, `thing`, and write some tests for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `thing` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the file `spec/classes/thing_spec.rb` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `rspec-puppet-init` command creates a framework of directories for you to
    put your specs (test programs) in. At the moment, we're just interested in the
    `spec/classes` directory. This is where you'll put your class specs, one per class,
    named after the class it tests, for example, `thing_spec.rb`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `spec` code itself begins with the following statement, which sets up the
    RSpec environment to run the specs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, a `describe` block follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The `describe` identifies the class we're going to test (`thing`) and wraps
    the list of assertions about the class inside a `do .. end` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assertions are our stated expectations of the `thing` class. For example, the
    first assertion is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The `create_class` assertion is used to ensure that the named class is actually
    created. The next line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The `contain_package` assertion means what it says: the class should contain
    a package resource named `thing`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we test for the existence of the `thing` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code actually contains two assertions. First, that the class
    contains a `thing` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, that the service has an `ensure` attribute with the value `running`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'You can specify any attributes and values you want using the `with` method,
    as a comma-separated list. For example, the following code asserts several attributes
    of a `file` resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `thing` example, we need to only test that the file `thing.conf` is
    present, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the `rake spec` command, `rspec-puppet` will compile the relevant
    Puppet classes, run all the specs it finds, and display the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we defined the file in our test as `/etc/things.conf` but the
    file in the manifests is `/etc/thing.conf`, so the test fails. Edit `thing_spec.rb`
    and change `/etc/things.conf to /etc/thing.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run rspec again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many conditions you can verify with rspec. Any resource type can be
    verified with `contain_<resource type>`(title). In addition to verifying your
    classes will apply correctly, you can also test functions and definitions by using
    the appropriate subdirectories within the spec directory (classes, defines, or
    functions).
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about `rspec-puppet`, including complete documentation
    for the assertions available and a tutorial, at [http://rspec-puppet.com/](http://rspec-puppet.com/).
  prefs: []
  type: TYPE_NORMAL
- en: When you want to start testing how your code applies to nodes, you'll need to
    look at another tool, beaker. Beaker works with various virtualization platforms
    to create temporary virtual machines to which Puppet code is applied. The results
    are then used for acceptance testing of the Puppet code. This method of testing
    and developing at the same time is known as **Test-driven development** (**TDD**).
    More information about beaker is available on the GitHub site at [https://github.com/puppetlabs/beaker](https://github.com/puppetlabs/beaker).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Checking your manifests with puppet-lint* recipe in [Chapter 1](ch01.html
    "Chapter 1. Puppet Language and Style"), *Puppet Language and Style*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using librarian-puppet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you begin to include modules from the forge in your Puppet infrastructure,
    keeping track of which versions you installed and ensuring consistency between
    all your testing areas can become a bit of a problem. Luckily, the tools we will
    discuss in the next two sections can bring order to your system. We will first
    begin with librarian-puppet, which uses a special configuration file named Puppetfile
    to specify the source location of your various modules.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll install librarian-puppet to work through the example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `librarian-puppet` on your Puppet master, using Puppet of course:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are working in a masterless environment, install `librarian-puppet` on
    the machine from which you will be managing your code. Your gem install may fail
    if the Ruby development packages are not available on your master; install the
    `ruby-dev` package to fix this issue (use Puppet to do it).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll use librarian-puppet to download and install a module in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a working directory for yourself; librarian-puppet will overwrite your
    modules directory by default, so we''ll work in a temporary location for now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new Puppetfile with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Alternatively, you can use `librarian-puppet init` to create an example Puppetfile
    and edit it to match our example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, run librarian-puppet to download and install the `puppetlabs-stdlib` module
    in the `modules` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first line of the `Puppetfile` makes the `Puppetfile` appear to be a Ruby
    source file. These are completely optional but coerces editors into treating the
    file as though it was written in Ruby (which it is):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'We next define where the Puppet Forge is located; you may specify an internal
    Forge here if you have a local mirror:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we added a line to include the `puppetlabs-stdlib` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `Puppetfile` in place, we ran `librarian-puppet` and it downloaded
    the module from the URL given in the Forge line. As the module was downloaded,
    `librarian-puppet` created a `Puppetfile.lock` file, which includes the location
    used as source and the version number for the downloaded module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Puppetfile` allows you to pull in modules from sources other than the forge.
    You may use a local Git url or even a GitHub url to download modules that are
    not on the Forge. More information on librarian-puppet can be found on the GitHub
    website at [https://github.com/rodjek/librarian-puppet](https://github.com/rodjek/librarian-puppet).
  prefs: []
  type: TYPE_NORMAL
- en: Note that librarian-puppet will create the modules directory and remove any
    modules you placed in there by default. Most installations using librarian-puppet
    opt to place their local modules in a `/local` subdirectory (`/dist` or `/companyname`
    are also used).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll talk about r10k, which goes one step further than
    librarian and manages your entire environment directory.
  prefs: []
  type: TYPE_NORMAL
- en: Using r10k
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Puppetfile` is a very good format to describe which modules you wish to
    include in your environment. Building upon the `Puppetfile` is another tool, **r10k**.
    r10k is a total environment management tool. You can use r10k to clone a local
    Git repository into your `environmentpath` and then place the modules specified
    in your `Puppetfile` into that directory. The local Git repository is known as
    the master repository; it is where r10k expects to find your `Puppetfile`. r10k
    also understands Puppet environments and will clone Git branches into subdirectories
    of your `environmentpath`, simplifying the deployment of multiple environments.
    What makes r10k particularly useful is its use of a local cache directory to speed
    up deployments. Using a configuration file, `r10k.yaml`, you can specify where
    to store this cache and also where your master repository is held.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll install r10k on our controlling machine (usually the master). This is
    where we will control all the modules downloaded and installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install r10k on your puppet master, or on whichever machine you wish to manage
    your `environmentpath` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make a new copy of your Git repository (optional, do this on your Git server):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check out the new Git repository (on your local machine) and move the existing
    modules directory to a new location. We''ll use `/local` in this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll create a Puppetfile to control r10k and install modules on our master.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Puppetfile` into the new Git repository with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `Puppetfile` to your new repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Back to your master, create `/etc/r10k.yaml` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run r10k to have the `/etc/puppet/environments` directory populated (hint:
    create a backup of your `/etc/puppet/environments` directory first):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify that your `/etc/puppet/environments` directory has a production subdirectory.
    Within that directory, the `/local` directory will exist and the modules directory
    will have all the modules listed in the `Puppetfile`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We started by creating a copy of our Git repository; this was only done to preserve
    the earlier work and is not required. The important thing to remember with r10k
    and librarian-puppet is that they both assume they are in control of the `/modules`
    subdirectory. We need to move our modules out of the way and create a new location
    for the modules.
  prefs: []
  type: TYPE_NORMAL
- en: In the `r10k.yaml` file, we specified the location of our new repository. When
    we ran r10k, it first downloaded this repository into its local cache. Once the
    Git repository is downloaded locally, r10k will go through each branch and look
    for a `Puppetfile` within the branch. For each `branch/Puppetfile` combination,
    the modules specified within are downloaded first to the local cache directory
    (`cachedir`) and then into the `basedir`, which was given in `r10k.yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can automate the deployment of your environments using `r10k`. The command
    we used to run `r10k` and populate our environments directory can be easily placed
    inside a Git hook to automatically update your environment. There is also a **marionette
    collective** (**mcollective**) plugin ([https://github.com/acidprime/r10k](https://github.com/acidprime/r10k)),
    which can be used to have `r10k` run on an arbitrary set of servers.
  prefs: []
  type: TYPE_NORMAL
- en: Using either of these tools will help keep your site consistent, even if you
    are not taking advantage of the various modules available on the Forge.
  prefs: []
  type: TYPE_NORMAL
