["```\napiVersion: policy/v1\nkind: PodDisruptionBudget\nmetadata:\n  name: webserver-pdb\nspec:\n  minAvailable: 2\n  selector:\n    matchLabels:\n      app: webserver\n```", "```\nkubectl autoscale <RESOURCE_TYPE> <RESOURCE_NAME> --cpu-percent=50 --min=2 --max=10\n```", "```\n    apiVersion: apps/v1\n    kind: StatefulSet\n    metadata:\n      name: db\n      labels:\n        component: db\n        app: simplestlab\n    spec:\n      replicas: 1\n      selector:\n        matchLabels:\n          component: db\n          app: simplestlab\n      template:\n        metadata:\n          labels:\n            component: db\n            app: simplestlab\n        spec:\n          securityContext:\n            runAsNonRoot: true\n            runAsUser: 10000\n            runAsGroup: 10000\n            fsGroup: 10000\n    ...\n      volumeClaimTemplates:\n      - metadata:\n          name: postgresdata\n        spec:\n          accessModes: [ \"ReadWriteOnce\" ]\n          #storageClassName: \"csi-hostpath-sc\"\n          resources:\n            requests:\n              storage: 1Gi\n    ```", "```\n         securityContext:\n            runAsNonRoot: true\n            runAsUser: 10000\n            runAsGroup: 10000\n            fsGroup: 10000\n            fsGroupChangePolicy: OnRootMismatch\n    ```", "```\n    apiVersion: v1\n    kind: Service\n    metadata:\n      name: db\n    spec:\n      clusterIP: None\n      selector:\n        component: db\n        app: simplestlab\n     ...\n    ```", "```\n    PS Chapter9> kubectl create -f .\\db.statefulset.yaml\n    statefulset.apps/db created\n    PS Chapter9> kubectl create -f .\\db.service.yaml\n    service/db created\n    PS Chapter9> kubectl get pods\n    NAME   READY   STATUS    RESTARTS   AGE\n    app component.\n    ```", "```\n    apiVersion: apps/v1\n    kind: Deployment\n    metadata:\n      name: app\n      labels:\n        component: app\n        app: simplestlab\n    spec:\n      replicas: 3\n      selector:\n        matchLabels:\n          component: app\n          app: simplestlab\n      template:\n        metadata:\n          labels:\n            component: app\n            app: simplestlab\n        spec:\n          securityContext:\n            runAsNonRoot: true\n            runAsUser: 10001\n            runAsGroup: 10001\n    ```", "```\n         securityContext:\n            runAsNonRoot: true\n            runAsUser: 10001\n            runAsGroup: 10001\n    ```", "```\n           securityContext:\n              readOnlyRootFilesystem: true\n    ```", "```\n           resources:\n              requests:\n                cpu: 10m\n                memory: 20M\n              limits:\n                cpu: 20m\n                memory: 30Mi\n    ```", "```\n    apiVersion: v1\n    kind: Service\n    metadata:\n      name: app\n    spec:\n      selector:\n        app: simplestlab\n        component: app\n      ports:\n        - protocol: TCP\n          port: 3000\n          targetPort: 3000\n    ```", "```\n    PS Chapter9> kubectl create -f .\\app.deployment.yaml `\n    -f .\\app.service.yaml\n    deployment.apps/app created\n    service/app created\n    PS Chapter9> kubectl get pods\n    NAME                  READY   STATUS    RESTARTS   AGE\n    db-0                  1/1     Running   0          96s\n    app-585f8bb87-r8dqh   1/1     Running   0          41s\n    app-585f8bb87-wsfm7   1/1     Running   0          41s\n    configMap with these special configurations for NGINX; you will find it as Chapter9/ lb.configmap.yaml. This configuration will allow us to run as user 101 (nginx). We created this configMap before the actual DaemonSet; although it is possible to do the opposite, it is important to understand the requirements and prepare them before the workload deployment. This configuration allows us to run NGINX as non-root on a port greater than 1024 (system ports). We will use port 8080 to publish the loadbalancer component.Notice that we added a `proxy_pass` sentence to reroute the requests for `/` to `http://app:3000`, where `app` is the Service’s name, resolved via internal DNS. We will use `/healthz` to check the container’s healthiness.\n    ```", "```\n    apiVersion: apps/v1\n    kind: DaemonSet\n    metadata:\n      name: lb\n      labels:\n        component: lb\n        app: simplestlab\n            image: docker.io/nginx:alpine\n            ports:\n            - containerPort: 8080\n            securityContext:\n              readOnlyRootFilesystem: true\n            volumeMounts:\n            - name: cache\n              mountPath: /var/cache/nginx\n            - name: tmp\n              mountPath: /tmp/nginx\n            - name: conf\n              mountPath: /etc/nginx/nginx.conf\n              subPath: nginx.conf\n    ...\n          volumes:\n          - name: cache\n            emptyDir: {}\n          - name: tmp\n            emptyDir: {}\n          - name: conf\n            configMap:\n              name: lb-config\n    ```", "```\n             securityContext:\n                runAsNonRoot: true\n                runAsUser: 101\n                runAsGroup: 101\n        ```", "```\n               securityContext:\n                  readOnlyRootFilesystem: true\n        ```", "```\n    apiVersion: v1\n    kind: Service\n    metadata:\n      name: lb\n    spec:\n      type: NodePort\n      selector:\n        app: simplestlab\n        component: lb\n      ports:\n        - protocol: TCP\n          port: 80\n          targetPort: 8080\n          nodePort: 32000\n    ```", "```\n    PS Chapter9> kubectl create -f .\\lb.configmap.yaml\n    configmap/lb-config created\n    PS Chapter9> kubectl create -f .\\lb.daemonset.yaml\n    daemonset.apps/lb created\n    PS Chapter9> kubectl create -f .\\lb.service.yaml\n    32000. Your browser should access the application and show something like this (if you’re using Docker Desktop, you will need to use http://localhost:32000):\n    ```"]