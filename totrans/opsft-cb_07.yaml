- en: Chapter 7. OpenShift for Java Developers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章：OpenShift for Java 开发者
- en: 'This chapter presents a number of recipes that show you how to get started
    with Java web application development on OpenShift. You will learn how to create
    and deploy **Java Enterprise Edition** (**Java EE**) applications on OpenShift
    using the JBoss EAP 6 and JBoss AS 7 application server cartridges. This chapter
    will also cover how to develop and host your Spring Framework applications on
    the Tomcat server. The specific recipes within this chapter are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一些示例，展示如何在 OpenShift 上开始 Java Web 应用程序开发。你将学习如何使用 JBoss EAP 6 和 JBoss AS
    7 应用程序服务器组件，在 OpenShift 上创建和部署**Java 企业版** (**Java EE**) 应用程序。本章还将涵盖如何在 Tomcat
    服务器上开发和托管 Spring 框架应用程序。本章的具体示例如下：
- en: Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JBoss EAP 和 PostgreSQL 9.2 组件创建并部署 Java EE 6 应用程序
- en: Configuring application security by defining the database login module in standalone.xml
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在 standalone.xml 中定义数据库登录模块来配置应用程序安全性
- en: Installing modules with JBoss cartridges
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JBoss 组件安装模块
- en: Managing JBoss cartridges using the management web interface and CLI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用管理 Web 界面和 CLI 管理 JBoss 组件
- en: Creating and deploying Spring applications using the Tomcat 7 cartridge
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Tomcat 7 组件创建并部署 Spring 应用程序
- en: Taking thread dumps of Java cartridges
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取 Java 组件的线程转储
- en: Choosing between Java 6 and Java 7
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Java 6 和 Java 7 之间进行选择
- en: Enabling hot deployment for Java applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Java 应用程序启用热部署
- en: Skipping the Maven build
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳过 Maven 构建
- en: Forcing a clean Maven build
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制进行干净的 Maven 构建
- en: Overriding the default Maven build command
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重写默认的 Maven 构建命令
- en: Installing the JAR file not present in the Maven central repository
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装在 Maven 中央仓库中没有的 JAR 文件
- en: Developing OpenShift Java applications using Eclipse
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Eclipse 开发 OpenShift Java 应用程序
- en: Using Eclipse System Explorer to SSH into the application gear
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Eclipse 系统资源管理器通过 SSH 连接到应用程序设备
- en: Debugging Java applications in the Cloud
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在云中调试 Java 应用程序
- en: Introduction
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter will explore how Java developers can get started with OpenShift
    to develop Java EE or Spring applications. Java is often thought of as the de
    facto open source, enterprise programming language. OpenShift supports the JBoss
    application server, which is a certified platform for Java EE 6 development. As
    an OpenShift Online user, you have access to both the community version of JBoss
    and commercial JBoss EAP 6 for free. The *Creating and deploying Java EE 6 applications
    using the JBoss EAP and PostgreSQL 9.2 cartridges* recipe will cover how to develop
    and deploy Java EE 6 applications on OpenShift. There is also a community-supported
    cartridge for WildFly, a certified Java EE 7 application server that you can use
    to deploy Java EE 7 applications. This chapter will not cover the WildFly cartridge.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨 Java 开发者如何使用 OpenShift 开始开发 Java EE 或 Spring 应用程序。Java 通常被认为是事实上的开源企业编程语言。OpenShift
    支持 JBoss 应用程序服务器，这是 Java EE 6 开发的认证平台。作为 OpenShift Online 用户，你可以免费使用 JBoss 社区版和商业版
    JBoss EAP 6。*使用 JBoss EAP 和 PostgreSQL 9.2 组件创建并部署 Java EE 6 应用程序* 的示例将展示如何在 OpenShift
    上开发和部署 Java EE 6 应用程序。此外，OpenShift 还支持 WildFly 组件，这是一个认证的 Java EE 7 应用程序服务器，你可以使用它来部署
    Java EE 7 应用程序。本章不会讨论 WildFly 组件。
- en: 'A popular alternative to Java EE development is Spring Framework. Spring developers
    normally use Apache Tomcat to host their applications. OpenShift supports two
    versions of Tomcat: Apache Tomcat 6 and Apache Tomcat 7\. The *Creating and deploying
    Spring applications using the Tomcat 7 cartridge* recipe will cover how to develop
    a Spring application and deploy it on OpenShift. Also, it is possible to run Apache
    Tomcat 8 (currently in beta) on OpenShift. You can read my blog to learn how to
    deploy Apache Tomcat 8 on OpenShift at [https://www.openshift.com/blogs/how-to-run-apache-tomcat-8-on-openshift](https://www.openshift.com/blogs/how-to-run-apache-tomcat-8-on-openshift).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流行的 Java EE 开发替代方案是 Spring 框架。Spring 开发者通常使用 Apache Tomcat 来托管他们的应用程序。OpenShift
    支持两个版本的 Tomcat：Apache Tomcat 6 和 Apache Tomcat 7。*使用 Tomcat 7 组件创建并部署 Spring 应用程序*
    的示例将展示如何开发一个 Spring 应用程序并将其部署到 OpenShift。同时，OpenShift 也可以运行 Apache Tomcat 8（目前处于测试阶段）。你可以阅读我的博客，了解如何在
    OpenShift 上部署 Apache Tomcat 8，链接：[https://www.openshift.com/blogs/how-to-run-apache-tomcat-8-on-openshift](https://www.openshift.com/blogs/how-to-run-apache-tomcat-8-on-openshift)。
- en: OpenShift uses Apache Maven to manage dependencies and build your OpenShift
    apps. All OpenShift Java applications are Maven-based applications. This chapter
    assumes that you are familiar with Apache Maven. In the event that you are not
    comfortable with Maven, then please refer to the documentation at [http://maven.apache.org/guides/getting-started/index.html](http://maven.apache.org/guides/getting-started/index.html).
    This chapter will cover various aspects of using Apache Maven with OpenShift,
    such as how to use your own JARs (not hosted on the Maven central repository)
    with OpenShift, and so on. OpenShift also allows you to use other build tools,
    such as Apache Ant and Gradle. Please refer to my blogs on Apache Ant ([https://www.openshift.com/blogs/running-ant-builds-on-openshift](https://www.openshift.com/blogs/running-ant-builds-on-openshift))
    and Gradle ([https://www.openshift.com/blogs/run-gradle-builds-on-openshift](https://www.openshift.com/blogs/run-gradle-builds-on-openshift))
    to learn how to use them with OpenShift applications.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Almost all Java developers use an IDE to build their applications. OpenShift
    has first-class support for the Eclipse IDE. The *Developing OpenShift Java applications
    using Eclipse* recipe will walk you through a step-by-step process of creating
    and managing an application from within Eclipse. You can even SSH into the application
    gear from within Eclipse. This will be covered in the *Using Eclipse System Explorer
    to SSH into the application gear* recipe.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to run the examples on your local machine, then please install
    Java 7, Apache Maven, and Eclipse. The instructions to install Java for your operating
    system can be found at [http://www.java.com/en/download/help/download_options.xml](http://www.java.com/en/download/help/download_options.xml).
    Next, instructions to install Apache Maven can be found here: [http://maven.apache.org/download.cgi#Installation](http://maven.apache.org/download.cgi#Installation).
    Finally, you can install Eclipse on your machine by following the instructions
    mentioned here: [http://wiki.eclipse.org/Eclipse/Installation](http://wiki.eclipse.org/Eclipse/Installation).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is based on the assumption that you know the basics of OpenShift
    application development and database cartridges. In the event that you are not
    comfortable with the basics, I will recommend that you first read [Chapter 3](part0041_split_000.html#page
    "Chapter 3. Creating and Managing Applications"), *Creating and Managing Applications*
    to [Chapter 6](part0079_split_000.html#page "Chapter 6. Using MongoDB and Third-party
    Database Cartridges with OpenShift Applications"), *Using MongoDB and Third-party
    Database Cartridges with OpenShift Applications* before continuing with this chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will develop a simple job portal application that will allow
    users to post job openings for a company. Users can create a company and then
    post jobs for that company. All the source code is on the *OpenShift-Cookbook*
    repository of the GitHub organization at [https://github.com/OpenShift-Cookbook](https://github.com/OpenShift-Cookbook).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gone are the days when Java EE or J2EE (as it was called in the olden days)
    was considered evil. Java EE now provides a very productive environment to build
    web applications. Java EE has embraced convention over configuration and annotations,
    which means that you are no longer required to maintain XML to configure each
    and every component. In this recipe, you will learn how to build a Java EE 6 application
    and deploy it on OpenShift. This recipe assumes that you have basic knowledge
    of Java and Java EE 6\. If you are not comfortable with Java EE 6, please read
    the official tutorial at [http://docs.oracle.com/javaee/6/tutorial/doc/](http://docs.oracle.com/javaee/6/tutorial/doc/).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will build a simple job portal that will allow users to
    post job openings and view a list of all the persisted jobs in the system. These
    two functionalities will be exposed using two REST endpoints.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: The source code for the application created in this recipe is on GitHub at [https://github.com/OpenShift-Cookbook/chapter7-jobstore-javaee6-simple](https://github.com/OpenShift-Cookbook/chapter7-jobstore-javaee6-simple).
    The example application that you will build in this recipe is a simple version
    of the `jobstore` application with only a single domain class and without any
    application interface. You can get the complete `jobstore` application source
    code on GitHub as well at [https://github.com/OpenShift-Cookbook/chapter7-jobstore-javaee6](https://github.com/OpenShift-Cookbook/chapter7-jobstore-javaee6).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will need the `rhc` command-line client installed
    on your machine. Please refer to the *Installing the OpenShift rhc command-line
    client* recipe in [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting
    Started with OpenShift"), *Getting Started with OpenShift*, for details. Also,
    you will need an IDE to work with the application code. The recommended IDE to
    work with OpenShift is Eclipse Luna, but you can also work with other IDEs, such
    as IntelliJ Idea and NetBeans. Download and install the Eclipse IDE for Java EE
    developers from the official website at [https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to create the `jobstore` application:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new command-line terminal, and go to a convenient location. Create a
    new JBoss EAP application by executing the following command:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding command will create a Maven project and clone it to your local
    machine.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the directory to `jobstore`, and execute the following command to add
    the PostgreSQL 9.2 cartridge to the application:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将目录更改为`jobstore`，然后执行以下命令将PostgreSQL 9.2 cartridge添加到应用程序中：
- en: '[PRE1]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Open Eclipse and navigate to the project workspace. Then, import the application
    created in step 1 as a Maven project. To import an existing Maven project, navigate
    to **File**|**Import**|**Maven**|**Existing Maven Projects**. Then, navigate to
    the location of your OpenShift Maven application created in step 1.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Eclipse并导航到项目工作空间。然后，将步骤1中创建的应用程序作为Maven项目导入。要导入现有的Maven项目，请导航至**文件**|**导入**|**Maven**|**现有的Maven项目**。然后，导航到您在步骤1中创建的OpenShift
    Maven应用程序的位置。
- en: 'Next, update `pom.xml` to use Java 7\. The Maven project created by OpenShift
    is configured to use JDK 6\. Replace the properties with the one shown in the
    following code:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新`pom.xml`以使用Java 7。OpenShift创建的Maven项目配置为使用JDK 6。请使用以下代码替换属性：
- en: '[PRE2]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Update the Maven project to allow the changes to take effect. You can update
    the Maven project by right-clicking on the project and navigating to **Maven**|**Update
    Project**.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新Maven项目以使更改生效。可以右键单击项目，然后导航至**Maven**|**更新项目**。
- en: 'Now, let us write the domain classes for our application. Java EE uses JPA
    to define the data model and manage entities. The application has one domain class:
    `Job`. Create a new package called `org.osbook.jobstore.domain`, and then create
    a new Java class called `Job` inside it. Have a look at the following code:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写应用程序的领域类。Java EE使用JPA定义数据模型并管理实体。应用程序有一个领域类：`Job`。创建一个名为`org.osbook.jobstore.domain`的新包，然后在其中创建一个名为`Job`的新Java类。请查看以下代码：
- en: '[PRE3]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a `META-INF` folder at `src/main/resources`, and then create a `persistence.xml`
    file with the following code:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/main/resources`下创建一个`META-INF`文件夹，然后创建一个名为`persistence.xml`的文件，其中包含以下代码：
- en: '[PRE4]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, we will create the `JobService` class that will use the JPA `EntityManager`
    API to work with the database. Create a new package called `org.osbook.jobstore.services`,
    and create a new Java class as shown in the following code. It defines the `save`
    and `findAll` operations on the `Job` entity.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建`JobService`类，该类将使用JPA `EntityManager` API与数据库交互。创建一个名为`org.osbook.jobstore.services`的新包，并创建一个新的Java类，如下所示。它定义了`Job`实体上的`save`和`findAll`操作。
- en: '[PRE5]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, enable **Contexts and Dependency Injection** (**CDI**) in the `jobstore`
    application by creating a file with the name `beans.xml` in the `src/main/webapp/WEB-INF`
    directory as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`jobstore`应用程序中通过在`src/main/webapp/WEB-INF`目录下创建一个名为`beans.xml`的文件来启用**上下文和依赖注入**（**CDI**），如下所示：
- en: '[PRE6]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `jobstore` application will expose the REST JSON web service. Before you
    can write the JAX-RS resources, you have to configure JAX-RS in your application.
    Create a new package called `org.osbook.jobstore.rest` and a new class called
    `RestConfig`, as shown in the following code:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`jobstore`应用程序将公开REST JSON web服务。在编写JAX-RS资源之前，您必须在应用程序中配置JAX-RS。创建一个名为`org.osbook.jobstore.rest`的新包和一个名为`RestConfig`的新类，如下所示：'
- en: '[PRE7]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a JAX-RS resource to expose the `create` and `findAll` operations of
    `JobService` as REST endpoints as follows:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建JAX-RS资源以暴露`JobService`的`create`和`findAll`操作作为REST端点，如下所示：
- en: '[PRE8]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Commit the code, and push it to the OpenShift application as shown in the following
    commands:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示提交代码，并将其推送到OpenShift应用程序中：
- en: '[PRE9]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After the build finishes successfully, the application will be accessible at
    `http://jobstore-{domain-name}.rhcloud.com`. Please replace `domain-name` with
    your own domain name.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建成功完成后，应用程序将在`http://jobstore-{domain-name}.rhcloud.com`上访问。请将`domain-name`替换为您自己的域名。
- en: 'To test the REST endpoints, you can use `curl`. `curl` is a command-line tool
    for transferring data across various protocols. We will use it to test our REST
    endpoints. To create a new job, you will run the following `curl` command:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试REST端点，可以使用`curl`。`curl`是一个用于跨各种协议传输数据的命令行工具。我们将使用它来测试我们的REST端点。要创建一个新作业，您将运行以下`curl`命令：
- en: '[PRE10]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To view all the jobs, you can run the following `curl` command:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看所有作业，可以运行以下`curl`命令：
- en: '[PRE11]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works…
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In the preceding steps, we created a Java EE application and deployed it on
    OpenShift. In step 1, you used the `rhc create-app` command to create a JBoss
    EAP web cartridge application. The `rhc` command-line tool makes a request to
    the OpenShift broker and asks it to create a new application using the JBoss EAP
    cartridge. The anatomy of application creation was explained in the *Creating
    an OpenShift application using the rhc command-line client* recipe in [Chapter
    3](part0041_split_000.html#page "Chapter 3. Creating and Managing Applications"),
    *Creating and Managing Applications*. Every OpenShift web cartridge specifies
    a template application that will be used as the default source code of the application.
    For Java web cartridges (JBoss EAP, JBoss AS7, Tomcat 6, and Tomcat 7), the template
    is a Maven-based application. After the application is created, it is cloned to
    the local machine using Git. The directory structure of the application is shown
    in the following command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see in the preceding command, apart from the `.git` and `.openshift`
    directories, this looks like a standard Maven project. OpenShift uses Maven to
    manage application dependencies and build your Java applications.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take a look at what''s inside the `jobstore` directory to better understand
    the layout of the application:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '**The src directory**: This directory contains the source code for the template
    application generated by OpenShift. You need to add your application source code
    here. The `src` folder helps in achieving source code deployment when following
    the standard Maven directory conventions.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The pom.xml file**: The Java applications created by OpenShift are Maven-based
    projects. So, a `pom.xml` file is required when you do source code deployment
    on OpenShift. This `pom.xml` file has a profile called `openshift`, which will
    be executed when you push code to OpenShift as shown in the following code. This
    profile will create a `ROOT` WAR file based upon your application source code.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**The deployments directory**: You should use this directory if you want to
    do binary deployments on OpenShift, that is, you want to deploy a WAR or EAR file
    directly instead of pushing the source code.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The .git directory**: This is a local Git repository. This directory contains
    the complete history of the repository. The `config` file in`.git/` contains the
    configuration for the repository. It defines a Git remote origin that points to
    the OpenShift application gear SSH URL. This makes sure that when you do `git
    push`, the source code is pushed to the remote Git repository hosted on your application
    gear. You can view the details of the origin Git remote by executing the following
    command:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**The .openshift directory**: This is an OpenShift-specific directory, which
    can be used for the following purposes:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The files under the `action_hooks` subdirectory allow you to hook onto the application
    lifecycle.
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The files under the `config` subdirectory allow you to make changes to the JBoss
    EAP configuration. The directory contains the `standalone.xml` JBoss EAP-specific
    configuration file.
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config`子目录下的文件允许你对JBoss EAP配置进行更改。该目录包含JBoss EAP特定的配置文件`standalone.xml`。'
- en: The files under the `cron` subdirectory are used when you add the cron cartridge
    to your application. This allows you to run scripts or jobs on a periodic basis.
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cron`子目录下的文件在你将cron卡带添加到应用程序时使用。这使得你可以定期运行脚本或作业。'
- en: The files under the `markers` subdirectory allow you to specify whether you
    want to use Java 6 or Java 7 or you want to do hot deploy or debug the application
    running in the Cloud, and so on.
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`markers`子目录下的文件允许你指定是否使用Java 6或Java 7，或者你是否希望进行热部署或调试在云端运行的应用程序等操作。'
- en: In step 2, you added the PostgreSQL 9.2 cartridge to the application using the
    `rhc cartridge-add` command. We will use the PostgreSQL database to store the
    `jobstore` application data. Then, in step 3, you imported the project in the
    Eclipse IDE as a Maven project. Eclipse Kepler has inbuilt support for Maven applications,
    which makes it easier to work with Maven-based applications.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2步中，你使用`rhc cartridge-add`命令将PostgreSQL 9.2卡带添加到应用程序中。我们将使用PostgreSQL数据库来存储`jobstore`应用程序的数据。接着，在第3步中，你将项目作为Maven项目导入到Eclipse
    IDE中。Eclipse Kepler内置对Maven应用程序的支持，这使得使用基于Maven的应用程序更加方便。
- en: From step 3 through step 5, you updated the project to use JDK 1.7 for the Maven
    compiler plugin. All the OpenShift Java applications use OpenJDK 7, so it makes
    sense to update the application to also use JDK 1.7 for compilation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从第3步到第5步，你更新了项目，以使用JDK 1.7作为Maven编译插件的编译器。所有的OpenShift Java应用程序都使用OpenJDK 7，因此更新应用程序以使用JDK
    1.7进行编译是合乎逻辑的。
- en: In step 6, you created the `job` domain class and annotated it with JPA annotations.
    The `@Entity` annotation marks the class as a JPA entity. An entity represents
    a table in the relational database, and each entity instance corresponds to a
    row in the table. Entity class fields represent the persistent state of the entity.
    You can learn more about JPA by reading the official documentation at [http://docs.oracle.com/javaee/6/tutorial/doc/bnbpz.html](http://docs.oracle.com/javaee/6/tutorial/doc/bnbpz.html).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6步中，你创建了`job`领域类并使用JPA注解对其进行了标注。`@Entity`注解将该类标记为JPA实体类。实体类表示关系型数据库中的一张表，每个实体实例对应表中的一行。实体类的字段表示实体的持久化状态。你可以通过阅读[http://docs.oracle.com/javaee/6/tutorial/doc/bnbpz.html](http://docs.oracle.com/javaee/6/tutorial/doc/bnbpz.html)上的官方文档，了解更多关于JPA的内容。
- en: The `@NotNull` and `@Size` annotation marks are Bean Validation annotations.
    Bean Validation is a new validation model available as a part of the Java EE 6
    platform. The `@NotNull` annotation adds a constraint that the value of the field
    must not be null. If the value is null, an exception will be raised. The `@Size`
    annotation adds a constraint that the value must match the specified minimum and
    maximum boundaries. You can learn more about Bean Validation by reading the official
    documentation at [http://docs.oracle.com/javaee/6/tutorial/doc/gircz.html](http://docs.oracle.com/javaee/6/tutorial/doc/gircz.html).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`@NotNull`和`@Size`注解是Bean验证注解。Bean验证是Java EE 6平台中的一种新验证模型。`@NotNull`注解添加了一个约束，要求字段的值不能为空。如果值为null，则会引发异常。`@Size`注解添加了一个约束，要求值符合指定的最小值和最大值边界。你可以通过阅读[http://docs.oracle.com/javaee/6/tutorial/doc/gircz.html](http://docs.oracle.com/javaee/6/tutorial/doc/gircz.html)上的官方文档，了解更多关于Bean验证的内容。'
- en: 'In JPA, entities are managed within a persistence context. Within the persistence
    context, the entity manager manages the entities. The configuration of the entity
    manager is defined in a standard configuration XML file called `persitence.xml`.
    In step 7, you created the `persistence.xml` file. The most important configuration
    option is the `jta-datasource-source` configuration tag. It points to `java:jboss/datasources/PostgreSQLDS`.
    When a user creates a JBoss EAP 6 application, then OpenShift defines a PostgreSQL
    datasource in the `standalone.xml` file. The `standalone.xml` file is a JBoss
    configuration file, which includes the technologies required by the Java EE 6
    full profile specification plus Java Connector 1.6 architecture, Java XML API
    for RESTful web services, and OSGi. Developers can override the configuration
    by making changes to the `standalone.xml` file in the `.openshift/config` location
    of your application directory. So, if you open the `standalone.xml` file in `.openshift/config/`
    in your favorite editor, you will find the following PostgreSQL datasource configuration:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In step 8, you created stateless **Enterprise JavaBeans** (**EJBs**) for our
    application service layer. The service classes work with the `EntityManager` API
    to perform operations on the `Job` entity.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: In step 9, you configured CDI by creating the `beans.xml` file in the `src/main/webapp/WEB-INF`
    directory. We are using CDI in our application so that we can use dependency injection
    instead of manually creating the objects ourselves. The CDI container will manage
    the bean life cycle, and the developer just has to write the business logic. To
    let the JBoss application server know that we are using CDI, we need to create
    a file called `beans.xml` in our `WEB-INF` directory. The file can be completely
    blank, but its presence tells the container that the CDI framework needs to be
    loaded.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: In step 10 and step 11, you configured JAX-RS and defined the REST resources
    for the `Job` entity. You activated JAX-RS by creating a class that extends `javax.ws.rs.ApplicationPath`.
    You need to specify the base URL under which your web service will be available.
    This is done by annotating the `RestConfig` class with the `ApplicationPath` annotation.
    You used `/api/v1` as the application path.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: In step 12, you added and committed the changes to the local repository and
    then pushed the changes to the application gear. After the bits are pushed, OpenShift
    will stop all the cartridges and then invoke the `mvn -e clean package -Popenshift
    -DskipTests` command to build the project. Maven will build a `ROOT.war` file,
    which will be copied to the JBoss EAP `deployments` folder. After the build successfully
    finishes, all the cartridges are started. Then the new updated `ROOT.war` file
    will be deployed. You can view the running application at `http://jobstore-{domain-name}.rhcloud.com`.
    Please replace `{domain-name}` with your account domain name.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you tested the REST endpoints using `curl` in step 14.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can perform all the aforementioned steps with just a single command as
    follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: See also
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Configuring application security by defining the database login module
    in standalone.xml* recipe
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Managing JBoss cartridges using the management web interface and CLI* recipe
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring application security by defining the database login module in standalone.xml
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the *Creating and deploying Java EE 6 applications using the JBoss EAP and
    PostgreSQL 9.2 cartridges* recipe, you learned how to develop a Java EE 6 application
    on OpenShift. The application allows you to create company entities and then assign
    jobs to them. The problem with the application is that it is not secured. The
    Java EE specification defines a simple, role-based security model for EJBs and
    web components. JBoss security is an extension to the application server and is
    included by default with your OpenShift JBoss applications. You can view the extension
    in the JBoss `standalone.xml` configuration file. The `standalone.xml` file exists
    in the `.openshift/config` location. The following code shows the extension:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: OpenShift allows developers to update the `standalone.xml` configuration file
    to meet their application needs. You make a change to the `standalone.xml` configuration
    file, commit the change to the local Git repository, then push the changes to
    the OpenShift application gear. Then, after the successful build, OpenShift will
    replace the existing `standalone.xml` file with your updated configuration file
    and then finally start the server. But please make sure that your changes are
    valid; otherwise, the application will fail to start.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to define the database login module in `standalone.xml`
    to authenticate users before they can perform any operation with the application.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The source code for the application created in this recipe is on GitHub at [https://github.com/OpenShift-Cookbook/chapter7-jobstore-security](https://github.com/OpenShift-Cookbook/chapter7-jobstore-security).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe builds on the application created in the *Creating and deploying
    Java EE 6 applications using the JBoss EAP and PostgreSQL 9.2 cartridges* recipe.
    So, please refer to that recipe before continuing with this recipe.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to add security to your web application:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the OpenShift application created in the *Creating and deploying Java
    EE 6 applications using the JBoss EAP and PostgreSQL 9.2 cartridges* recipe using
    the following command:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After the application creation, SSH into the application gear, and connect
    with the PostgreSQL database using the `psql` client. Then, create the following
    tables and insert the test data:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Exit from the SSH shell, and open the `standalone.xml` file in the`.openshift/config`
    directory. Update the security domain with the following code:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create the web deployment descriptor (that is, `web.xml`) in the `src/main/webapp/WEB-INF`
    folder. Add the following content to it:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create the `login.html` file in the `src/main/webapp` directory. The `login.html`
    page will be used for user authentication. The following code shows the contents
    of this file:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create an `error.html` file in the `src/main/webapp` directory. The `error.html`
    page will be shown after unsuccessful authentication. The following code shows
    the contents of this file:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Commit the changes, and push them to the OpenShift application gear:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Go to the application page at `http://jobstore-{domain-name}.rhcloud.com`, and
    you will be asked to log in before you can view the application. Use `admin@jobstore.com/admin`
    as the username-password combination to log in to the application.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s now understand what you did in the preceding steps. In step 1, you recreated
    the `jobstore` application we developed in the *Creating and deploying Java EE
    6 applications using the JBoss EAP and PostgreSQL 9.2 cartridges* recipe. Next,
    in step 2, you performed an SSH into the application gear and created the `USERS`
    and `USER_ROLES` tables. These tables will be used by the JBoss database login
    module to authenticate users. As our application does not have the user registration
    functionality, we created a default user for the application. Storing the password
    as a clear text string is a bad practice, so we have stored the MD5 hash of the
    password. The MD5 hash of the `admin` password is `ISMvKXpXpadDiUoOSoAfww==`.
    If you want to generate the hashed password in your application, I have included
    a simple Java class, which uses `org.jboss.crypto.CryptoUtil` to generate the
    MD5 hash of any string. The `CryptoUtil` class is part of the `picketbox` library.
    The following code depicts this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In step 3, you logged out of the SSH session and updated the `standalone.xml`
    JBoss configuration file with the database login module configuration. There are
    several login module implementations available out of the box. This book will
    only talk about the database login module, as discussing all the modules is outside
    the scope of this book. You can read about all the login modules at [https://docs.jboss.org/author/display/AS7/Security+subsystem+configuration](https://docs.jboss.org/author/display/AS7/Security+subsystem+configuration).
    The database login module checks the user credentials against a relational database.
    To configure the database login module, you have to specify a few configuration
    options. The `dsJndiName` option is used to specify the application datasource.
    As we are using a configured PostgreSQL datasource for our application, you specified
    the same `dsJndiName` option value. Next, you have to specify the SQL queries
    to fetch the user and its roles. Then, you have specified that the password will
    be hashed against an MD5 hash algorithm by specifying the `hashAlgorithm` configuration.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: In step 4, you applied the database login module to the `jobstore` application
    by defining the security constraints in `web.xml`. This configuration will add
    a security constraint on all the web resources of the application that will restrict
    access to authenticated users with role admin. You have also configured your application
    to use FORM-based authentication. This will make sure that when unauthenticated
    users visit the website, they will be redirected to the `login.html` page created
    in step 5\. If the user enters a wrong e-mail/password combination, then they
    will be redirected to the `error.html` page created in step 6.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in step 7, you committed the changes to the local Git repository and
    pushed the changes to the application gear. OpenShift will make sure that the
    JBoss EAP application server uses the updated `standalone.xml` configuration file.
    Now, the user will be asked to authenticate before they can work with the application.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges* recipe
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Installing modules with JBoss cartridges* recipe
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Managing JBoss cartridges using the management web interface and CLI* recipe
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing modules with JBoss cartridges
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From version 7 of the JBoss application server, class loading is based on the
    JBoss Modules project. In this recipe, you will learn how to install the `Twitter4J`
    library as a module on the JBoss EAP 6 cartridge. The `modules` directory under
    the JBoss server home houses all the modules installed on the application server.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: The source code for the application created in this recipe is on GitHub at [https://github.com/OpenShift-Cookbook/chapter7-recipe4](https://github.com/OpenShift-Cookbook/chapter7-recipe4).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe builds on the application created in the *Creating and deploying
    Java EE 6 applications using the JBoss EAP and PostgreSQL 9.2 cartridges* recipe.
    So, please refer to that recipe before continuing with this recipe.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to install the `Twitter4J` library as a module:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the OpenShift application created in the *Creating and deploying Java
    EE 6 applications using the JBoss EAP and PostgreSQL 9.2 cartridges* recipe using
    the following command:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To install a new module, you have to create the module path under the `.openshift/config/modules`
    directory as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Download the `twitter4j-core` library from [http://mvnrepository.com/artifact/org.twitter4j/twitter4j-core/3.0.5](http://mvnrepository.com/artifact/org.twitter4j/twitter4j-core/3.0.5),
    and place it under the `.openshift/config/modules/org/twitter4j/main` directory.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, in the `main` folder, add a file named `module.xml`. This file contains
    the actual module definition as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, to use this module in your application, you have to first add its dependency
    in your `pom.xml` file. Make sure that the scope is provided, as the server will
    already have this dependency since you are adding it as a module:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Secondly, you have to update the Maven WAR plugin configuration by adding the
    `org.twitter4j` module dependency in the `META-INF/MANIFEST.MF` location:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Finally, commit the changes, and push them to the application gear. Now, after
    the server restarts, JBoss will have the `twitter4j` library as a module.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding steps, you learned how to install a third-party library as
    a module. The alternative to using a third-party library is to add a compile scope
    dependency in `pom.xml` and then use the `twitter4j` library in your application.
    The advantage of using a module is that you do not have to bundle the JAR file
    with your application archive. If you are deploying multiple applications on a
    single server instance, then the server will only need one copy of the JAR file.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: After creating the application in step 1, you created a directory structure
    required to define a module inside the`.openshift/config` directory in step 2\.
    This directory is added to the module path of the JBoss EAP server associated
    with your OpenShift application. It has the same structure as the standard JBoss
    EAP `modules` directory. Inside `org.twitter4j.main`, you placed the `twitter4j-core-3.0.5.jar`
    file in step 3\. In step 4, you created a file called `module.xml` inside the
    `org.twitter4j.main` directory. The `module.xml` file is used to define a module
    and its dependencies. The module name `org.twitter4j` corresponds to the module
    attribute that you will define in your application manifest. Next, you need to
    state the path to the `twitter4j-core` library and finally, its dependencies.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Next, in step 5, you added a provided scope dependency to the `twitter4j-core`
    library. The provided scope indicated that you expect the application container
    to provide the dependency at runtime. Also, provided dependencies are not packaged
    with web applications. This makes sure that the application archives are smaller
    in size and the application deploys faster. Also, in step 5, you updated the Maven
    WAR plugin configuration to add a dependency on the `org.twitter4j` module to
    the application archive `META-INF/MANIFEST.MF` file.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: In step 6, you committed the changes and pushed them to the application gear.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, I have not covered how to use the `Twitter4J` library. If you
    want to see `Twitter4J` in action, I have created an application for you, which
    will tweet after posting a job. To use the application, you have to first create
    a Twitter application. Go to [https://dev.twitter.com](https://dev.twitter.com),
    and create a new Twitter application. Give the application the read-and-write
    level access. Once you are done, create a new OpenShift application by running
    the following command. Please replace the environment variable values with your
    Twitter application values. You can find these values under the Twitter application's
    **API Keys** section.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: After the application is successfully created, a tweet will be sent after every
    job posting.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges* recipe
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Managing JBoss cartridges using the management web interface and CLI* recipe
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing JBoss cartridges using the management web interface and CLI
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JBoss provides three different ways to manage the server: a web interface,
    a command-line client, and the XML configuration files. In this recipe, you will
    learn how to deploy WAR files to your JBoss cartridge using the web management
    interface and JBoss CLI.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will need to have the JBoss application server
    binary on your local machine. This is required to connect with the JBoss cartridge
    using `jboss-cli`. Download the JBoss AS7 binary from the official website at
    [http://www.jboss.org/jbossas/downloads](http://www.jboss.org/jbossas/downloads).
    Extract the ZIP file, and you will find the `jboss-cli` script in the `bin` folder.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use the `jobstore` application that we created in the
    *Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges* recipe.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new command-line terminal, and navigate to the directory where the `jobstore`
    application is located. Run the `rhc port-forward` command to forward the remote
    ports on your local machine:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Open the management interface at `http://127.0.0.1:9990` in your favorite web
    browser. This information is available in the output of the `rhc port-forward`
    command.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this recipe, we will deploy the WAR file of the application we created in
    the *Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges* recipe using the JBoss management interface. Download the WAR
    file from [https://github.com/OpenShift-Cookbook/chapter7-recipe5/raw/master/ROOT.war](https://github.com/OpenShift-Cookbook/chapter7-recipe5/raw/master/ROOT.war)
    to your local machine.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After downloading the WAR file, navigate to **Runtime** | **Manage Deployments**,
    and remove the existing `ROOT.war` file by clicking on the **Remove** button as
    shown in the following screenshot. It will ask you to confirm the removal, and
    you can click on the **OK** button. Have a look at the following screenshot:![How
    to do it…](img/00062.jpeg)
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To deploy the WAR file, click on the **Add** button, and then upload the `ROOT.war`
    file from your local machine. After uploading the WAR file, you will be asked
    to verify the deployment name. Choose the default values, and click on the **Save**
    button as shown in the following screenshot:![How to do it…](img/00063.jpeg)
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uploading the WAR file does not initiate the deployment. You have to click on
    the **En/Disable** button to initiate the deployment. You will be asked to confirm
    your decision. Click on the **Confirm** button as shown in the following screenshot:![How
    to do it…](img/00064.jpeg)
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, if you go to `http://myapp-{domain-name}.rhcloud.com`, you will see your
    application deployed.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Another way to deploy an application is via the `jboss-cli` command-line interface.
    The `jboss-cli` script can be found in your local downloaded JBoss archive `bin`
    folder. Launch the `jboss-cli` client, and you will see the message shown in the
    following command:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To connect to the JBoss cartridge, type the `connect` command as follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, you can check the deployed applications using the `deploy` command. Type
    `deploy`, and then press *Enter*:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As you can see in the preceding command, `ROOT.war` is currently deployed.
    This WAR file was deployed using the web interface. To withdraw this WAR file,
    type the `undeploy` command:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, if you go to `http://myapp-{domain-name}.rhcloud.com`, you will get a 404
    error as the application is not deployed.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To deploy the application using `jboss-cli`, you can use the `deploy` command
    as shown in the following command line. Please make sure you have downloaded the
    application `ROOT.war` file as discussed in step 3\. Have a look at the following
    command:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Finally, you can see the application running at `http://myapp-{domain-name}.rhcloud.com`.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding steps, you learned how to manage your application deployment
    from the JBoss web management and command-line interface. In step 1, you ran the
    `rhc port-forward` command to enable SSH port forwarding. The `rhc port-forward`
    command forwarded all the remote ports running on the application gear to your
    local machine. In the output of the `rhc port-forward` command, you can see that
    the management interface is exposed on port `9090`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'From step 3 through step 5, you saw how to connect with the web interface from
    your local machine and undeploy the existing `ROOT.war` file. The web interface
    is a **Google Web Toolkit** (**GWT**) application accessible on port `9090`. Google
    Web Toolkit is an open source set of tools that allows Java developers to write
    complex JavaScript-based web applications in Java. OpenShift only exposes port
    `8080` to the outside world; all other ports are internal to the application gear
    and can only be connected via port forwarding. This is a secure setup as no one
    from the outside world will be able to connect with your application web management
    interface, because the `rhc port-forward` command will only work if their SSH
    keys are uploaded. The web console is divided into two main tabs: the **Profile**
    and the **Runtime** tab. The **Profile** tab gives access to all the subsystem
    configurations. You can edit the configuration without fiddling with XML. For
    example, you can go to `http://127.0.0.1:9990/console/App.html#datasources` to
    edit the `datasource` configuration. The **Runtime** tab can be used to manage
    application deployment, and you used it to undeploy the WAR file in step 5\. You
    can learn more about the management interface from the documentation at [https://docs.jboss.org/author/display/AS7/Admin+Guide](https://docs.jboss.org/author/display/AS7/Admin+Guide).'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: In step 6, you uploaded the `ROOT.war` file to your JBoss cartridge. After upload,
    the deployment is listed in the **Deployments** table. The WAR file is not deployed
    by default; you have to click on the **En/Disable** button to enable the deployment
    of the application as you did in step 7.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to deploy an application is using the `jboss-cli` command-line
    interface. In step 9, you launched the `jboss-cli` script. The `jboss-cli` console
    provides a built-in autocomplete feature using the *Tab* key. At any point in
    time, you can list all the available commands using the *Tab* key as shown in
    the following command. For brevity, only part of the output is shown:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In step 9, you undeployed the existing `ROOT.war` file using the `undeploy`
    command. The `undeploy` command takes the application that is already deployed
    as an argument. Finally, in step 10, you deployed the `ROOT.war` file on your
    local machine to the JBoss cartridge running on OpenShift using the `deploy` command.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Configuring application security by defining the database login module
    in standalone.xml* recipe
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Installing modules with JBoss cartridges* recipe
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and deploying Spring applications using the Tomcat 7 cartridge
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Framework is a very popular alternative to Java EE web development.
    Java developers around the world use Spring Framework to build their enterprise
    applications. Spring Framework is often thought of as a lightweight alternative
    to Java EE, and Java developers normally use a lightweight web container, such
    as Apache Tomcat, for deployment. At the time of this writing, OpenShift supports
    two versions of Apache Tomcat: Apache Tomcat 6 and Apache Tomcat 7\. They are
    shown using the following command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this recipe, you will learn how to develop a simple Spring Framework application
    from scratch using OpenShift's Tomcat 7 cartridge. The application exposes a REST
    endpoint. When a user makes an HTTP request to `/api/v1/ping`, then the applicaton
    will return a JSON response with the message `It works`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: The source code for the application created in this recipe is on GitHub at [https://github.com/OpenShift-Cookbook/chapter7-jobstore-spring](https://github.com/OpenShift-Cookbook/chapter7-jobstore-spring).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will need the `rhc` command-line client installed
    on your machine. Please refer to the *Installing the OpenShift rhc command-line
    client* recipe in [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting
    Started with OpenShift"), *Getting Started with OpenShift*, for details.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to create an application using Spring Framework:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new command-line terminal, and go to a convenient location. Create a
    new Tomcat 7 and MySQL 5.5 application by executing the following commands:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The preceding command will create a Maven-based project and clone it to your
    local machine.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open Eclipse and navigate to the project workspace. Then, import the application
    created in step 1 as a Maven application. To import an existing Maven project,
    navigate to **File**|**Import**|**Maven**|**Existing Maven Projects**. Then browse
    to the location of your OpenShift Maven application created in step 1.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, update `pom.xml` to use Java 7\. The Maven project created by OpenShift
    is configured to use JDK 6\. Replace the properties with the one shown in the
    following code:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Update the Maven project to allow the changes to take effect. You can update
    the Maven project by right-clicking on the project and navigating to **Maven**|**Update
    Project**.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add Spring Maven dependencies to your `pom.xml` file. These are the minimum
    dependencies that you need to write a REST JSON web service using Spring Framework.
    The code is as follows:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create a new package called `org.myapp.config`, and create a new class named
    `WebMvcConfig`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create another configuration class in the `org.myapp.config` package. This
    `@Configuration` class will be used for defining application beans, such as `datasource`,
    and so on. This will be covered later in this recipe. The code is as follows:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'From Servlet 3.0 onwards, the `web.xml` deployment descriptor is optional.
    Prior to Servlet 3.0, we configured the Spring MVC dispatcher servlet in `web.xml`,
    but now we can programmatically configure it using `WebApplicationInitializer`.
    Create a new class called `JobStoreWebApplicationInitializer` in the `org.myapp.config`
    package as follows:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, we will create a simple REST resource called `PingResource`. `PingResource`
    will be invoked when a request is made to `/api/v1/ping` and will respond with
    a JSON message. Create a new class called `PingResource` in the `org.myapp.rest`
    package. Have a look at the following code:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Also, create another class called `PingResponse` as shown in the following
    code:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Commit the changes and push them to the OpenShift application gear as follows:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You can test the `PingResource` using a command-line tool, such as `curl`,
    or by opening the `http://myapp-{domain-name}.rhcloud.com/api/v1/ping` location
    in your favorite browser. You should see the following JSON message:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works…
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding steps, we created a Spring application and deployed it to
    OpenShift. In step 1, you used the `rhc create-app` command to create Apache Tomcat
    7 MySQL 5.5\. Every OpenShift web cartridge specifies a template application that
    will be used as the default source code of the application. For Java-based web
    cartridges, such as JBoss EAP, JBoss AS7, Tomcat 6, and Tomcat 7, the template
    is a Maven-based application. After the application is created, the template application
    is cloned to the local machine using Git. The directory structure of the application
    is shown in the following command:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As you can see in the preceding command-line output, apart from the`.git` and
    `.openshift` directories, this looks like a standard Maven project. OpenShift
    uses Maven for managing application dependencies and building your Java applications.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: The directory structure was explained in the *Creating and deploying Java EE
    6 applications using the JBoss EAP and PostgreSQL 9.2 cartridges* recipe. Please
    refer to the recipe to get an understanding of the directory structure.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: From step 3 through step 5, you made a few changes in `pom.xml`. You updated
    the project to use JDK 1.7 for the Maven compiler plugin. All the OpenShift Java
    applications use OpenJDK 7, so it makes sense to update the application to also
    use JDK 1.7 for compilation. Another change you made to `pom.xml` is that you
    updated the Maven WAR plugin configuration not to fail the build if `web.xml`
    is not found. Next, you added the Spring Web MVC dependencies to `pom.xml`. The
    Servlet 3.1.0 is provided, as this should exist in Apache Tomcat 7\. The `jackson-databind`
    dependency is added to convert Java objects to JSON.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'From step 6 through step 8, you configured the Spring Web MVC framework programmatically.
    Normally, we configure the Spring Web MVC dispatcher servlet in `web.xml`, but
    now, we can programmatically configure it using `WebApplicationInitializer`. From
    Spring 3.1, Spring provides an implementation of the `ServletContainerInitializer`
    interface called `SpringServletContainerInitializer`. The `SpringServletContainerInitializer`
    class delegates to an implementation of `org.springframework.web.WebApplicationInitializer`
    that you provide. There is just one method that you need to implement: `WebApplicationInitializer#onStartup(ServletContext)`.
    You are handed the `ServletContext` parameter that you need to initialize.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: From step 9 through step 11, you created a simple REST JSON resource called
    `PingResource` using Spring MVC. `PingResource` is available at the`/api/v1/ping`
    URL as defined using the `@RequestMapping` annotation.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can perform all the preceding steps with just the following single command:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: See also
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Taking thread dumps of Java cartridges* recipe
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking thread dumps of Java cartridges
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to take thread dumps of your Java cartridge
    applications. A thread dump lists all the Java threads that are currently active
    in a **Java Virtual Machine** (**JVM**). It can help you understand the state
    of every thread in the JVM at a particular point in time. It gives you a snapshot
    of exactly what's executing at a moment in time. Thread dumps are very useful
    to debug a deadlock condition or to understand resource usage.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This command will work with all the four supported Java cartridges (Apache Tomcat
    6, Apache Tomcat 7, JBoss AS7, and JBoss EAP).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe will request for a thread dump of the application created in the
    *Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges* recipe. So, please refer to the aforementioned recipe before continuing
    with this recipe.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to take a thread dump of your Java application:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Open a new command-line terminal, and navigate to the directory where the `jobstore`
    application is located.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To take a thread dump of the `jobstore` application, run the following command:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works…
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you run the `rhc threaddump` command, the JBoss EAP cartridge initiates
    a thread dump. It first gets the process ID of the JBoss application server and
    then runs the `kill -3 <process id>` command. The `kill -3` command sends the
    `HUP` or `BREAK` signal to the Java process. The thread dump log will be placed
    in the `jbosseap.log` file in `$OPENSHIFT_LOG_DIR/`, which you can download on
    your local machine for analysis. You can also view the logfile using the `rhc
    tail` command, as mentioned in the following command output:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To download the thread dump file on your local machine, you can use the `rhc
    scp` command. The `rhc scp` command can be used to transfer files to and from
    your applications using SCP ([http://en.wikipedia.org/wiki/Secure_copy](http://en.wikipedia.org/wiki/Secure_copy)).
    Run the following command to download the `jbosseap.log` file:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now, you can use tools, such as samurai ([http://yusuke.homeip.net/samurai/en/index.html](http://yusuke.homeip.net/samurai/en/index.html)),
    to analyze the thread dump on your local machine.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also take a thread dump of the Java application using the `jps` and
    `jstack` JVM tools. To do that, perform the following steps:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a command-line terminal and then SSH into the `jobstore` application gear
    as follows:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Once inside the application gear, run the `jps` utility to list all the available
    Java processes as follows:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `jps` utility ships with JDK and lists all the Java process IDs.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output of the `jps -l` command is as follows:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, to take a thread dump of the Java process with ID `157027`, run the following
    command:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `jstack` utility is also part of JDK and is used to take a thread dump of
    a Java process.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Choosing between Java 6 and Java 7* recipe
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Enabling hot deployment for Java applications* recipe
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges* recipe
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing between Java 6 and Java 7
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OpenShift supports both Java 6 and Java 7 to run your applications. By default,
    all the Java applications use OpenJDK 7, but you can configure your application
    to use OpenJDK 6 as well. To get the exact version of your Java installation,
    you can SSH into the application gear and run the `java -version` command or run
    the following command:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In this recipe, you will learn how you can choose among different supported
    versions of Java.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recipe will work with all the four supported Java cartridges (Apache Tomcat
    6, Apache Tomcat 7, JBoss AS7, and JBoss EAP).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to switch to OpenJDK 6:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Create a new JBoss AS 7 application by running the following command. If you
    already have a Java application deployed on OpenShift, then you can use that as
    well.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Once the application is created, you can check the default Java version by
    running the `java -version` command on the application gear as shown in the following
    command:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To configure your application to use Java 6, delete a marker file called `java7`
    in the `.openshift/markers` directory as follows:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Commit the changes and push them to your application gear as follows:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'After a successful build, run the `java -version` command again to verify that
    you are now using Java 6 as follows:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: How it works…
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenShift uses the marker files to configure various aspects of the application,
    such as the Java version, hot deployment, debugging, and so on. The presence of
    a marker file in the `.openshift/markers` location tells OpenShift that you want
    to enable the feature. For example, every OpenShift application has a `java7`
    marker file in the `.openshift/markers` directory that informs OpenShift that
    it should use Java 7 for application deployment. When you perform code deployment
    using `git push`, OpenShift will set the `JAVA_HOME` environment variable depending
    on the Java version you want to use in your application.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: To use Java 6, you just deleted the `java7` marker file. This informs OpenShift
    that it should fall back to Java 6\. From now on, your application will use Java
    6.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Taking thread dumps of Java cartridges* recipe
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Enabling hot deployment for Java applications* recipe
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling hot deployment for Java applications
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every time you make a change and push it to the OpenShift application gear,
    OpenShift stops your gear (that is, all the cartridges), copies the source code
    from your application Git repo to `app-root/runtime/repo`, performs a build, prepares
    the artifact, and finally starts your gear (that is, all the cartridges). This
    process takes time and does not suit rapid development. To enable rapid development
    and faster deployment, OpenShift supports hot deployment. Hot deployment means
    that you can deploy your changes without the need to restart all the application
    cartridges.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recipe will work with all the four supported Java cartridges (Apache Tomcat
    6, Apache Tomcat 7, JBoss AS7, and JBoss EAP).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to enable hot deployment:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new command-line terminal, and navigate to the directory where you want
    to create the application. To create a new JBoss EAP application, execute the
    following command. If you already have an OpenShift Java application, then you
    can work with that as well. Have a look at the following command:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'To enable hot deployment, create a new file with the name `hot_deploy` inside
    the `.openshift/markers` directory. On *nix machines, you can create a new file
    using the `touch` command as shown in the following command. On Windows machines,
    you can use file explorer to create a new file. Have a look at the following code:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Add the new file to the Git repository index, commit it to the local repository,
    and then push the changes to the application''s remote Git repository:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In the `git push` logs, you will see a message that cartridges are not stopped
    because hot deployment is enabled as follows:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: How it works…
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The presence of the `hot_deploy` marker file informs OpenShift that you want
    to do hot deployment. Before stopping and starting the application cartridges,
    OpenShift checks for the existence of the `hot_deploy` marker file. For JBoss
    cartridges, hot deployment is achieved by using the JBoss deployment scanner.
    The scanner polls the `deployments` directory every 5 seconds to check for the
    existence of the WAR file. If the WAR file exists, it will undeploy the existing
    WAR file and deploy the new WAR file. You can configure the deployment scanner''s
    `scan-interval` option in `.openshift/config/standalone.xml`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: When your application is using hot deploy, then your application will have downtime
    starting when the JBoss deployment scanner recognizes the new WAR file, undeploys
    the old one, and deploys the new WAR file. Your application will be back online
    once the new file is deployed.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Hot deployment is ideal for development, and I recommend you should always use
    it during development.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you set new environment variables with hot deployment enabled, then you have
    to restart the application to allow the server to pick the new environment variables.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Taking thread dumps of Java cartridges* recipe
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Choosing between Java 6 and Java 7* recipe
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skipping the Maven build
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every OpenShift Java application is a Maven-based application. Whenever you
    run a `git push` command, a Maven build is performed, and the resulting archive
    (WAR or EAR) is deployed. There are scenarios where you don't want to do a Maven
    build with every push to the gear. These scenarios can be WAR deployment or executing
    only action hooks. In this recipe, you will learn how to skip the Maven build
    step during deployment.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recipe will work with all the four supported Java cartridges (Apache Tomcat
    6, Apache Tomcat 7, JBoss AS7, and JBoss EAP).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will need the `jobstore` application created in
    the *Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges* recipe. Please refer to this recipe if you don't have a running
    OpenShift application.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to skip the Maven build:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Open a new command-line terminal, and navigate to the directory where the `jobstore`
    application is located. If you don't have a Java OpenShift application, then you
    can recreate a new application by following the steps mentioned in the *Creating
    and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL 9.2 cartridges*
    recipe.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To skip a Maven build during deployment, create a marker file called `skip_maven_build`
    in the `.openshift/markers` directory. On *nix systems, you can use the `touch`
    command as shown in the following command. On Windows machines, you can use file
    explorer. Have a look at the following code:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Add the new file to the Git repository index, commit it to the local repository,
    and then push the changes to the application''s remote Git repository as follows:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: How it works…
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The presence of the `skip_maven_build` marker informs OpenShift that it should
    not build the application. In the `git push` command output, you will see that
    the Maven build is skipped because of the presence of the `skip_maven_build` marker
    file:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: There's more…
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to skip the Maven build is to delete the `pom.xml` file. If there
    is no `pom.xml` file, then OpenShift does not try to build the application.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Forcing a clean Maven build* recipe
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Installing the JAR file not present in the Maven central repository* recipe
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Overriding the default Maven build command* recipe
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forcing a clean Maven build
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first time you push your changes to the application gear, Maven will download
    all the dependencies and will store those dependencies in the `.m2` directory
    under your application gear home directory. After the first push, OpenShift will
    reuse all the dependencies in the `.m2` repository and will only download new
    dependencies. This saves build time and make application deployment faster. But,
    there are a few situations when you want to do a clean build. One situation can
    be when you want to download all the latest Maven dependencies. In this recipe,
    you will learn how you can inform OpenShift to perform a clean build.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recipe will work with all the four supported Java cartridges (Apache Tomcat
    6, Apache Tomcat 7, JBoss AS7, and JBoss EAP).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will need the `jobstore` application created in
    the *Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges* recipe. Please refer to this recipe if you don't have a running
    OpenShift application.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to force a clean Maven build of your Java application:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Open a new command-line terminal, and navigate to the directory where the `jobstore`
    application is located. If you don't have a Java OpenShift application, then you
    can recreate a new application by following the steps mentioned in the *Creating
    and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL 9.2 cartridges*
    recipe.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To force a clean Maven build during deployment, create a marker file called
    `force_clean_build` inside the application''s`.openshift/markers` directory. On
    *nix systems, you can use the `touch` command as shown in the following command.
    On Windows machines, you can use file explorer. Have a look at the following screenshot:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Add the new file to the Git repository index, commit it to the local repository,
    and then push the changes to the application''s remote Git repository as follows:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: How it works…
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The presence of the `force_clean_build` marker file informs OpenShift that
    you want to do a clean build. When you run a `git push` command, OpenShift will
    first delete the `.m2` directory and then start the build process by invoking
    the `mvn clean package -Popenshift -DskipTests` command. Maven will now download
    all the dependencies again. You will see the following log message in the `git
    push` command output. Have a look at the following command:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: See also
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Forcing a clean Maven build* recipe
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Installing the JAR file not present in the Maven central repository* recipe
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Overriding the default Maven build command* recipe
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding the default Maven build command
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenShift, by default, will execute the `mvn -e clean package -Popenshift -DskipTests`
    command to build the project. If you don't want to use the OpenShift Maven profile
    or want to run tests, then you have to tell OpenShift to run a different command.
    In this recipe, you will learn how you can tell OpenShift to use a different command.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will need the `jobstore` application created in
    the *Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges* recipe. Please refer to this recipe if you don't have a running
    OpenShift application.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to override the default Maven build command:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Open a new command-line terminal, and navigate to the directory where the `jobstore`
    application is located.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To configure OpenShift to use a different build command, create a new environment
    variable with the name `MAVEN_ARGS`. The value of the `MAVEN_ARGS` environment
    variable is the Maven build phases you want to run, as shown in the following
    command:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: How it works…
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before running the build, OpenShift first checks whether the environment variable
    called `MAVEN_ARGS` is set. It uses the phases and goals defined in this environment
    variable to create a Maven command that will be used to build the project. If
    `MAVEN_ARGS` is not set, then it will set the default value, that is, `clean package
    -Popenshift -DskipTests`, else it will use the value of the `MAVEN_ARGS` environment
    variable.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when you run the `git push` command, you will see an entry in the `git
    push` logs, as shown in the following command output:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: See also
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Forcing a clean Maven build* recipe
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Installing the JAR file not present in the Maven central repository* recipe
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Skipping the Maven build* recipe
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the JAR file not present in the Maven central repository
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenShift will download all the dependencies from the Maven central repositories
    specified in your `pom.xml` file. There are times when your application depends
    on the libraries that do not exist in any public Maven repository. In this recipe,
    you will learn how you can use the OpenShift action hooks to install a local JAR.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will need the `jobstore` application created in
    the *Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges* recipe. Please refer to this recipe if you don't have a running
    OpenShift application.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to install the JAR file not present in the configured
    Maven repositories:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: Open a new command-line terminal, and navigate to the directory where the `jobstore`
    application is located.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `lib` directory in the root of your application directory, and add
    your local JAR file here. To demonstrate this recipe, I have created a simple
    library that you can download from [https://github.com/OpenShift-Cookbook/chapter7-recipe14/raw/master/lib/simplelogger-0.0.1.jar](https://github.com/OpenShift-Cookbook/chapter7-recipe14/raw/master/lib/simplelogger-0.0.1.jar).
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `pre_build` action hook inside the `.openshift/action_hooks` directory,
    and add the following content to it:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The following command will install the JAR file to the local Maven repository
    located on the application gear:'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Make sure the `pre_build` action hook is executable. You can make the `pre_build`
    action hook script executable by running the following command:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Add the dependency to the application''s `pom.xml` file so that your application
    can use the library in the application source code as follows:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: How it works…
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step 2, you created a `lib` directory inside the application source code
    root. You downloaded the `simplelogging` library and placed it in the `lib` directory.
    Next, in step 2, you created a `pre_build` action hook that installs the `simplelogging-0.0.1.jar`
    file into the application gear's`.m2` repository. The `pre_build` script is executed
    before the build step. This means your library will be available during the build.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On Windows, the execute permissions on the action hooks will be lost during
    `git push`. You can fix the problem by running the following command:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Finally, you added the library as a dependency in your application's `pom.xml`
    file so that you can use the library in your application.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Forcing a clean Maven build* recipe
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Overriding the default Maven build command* recipe
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Skipping the Maven build* recipe
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing OpenShift Java applications using Eclipse
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can build, deploy, and manage your OpenShift Java applications right from
    within the Eclipse IDE using the JBoss Tools OpenShift plugin. This recipe will
    guide you through installation, setup, application creation, and managing your
    application from within Eclipse. In this recipe, you will develop a Java EE 6
    PostgreSQL 9.2 application and deploy it on the JBoss EAP 6 application server
    running on OpenShift all from within Eclipse.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Download the latest Eclipse package for your operating system from the official
    Eclipse website at [http://www.eclipse.org/downloads/](http://www.eclipse.org/downloads/).
    At the time of this writing, the latest Eclipse package is Kepler.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: 'It is very easy to install Eclipse; just extract the downloaded package, and
    we are done. On Linux and Mac, open a new command-line terminal, and type the
    following command:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: On Windows, you can extract the ZIP file using WinZip or 7-zip ([http://www.7-zip.org/download.html](http://www.7-zip.org/download.html))
    or any other software.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: After we have extracted the Eclipse file, there will be a folder named `*eclipse*`
    in the directory where we extracted Eclipse. We can optionally create a shortcut
    to the executable file.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is recommended that you use the latest version of Eclipse, that is, Kepler,
    to work with OpenShift. Earlier versions are not supported and might not even
    work.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to create OpenShift applications using OpenShift
    Eclipse tooling:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: After downloading and extracting the Eclipse Kepler IDE for Java EE, open Eclipse,
    and navigate to the project workspace. Navigate to **Help**|**Eclipse Marketplace**.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the search box, type `jboss tools`, and then click on the **Go** button.
    After clicking on the **Go** button, we will see **JBoss Tools (Kepler)** as the
    first result. Now click on the **Install** button. Have a look at the following
    screenshot:![How to do it…](img/00065.jpeg)
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After clicking on the **Install** button, you will get a list of plugins that
    you can install. As the purpose of this recipe is to demonstrate the OpenShift
    Eclipse support, we will only select **JBoss OpenShift Tools** from the list.
    After selecting **JBoss OpenShift Tools**, click on the **Confirm** button. Have
    a look at the following screenshot:![How to do it…](img/00066.jpeg)
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accept the license by clicking on the **I accept the terms of the license agreement**
    radio button, and then click on the **Finish** button.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the JBoss Tools OpenShift plugin is unsigned, you will get a security message.
    Click on the **OK** button, and restart Eclipse to apply the changes.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you've installed the OpenShift Eclipse plugin, you have everything
    required to start building the application. Create a new OpenShift application
    by navigating to **File**|**New**|**Other**|**OpenShift Application**:![How to
    do it…](img/00067.jpeg)
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Next** button, and you will be asked to provide your OpenShift
    account credentials. If you do not have an OpenShift account, you can click on
    the sign up **here** link on the wizard to create a new OpenShift account. Have
    a look at the following screenshot:![How to do it…](img/00068.jpeg)
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter your OpenShift account details. Also, check the **Save password** checkbox
    so that we do not have to enter the password with every command. Click on the
    **Next** button. Have a look at the following screenshot:![How to do it…](img/00069.jpeg)
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After clicking on the **Next** button, you will be asked to enter additional
    information for password recovery. I choose **No**, but you can choose **Yes**
    as well.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will be asked to create a new OpenShift domain if you don't have a
    domain associated with your account already. The domain name is the unique namespace,
    and all the user applications will exist under this namespace. This is shown in
    the following screenshot:![How to do it…](img/00070.jpeg)
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will be asked to upload your public SSH keys to OpenShift, as shown
    in the following screenshot:![How to do it…](img/00071.jpeg)
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can either upload your existing SSH keys or create a new SSH key by clicking
    on the **New** button. Let's create a new key by clicking on the **New** button.
    We need to provide a name for the key and a name for the private and public key
    filenames. I have used my name as the key name and filename. Have a look at the
    following screenshot:![How to do it…](img/00072.jpeg)
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you will be directed to the application creation wizard where you have
    to enter the application details. The details include the name of the application,
    the type of the application, the gear profile (whether you want a small, medium,
    or large instance; in a free tier, you have access only to small instances), whether
    you want a scalable application or a nonscalable application, and whether you
    want to embed any or multiple cartridges, such as MySQL, PostgreSQL, MongoDB,
    and others. For our application, we will select the JBoss EAP and PostgreSQL cartridges.
    We will name the application `jobstore` as shown in the following screenshot:![How
    to do it…](img/00073.jpeg)
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you have to set up a `jobstore` application and configure the server adapter
    settings. Choose the default and click on **Next**.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next screen will ask us to specify the location where we want to clone the
    Git repository and the name of the Git remote. Have a look at the following screenshot:![How
    to do it…](img/00074.jpeg)
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, click on the **Finish** button to initiate the application creation
    process. This will create an application container for us, called a gear, and
    set up all the required SELinux policies and cgroup configuration. OpenShift will
    install the PostgreSQL cartridge on the application gear, and the JBoss Tools
    OpenShift plugin will show an information box with the PostgreSQL details.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the project is imported as a Maven project in the Eclipse workspace.
    After importing the application to Eclipse, you will be asked whether you want
    to publish the uncommitted changes. You might start wondering why it is asking
    you to publish changes. The reason is that when a project is imported into Eclipse,
    JBoss Tools creates a new file called `.jsdtscope` under the `.settings` directory.
    As the file is not ignored, the OpenShift Eclipse plugin asks you for a deployment.
    You can easily ignore the file by navigating to the **Git Staging** view. To open
    the **Git Staging** view, navigate to **Window**|**Show View**|**Other**|**Git**|**Git
    Staging**. Have a look at the following screenshot:![How to do it…](img/00075.jpeg)
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `.jsdtscope` file under the **Git Staging** view, and then
    choose **Ignore**. Have a look at the following screenshot:![How to do it…](img/00076.jpeg)
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, open the **OpenShift Explorer** view. Navigate to **Window**|**Show View**|**Other**|**JBoss
    Tools**|**OpenShift Explorer**. This will open up a new view as shown in the following
    screenshot:![How to do it…](img/00077.jpeg)
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, right-click on the application, and then click on the **Show in Web Browser**
    option. This will open up the template application in the default browser.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The preceding steps help you to create OpenShift Java applications using Eclipse.
    In this recipe, I used the JBoss EAP cartridge, but you can do the same for the
    Tomcat or JBoss AS7 cartridge. The preceding steps are self-explanatory and do
    not require any explanation. Now, I will explain to you how your development workflow
    should work. The recommended way to work with OpenShift Eclipse tooling is split
    into two steps, which are as follows:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: Write code for functionality, and then commit the code to a Git local repository
    using the **Git Staging** view. The **Git Staging** view gives a graphical view
    to the changes, and you can easily compare and look at all the files we have changed.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Git Staging** view, you have two options. You can either commit the
    changes to the local repository or do a commit and push together. When you perform
    `git commit` and `push` together, the code is pushed to a Git remote called `origin`.
    The `origin` remote points to a private Git repository created by OpenShift. When
    the code is pushed to the remote repository, OpenShift will kick off the build.
    The problem with the **Git Staging** view **Commit and Push** button is that you
    will not be able to monitor the application build logs. To view the application
    build logs, you should use the server view publication mechanism. We will use
    the server configured for the `jobstore` OpenShift application. To publish the
    changes, right-click on the server, and click on **Publish**. This internally
    does a `git push`. The advantage of this approach is that it will open up a new
    console view, where we can monitor the application build progress.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s make a small change to the application to better understand the development
    workflow discussed in the previous section. Open the `index.html` file, and consider
    the following code:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'And change it to:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Go to the **Git Staging** view, and you will see the change shown in the following
    screenshot:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/00078.jpeg)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
- en: 'Next, drag the change to **Staged Changes**, and write a commit message. Have
    a look at the following screenshot:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/00079.jpeg)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
- en: Commit the change by clicking on the **Commit** button. As I mentioned before,
    do not use **Commit and Push**, as that will trigger application deployment and
    will not show the build log. The build log is very useful when the build fails.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: Go to the **Servers** view, and you will see a server configured for the `jobstore`
    application.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the application server, and then click on **Publish**. Have
    a look at the following screenshot:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/00080.jpeg)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
- en: 'You will get a dialog where you have to confirm whether you want to publish
    the changes or not. Click on **Yes**, and it will open a new **Console** view
    where we can track the build progress. Have a look at the following screenshot:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/00081.jpeg)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
- en: 'To view the logfiles of the JBoss EAP application server, go to the **OpenShift
    Explorer** view, and right-click on the application. Click on **Tail files…**.
    Have a look at the following screenshot:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/00082.jpeg)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
- en: 'Next, you will configure to tail only the JBoss EAP `server.log` file. By default,
    it will tail all the logfiles, which includes the database logfiles as well, as
    shown in the following screenshot:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/00083.jpeg)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
- en: It will open up another console view where it will tail only the JBoss EAP `server.log`
    file.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can view the change in the browser by right-clicking on the **jobstore**
    server, and then navigating to **Show In**|**Web Browser**. This will open up
    the default web browser, where we can view the change that we made in `index.html`.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can do a lot more with the OpenShift Eclipse plugin. For faster development,
    you should enable hot deployment. The OpenShift Eclipse plugin makes it very easy
    to enable hot deployment. To enable hot deployment, right-click on the project,
    and then navigate to **OpenShift**|**Configure Markers**. Have a look at the following
    screenshot:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/00084.jpeg)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
- en: 'Then, you will see a view where you can configure which OpenShift markers you
    want to enable for the application. Select the **Hot Deploy** marker. Have a look
    at the following screenshot:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/00085.jpeg)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
- en: 'This will create a new empty file called `hot_deploy` in the `.openshift/markers`
    directory. You can commit the changes by going to the **Git Staging** view. Go
    to the **Servers** view, and publish this change. The build log will show that
    the cartridges are not stopped as hot deploy is enabled. Have a look at the following
    build log:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: See also
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using Eclipse System Explorer to SSH into the application gear* recipe
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Debugging Java applications in the Cloud* recipe
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Eclipse System Explorer to SSH into the application gear
  id: totrans-473
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how you can SSH into the application gear from
    within Eclipse.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires you to have Eclipse with the JBoss Tools OpenShift plugin
    installed. Please refer to the *Developing OpenShift Java applications using Eclipse*
    recipe for more information.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to learn how to SSH into the application gear from
    within Eclipse:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: Create a new application using the OpenShift Eclipse plugin. Refer to the *Developing
    OpenShift Java applications using Eclipse* recipe for instructions.
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Window**|**Open Perspective**|**Other**|**Remote System Explorer**
    to open the **Remote System Explorer** perspective. Have a look at the following
    screenshot:![How to do it…](img/00086.jpeg)
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **OpenShift Explorer** and copy the SSH connection details as shown in
    the following screenshot:![How to do it…](img/00087.jpeg)
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the SSH details as shown in the following screenshot:![How to do it…](img/00088.jpeg)
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to the **Remote System Explorer** perspective, and define a new connection
    to the remote system as shown in the following screenshot:![How to do it…](img/00089.jpeg)
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, it will ask you to select the remote system type. Select the **SSH Only**
    option as shown in the following screenshot:![How to do it…](img/00090.jpeg)
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will be asked to enter the details of the new connection. Enter the
    hostname of your application as shown in the following screenshot:![How to do
    it…](img/00091.jpeg)
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Finish** button to create a new connection. The connection will
    be listed in the left-hand side bar.
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To open an SSH terminal, navigate to **Ssh Terminals**|**Launch Terminal** as
    follows:![How to do it…](img/00092.jpeg)
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will be asked to enter the user ID with which you want to connect.
    The user ID is the `UUID` part of the SSH connection URL. Click on **OK**. Have
    a look at the following screenshot:![How to do it…](img/00093.jpeg)
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch the terminal again, and you will see an SSH terminal as shown in the
    following screenshot:![How to do it…](img/00094.jpeg)
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding steps, you used Eclipse Remote System Explorer to SSH into
    the OpenShift application gear. Remote System Explorer comes bundled with Eclipse
    Kepler for Java EE. Remote System Explorer allows you to connect and work with
    a variety of remote systems. To learn more about Remote System Explorer, you can
    refer to the documentation at [http://help.eclipse.org/kepler/index.jsp?nav=%2F56](http://help.eclipse.org/kepler/index.jsp?nav=%2F56).
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-492
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Developing OpenShift Java applications using Eclipse* recipe
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Debugging Java applications in the Cloud* recipe
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging Java applications in the Cloud
  id: totrans-495
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to debug Java applications running on OpenShift.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires you to have Eclipse with the JBoss Tools OpenShift plugin
    installed. Please refer to the *Developing OpenShift Java applications using Eclipse*
    recipe for more information.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-499
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to learn how to debug your Java applications:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: In the *Developing OpenShift Java applications using Eclipse* recipe, you learned
    how to create a Java application using the Eclipse plugin. The application that
    we developed used the OpenShift template application as its starting point. As
    you might know, in the `rhc` command line, you can use the `--from-code` option
    to specify your own template application. Let's create a new Java application
    using Eclipse that uses the application we created in the *Creating and deploying
    Java EE 6 applications using the JBoss EAP and PostgreSQL 9.2 cartridges* recipe
    using Eclipse. Create a new OpenShift application by navigating to **File**|**New**|**Other**|**OpenShift
    Application**. After validating your account, you will get a screen where you
    need to enter the application details. Please select the **JBoss EAP** and **PostgreSQL
    9.2** cartridges. To specify the Git repository, click on the **Advanced** button,
    and then uncheck the **Use default source code** checkbox.
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the input box, specify the URL of the Git repository as shown in the following
    screenshot:'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/00095.jpeg)'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Next, you have to set up a `jobstore` application and configure the server adapter
    settings. Choose the default and click on **Next**.
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next screen will ask us to specify the location where you want to clone
    the Git repository and the name of the Git remote. Specify a writable directory,
    and click on **Finish**.
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, a new application instance will be created using the selected cartridges
    and Git repository. Finally, the project will be imported into Eclipse as a Maven
    project.
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To enable debugging, you have to create a new marker file called `enable_jpda`
    inside the `.openshift/markers` directory. The Eclipse plugin can help us create
    the file. Right-click on the project, and navigate to **OpenShift** |**Configure
    Markers…**.
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will open a dialog where you can select the marker files. Select the **Enable
    JPDA** marker as shown in the following screenshot. This will create a new file
    called `enable_jpda` inside the `.openshift/markers` directory.![How to do it…](img/00096.jpeg)
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **Git Staging** view, and commit the change. Have a look at the following
    screenshot:![How to do it…](img/00097.jpeg)
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After committing the change, go to the **Servers** view, and publish your changes.
    This will start the server with JPDA enabled.
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, enable port forwarding so that you can connect with the JPDA port. Go to
    the **OpenShift Explorer** view, and right-click on the project to enable port
    forwarding. Have a look at the following screenshot:![How to do it…](img/00098.jpeg)
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will open a dialog where you can configure port forwarding. Click on the
    **Start All** button to enable port forwarding. The port `8787` is used to debug.
    This is shown in the following screenshot:![How to do it…](img/00099.jpeg)
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we will add the breakpoint to the `CompanyResource` class at line number
    32\. After setting the debug point, create a new debug configuration by right-clicking
    on the debug point, navigating to **Debug Configurations**|**Remote Java Application**|**New**
    and giving it a name, and enter the port as `8787` as shown in the following screenshot:![How
    to do it…](img/00100.jpeg)
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After entering all the details, click on the **Debug** button. Open the debug
    perspective, and you will see the remote debugger in action. Please note that
    it will take some time to enable remote debugging, so please be patient. This
    is shown in the following screenshot:![How to do it…](img/00101.jpeg)
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, go to `http://jobstore-{domain-name}.rhcloud.com/#companies/new` and create
    a new company. This will invoke the breakpoint as shown in the following screenshot:![How
    to do it…](img/00102.jpeg)
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-516
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The preceding steps enable Java developers to debug their OpenShift Java applications.
    To enable debugging, you created a marker file under the`.openshift/markers` directory
    using the Eclipse plugin. The file is committed, and the changes are pushed to
    the OpenShift application gear. After a push, the JBoss server is stopped and
    then started again. The JBoss cartridge checks the presence of the `enable_jpda`
    file. If the `enable_jpda` marker file exists, then the server is started in debug
    mode. The debugging provided by JBoss is based on the **Java Platform Debugger
    Architecture** (**JPDA**). To enable debugging, the JBoss server is started with
    the `JAVA_OPTS` environment variable set to the value shown in the following code:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: As the port `8787` is not accessible to the outside world, you have to enable
    port forwarding. After enabling port forwarding, you created a new remote Java
    application that will connect to the JBoss EAP cartridge running in debug mode.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-520
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Developing OpenShift Java applications using Eclipse* recipe
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using Eclipse System Explorer to SSH into the application gear* recipe
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
