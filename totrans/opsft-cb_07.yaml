- en: Chapter 7. OpenShift for Java Developers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter presents a number of recipes that show you how to get started
    with Java web application development on OpenShift. You will learn how to create
    and deploy **Java Enterprise Edition** (**Java EE**) applications on OpenShift
    using the JBoss EAP 6 and JBoss AS 7 application server cartridges. This chapter
    will also cover how to develop and host your Spring Framework applications on
    the Tomcat server. The specific recipes within this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring application security by defining the database login module in standalone.xml
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing modules with JBoss cartridges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing JBoss cartridges using the management web interface and CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and deploying Spring applications using the Tomcat 7 cartridge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking thread dumps of Java cartridges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing between Java 6 and Java 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling hot deployment for Java applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skipping the Maven build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forcing a clean Maven build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding the default Maven build command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the JAR file not present in the Maven central repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing OpenShift Java applications using Eclipse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Eclipse System Explorer to SSH into the application gear
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging Java applications in the Cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will explore how Java developers can get started with OpenShift
    to develop Java EE or Spring applications. Java is often thought of as the de
    facto open source, enterprise programming language. OpenShift supports the JBoss
    application server, which is a certified platform for Java EE 6 development. As
    an OpenShift Online user, you have access to both the community version of JBoss
    and commercial JBoss EAP 6 for free. The *Creating and deploying Java EE 6 applications
    using the JBoss EAP and PostgreSQL 9.2 cartridges* recipe will cover how to develop
    and deploy Java EE 6 applications on OpenShift. There is also a community-supported
    cartridge for WildFly, a certified Java EE 7 application server that you can use
    to deploy Java EE 7 applications. This chapter will not cover the WildFly cartridge.
  prefs: []
  type: TYPE_NORMAL
- en: 'A popular alternative to Java EE development is Spring Framework. Spring developers
    normally use Apache Tomcat to host their applications. OpenShift supports two
    versions of Tomcat: Apache Tomcat 6 and Apache Tomcat 7\. The *Creating and deploying
    Spring applications using the Tomcat 7 cartridge* recipe will cover how to develop
    a Spring application and deploy it on OpenShift. Also, it is possible to run Apache
    Tomcat 8 (currently in beta) on OpenShift. You can read my blog to learn how to
    deploy Apache Tomcat 8 on OpenShift at [https://www.openshift.com/blogs/how-to-run-apache-tomcat-8-on-openshift](https://www.openshift.com/blogs/how-to-run-apache-tomcat-8-on-openshift).'
  prefs: []
  type: TYPE_NORMAL
- en: OpenShift uses Apache Maven to manage dependencies and build your OpenShift
    apps. All OpenShift Java applications are Maven-based applications. This chapter
    assumes that you are familiar with Apache Maven. In the event that you are not
    comfortable with Maven, then please refer to the documentation at [http://maven.apache.org/guides/getting-started/index.html](http://maven.apache.org/guides/getting-started/index.html).
    This chapter will cover various aspects of using Apache Maven with OpenShift,
    such as how to use your own JARs (not hosted on the Maven central repository)
    with OpenShift, and so on. OpenShift also allows you to use other build tools,
    such as Apache Ant and Gradle. Please refer to my blogs on Apache Ant ([https://www.openshift.com/blogs/running-ant-builds-on-openshift](https://www.openshift.com/blogs/running-ant-builds-on-openshift))
    and Gradle ([https://www.openshift.com/blogs/run-gradle-builds-on-openshift](https://www.openshift.com/blogs/run-gradle-builds-on-openshift))
    to learn how to use them with OpenShift applications.
  prefs: []
  type: TYPE_NORMAL
- en: Almost all Java developers use an IDE to build their applications. OpenShift
    has first-class support for the Eclipse IDE. The *Developing OpenShift Java applications
    using Eclipse* recipe will walk you through a step-by-step process of creating
    and managing an application from within Eclipse. You can even SSH into the application
    gear from within Eclipse. This will be covered in the *Using Eclipse System Explorer
    to SSH into the application gear* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to run the examples on your local machine, then please install
    Java 7, Apache Maven, and Eclipse. The instructions to install Java for your operating
    system can be found at [http://www.java.com/en/download/help/download_options.xml](http://www.java.com/en/download/help/download_options.xml).
    Next, instructions to install Apache Maven can be found here: [http://maven.apache.org/download.cgi#Installation](http://maven.apache.org/download.cgi#Installation).
    Finally, you can install Eclipse on your machine by following the instructions
    mentioned here: [http://wiki.eclipse.org/Eclipse/Installation](http://wiki.eclipse.org/Eclipse/Installation).'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is based on the assumption that you know the basics of OpenShift
    application development and database cartridges. In the event that you are not
    comfortable with the basics, I will recommend that you first read [Chapter 3](part0041_split_000.html#page
    "Chapter 3. Creating and Managing Applications"), *Creating and Managing Applications*
    to [Chapter 6](part0079_split_000.html#page "Chapter 6. Using MongoDB and Third-party
    Database Cartridges with OpenShift Applications"), *Using MongoDB and Third-party
    Database Cartridges with OpenShift Applications* before continuing with this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will develop a simple job portal application that will allow
    users to post job openings for a company. Users can create a company and then
    post jobs for that company. All the source code is on the *OpenShift-Cookbook*
    repository of the GitHub organization at [https://github.com/OpenShift-Cookbook](https://github.com/OpenShift-Cookbook).
  prefs: []
  type: TYPE_NORMAL
- en: Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gone are the days when Java EE or J2EE (as it was called in the olden days)
    was considered evil. Java EE now provides a very productive environment to build
    web applications. Java EE has embraced convention over configuration and annotations,
    which means that you are no longer required to maintain XML to configure each
    and every component. In this recipe, you will learn how to build a Java EE 6 application
    and deploy it on OpenShift. This recipe assumes that you have basic knowledge
    of Java and Java EE 6\. If you are not comfortable with Java EE 6, please read
    the official tutorial at [http://docs.oracle.com/javaee/6/tutorial/doc/](http://docs.oracle.com/javaee/6/tutorial/doc/).
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will build a simple job portal that will allow users to
    post job openings and view a list of all the persisted jobs in the system. These
    two functionalities will be exposed using two REST endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for the application created in this recipe is on GitHub at [https://github.com/OpenShift-Cookbook/chapter7-jobstore-javaee6-simple](https://github.com/OpenShift-Cookbook/chapter7-jobstore-javaee6-simple).
    The example application that you will build in this recipe is a simple version
    of the `jobstore` application with only a single domain class and without any
    application interface. You can get the complete `jobstore` application source
    code on GitHub as well at [https://github.com/OpenShift-Cookbook/chapter7-jobstore-javaee6](https://github.com/OpenShift-Cookbook/chapter7-jobstore-javaee6).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will need the `rhc` command-line client installed
    on your machine. Please refer to the *Installing the OpenShift rhc command-line
    client* recipe in [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting
    Started with OpenShift"), *Getting Started with OpenShift*, for details. Also,
    you will need an IDE to work with the application code. The recommended IDE to
    work with OpenShift is Eclipse Luna, but you can also work with other IDEs, such
    as IntelliJ Idea and NetBeans. Download and install the Eclipse IDE for Java EE
    developers from the official website at [https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to create the `jobstore` application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new command-line terminal, and go to a convenient location. Create a
    new JBoss EAP application by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding command will create a Maven project and clone it to your local
    machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the directory to `jobstore`, and execute the following command to add
    the PostgreSQL 9.2 cartridge to the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open Eclipse and navigate to the project workspace. Then, import the application
    created in step 1 as a Maven project. To import an existing Maven project, navigate
    to **File**|**Import**|**Maven**|**Existing Maven Projects**. Then, navigate to
    the location of your OpenShift Maven application created in step 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, update `pom.xml` to use Java 7\. The Maven project created by OpenShift
    is configured to use JDK 6\. Replace the properties with the one shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Update the Maven project to allow the changes to take effect. You can update
    the Maven project by right-clicking on the project and navigating to **Maven**|**Update
    Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let us write the domain classes for our application. Java EE uses JPA
    to define the data model and manage entities. The application has one domain class:
    `Job`. Create a new package called `org.osbook.jobstore.domain`, and then create
    a new Java class called `Job` inside it. Have a look at the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `META-INF` folder at `src/main/resources`, and then create a `persistence.xml`
    file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we will create the `JobService` class that will use the JPA `EntityManager`
    API to work with the database. Create a new package called `org.osbook.jobstore.services`,
    and create a new Java class as shown in the following code. It defines the `save`
    and `findAll` operations on the `Job` entity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, enable **Contexts and Dependency Injection** (**CDI**) in the `jobstore`
    application by creating a file with the name `beans.xml` in the `src/main/webapp/WEB-INF`
    directory as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `jobstore` application will expose the REST JSON web service. Before you
    can write the JAX-RS resources, you have to configure JAX-RS in your application.
    Create a new package called `org.osbook.jobstore.rest` and a new class called
    `RestConfig`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a JAX-RS resource to expose the `create` and `findAll` operations of
    `JobService` as REST endpoints as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Commit the code, and push it to the OpenShift application as shown in the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After the build finishes successfully, the application will be accessible at
    `http://jobstore-{domain-name}.rhcloud.com`. Please replace `domain-name` with
    your own domain name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To test the REST endpoints, you can use `curl`. `curl` is a command-line tool
    for transferring data across various protocols. We will use it to test our REST
    endpoints. To create a new job, you will run the following `curl` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To view all the jobs, you can run the following `curl` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding steps, we created a Java EE application and deployed it on
    OpenShift. In step 1, you used the `rhc create-app` command to create a JBoss
    EAP web cartridge application. The `rhc` command-line tool makes a request to
    the OpenShift broker and asks it to create a new application using the JBoss EAP
    cartridge. The anatomy of application creation was explained in the *Creating
    an OpenShift application using the rhc command-line client* recipe in [Chapter
    3](part0041_split_000.html#page "Chapter 3. Creating and Managing Applications"),
    *Creating and Managing Applications*. Every OpenShift web cartridge specifies
    a template application that will be used as the default source code of the application.
    For Java web cartridges (JBoss EAP, JBoss AS7, Tomcat 6, and Tomcat 7), the template
    is a Maven-based application. After the application is created, it is cloned to
    the local machine using Git. The directory structure of the application is shown
    in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding command, apart from the `.git` and `.openshift`
    directories, this looks like a standard Maven project. OpenShift uses Maven to
    manage application dependencies and build your Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take a look at what''s inside the `jobstore` directory to better understand
    the layout of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The src directory**: This directory contains the source code for the template
    application generated by OpenShift. You need to add your application source code
    here. The `src` folder helps in achieving source code deployment when following
    the standard Maven directory conventions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The pom.xml file**: The Java applications created by OpenShift are Maven-based
    projects. So, a `pom.xml` file is required when you do source code deployment
    on OpenShift. This `pom.xml` file has a profile called `openshift`, which will
    be executed when you push code to OpenShift as shown in the following code. This
    profile will create a `ROOT` WAR file based upon your application source code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**The deployments directory**: You should use this directory if you want to
    do binary deployments on OpenShift, that is, you want to deploy a WAR or EAR file
    directly instead of pushing the source code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The .git directory**: This is a local Git repository. This directory contains
    the complete history of the repository. The `config` file in`.git/` contains the
    configuration for the repository. It defines a Git remote origin that points to
    the OpenShift application gear SSH URL. This makes sure that when you do `git
    push`, the source code is pushed to the remote Git repository hosted on your application
    gear. You can view the details of the origin Git remote by executing the following
    command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**The .openshift directory**: This is an OpenShift-specific directory, which
    can be used for the following purposes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The files under the `action_hooks` subdirectory allow you to hook onto the application
    lifecycle.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The files under the `config` subdirectory allow you to make changes to the JBoss
    EAP configuration. The directory contains the `standalone.xml` JBoss EAP-specific
    configuration file.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The files under the `cron` subdirectory are used when you add the cron cartridge
    to your application. This allows you to run scripts or jobs on a periodic basis.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The files under the `markers` subdirectory allow you to specify whether you
    want to use Java 6 or Java 7 or you want to do hot deploy or debug the application
    running in the Cloud, and so on.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In step 2, you added the PostgreSQL 9.2 cartridge to the application using the
    `rhc cartridge-add` command. We will use the PostgreSQL database to store the
    `jobstore` application data. Then, in step 3, you imported the project in the
    Eclipse IDE as a Maven project. Eclipse Kepler has inbuilt support for Maven applications,
    which makes it easier to work with Maven-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: From step 3 through step 5, you updated the project to use JDK 1.7 for the Maven
    compiler plugin. All the OpenShift Java applications use OpenJDK 7, so it makes
    sense to update the application to also use JDK 1.7 for compilation.
  prefs: []
  type: TYPE_NORMAL
- en: In step 6, you created the `job` domain class and annotated it with JPA annotations.
    The `@Entity` annotation marks the class as a JPA entity. An entity represents
    a table in the relational database, and each entity instance corresponds to a
    row in the table. Entity class fields represent the persistent state of the entity.
    You can learn more about JPA by reading the official documentation at [http://docs.oracle.com/javaee/6/tutorial/doc/bnbpz.html](http://docs.oracle.com/javaee/6/tutorial/doc/bnbpz.html).
  prefs: []
  type: TYPE_NORMAL
- en: The `@NotNull` and `@Size` annotation marks are Bean Validation annotations.
    Bean Validation is a new validation model available as a part of the Java EE 6
    platform. The `@NotNull` annotation adds a constraint that the value of the field
    must not be null. If the value is null, an exception will be raised. The `@Size`
    annotation adds a constraint that the value must match the specified minimum and
    maximum boundaries. You can learn more about Bean Validation by reading the official
    documentation at [http://docs.oracle.com/javaee/6/tutorial/doc/gircz.html](http://docs.oracle.com/javaee/6/tutorial/doc/gircz.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'In JPA, entities are managed within a persistence context. Within the persistence
    context, the entity manager manages the entities. The configuration of the entity
    manager is defined in a standard configuration XML file called `persitence.xml`.
    In step 7, you created the `persistence.xml` file. The most important configuration
    option is the `jta-datasource-source` configuration tag. It points to `java:jboss/datasources/PostgreSQLDS`.
    When a user creates a JBoss EAP 6 application, then OpenShift defines a PostgreSQL
    datasource in the `standalone.xml` file. The `standalone.xml` file is a JBoss
    configuration file, which includes the technologies required by the Java EE 6
    full profile specification plus Java Connector 1.6 architecture, Java XML API
    for RESTful web services, and OSGi. Developers can override the configuration
    by making changes to the `standalone.xml` file in the `.openshift/config` location
    of your application directory. So, if you open the `standalone.xml` file in `.openshift/config/`
    in your favorite editor, you will find the following PostgreSQL datasource configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In step 8, you created stateless **Enterprise JavaBeans** (**EJBs**) for our
    application service layer. The service classes work with the `EntityManager` API
    to perform operations on the `Job` entity.
  prefs: []
  type: TYPE_NORMAL
- en: In step 9, you configured CDI by creating the `beans.xml` file in the `src/main/webapp/WEB-INF`
    directory. We are using CDI in our application so that we can use dependency injection
    instead of manually creating the objects ourselves. The CDI container will manage
    the bean life cycle, and the developer just has to write the business logic. To
    let the JBoss application server know that we are using CDI, we need to create
    a file called `beans.xml` in our `WEB-INF` directory. The file can be completely
    blank, but its presence tells the container that the CDI framework needs to be
    loaded.
  prefs: []
  type: TYPE_NORMAL
- en: In step 10 and step 11, you configured JAX-RS and defined the REST resources
    for the `Job` entity. You activated JAX-RS by creating a class that extends `javax.ws.rs.ApplicationPath`.
    You need to specify the base URL under which your web service will be available.
    This is done by annotating the `RestConfig` class with the `ApplicationPath` annotation.
    You used `/api/v1` as the application path.
  prefs: []
  type: TYPE_NORMAL
- en: In step 12, you added and committed the changes to the local repository and
    then pushed the changes to the application gear. After the bits are pushed, OpenShift
    will stop all the cartridges and then invoke the `mvn -e clean package -Popenshift
    -DskipTests` command to build the project. Maven will build a `ROOT.war` file,
    which will be copied to the JBoss EAP `deployments` folder. After the build successfully
    finishes, all the cartridges are started. Then the new updated `ROOT.war` file
    will be deployed. You can view the running application at `http://jobstore-{domain-name}.rhcloud.com`.
    Please replace `{domain-name}` with your account domain name.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you tested the REST endpoints using `curl` in step 14.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can perform all the aforementioned steps with just a single command as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Configuring application security by defining the database login module
    in standalone.xml* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Managing JBoss cartridges using the management web interface and CLI* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring application security by defining the database login module in standalone.xml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the *Creating and deploying Java EE 6 applications using the JBoss EAP and
    PostgreSQL 9.2 cartridges* recipe, you learned how to develop a Java EE 6 application
    on OpenShift. The application allows you to create company entities and then assign
    jobs to them. The problem with the application is that it is not secured. The
    Java EE specification defines a simple, role-based security model for EJBs and
    web components. JBoss security is an extension to the application server and is
    included by default with your OpenShift JBoss applications. You can view the extension
    in the JBoss `standalone.xml` configuration file. The `standalone.xml` file exists
    in the `.openshift/config` location. The following code shows the extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: OpenShift allows developers to update the `standalone.xml` configuration file
    to meet their application needs. You make a change to the `standalone.xml` configuration
    file, commit the change to the local Git repository, then push the changes to
    the OpenShift application gear. Then, after the successful build, OpenShift will
    replace the existing `standalone.xml` file with your updated configuration file
    and then finally start the server. But please make sure that your changes are
    valid; otherwise, the application will fail to start.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to define the database login module in `standalone.xml`
    to authenticate users before they can perform any operation with the application.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for the application created in this recipe is on GitHub at [https://github.com/OpenShift-Cookbook/chapter7-jobstore-security](https://github.com/OpenShift-Cookbook/chapter7-jobstore-security).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe builds on the application created in the *Creating and deploying
    Java EE 6 applications using the JBoss EAP and PostgreSQL 9.2 cartridges* recipe.
    So, please refer to that recipe before continuing with this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to add security to your web application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the OpenShift application created in the *Creating and deploying Java
    EE 6 applications using the JBoss EAP and PostgreSQL 9.2 cartridges* recipe using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the application creation, SSH into the application gear, and connect
    with the PostgreSQL database using the `psql` client. Then, create the following
    tables and insert the test data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Exit from the SSH shell, and open the `standalone.xml` file in the`.openshift/config`
    directory. Update the security domain with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the web deployment descriptor (that is, `web.xml`) in the `src/main/webapp/WEB-INF`
    folder. Add the following content to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `login.html` file in the `src/main/webapp` directory. The `login.html`
    page will be used for user authentication. The following code shows the contents
    of this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an `error.html` file in the `src/main/webapp` directory. The `error.html`
    page will be shown after unsuccessful authentication. The following code shows
    the contents of this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Commit the changes, and push them to the OpenShift application gear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Go to the application page at `http://jobstore-{domain-name}.rhcloud.com`, and
    you will be asked to log in before you can view the application. Use `admin@jobstore.com/admin`
    as the username-password combination to log in to the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s now understand what you did in the preceding steps. In step 1, you recreated
    the `jobstore` application we developed in the *Creating and deploying Java EE
    6 applications using the JBoss EAP and PostgreSQL 9.2 cartridges* recipe. Next,
    in step 2, you performed an SSH into the application gear and created the `USERS`
    and `USER_ROLES` tables. These tables will be used by the JBoss database login
    module to authenticate users. As our application does not have the user registration
    functionality, we created a default user for the application. Storing the password
    as a clear text string is a bad practice, so we have stored the MD5 hash of the
    password. The MD5 hash of the `admin` password is `ISMvKXpXpadDiUoOSoAfww==`.
    If you want to generate the hashed password in your application, I have included
    a simple Java class, which uses `org.jboss.crypto.CryptoUtil` to generate the
    MD5 hash of any string. The `CryptoUtil` class is part of the `picketbox` library.
    The following code depicts this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In step 3, you logged out of the SSH session and updated the `standalone.xml`
    JBoss configuration file with the database login module configuration. There are
    several login module implementations available out of the box. This book will
    only talk about the database login module, as discussing all the modules is outside
    the scope of this book. You can read about all the login modules at [https://docs.jboss.org/author/display/AS7/Security+subsystem+configuration](https://docs.jboss.org/author/display/AS7/Security+subsystem+configuration).
    The database login module checks the user credentials against a relational database.
    To configure the database login module, you have to specify a few configuration
    options. The `dsJndiName` option is used to specify the application datasource.
    As we are using a configured PostgreSQL datasource for our application, you specified
    the same `dsJndiName` option value. Next, you have to specify the SQL queries
    to fetch the user and its roles. Then, you have specified that the password will
    be hashed against an MD5 hash algorithm by specifying the `hashAlgorithm` configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In step 4, you applied the database login module to the `jobstore` application
    by defining the security constraints in `web.xml`. This configuration will add
    a security constraint on all the web resources of the application that will restrict
    access to authenticated users with role admin. You have also configured your application
    to use FORM-based authentication. This will make sure that when unauthenticated
    users visit the website, they will be redirected to the `login.html` page created
    in step 5\. If the user enters a wrong e-mail/password combination, then they
    will be redirected to the `error.html` page created in step 6.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in step 7, you committed the changes to the local Git repository and
    pushed the changes to the application gear. OpenShift will make sure that the
    JBoss EAP application server uses the updated `standalone.xml` configuration file.
    Now, the user will be asked to authenticate before they can work with the application.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Installing modules with JBoss cartridges* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Managing JBoss cartridges using the management web interface and CLI* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing modules with JBoss cartridges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From version 7 of the JBoss application server, class loading is based on the
    JBoss Modules project. In this recipe, you will learn how to install the `Twitter4J`
    library as a module on the JBoss EAP 6 cartridge. The `modules` directory under
    the JBoss server home houses all the modules installed on the application server.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for the application created in this recipe is on GitHub at [https://github.com/OpenShift-Cookbook/chapter7-recipe4](https://github.com/OpenShift-Cookbook/chapter7-recipe4).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe builds on the application created in the *Creating and deploying
    Java EE 6 applications using the JBoss EAP and PostgreSQL 9.2 cartridges* recipe.
    So, please refer to that recipe before continuing with this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to install the `Twitter4J` library as a module:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the OpenShift application created in the *Creating and deploying Java
    EE 6 applications using the JBoss EAP and PostgreSQL 9.2 cartridges* recipe using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To install a new module, you have to create the module path under the `.openshift/config/modules`
    directory as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Download the `twitter4j-core` library from [http://mvnrepository.com/artifact/org.twitter4j/twitter4j-core/3.0.5](http://mvnrepository.com/artifact/org.twitter4j/twitter4j-core/3.0.5),
    and place it under the `.openshift/config/modules/org/twitter4j/main` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, in the `main` folder, add a file named `module.xml`. This file contains
    the actual module definition as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, to use this module in your application, you have to first add its dependency
    in your `pom.xml` file. Make sure that the scope is provided, as the server will
    already have this dependency since you are adding it as a module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Secondly, you have to update the Maven WAR plugin configuration by adding the
    `org.twitter4j` module dependency in the `META-INF/MANIFEST.MF` location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, commit the changes, and push them to the application gear. Now, after
    the server restarts, JBoss will have the `twitter4j` library as a module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding steps, you learned how to install a third-party library as
    a module. The alternative to using a third-party library is to add a compile scope
    dependency in `pom.xml` and then use the `twitter4j` library in your application.
    The advantage of using a module is that you do not have to bundle the JAR file
    with your application archive. If you are deploying multiple applications on a
    single server instance, then the server will only need one copy of the JAR file.
  prefs: []
  type: TYPE_NORMAL
- en: After creating the application in step 1, you created a directory structure
    required to define a module inside the`.openshift/config` directory in step 2\.
    This directory is added to the module path of the JBoss EAP server associated
    with your OpenShift application. It has the same structure as the standard JBoss
    EAP `modules` directory. Inside `org.twitter4j.main`, you placed the `twitter4j-core-3.0.5.jar`
    file in step 3\. In step 4, you created a file called `module.xml` inside the
    `org.twitter4j.main` directory. The `module.xml` file is used to define a module
    and its dependencies. The module name `org.twitter4j` corresponds to the module
    attribute that you will define in your application manifest. Next, you need to
    state the path to the `twitter4j-core` library and finally, its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in step 5, you added a provided scope dependency to the `twitter4j-core`
    library. The provided scope indicated that you expect the application container
    to provide the dependency at runtime. Also, provided dependencies are not packaged
    with web applications. This makes sure that the application archives are smaller
    in size and the application deploys faster. Also, in step 5, you updated the Maven
    WAR plugin configuration to add a dependency on the `org.twitter4j` module to
    the application archive `META-INF/MANIFEST.MF` file.
  prefs: []
  type: TYPE_NORMAL
- en: In step 6, you committed the changes and pushed them to the application gear.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, I have not covered how to use the `Twitter4J` library. If you
    want to see `Twitter4J` in action, I have created an application for you, which
    will tweet after posting a job. To use the application, you have to first create
    a Twitter application. Go to [https://dev.twitter.com](https://dev.twitter.com),
    and create a new Twitter application. Give the application the read-and-write
    level access. Once you are done, create a new OpenShift application by running
    the following command. Please replace the environment variable values with your
    Twitter application values. You can find these values under the Twitter application's
    **API Keys** section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: After the application is successfully created, a tweet will be sent after every
    job posting.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Managing JBoss cartridges using the management web interface and CLI* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing JBoss cartridges using the management web interface and CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JBoss provides three different ways to manage the server: a web interface,
    a command-line client, and the XML configuration files. In this recipe, you will
    learn how to deploy WAR files to your JBoss cartridge using the web management
    interface and JBoss CLI.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will need to have the JBoss application server
    binary on your local machine. This is required to connect with the JBoss cartridge
    using `jboss-cli`. Download the JBoss AS7 binary from the official website at
    [http://www.jboss.org/jbossas/downloads](http://www.jboss.org/jbossas/downloads).
    Extract the ZIP file, and you will find the `jboss-cli` script in the `bin` folder.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use the `jobstore` application that we created in the
    *Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new command-line terminal, and navigate to the directory where the `jobstore`
    application is located. Run the `rhc port-forward` command to forward the remote
    ports on your local machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the management interface at `http://127.0.0.1:9990` in your favorite web
    browser. This information is available in the output of the `rhc port-forward`
    command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this recipe, we will deploy the WAR file of the application we created in
    the *Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges* recipe using the JBoss management interface. Download the WAR
    file from [https://github.com/OpenShift-Cookbook/chapter7-recipe5/raw/master/ROOT.war](https://github.com/OpenShift-Cookbook/chapter7-recipe5/raw/master/ROOT.war)
    to your local machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After downloading the WAR file, navigate to **Runtime** | **Manage Deployments**,
    and remove the existing `ROOT.war` file by clicking on the **Remove** button as
    shown in the following screenshot. It will ask you to confirm the removal, and
    you can click on the **OK** button. Have a look at the following screenshot:![How
    to do it…](img/00062.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To deploy the WAR file, click on the **Add** button, and then upload the `ROOT.war`
    file from your local machine. After uploading the WAR file, you will be asked
    to verify the deployment name. Choose the default values, and click on the **Save**
    button as shown in the following screenshot:![How to do it…](img/00063.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uploading the WAR file does not initiate the deployment. You have to click on
    the **En/Disable** button to initiate the deployment. You will be asked to confirm
    your decision. Click on the **Confirm** button as shown in the following screenshot:![How
    to do it…](img/00064.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, if you go to `http://myapp-{domain-name}.rhcloud.com`, you will see your
    application deployed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Another way to deploy an application is via the `jboss-cli` command-line interface.
    The `jboss-cli` script can be found in your local downloaded JBoss archive `bin`
    folder. Launch the `jboss-cli` client, and you will see the message shown in the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To connect to the JBoss cartridge, type the `connect` command as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you can check the deployed applications using the `deploy` command. Type
    `deploy`, and then press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see in the preceding command, `ROOT.war` is currently deployed.
    This WAR file was deployed using the web interface. To withdraw this WAR file,
    type the `undeploy` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, if you go to `http://myapp-{domain-name}.rhcloud.com`, you will get a 404
    error as the application is not deployed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To deploy the application using `jboss-cli`, you can use the `deploy` command
    as shown in the following command line. Please make sure you have downloaded the
    application `ROOT.war` file as discussed in step 3\. Have a look at the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, you can see the application running at `http://myapp-{domain-name}.rhcloud.com`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding steps, you learned how to manage your application deployment
    from the JBoss web management and command-line interface. In step 1, you ran the
    `rhc port-forward` command to enable SSH port forwarding. The `rhc port-forward`
    command forwarded all the remote ports running on the application gear to your
    local machine. In the output of the `rhc port-forward` command, you can see that
    the management interface is exposed on port `9090`.
  prefs: []
  type: TYPE_NORMAL
- en: 'From step 3 through step 5, you saw how to connect with the web interface from
    your local machine and undeploy the existing `ROOT.war` file. The web interface
    is a **Google Web Toolkit** (**GWT**) application accessible on port `9090`. Google
    Web Toolkit is an open source set of tools that allows Java developers to write
    complex JavaScript-based web applications in Java. OpenShift only exposes port
    `8080` to the outside world; all other ports are internal to the application gear
    and can only be connected via port forwarding. This is a secure setup as no one
    from the outside world will be able to connect with your application web management
    interface, because the `rhc port-forward` command will only work if their SSH
    keys are uploaded. The web console is divided into two main tabs: the **Profile**
    and the **Runtime** tab. The **Profile** tab gives access to all the subsystem
    configurations. You can edit the configuration without fiddling with XML. For
    example, you can go to `http://127.0.0.1:9990/console/App.html#datasources` to
    edit the `datasource` configuration. The **Runtime** tab can be used to manage
    application deployment, and you used it to undeploy the WAR file in step 5\. You
    can learn more about the management interface from the documentation at [https://docs.jboss.org/author/display/AS7/Admin+Guide](https://docs.jboss.org/author/display/AS7/Admin+Guide).'
  prefs: []
  type: TYPE_NORMAL
- en: In step 6, you uploaded the `ROOT.war` file to your JBoss cartridge. After upload,
    the deployment is listed in the **Deployments** table. The WAR file is not deployed
    by default; you have to click on the **En/Disable** button to enable the deployment
    of the application as you did in step 7.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to deploy an application is using the `jboss-cli` command-line
    interface. In step 9, you launched the `jboss-cli` script. The `jboss-cli` console
    provides a built-in autocomplete feature using the *Tab* key. At any point in
    time, you can list all the available commands using the *Tab* key as shown in
    the following command. For brevity, only part of the output is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In step 9, you undeployed the existing `ROOT.war` file using the `undeploy`
    command. The `undeploy` command takes the application that is already deployed
    as an argument. Finally, in step 10, you deployed the `ROOT.war` file on your
    local machine to the JBoss cartridge running on OpenShift using the `deploy` command.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Configuring application security by defining the database login module
    in standalone.xml* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Installing modules with JBoss cartridges* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and deploying Spring applications using the Tomcat 7 cartridge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Framework is a very popular alternative to Java EE web development.
    Java developers around the world use Spring Framework to build their enterprise
    applications. Spring Framework is often thought of as a lightweight alternative
    to Java EE, and Java developers normally use a lightweight web container, such
    as Apache Tomcat, for deployment. At the time of this writing, OpenShift supports
    two versions of Apache Tomcat: Apache Tomcat 6 and Apache Tomcat 7\. They are
    shown using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this recipe, you will learn how to develop a simple Spring Framework application
    from scratch using OpenShift's Tomcat 7 cartridge. The application exposes a REST
    endpoint. When a user makes an HTTP request to `/api/v1/ping`, then the applicaton
    will return a JSON response with the message `It works`.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for the application created in this recipe is on GitHub at [https://github.com/OpenShift-Cookbook/chapter7-jobstore-spring](https://github.com/OpenShift-Cookbook/chapter7-jobstore-spring).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will need the `rhc` command-line client installed
    on your machine. Please refer to the *Installing the OpenShift rhc command-line
    client* recipe in [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting
    Started with OpenShift"), *Getting Started with OpenShift*, for details.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to create an application using Spring Framework:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new command-line terminal, and go to a convenient location. Create a
    new Tomcat 7 and MySQL 5.5 application by executing the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding command will create a Maven-based project and clone it to your
    local machine.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open Eclipse and navigate to the project workspace. Then, import the application
    created in step 1 as a Maven application. To import an existing Maven project,
    navigate to **File**|**Import**|**Maven**|**Existing Maven Projects**. Then browse
    to the location of your OpenShift Maven application created in step 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, update `pom.xml` to use Java 7\. The Maven project created by OpenShift
    is configured to use JDK 6\. Replace the properties with the one shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Update the Maven project to allow the changes to take effect. You can update
    the Maven project by right-clicking on the project and navigating to **Maven**|**Update
    Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add Spring Maven dependencies to your `pom.xml` file. These are the minimum
    dependencies that you need to write a REST JSON web service using Spring Framework.
    The code is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new package called `org.myapp.config`, and create a new class named
    `WebMvcConfig`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create another configuration class in the `org.myapp.config` package. This
    `@Configuration` class will be used for defining application beans, such as `datasource`,
    and so on. This will be covered later in this recipe. The code is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From Servlet 3.0 onwards, the `web.xml` deployment descriptor is optional.
    Prior to Servlet 3.0, we configured the Spring MVC dispatcher servlet in `web.xml`,
    but now we can programmatically configure it using `WebApplicationInitializer`.
    Create a new class called `JobStoreWebApplicationInitializer` in the `org.myapp.config`
    package as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will create a simple REST resource called `PingResource`. `PingResource`
    will be invoked when a request is made to `/api/v1/ping` and will respond with
    a JSON message. Create a new class called `PingResource` in the `org.myapp.rest`
    package. Have a look at the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, create another class called `PingResponse` as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Commit the changes and push them to the OpenShift application gear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can test the `PingResource` using a command-line tool, such as `curl`,
    or by opening the `http://myapp-{domain-name}.rhcloud.com/api/v1/ping` location
    in your favorite browser. You should see the following JSON message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding steps, we created a Spring application and deployed it to
    OpenShift. In step 1, you used the `rhc create-app` command to create Apache Tomcat
    7 MySQL 5.5\. Every OpenShift web cartridge specifies a template application that
    will be used as the default source code of the application. For Java-based web
    cartridges, such as JBoss EAP, JBoss AS7, Tomcat 6, and Tomcat 7, the template
    is a Maven-based application. After the application is created, the template application
    is cloned to the local machine using Git. The directory structure of the application
    is shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding command-line output, apart from the`.git` and
    `.openshift` directories, this looks like a standard Maven project. OpenShift
    uses Maven for managing application dependencies and building your Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: The directory structure was explained in the *Creating and deploying Java EE
    6 applications using the JBoss EAP and PostgreSQL 9.2 cartridges* recipe. Please
    refer to the recipe to get an understanding of the directory structure.
  prefs: []
  type: TYPE_NORMAL
- en: From step 3 through step 5, you made a few changes in `pom.xml`. You updated
    the project to use JDK 1.7 for the Maven compiler plugin. All the OpenShift Java
    applications use OpenJDK 7, so it makes sense to update the application to also
    use JDK 1.7 for compilation. Another change you made to `pom.xml` is that you
    updated the Maven WAR plugin configuration not to fail the build if `web.xml`
    is not found. Next, you added the Spring Web MVC dependencies to `pom.xml`. The
    Servlet 3.1.0 is provided, as this should exist in Apache Tomcat 7\. The `jackson-databind`
    dependency is added to convert Java objects to JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'From step 6 through step 8, you configured the Spring Web MVC framework programmatically.
    Normally, we configure the Spring Web MVC dispatcher servlet in `web.xml`, but
    now, we can programmatically configure it using `WebApplicationInitializer`. From
    Spring 3.1, Spring provides an implementation of the `ServletContainerInitializer`
    interface called `SpringServletContainerInitializer`. The `SpringServletContainerInitializer`
    class delegates to an implementation of `org.springframework.web.WebApplicationInitializer`
    that you provide. There is just one method that you need to implement: `WebApplicationInitializer#onStartup(ServletContext)`.
    You are handed the `ServletContext` parameter that you need to initialize.'
  prefs: []
  type: TYPE_NORMAL
- en: From step 9 through step 11, you created a simple REST JSON resource called
    `PingResource` using Spring MVC. `PingResource` is available at the`/api/v1/ping`
    URL as defined using the `@RequestMapping` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can perform all the preceding steps with just the following single command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Taking thread dumps of Java cartridges* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking thread dumps of Java cartridges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to take thread dumps of your Java cartridge
    applications. A thread dump lists all the Java threads that are currently active
    in a **Java Virtual Machine** (**JVM**). It can help you understand the state
    of every thread in the JVM at a particular point in time. It gives you a snapshot
    of exactly what's executing at a moment in time. Thread dumps are very useful
    to debug a deadlock condition or to understand resource usage.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This command will work with all the four supported Java cartridges (Apache Tomcat
    6, Apache Tomcat 7, JBoss AS7, and JBoss EAP).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe will request for a thread dump of the application created in the
    *Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges* recipe. So, please refer to the aforementioned recipe before continuing
    with this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to take a thread dump of your Java application:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new command-line terminal, and navigate to the directory where the `jobstore`
    application is located.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To take a thread dump of the `jobstore` application, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you run the `rhc threaddump` command, the JBoss EAP cartridge initiates
    a thread dump. It first gets the process ID of the JBoss application server and
    then runs the `kill -3 <process id>` command. The `kill -3` command sends the
    `HUP` or `BREAK` signal to the Java process. The thread dump log will be placed
    in the `jbosseap.log` file in `$OPENSHIFT_LOG_DIR/`, which you can download on
    your local machine for analysis. You can also view the logfile using the `rhc
    tail` command, as mentioned in the following command output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'To download the thread dump file on your local machine, you can use the `rhc
    scp` command. The `rhc scp` command can be used to transfer files to and from
    your applications using SCP ([http://en.wikipedia.org/wiki/Secure_copy](http://en.wikipedia.org/wiki/Secure_copy)).
    Run the following command to download the `jbosseap.log` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can use tools, such as samurai ([http://yusuke.homeip.net/samurai/en/index.html](http://yusuke.homeip.net/samurai/en/index.html)),
    to analyze the thread dump on your local machine.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also take a thread dump of the Java application using the `jps` and
    `jstack` JVM tools. To do that, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a command-line terminal and then SSH into the `jobstore` application gear
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once inside the application gear, run the `jps` utility to list all the available
    Java processes as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `jps` utility ships with JDK and lists all the Java process IDs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output of the `jps -l` command is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, to take a thread dump of the Java process with ID `157027`, run the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `jstack` utility is also part of JDK and is used to take a thread dump of
    a Java process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Choosing between Java 6 and Java 7* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Enabling hot deployment for Java applications* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing between Java 6 and Java 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OpenShift supports both Java 6 and Java 7 to run your applications. By default,
    all the Java applications use OpenJDK 7, but you can configure your application
    to use OpenJDK 6 as well. To get the exact version of your Java installation,
    you can SSH into the application gear and run the `java -version` command or run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In this recipe, you will learn how you can choose among different supported
    versions of Java.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recipe will work with all the four supported Java cartridges (Apache Tomcat
    6, Apache Tomcat 7, JBoss AS7, and JBoss EAP).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to switch to OpenJDK 6:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new JBoss AS 7 application by running the following command. If you
    already have a Java application deployed on OpenShift, then you can use that as
    well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the application is created, you can check the default Java version by
    running the `java -version` command on the application gear as shown in the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To configure your application to use Java 6, delete a marker file called `java7`
    in the `.openshift/markers` directory as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Commit the changes and push them to your application gear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After a successful build, run the `java -version` command again to verify that
    you are now using Java 6 as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenShift uses the marker files to configure various aspects of the application,
    such as the Java version, hot deployment, debugging, and so on. The presence of
    a marker file in the `.openshift/markers` location tells OpenShift that you want
    to enable the feature. For example, every OpenShift application has a `java7`
    marker file in the `.openshift/markers` directory that informs OpenShift that
    it should use Java 7 for application deployment. When you perform code deployment
    using `git push`, OpenShift will set the `JAVA_HOME` environment variable depending
    on the Java version you want to use in your application.
  prefs: []
  type: TYPE_NORMAL
- en: To use Java 6, you just deleted the `java7` marker file. This informs OpenShift
    that it should fall back to Java 6\. From now on, your application will use Java
    6.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Taking thread dumps of Java cartridges* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Enabling hot deployment for Java applications* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling hot deployment for Java applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every time you make a change and push it to the OpenShift application gear,
    OpenShift stops your gear (that is, all the cartridges), copies the source code
    from your application Git repo to `app-root/runtime/repo`, performs a build, prepares
    the artifact, and finally starts your gear (that is, all the cartridges). This
    process takes time and does not suit rapid development. To enable rapid development
    and faster deployment, OpenShift supports hot deployment. Hot deployment means
    that you can deploy your changes without the need to restart all the application
    cartridges.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recipe will work with all the four supported Java cartridges (Apache Tomcat
    6, Apache Tomcat 7, JBoss AS7, and JBoss EAP).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to enable hot deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new command-line terminal, and navigate to the directory where you want
    to create the application. To create a new JBoss EAP application, execute the
    following command. If you already have an OpenShift Java application, then you
    can work with that as well. Have a look at the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To enable hot deployment, create a new file with the name `hot_deploy` inside
    the `.openshift/markers` directory. On *nix machines, you can create a new file
    using the `touch` command as shown in the following command. On Windows machines,
    you can use file explorer to create a new file. Have a look at the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the new file to the Git repository index, commit it to the local repository,
    and then push the changes to the application''s remote Git repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `git push` logs, you will see a message that cartridges are not stopped
    because hot deployment is enabled as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The presence of the `hot_deploy` marker file informs OpenShift that you want
    to do hot deployment. Before stopping and starting the application cartridges,
    OpenShift checks for the existence of the `hot_deploy` marker file. For JBoss
    cartridges, hot deployment is achieved by using the JBoss deployment scanner.
    The scanner polls the `deployments` directory every 5 seconds to check for the
    existence of the WAR file. If the WAR file exists, it will undeploy the existing
    WAR file and deploy the new WAR file. You can configure the deployment scanner''s
    `scan-interval` option in `.openshift/config/standalone.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: When your application is using hot deploy, then your application will have downtime
    starting when the JBoss deployment scanner recognizes the new WAR file, undeploys
    the old one, and deploys the new WAR file. Your application will be back online
    once the new file is deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Hot deployment is ideal for development, and I recommend you should always use
    it during development.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you set new environment variables with hot deployment enabled, then you have
    to restart the application to allow the server to pick the new environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Taking thread dumps of Java cartridges* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Choosing between Java 6 and Java 7* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skipping the Maven build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every OpenShift Java application is a Maven-based application. Whenever you
    run a `git push` command, a Maven build is performed, and the resulting archive
    (WAR or EAR) is deployed. There are scenarios where you don't want to do a Maven
    build with every push to the gear. These scenarios can be WAR deployment or executing
    only action hooks. In this recipe, you will learn how to skip the Maven build
    step during deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recipe will work with all the four supported Java cartridges (Apache Tomcat
    6, Apache Tomcat 7, JBoss AS7, and JBoss EAP).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will need the `jobstore` application created in
    the *Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges* recipe. Please refer to this recipe if you don't have a running
    OpenShift application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to skip the Maven build:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new command-line terminal, and navigate to the directory where the `jobstore`
    application is located. If you don't have a Java OpenShift application, then you
    can recreate a new application by following the steps mentioned in the *Creating
    and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL 9.2 cartridges*
    recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To skip a Maven build during deployment, create a marker file called `skip_maven_build`
    in the `.openshift/markers` directory. On *nix systems, you can use the `touch`
    command as shown in the following command. On Windows machines, you can use file
    explorer. Have a look at the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the new file to the Git repository index, commit it to the local repository,
    and then push the changes to the application''s remote Git repository as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The presence of the `skip_maven_build` marker informs OpenShift that it should
    not build the application. In the `git push` command output, you will see that
    the Maven build is skipped because of the presence of the `skip_maven_build` marker
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to skip the Maven build is to delete the `pom.xml` file. If there
    is no `pom.xml` file, then OpenShift does not try to build the application.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Forcing a clean Maven build* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Installing the JAR file not present in the Maven central repository* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Overriding the default Maven build command* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forcing a clean Maven build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first time you push your changes to the application gear, Maven will download
    all the dependencies and will store those dependencies in the `.m2` directory
    under your application gear home directory. After the first push, OpenShift will
    reuse all the dependencies in the `.m2` repository and will only download new
    dependencies. This saves build time and make application deployment faster. But,
    there are a few situations when you want to do a clean build. One situation can
    be when you want to download all the latest Maven dependencies. In this recipe,
    you will learn how you can inform OpenShift to perform a clean build.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recipe will work with all the four supported Java cartridges (Apache Tomcat
    6, Apache Tomcat 7, JBoss AS7, and JBoss EAP).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will need the `jobstore` application created in
    the *Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges* recipe. Please refer to this recipe if you don't have a running
    OpenShift application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to force a clean Maven build of your Java application:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new command-line terminal, and navigate to the directory where the `jobstore`
    application is located. If you don't have a Java OpenShift application, then you
    can recreate a new application by following the steps mentioned in the *Creating
    and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL 9.2 cartridges*
    recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To force a clean Maven build during deployment, create a marker file called
    `force_clean_build` inside the application''s`.openshift/markers` directory. On
    *nix systems, you can use the `touch` command as shown in the following command.
    On Windows machines, you can use file explorer. Have a look at the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the new file to the Git repository index, commit it to the local repository,
    and then push the changes to the application''s remote Git repository as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The presence of the `force_clean_build` marker file informs OpenShift that
    you want to do a clean build. When you run a `git push` command, OpenShift will
    first delete the `.m2` directory and then start the build process by invoking
    the `mvn clean package -Popenshift -DskipTests` command. Maven will now download
    all the dependencies again. You will see the following log message in the `git
    push` command output. Have a look at the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Forcing a clean Maven build* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Installing the JAR file not present in the Maven central repository* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Overriding the default Maven build command* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding the default Maven build command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenShift, by default, will execute the `mvn -e clean package -Popenshift -DskipTests`
    command to build the project. If you don't want to use the OpenShift Maven profile
    or want to run tests, then you have to tell OpenShift to run a different command.
    In this recipe, you will learn how you can tell OpenShift to use a different command.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will need the `jobstore` application created in
    the *Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges* recipe. Please refer to this recipe if you don't have a running
    OpenShift application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to override the default Maven build command:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new command-line terminal, and navigate to the directory where the `jobstore`
    application is located.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To configure OpenShift to use a different build command, create a new environment
    variable with the name `MAVEN_ARGS`. The value of the `MAVEN_ARGS` environment
    variable is the Maven build phases you want to run, as shown in the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before running the build, OpenShift first checks whether the environment variable
    called `MAVEN_ARGS` is set. It uses the phases and goals defined in this environment
    variable to create a Maven command that will be used to build the project. If
    `MAVEN_ARGS` is not set, then it will set the default value, that is, `clean package
    -Popenshift -DskipTests`, else it will use the value of the `MAVEN_ARGS` environment
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when you run the `git push` command, you will see an entry in the `git
    push` logs, as shown in the following command output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Forcing a clean Maven build* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Installing the JAR file not present in the Maven central repository* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Skipping the Maven build* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the JAR file not present in the Maven central repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenShift will download all the dependencies from the Maven central repositories
    specified in your `pom.xml` file. There are times when your application depends
    on the libraries that do not exist in any public Maven repository. In this recipe,
    you will learn how you can use the OpenShift action hooks to install a local JAR.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will need the `jobstore` application created in
    the *Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges* recipe. Please refer to this recipe if you don't have a running
    OpenShift application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to install the JAR file not present in the configured
    Maven repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new command-line terminal, and navigate to the directory where the `jobstore`
    application is located.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `lib` directory in the root of your application directory, and add
    your local JAR file here. To demonstrate this recipe, I have created a simple
    library that you can download from [https://github.com/OpenShift-Cookbook/chapter7-recipe14/raw/master/lib/simplelogger-0.0.1.jar](https://github.com/OpenShift-Cookbook/chapter7-recipe14/raw/master/lib/simplelogger-0.0.1.jar).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `pre_build` action hook inside the `.openshift/action_hooks` directory,
    and add the following content to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following command will install the JAR file to the local Maven repository
    located on the application gear:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make sure the `pre_build` action hook is executable. You can make the `pre_build`
    action hook script executable by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the dependency to the application''s `pom.xml` file so that your application
    can use the library in the application source code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step 2, you created a `lib` directory inside the application source code
    root. You downloaded the `simplelogging` library and placed it in the `lib` directory.
    Next, in step 2, you created a `pre_build` action hook that installs the `simplelogging-0.0.1.jar`
    file into the application gear's`.m2` repository. The `pre_build` script is executed
    before the build step. This means your library will be available during the build.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On Windows, the execute permissions on the action hooks will be lost during
    `git push`. You can fix the problem by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you added the library as a dependency in your application's `pom.xml`
    file so that you can use the library in your application.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Forcing a clean Maven build* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Overriding the default Maven build command* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Skipping the Maven build* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing OpenShift Java applications using Eclipse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can build, deploy, and manage your OpenShift Java applications right from
    within the Eclipse IDE using the JBoss Tools OpenShift plugin. This recipe will
    guide you through installation, setup, application creation, and managing your
    application from within Eclipse. In this recipe, you will develop a Java EE 6
    PostgreSQL 9.2 application and deploy it on the JBoss EAP 6 application server
    running on OpenShift all from within Eclipse.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Download the latest Eclipse package for your operating system from the official
    Eclipse website at [http://www.eclipse.org/downloads/](http://www.eclipse.org/downloads/).
    At the time of this writing, the latest Eclipse package is Kepler.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is very easy to install Eclipse; just extract the downloaded package, and
    we are done. On Linux and Mac, open a new command-line terminal, and type the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: On Windows, you can extract the ZIP file using WinZip or 7-zip ([http://www.7-zip.org/download.html](http://www.7-zip.org/download.html))
    or any other software.
  prefs: []
  type: TYPE_NORMAL
- en: After we have extracted the Eclipse file, there will be a folder named `*eclipse*`
    in the directory where we extracted Eclipse. We can optionally create a shortcut
    to the executable file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is recommended that you use the latest version of Eclipse, that is, Kepler,
    to work with OpenShift. Earlier versions are not supported and might not even
    work.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to create OpenShift applications using OpenShift
    Eclipse tooling:'
  prefs: []
  type: TYPE_NORMAL
- en: After downloading and extracting the Eclipse Kepler IDE for Java EE, open Eclipse,
    and navigate to the project workspace. Navigate to **Help**|**Eclipse Marketplace**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the search box, type `jboss tools`, and then click on the **Go** button.
    After clicking on the **Go** button, we will see **JBoss Tools (Kepler)** as the
    first result. Now click on the **Install** button. Have a look at the following
    screenshot:![How to do it…](img/00065.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After clicking on the **Install** button, you will get a list of plugins that
    you can install. As the purpose of this recipe is to demonstrate the OpenShift
    Eclipse support, we will only select **JBoss OpenShift Tools** from the list.
    After selecting **JBoss OpenShift Tools**, click on the **Confirm** button. Have
    a look at the following screenshot:![How to do it…](img/00066.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accept the license by clicking on the **I accept the terms of the license agreement**
    radio button, and then click on the **Finish** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the JBoss Tools OpenShift plugin is unsigned, you will get a security message.
    Click on the **OK** button, and restart Eclipse to apply the changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you've installed the OpenShift Eclipse plugin, you have everything
    required to start building the application. Create a new OpenShift application
    by navigating to **File**|**New**|**Other**|**OpenShift Application**:![How to
    do it…](img/00067.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Next** button, and you will be asked to provide your OpenShift
    account credentials. If you do not have an OpenShift account, you can click on
    the sign up **here** link on the wizard to create a new OpenShift account. Have
    a look at the following screenshot:![How to do it…](img/00068.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter your OpenShift account details. Also, check the **Save password** checkbox
    so that we do not have to enter the password with every command. Click on the
    **Next** button. Have a look at the following screenshot:![How to do it…](img/00069.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After clicking on the **Next** button, you will be asked to enter additional
    information for password recovery. I choose **No**, but you can choose **Yes**
    as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will be asked to create a new OpenShift domain if you don't have a
    domain associated with your account already. The domain name is the unique namespace,
    and all the user applications will exist under this namespace. This is shown in
    the following screenshot:![How to do it…](img/00070.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will be asked to upload your public SSH keys to OpenShift, as shown
    in the following screenshot:![How to do it…](img/00071.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can either upload your existing SSH keys or create a new SSH key by clicking
    on the **New** button. Let's create a new key by clicking on the **New** button.
    We need to provide a name for the key and a name for the private and public key
    filenames. I have used my name as the key name and filename. Have a look at the
    following screenshot:![How to do it…](img/00072.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you will be directed to the application creation wizard where you have
    to enter the application details. The details include the name of the application,
    the type of the application, the gear profile (whether you want a small, medium,
    or large instance; in a free tier, you have access only to small instances), whether
    you want a scalable application or a nonscalable application, and whether you
    want to embed any or multiple cartridges, such as MySQL, PostgreSQL, MongoDB,
    and others. For our application, we will select the JBoss EAP and PostgreSQL cartridges.
    We will name the application `jobstore` as shown in the following screenshot:![How
    to do it…](img/00073.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you have to set up a `jobstore` application and configure the server adapter
    settings. Choose the default and click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next screen will ask us to specify the location where we want to clone the
    Git repository and the name of the Git remote. Have a look at the following screenshot:![How
    to do it…](img/00074.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, click on the **Finish** button to initiate the application creation
    process. This will create an application container for us, called a gear, and
    set up all the required SELinux policies and cgroup configuration. OpenShift will
    install the PostgreSQL cartridge on the application gear, and the JBoss Tools
    OpenShift plugin will show an information box with the PostgreSQL details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the project is imported as a Maven project in the Eclipse workspace.
    After importing the application to Eclipse, you will be asked whether you want
    to publish the uncommitted changes. You might start wondering why it is asking
    you to publish changes. The reason is that when a project is imported into Eclipse,
    JBoss Tools creates a new file called `.jsdtscope` under the `.settings` directory.
    As the file is not ignored, the OpenShift Eclipse plugin asks you for a deployment.
    You can easily ignore the file by navigating to the **Git Staging** view. To open
    the **Git Staging** view, navigate to **Window**|**Show View**|**Other**|**Git**|**Git
    Staging**. Have a look at the following screenshot:![How to do it…](img/00075.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `.jsdtscope` file under the **Git Staging** view, and then
    choose **Ignore**. Have a look at the following screenshot:![How to do it…](img/00076.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, open the **OpenShift Explorer** view. Navigate to **Window**|**Show View**|**Other**|**JBoss
    Tools**|**OpenShift Explorer**. This will open up a new view as shown in the following
    screenshot:![How to do it…](img/00077.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, right-click on the application, and then click on the **Show in Web Browser**
    option. This will open up the template application in the default browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The preceding steps help you to create OpenShift Java applications using Eclipse.
    In this recipe, I used the JBoss EAP cartridge, but you can do the same for the
    Tomcat or JBoss AS7 cartridge. The preceding steps are self-explanatory and do
    not require any explanation. Now, I will explain to you how your development workflow
    should work. The recommended way to work with OpenShift Eclipse tooling is split
    into two steps, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Write code for functionality, and then commit the code to a Git local repository
    using the **Git Staging** view. The **Git Staging** view gives a graphical view
    to the changes, and you can easily compare and look at all the files we have changed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Git Staging** view, you have two options. You can either commit the
    changes to the local repository or do a commit and push together. When you perform
    `git commit` and `push` together, the code is pushed to a Git remote called `origin`.
    The `origin` remote points to a private Git repository created by OpenShift. When
    the code is pushed to the remote repository, OpenShift will kick off the build.
    The problem with the **Git Staging** view **Commit and Push** button is that you
    will not be able to monitor the application build logs. To view the application
    build logs, you should use the server view publication mechanism. We will use
    the server configured for the `jobstore` OpenShift application. To publish the
    changes, right-click on the server, and click on **Publish**. This internally
    does a `git push`. The advantage of this approach is that it will open up a new
    console view, where we can monitor the application build progress.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s make a small change to the application to better understand the development
    workflow discussed in the previous section. Open the `index.html` file, and consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'And change it to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to the **Git Staging** view, and you will see the change shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/00078.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, drag the change to **Staged Changes**, and write a commit message. Have
    a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/00079.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Commit the change by clicking on the **Commit** button. As I mentioned before,
    do not use **Commit and Push**, as that will trigger application deployment and
    will not show the build log. The build log is very useful when the build fails.
  prefs: []
  type: TYPE_NORMAL
- en: Go to the **Servers** view, and you will see a server configured for the `jobstore`
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the application server, and then click on **Publish**. Have
    a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/00080.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You will get a dialog where you have to confirm whether you want to publish
    the changes or not. Click on **Yes**, and it will open a new **Console** view
    where we can track the build progress. Have a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/00081.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To view the logfiles of the JBoss EAP application server, go to the **OpenShift
    Explorer** view, and right-click on the application. Click on **Tail files…**.
    Have a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/00082.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, you will configure to tail only the JBoss EAP `server.log` file. By default,
    it will tail all the logfiles, which includes the database logfiles as well, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/00083.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It will open up another console view where it will tail only the JBoss EAP `server.log`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can view the change in the browser by right-clicking on the **jobstore**
    server, and then navigating to **Show In**|**Web Browser**. This will open up
    the default web browser, where we can view the change that we made in `index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can do a lot more with the OpenShift Eclipse plugin. For faster development,
    you should enable hot deployment. The OpenShift Eclipse plugin makes it very easy
    to enable hot deployment. To enable hot deployment, right-click on the project,
    and then navigate to **OpenShift**|**Configure Markers**. Have a look at the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/00084.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, you will see a view where you can configure which OpenShift markers you
    want to enable for the application. Select the **Hot Deploy** marker. Have a look
    at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/00085.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This will create a new empty file called `hot_deploy` in the `.openshift/markers`
    directory. You can commit the changes by going to the **Git Staging** view. Go
    to the **Servers** view, and publish this change. The build log will show that
    the cartridges are not stopped as hot deploy is enabled. Have a look at the following
    build log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using Eclipse System Explorer to SSH into the application gear* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Debugging Java applications in the Cloud* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Eclipse System Explorer to SSH into the application gear
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how you can SSH into the application gear from
    within Eclipse.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires you to have Eclipse with the JBoss Tools OpenShift plugin
    installed. Please refer to the *Developing OpenShift Java applications using Eclipse*
    recipe for more information.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to learn how to SSH into the application gear from
    within Eclipse:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new application using the OpenShift Eclipse plugin. Refer to the *Developing
    OpenShift Java applications using Eclipse* recipe for instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Window**|**Open Perspective**|**Other**|**Remote System Explorer**
    to open the **Remote System Explorer** perspective. Have a look at the following
    screenshot:![How to do it…](img/00086.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **OpenShift Explorer** and copy the SSH connection details as shown in
    the following screenshot:![How to do it…](img/00087.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the SSH details as shown in the following screenshot:![How to do it…](img/00088.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to the **Remote System Explorer** perspective, and define a new connection
    to the remote system as shown in the following screenshot:![How to do it…](img/00089.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, it will ask you to select the remote system type. Select the **SSH Only**
    option as shown in the following screenshot:![How to do it…](img/00090.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will be asked to enter the details of the new connection. Enter the
    hostname of your application as shown in the following screenshot:![How to do
    it…](img/00091.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Finish** button to create a new connection. The connection will
    be listed in the left-hand side bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To open an SSH terminal, navigate to **Ssh Terminals**|**Launch Terminal** as
    follows:![How to do it…](img/00092.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will be asked to enter the user ID with which you want to connect.
    The user ID is the `UUID` part of the SSH connection URL. Click on **OK**. Have
    a look at the following screenshot:![How to do it…](img/00093.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch the terminal again, and you will see an SSH terminal as shown in the
    following screenshot:![How to do it…](img/00094.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding steps, you used Eclipse Remote System Explorer to SSH into
    the OpenShift application gear. Remote System Explorer comes bundled with Eclipse
    Kepler for Java EE. Remote System Explorer allows you to connect and work with
    a variety of remote systems. To learn more about Remote System Explorer, you can
    refer to the documentation at [http://help.eclipse.org/kepler/index.jsp?nav=%2F56](http://help.eclipse.org/kepler/index.jsp?nav=%2F56).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Developing OpenShift Java applications using Eclipse* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Debugging Java applications in the Cloud* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging Java applications in the Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to debug Java applications running on OpenShift.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires you to have Eclipse with the JBoss Tools OpenShift plugin
    installed. Please refer to the *Developing OpenShift Java applications using Eclipse*
    recipe for more information.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to learn how to debug your Java applications:'
  prefs: []
  type: TYPE_NORMAL
- en: In the *Developing OpenShift Java applications using Eclipse* recipe, you learned
    how to create a Java application using the Eclipse plugin. The application that
    we developed used the OpenShift template application as its starting point. As
    you might know, in the `rhc` command line, you can use the `--from-code` option
    to specify your own template application. Let's create a new Java application
    using Eclipse that uses the application we created in the *Creating and deploying
    Java EE 6 applications using the JBoss EAP and PostgreSQL 9.2 cartridges* recipe
    using Eclipse. Create a new OpenShift application by navigating to **File**|**New**|**Other**|**OpenShift
    Application**. After validating your account, you will get a screen where you
    need to enter the application details. Please select the **JBoss EAP** and **PostgreSQL
    9.2** cartridges. To specify the Git repository, click on the **Advanced** button,
    and then uncheck the **Use default source code** checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the input box, specify the URL of the Git repository as shown in the following
    screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/00095.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Next, you have to set up a `jobstore` application and configure the server adapter
    settings. Choose the default and click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next screen will ask us to specify the location where you want to clone
    the Git repository and the name of the Git remote. Specify a writable directory,
    and click on **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, a new application instance will be created using the selected cartridges
    and Git repository. Finally, the project will be imported into Eclipse as a Maven
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To enable debugging, you have to create a new marker file called `enable_jpda`
    inside the `.openshift/markers` directory. The Eclipse plugin can help us create
    the file. Right-click on the project, and navigate to **OpenShift** |**Configure
    Markers…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will open a dialog where you can select the marker files. Select the **Enable
    JPDA** marker as shown in the following screenshot. This will create a new file
    called `enable_jpda` inside the `.openshift/markers` directory.![How to do it…](img/00096.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **Git Staging** view, and commit the change. Have a look at the following
    screenshot:![How to do it…](img/00097.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After committing the change, go to the **Servers** view, and publish your changes.
    This will start the server with JPDA enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, enable port forwarding so that you can connect with the JPDA port. Go to
    the **OpenShift Explorer** view, and right-click on the project to enable port
    forwarding. Have a look at the following screenshot:![How to do it…](img/00098.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will open a dialog where you can configure port forwarding. Click on the
    **Start All** button to enable port forwarding. The port `8787` is used to debug.
    This is shown in the following screenshot:![How to do it…](img/00099.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we will add the breakpoint to the `CompanyResource` class at line number
    32\. After setting the debug point, create a new debug configuration by right-clicking
    on the debug point, navigating to **Debug Configurations**|**Remote Java Application**|**New**
    and giving it a name, and enter the port as `8787` as shown in the following screenshot:![How
    to do it…](img/00100.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After entering all the details, click on the **Debug** button. Open the debug
    perspective, and you will see the remote debugger in action. Please note that
    it will take some time to enable remote debugging, so please be patient. This
    is shown in the following screenshot:![How to do it…](img/00101.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, go to `http://jobstore-{domain-name}.rhcloud.com/#companies/new` and create
    a new company. This will invoke the breakpoint as shown in the following screenshot:![How
    to do it…](img/00102.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The preceding steps enable Java developers to debug their OpenShift Java applications.
    To enable debugging, you created a marker file under the`.openshift/markers` directory
    using the Eclipse plugin. The file is committed, and the changes are pushed to
    the OpenShift application gear. After a push, the JBoss server is stopped and
    then started again. The JBoss cartridge checks the presence of the `enable_jpda`
    file. If the `enable_jpda` marker file exists, then the server is started in debug
    mode. The debugging provided by JBoss is based on the **Java Platform Debugger
    Architecture** (**JPDA**). To enable debugging, the JBoss server is started with
    the `JAVA_OPTS` environment variable set to the value shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: As the port `8787` is not accessible to the outside world, you have to enable
    port forwarding. After enabling port forwarding, you created a new remote Java
    application that will connect to the JBoss EAP cartridge running in debug mode.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Developing OpenShift Java applications using Eclipse* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using Eclipse System Explorer to SSH into the application gear* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
