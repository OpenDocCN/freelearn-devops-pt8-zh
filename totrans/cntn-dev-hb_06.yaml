- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Fundamentals of Container Orchestration
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器编排的基本原理
- en: So far, we have learned what software containers are, how they work, and how
    to create them. We focused on using them, as developers, to create our applications
    and distribute functionalities into different components running in containers.
    This chapter will introduce you to a whole new perspective. We will learn how
    our applications run in production using containers. We will also introduce the
    concept of container orchestrators and cover what they can deliver and the key
    improvements we need to include in our applications to run them in a distributed
    cluster-wide fashion.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了什么是软件容器，它们如何工作，以及如何创建它们。我们专注于作为开发人员使用它们，创建我们的应用程序并将功能分布到在容器中运行的不同组件中。本章将为你介绍一个全新的视角。我们将学习如何在生产环境中使用容器运行我们的应用程序。我们还将介绍容器编排器的概念，探讨它们能提供什么，并讨论我们需要在应用程序中加入哪些关键改进，以便在分布式集群中以集群范围的方式运行它们。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing the key concepts of orchestration
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍编排的关键概念
- en: Understanding stateless and stateful applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解无状态和有状态应用程序
- en: Exploring container orchestrators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索容器编排器
- en: We will then go on to study how to leverage Docker Swarm and Kubernetes orchestrators’
    features in [*Chapter 7*](B19845_07.xhtml#_idTextAnchor147), *Orchestrating with
    Swarm*, and [*Chapter 8*](B19845_08.xhtml#_idTextAnchor170), *Deploying Applications
    with the Kubernetes Orchestrator*. This chapter does not include any labs as it
    is intended to teach you the theory behind Docker Swarm and Kubernetes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将研究如何在[*第7章*](B19845_07.xhtml#_idTextAnchor147)《使用Swarm进行编排》和[*第8章*](B19845_08.xhtml#_idTextAnchor170)《使用Kubernetes编排器部署应用程序》中利用Docker
    Swarm和Kubernetes编排器的功能。本章不包括任何实验，因为它旨在教授Docker Swarm和Kubernetes背后的理论。
- en: Introducing the key concepts of orchestration
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍编排的关键概念
- en: Running an application on a host may be complicated, but executing this same
    application on a distributed environment composed of multiple hosts would be very
    tedious. In this section, we will review some of the key concepts regarding the
    orchestration of application components, regardless of whether they are run using
    containers or as different virtual machines.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在主机上运行应用程序可能会很复杂，但在由多个主机组成的分布式环境中执行同一应用程序则会非常繁琐。在本节中，我们将回顾一些关于应用组件编排的关键概念，无论它们是通过容器运行，还是作为不同的虚拟机运行。
- en: 'Orchestrators are special software components that help us manage the different
    interactions and dependencies between our application components. As you can imagine,
    if you divide your application into its many different functionalities, each with
    its own entity, orchestrating them together is key. We have to say here that some
    special functionalities, such as dependency management, may not be available in
    your orchestrator and therefore you will need to manage them by yourself. This
    gives rise to an important question: what do we need to know about orchestrators
    to prepare our applications for them? Orchestrators keep our processes up and
    running, manage the communications between our applications’ components, and attach
    the storage required for these processes.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 编排器是帮助我们管理应用程序组件之间不同交互和依赖关系的特殊软件组件。正如你能想象的那样，如果你将应用程序拆分为多个不同的功能模块，每个模块都有自己的实体，那么将它们编排在一起是至关重要的。我们必须在此提到，某些特殊功能，例如依赖管理，可能在你的编排器中不可用，因此你需要自己进行管理。这就引出了一个重要问题：为了准备我们的应用程序，我们需要了解编排器的哪些知识？编排器保持我们的进程运行，管理应用程序组件之间的通信，并连接这些进程所需的存储。
- en: Focusing specifically on container-based applications, it is easy to understand
    that container runtimes will be part of the orchestration infrastructure as they
    are required to run containers. The biggest challenge when working with containers
    is the intrinsic dynamism associated with their networking features. This will
    probably not be a problem in virtual machine environments, but containers commonly
    use different IP addresses on each execution (and although we can manually assign
    IP addresses to containers, it is not good practice). Note that in the previous
    chapters’ labs ([*Chapter 4*](B19845_04.xhtml#_idTextAnchor096), *Running Docker
    Containers*, and [*Chapter 5*](B19845_05.xhtml#_idTextAnchor118), *Creating Multi-Container
    Applications*), we used service names instead of container IP addresses.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 特别针对基于容器的应用程序，很容易理解容器运行时将成为编排基础设施的一部分，因为它们是运行容器所必需的。与容器工作时最大的问题是与其网络功能相关的内在动态性。这在虚拟机环境中可能不是问题，但容器通常在每次执行时使用不同的
    IP 地址（尽管我们可以手动为容器分配 IP 地址，但这并不是一个好习惯）。请注意，在之前章节的实验中（[*第4章*](B19845_04.xhtml#_idTextAnchor096)，*运行
    Docker 容器*，和 [*第5章*](B19845_05.xhtml#_idTextAnchor118)，*创建多容器应用程序*），我们使用了服务名称而不是容器
    IP 地址。
- en: 'Let’s review the key concepts to bear in mind when designing an application
    to run its components in a distributed cluster-wide fashion:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下在设计应用程序以在分布式集群中运行其组件时需要牢记的关键概念：
- en: '**Dependencies resolution**: Some dependencies may exist in your application.
    This means that some services are required *before* others to enable your application’s
    functionality. Some orchestration solutions such as Docker Compose (standalone
    orchestration) include this feature, but most others usually don’t. It is up to
    you, as a developer, to resolve any issues arising from these dependencies in
    your code. A simple example is a database connection. It is up to you to determine
    what to do if the connection from some components is lost due to a database failure.
    Some components may function correctly while others may need to reconnect. In
    such situations, you should include a verification of the connectivity before
    any transaction and prepare to manage queued transactions that may accrue before
    your component realizes that the database isn’t working.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖关系解析**：你的应用程序可能存在一些依赖关系。这意味着某些服务需要在其他服务之前启动，以使应用程序功能正常。一些编排解决方案，如 Docker
    Compose（独立编排），包括此功能，但大多数其他解决方案通常没有。作为开发者，你需要在代码中解决这些依赖关系所带来的问题。一个简单的例子是数据库连接。如果由于数据库故障，某些组件的连接丢失，那么由你来决定如何处理。某些组件可能仍能正常工作，而其他组件可能需要重新连接。在这种情况下，你应该在任何事务之前进行连接性验证，并准备管理可能在组件发现数据库故障之前积压的排队事务。'
- en: '**Status**: Knowing the current status of each component is critical at any
    time. Some orchestrators have their own features to check and verify the status
    of each component, but you, as the developer of your application, know best which
    paths, processes, ports, and so on are required and how to test whether they are
    alive. In [*Chapter 2*](B19845_02.xhtml#_idTextAnchor036), *Building Docker Images*,
    we discussed how the simpler the content on your container images, the better
    the security. If your application requires some additional software for testing
    its health, you should include it; however, it may be a better idea to include
    some test endpoints or testing functions that can be called when required to verify
    the health of the application’s components.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**：随时了解每个组件的当前状态至关重要。一些调度器有自己的功能来检查和验证每个组件的状态，但作为应用程序的开发者，你最清楚哪些路径、进程、端口等是必需的，以及如何测试它们是否正常工作。在[*第2章*](B19845_02.xhtml#_idTextAnchor036)，*构建
    Docker 镜像*中，我们讨论了容器镜像内容越简洁，安全性就越好。如果你的应用程序需要额外的软件来测试其健康状况，你应该包括它；然而，可能更好的做法是包括一些测试端点或可以在需要时调用的测试函数，以验证应用程序组件的健康状况。'
- en: '**Circuit breakers**: If we have already successfully managed our application’s
    dependencies, circuit breakers will allow us to identify any problems and make
    appropriate decisions when some components are down. Orchestrators don’t provide
    any circuit breakers natively; you will need additional software or infrastructure
    components to implement such solutions. Depending on the complexity of your application,
    it can be beneficial to integrate some circuit breakers. For example, we can stop
    all the components that require a healthy database whenever this is not available,
    while other components can continue running and providing their functionality
    as usual.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**熔断器**：如果我们已经成功地管理了应用程序的依赖关系，熔断器将帮助我们识别任何问题，并在某些组件出现故障时做出适当的决策。编排工具本身不提供任何熔断器功能；你需要额外的软件或基础设施组件来实现此类解决方案。根据应用程序的复杂性，集成一些熔断器可能是有益的。例如，我们可以在数据库不可用时停止所有依赖健康数据库的组件，而其他组件可以继续运行并提供其功能。'
- en: '**Scalability**: Perhaps some of your application’s components run with more
    than one replica. Scalability should be built in by design. Orchestrators allow
    you to execute more than one replica of any component, but it is up to you to
    manage their co-existence. A database component running with more than one replica
    will corrupt your data if it is not prepared for such a situation. In this example,
    you would need to use a master-slave or distributed database architecture. Other
    issues regarding data transactions may appear, such as in your frontends, if you
    don’t manage user sessions. In such situations, session integrity may require
    additional components to ensure that all transactions follow a coordinated workflow.
    Orchestrators do not know about any of your application’s components’ functionality
    and as such, it is up to you to determine whether some components can scale up
    or down. Some orchestrators will provide you with rules for deciding when this
    should occur, but they just trigger the actions for managing your component’s
    replicas. All replicas will be treated in the same way and you will need to add
    additional components if you require weight distribution functionality to ensure
    some replicas receive more data than others.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：也许你的一些应用组件会以多个副本的形式运行。可扩展性应在设计时就考虑进去。编排工具允许你执行多个副本的任何组件，但管理它们的共存仍然由你来负责。如果一个数据库组件以多个副本运行，而没有为这种情况做准备，就会损坏你的数据。在这种情况下，你需要使用主从式或分布式数据库架构。关于数据事务的其他问题可能会出现，比如在前端，如果你没有管理用户会话。在这种情况下，确保会话一致性可能需要额外的组件，以确保所有事务遵循协调的工作流。编排工具并不了解你应用组件的功能，因此，由你来决定哪些组件可以扩展或缩减。一些编排工具会提供规则，帮助你决定何时进行扩展，但它们仅仅触发管理组件副本的动作。所有副本将以相同方式处理，如果你需要负载均衡功能来确保某些副本接收比其他副本更多的数据，你需要添加额外的组件。'
- en: '**High availability**: The concept of high availability may vary depending
    on whether you ask someone from the infrastructure team or the application side,
    but both will agree that it should be transparent for the end user. In terms of
    infrastructure, we can think of high availability at various levels:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高可用性**：高可用性的概念可能因询问对象的不同而有所不同，无论是基础设施团队还是应用团队的人，他们都会同意它应该对最终用户是透明的。从基础设施的角度来看，我们可以从多个层面考虑高可用性：'
- en: '**Duplicity of infrastructure**: When physical or virtual machines are used
    to provide high availability for our applications, we need to have all our infrastructure
    duplicated, including the underlying communications layers and storage. Most devices
    know how to manage the special configurations that must be changed when a replicated
    device acts as a master. Servers should maintain quorum or master-slave relations
    to decide which of them will handle user requests. This will be required even
    if we plan to have active-passive (where only one instance handles all requests
    and the others take over only if any error is found) or active-active responses
    (all instances serve at the same time).'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施冗余**：当物理或虚拟机用于提供我们应用的高可用性时，我们需要对所有基础设施进行冗余，包括底层的通信层和存储层。大多数设备都知道如何管理当复制设备作为主设备时必须更改的特殊配置。服务器应保持法定人数或主从关系，以决定哪一台服务器处理用户请求。这在我们计划采用主动-被动（只有一个实例处理所有请求，其他实例只有在出现错误时才接管）或主动-主动响应（所有实例同时提供服务）的情况下也是必要的。'
- en: '**Routes to healthy components**: Duplicated infrastructure requires a layer
    of extra components to route the user’s request. Load balancers help present the
    different applications’ endpoints in a completely transparent way for the users.'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**健康组件的路由**：复制的基础设施需要额外的组件层来路由用户的请求。负载均衡器帮助以完全透明的方式为用户呈现不同应用程序的端点。'
- en: '**Storage backends**: As we would expect, storage not only has to maintain
    the data safely and securely, but also attach it to any running and serving instance.
    In active-passive environments, storage will switch from a damaged instance to
    a healthy one. You, as the developer, may need to ensure data integrity after
    a switchover.'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储后端**：正如我们所期望的那样，存储不仅必须安全地保留数据，还必须将其附加到任何正在运行和提供服务的实例上。在主备环境中，存储将从损坏的实例切换到健康的实例。作为开发人员，您可能需要在切换后确保数据完整性。'
- en: High availability means that services will never be interrupted, even when maintenance
    tasks require one instance to be stopped. Container orchestrators don’t provide
    high availability by themselves; it must be factored in as part of your application
    design.
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 高可用性意味着服务永远不会中断，即使维护任务需要停止一个实例。容器编排器本身不提供高可用性；它必须作为应用程序设计的一部分考虑进去。
- en: '**Service state definition**: We usually define how an application is to be
    deployed, including the number of replicas that must be available for the service
    to be considered healthy. If any replica fails, the orchestrator will create or
    start a new one for you. We don’t need to trigger any event, just define the monitors
    to allow the orchestrator to review the status of each application component.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务状态定义**：通常我们定义应用程序的部署方式，包括必须可用的副本数量，以便服务被视为健康。如果任何副本失败，编排器将为您创建或启动一个新的副本。我们不需要触发任何事件，只需定义监视器，以便编排器审查每个应用程序组件的状态。'
- en: '**Resilience**: Applications may fail, and the orchestrator will try to start
    them again. This is the concept of *resilience*, which orchestrators provide by
    default. When your application is run in containers, the container runtimes keep
    the application alive by starting them again when something goes wrong. Orchestrators
    interact with container runtimes to manage the start and stop processes for your
    containers cluster-wide, trying to mitigate the impact of the failures in your
    applications. Therefore, you must design your applications to stop and start fast.
    Usually, applications running in containers don’t take more than a few seconds
    to get running, so your users may not even notice an outage. So, to avoid significant
    issues for users, we must provide high availability for our application’s components.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：应用程序可能会失败，编排器会尝试重新启动它们。这就是*弹性*的概念，编排器默认提供。当您的应用程序在容器中运行时，容器运行时会在出现问题时重新启动应用程序，保持应用程序的运行。编排器与容器运行时交互，管理容器在整个集群范围内的启动和停止过程，试图减轻应用程序失败的影响。因此，您必须设计您的应用程序以快速停止和启动。通常，在容器中运行的应用程序不会花费超过几秒钟的时间来运行，因此您的用户可能甚至不会注意到中断。因此，为了避免给用户带来重大问题，我们必须为应用程序的组件提供高可用性。'
- en: '**Distributed data**: When your applications run in a distributed cluster-wide
    fashion, different hosts will run your application’s components, hence the data
    required needs to be made available when needed. The orchestrator will interact
    with container runtimes to mount container volumes. You can mount your data in
    all the possible hosts in anticipation that the containers will use it, and this
    may seem a good idea at first. However, managing an application’s data permissions
    may leave you with unexpected consequences. For example, you can misconfigure
    the permissions for a root directory where different applications are storing
    their data, allowing some applications to read others’ data files. It is usually
    better to entrust the volume management to the orchestrator itself, using the
    features it makes available for this.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式数据**：当您的应用程序以分布式集群方式运行时，不同的主机将运行您的应用程序组件，因此需要在需要时提供所需的数据。编排器将与容器运行时交互以挂载容器卷。您可以在所有可能的主机上挂载数据，以预期容器将使用它，这乍看起来可能是个好主意。然而，管理应用程序数据权限可能会给您带来意想不到的后果。例如，您可能会错误配置根目录的权限，不同的应用程序正在其中存储它们的数据，允许一些应用程序读取其他应用程序的数据文件。通常最好将卷管理委托给编排器本身，利用其为此提供的功能。'
- en: '**Interoperability**: Communications between your application components can
    be complicated, but orchestration provides you with a simplified network layer.
    In [*Chapter 7*](B19845_07.xhtml#_idTextAnchor147), *Orchestrating with Swarm*,
    and [*Chapter 8*](B19845_08.xhtml#_idTextAnchor170), *Deploying Applications with
    the Kubernetes Orchestrator*, we will see how both of these orchestrators provide
    a different layer of communications for your applications. It is very important
    to learn and understand how they deploy your application’s communications and
    design your application to avoid any network lock-in from the beginning. This
    will allow your applications to work on any of the available orchestrators.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互操作性**：应用程序组件之间的通信可能非常复杂，但编排提供了简化的网络层。在[*第7章*](B19845_07.xhtml#_idTextAnchor147)《使用Swarm进行编排》和[*第8章*](B19845_08.xhtml#_idTextAnchor170)《使用Kubernetes编排器部署应用程序》中，我们将看到这两种编排器如何为您的应用程序提供不同的通信层。学习和理解它们如何部署应用程序的通信，并从一开始就设计应用程序以避免任何网络锁定非常重要。这样，您的应用程序就可以在任何可用的编排器上运行。'
- en: '**Dynamic addressing**: Container environments are based on dynamic objects
    managed by the container runtime. Some of these objects can have static properties
    such as IP addresses within containers. Managing static properties in very dynamic
    infrastructures can be difficult and is not recommended. Orchestrators will manage
    dynamism for you if you follow their rules.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态寻址**：容器环境基于由容器运行时管理的动态对象。这些对象中的一些可能具有静态属性，例如容器内的IP地址。在高度动态的基础设施中管理静态属性可能非常困难，并且不推荐这样做。如果您遵循编排器的规则，编排器会为您管理动态性。'
- en: '**Service discoverability**: Services published within orchestrators will be
    announced internally and can be reached from any other application component.
    By default, such services only work internally, which improves the security of
    your full application as you only externally publish those frontend services that
    must be reached by users.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务可发现性**：在编排器中发布的服务将会在内部宣布，并且可以从其他任何应用程序组件访问。默认情况下，这些服务仅在内部工作，这提高了您完整应用程序的安全性，因为您仅发布那些必须由用户访问的前端服务。'
- en: '**Multisite**: Having multiple data centers for follow-the-sun or disaster
    recovery architectures is common in big enterprises. You must always ensure that
    your applications can run anywhere. We can go further than this because some companies
    may have cloud-provisioned infrastructure as well as on-premises services – in
    such situations, your applications may run some components on cloud infrastructure
    while others run locally. Apart from the infrastructure synchronization challenges
    that this scenario may create, if you design your applications with these advanced
    environments in mind and you understand the breakpoints to avoid (for example,
    quorum between components if communications are lost), you will still be able
    to run your applications in extreme situations.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多站点**：对于跟随太阳的工作负载或灾难恢复架构，拥有多个数据中心在大型企业中是很常见的。您必须始终确保您的应用程序可以在任何地方运行。我们可以更进一步，因为一些公司可能同时拥有云提供的基础设施和本地服务——在这种情况下，您的应用程序可能在云基础设施上运行某些组件，而其他组件则在本地运行。除了这种情况可能带来的基础设施同步挑战，如果您在设计应用程序时考虑到这些高级环境，并且了解需要避免的断点（例如，失去通信时组件之间的法定人数问题），您仍然能够在极端情况下运行您的应用程序。'
- en: One of the key aspects of deploying applications cluster-wide is the management
    of component status. In the next section, we will review the importance of setting
    a component's status outside the container’s life cycle when designing our applications.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 部署应用程序到集群中的关键方面之一是组件状态的管理。在下一节中，我们将回顾在设计应用程序时，将组件的状态设置在容器生命周期之外的重要性。
- en: Understanding stateless and stateful applications
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解无状态和有状态应用程序
- en: Previously, we provided a brief description of the key points and concepts regarding
    orchestrating your applications and running them distributed across a cluster,
    in which you may have noticed that providing a service to your users without outages
    can be complex. We reviewed how orchestrators help us deliver resilient processes
    and saw how high availability has to be designed into applications. One of the
    key aspects of such a design concerns how your application manages the processes’
    state over time.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们简要介绍了关于如何协调应用程序并将其分布式运行在集群上的关键点和概念，你可能已经注意到，在没有中断的情况下向用户提供服务是非常复杂的。我们回顾了编排工具如何帮助我们提供具有弹性的进程，并且看到高可用性如何必须在应用程序中设计。此类设计的一个关键方面涉及到你的应用程序如何随着时间推移管理进程的状态。
- en: 'Applications fall into two different categories, depending on how they manage
    their processes’ state: **stateful** and **stateless**.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序根据其如何管理进程的状态分为两类：**有状态**和**无状态**。
- en: Before learning about each one, it is important to understand what the state
    of an application or process means. The state of a system is the condition in
    which it is at a specific time. This system can be running or stopped, or even
    in between both when it is either starting or stopping. It is important to be
    able to identify and manage the status of the application’s components. To manage
    the state of a system, such as triggering an action to start or stop the system,
    we must know how to retrieve the state. In many cases, this is not simple, and
    particularly complex situations may require managing some dependencies or interactions
    with other external systems.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习每一个之前，理解应用程序或进程的状态意味着什么非常重要。系统的状态是指在特定时间点其所处的状态。这个系统可以是运行中的，也可以是停止的，或者处于两者之间的状态，如正在启动或停止。能够识别和管理应用程序组件的状态非常重要。为了管理系统的状态，例如触发启动或停止系统的操作，我们必须知道如何获取状态。在许多情况下，这并不简单，尤其是复杂的情况可能需要管理某些依赖关系或与其他外部系统的交互。
- en: Now that we have a definition for the state of a system, let’s describe stateful
    and stateless applications with some examples.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了系统的状态，接下来让我们通过一些示例来描述有状态应用和无状态应用。
- en: Stateful applications
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有状态应用
- en: Imagine a situation where a process needs some data to be loaded before it can
    start. If the process reads all its configurations when this starts, we will need
    to restart it for any change to take effect. But if this process reads part of
    the configuration (or the full content) whenever it is needed for some functions
    or actions, a restart may not be needed. That’s why we will need to know whether
    the process has already started or not to load the required data. In some cases,
    we can design a full process that loads the data whenever the process starts without
    reviewing whether it was started before. However, other times, this can’t be done
    because we can’t replace the data or load it more than once. A simple file can
    be used as a flag to specify whether the load process was already executed or
    if we need to load the data again.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下一个情境，一个进程需要加载一些数据才能启动。如果这个进程在启动时读取所有配置，那么每次配置发生变化时，我们都需要重启它。但如果这个进程在需要某些功能或操作时才读取部分配置（或全部配置），那么就可能不需要重启。这就是为什么我们需要知道进程是否已经启动，以便加载所需数据。在某些情况下，我们可以设计一个完整的进程，每次启动时都加载数据，而不需要检查之前是否已启动。然而，在其他情况下，不能这样做，因为我们不能替换数据或加载数据超过一次。一个简单的文件可以用作标志，指示加载过程是否已经执行，或者是否需要重新加载数据。
- en: This can be managed locally quite easily if our application is running on a
    host as a simple process but isn’t easy when working with containers. When a container
    runs in a host, it uses its own storage layers unless we specify a volume to store
    some data. A new container running the same process can reuse a previous volume
    if your application stores this flag file outside the container’s life cycle by
    design. This appears easy enough in a standalone host where all the processes
    run in the same host.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的应用程序作为一个简单进程在主机上运行，那么可以很容易地在本地管理状态，但如果使用容器则不太容易。当容器在主机上运行时，它使用自己的存储层，除非我们指定一个卷来存储一些数据。运行相同进程的一个新容器，如果你的应用程序通过设计将该标志文件存储在容器生命周期之外，则可以重用以前的卷。在一个独立的主机上运行所有进程时，这看起来相当简单。
- en: The volume can be either a bind mount (a directory from the host’s filesystem)
    or a named volume (a volume with a known and reusable name). When you run your
    application cluster-wide, this approach may not work correctly. This is because
    a bind mount is attached to a host, and that directory will not exist on other
    hosts. Remote filesystems can be used to persist the flag and make it available
    in other hosts. In this case, we use a volume and the orchestrator will manage
    the mounting of the required filesystem.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 卷可以是绑定挂载（来自主机文件系统的目录）或命名卷（具有已知且可重用名称的卷）。当你在集群范围内运行应用程序时，这种方法可能无法正确工作。因为绑定挂载是附加到主机的，该目录在其他主机上不存在。可以使用远程文件系统来持久化标志，并使其在其他主机上可用。在这种情况下，我们使用卷，编排工具将管理所需文件系统的挂载。
- en: However, managing an application’s state is more difficult when more than one
    process is involved. In such situations, it is recommended to take this requirement
    into account at the very beginning of your application’s design process. If we
    were designing a web application, for example, we would need to store some user
    data to identify who made a given request. In this scenario, we don’t just have
    to manage the process state – we also need to manage users’ data, so more than
    one file will be required and we will have to use a database to store this data.
    We usually say that such an application is **stateful** and requires **persistent
    data**.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当涉及多个进程时，管理应用程序的状态会变得更加困难。在这种情况下，建议从一开始就将这一需求纳入应用程序设计过程中。例如，如果我们设计一个 Web
    应用程序，我们需要存储一些用户数据以识别谁发起了特定请求。在这种情况下，我们不仅要管理进程状态——还需要管理用户数据，因此需要多个文件，并且我们必须使用数据库来存储这些数据。我们通常说这样的应用程序是**有状态**的，并且需要**持久数据**。
- en: Stateless applications
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无状态应用程序
- en: Stateless applications, on the other hand, do not require any data persistence.
    We can restart these components whenever needed without persisting any data. The
    application itself contains all the required information. Imagine a service that
    receives some data, and if the service doesn’t respond, we send the data again
    until it gives a response. This service can do some operations with the received
    data and send a response without needing to save any data. In such a situation,
    this service is **stateless**. It may require some external data to do operations,
    but if something goes wrong and we need to restart the service, we aren’t concerned
    with the status of any pending operations. We will simply send the data again
    until we get a valid response. When some operations are still pending, we have
    both a stateful process, which requires us to load some pending requests, and
    a stateless process, because it doesn’t store the requests by itself. The service
    sending the request may need to store it while the one processing the operation
    doesn’t.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态应用程序则不需要任何数据持久性。我们可以在需要时重新启动这些组件，而无需持久化任何数据。应用程序本身包含所有所需的信息。想象一个接收数据的服务，如果该服务没有响应，我们会再次发送数据，直到它给出响应。这个服务可以对接收到的数据执行一些操作并发送响应，而无需保存任何数据。在这种情况下，这个服务是**无状态**的。它可能需要一些外部数据来执行操作，但如果出现问题需要重新启动服务，我们无需关心任何挂起操作的状态。我们只需再次发送数据，直到获得有效响应。当一些操作仍在等待时，我们就有了一个有状态的过程，它需要我们加载一些挂起的请求，以及一个无状态的过程，因为它不会自行存储请求。发送请求的服务可能需要存储请求，而处理操作的服务则不需要。
- en: As you may imagine, stateless applications are easier to manage in distributed
    environments. We don’t need to manage process states and their associated data
    in different locations across a cluster.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能想象的那样，无状态应用程序在分布式环境中更容易管理。我们不需要在集群的不同位置管理进程状态及其相关数据。
- en: In the next section, we will review some of the most popular container orchestrators.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将回顾一些最受欢迎的容器编排工具。
- en: Exploring container orchestrators
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索容器编排工具
- en: Now that we know what to expect from any container orchestrator, let’s review
    some of the most important and technically relevant ones available. We will also
    take a quick look at the strengths and weaknesses of each option presented.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了容器编排工具的基本要求，让我们回顾一些最重要和最具技术相关性的工具。我们还将快速了解每个选项的优缺点。
- en: We will start with the currently most popular and widely extended container
    orchestrator, Kubernetes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从目前最受欢迎和广泛应用的容器编排工具 Kubernetes 开始。
- en: Kubernetes
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes
- en: '**Kubernetes** is an open source container orchestration platform, fast becoming
    the de facto standard for running microservices on cloud providers and local data
    centers. It started as a Google project for managing the company’s internal applications
    back in 2003\. This project was initially called Borg and was created for deploying
    workloads distributed across different nodes and clusters. This project evolved
    into a more complex orchestration platform called Omega, which focused on bigger
    clusters running thousands of workloads for very different applications. In 2014,
    Google published Borg’s code to the open source community and it finally became
    Kubernetes that same year. In 2015, the first release, Kubernetes 1.0, was published
    after Red Hat, IBM, Microsoft, and Docker joined the community project. The Kubernetes
    community is now huge and a very important part of why this orchestrator has become
    so popular nowadays.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kubernetes** 是一个开源容器编排平台，正迅速成为在云提供商和本地数据中心运行微服务的事实标准。它起初是 Google 为管理公司内部应用程序而开发的一个项目，始于
    2003 年。这个项目最初叫做 Borg，旨在部署分布在不同节点和集群中的工作负载。该项目逐渐发展成一个更复杂的编排平台，称为 Omega，专注于运行数千个工作负载的大型集群，用于不同的应用程序。2014
    年，Google 将 Borg 的代码公开发布到开源社区，并在同年将其改名为 Kubernetes。2015 年，Kubernetes 1.0 的第一个版本发布，此时
    Red Hat、IBM、Microsoft 和 Docker 等公司也加入了这一社区项目。Kubernetes 社区现在非常庞大，正是这一点使得该编排器在当今如此受欢迎。'
- en: The most important feature of Kubernetes is that its core is focused on executing
    a few tasks and delegating more complicated tasks to external plugins or controllers.
    It is so extensible that many contributors add new features daily. Nowadays, as
    Kubernetes is the most popular and extended container orchestrator, it is quite
    common for software vendors to provide their own Kubernetes definitions for their
    applications when you ask them for high availability. Kubernetes does not provide
    container runtimes, cluster network capabilities, or clustered storage by default.
    It is up to us to decide which container runtime to use for running the containers
    to be deployed and maintained by the orchestrator.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 最重要的特点是，它的核心专注于执行少数任务，并将更复杂的任务委托给外部插件或控制器。它的可扩展性极强，许多贡献者每天都会添加新功能。如今，Kubernetes
    已成为最受欢迎且广泛使用的容器编排工具，当你要求软件供应商提供高可用性时，提供自己 Kubernetes 定义的应用程序已变得相当普遍。Kubernetes
    默认不提供容器运行时、集群网络功能或集群存储。我们需要自己决定使用哪种容器运行时来运行容器，这些容器将由编排器进行部署和维护。
- en: On the network side, Kubernetes defines a list of rules that must be followed
    by any **Container Network Interface** (**CNI**) we want to be included in our
    platform to deliver inter-container communications cluster-wide, as we will learn
    in [*Chapter 8*](B19845_08.xhtml#_idTextAnchor170), *Deploying Applications with
    the Kubernetes Orchestrator*. The Kubernetes network model differs from other
    orchestration solutions in the way it presents a plain or flat network (no routing
    is required between containers), where all containers are reachable by default.
    Many open source and proprietary options for deploying the Kubernetes network
    are also available, including Flannel, Weave, Cilium, and Calico. These network
    providers define the overlay networks and IPAM configurations for our Kubernetes
    cluster and even encrypt communications between nodes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络方面，Kubernetes 定义了一系列规则，任何我们希望在平台中包含的 **容器网络接口** (**CNI**) 都必须遵循这些规则，以便实现跨容器通信的集群功能，正如我们将在[*第八章*](B19845_08.xhtml#_idTextAnchor170)《使用
    Kubernetes 编排器部署应用程序》中学习到的那样。Kubernetes 的网络模型与其他编排解决方案不同，它呈现的是一种简单或扁平的网络（容器之间不需要路由），所有容器默认都是可以访问的。部署
    Kubernetes 网络的许多开源和专有选项也可用，包括 Flannel、Weave、Cilium 和 Calico。这些网络提供商定义了我们的 Kubernetes
    集群的覆盖网络和 IPAM 配置，甚至加密节点之间的通信。
- en: Kubernetes provides many cloud provider integrations because it was designed
    to be cloud-ready. A cloud controller is available for managing integrations with
    publishing applications or using some special cloud-provided storage backends.
    As mentioned earlier in this section, Kubernetes does not provide a solution for
    deploying any cluster-wide storage backend, but you can integrate NFS and some
    AWS, Google, and Azure storage backends for your applications. To extend your
    storage possibilities, you can use **Container Storage Interfaces** (**CSI**),
    which are different vendor or community-driven storage backends that can easily
    be integrated into Kubernetes to provide different storage solutions for our orchestrated
    containers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes提供了许多云服务提供商的集成，因为它的设计初衷就是云就绪。提供云控制器用于管理与发布应用程序或使用某些特殊云提供的存储后端的集成。如本节前面所述，Kubernetes并未提供部署任何集群级存储后端的解决方案，但你可以将NFS和一些AWS、Google和Azure存储后端集成到你的应用程序中。为了扩展存储可能性，你可以使用**容器存储接口**（**CSI**），这是不同供应商或社区驱动的存储后端，可以轻松地集成到Kubernetes中，为我们管理的容器提供不同的存储解决方案。
- en: Many cloud providers and software vendors package and share or sell their own
    Kubernetes flavors. For example, Red Hat/IBM provide their own Kubernetes platform
    inside their OpenShift product. Microsoft, Amazon, Google, and indeed almost all
    cloud service providers have their own Kubernetes implementations ready for use.
    In these Kubernetes platforms, you don’t even have to manage any of the control
    plane features – the platforms are offered as Kubernetes-managed solutions for
    you, as the developer, to use for delivering your applications. These solutions
    are known as **Kubernetes-as-a-Service** platforms and are where you pay for your
    workloads and the bandwidth used in your applications.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 许多云服务提供商和软件供应商打包并分享或销售他们自己的Kubernetes版本。例如，Red Hat/IBM在其OpenShift产品中提供了自己的Kubernetes平台。微软、亚马逊、谷歌，实际上几乎所有的云服务提供商都有自己的Kubernetes实现，供用户使用。在这些Kubernetes平台中，你甚至不需要管理任何控制平面功能——这些平台作为Kubernetes管理的解决方案提供给你，作为开发者，你可以使用它们来交付应用程序。这些解决方案被称为**Kubernetes即服务**平台，用户为工作负载和应用程序使用的带宽付费。
- en: The Kubernetes project publishes a release approximately every 4 months and
    maintains three minor releases at a time (thus providing almost a year of patches
    and support for each release). Some changes and deprecations are always expected
    between releases, so it is very important to review the change notes for each
    release.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes项目大约每4个月发布一次版本，并同时维护三个次要版本（因此每个版本都能提供几乎一年的补丁和支持）。在版本之间总是会有一些变动和弃用，因此非常重要的是要审查每个版本的变更说明。
- en: 'Kubernetes clusters have nodes with different roles: **master** nodes create
    the control plane for delivering containers, while **worker** nodes execute the
    workloads assigned to them. This model allows us to deploy a Kubernetes cluster
    with high availability by replicating some of the master node’s services. An open
    source key-value database, called etcd, is used for managing all objects’ (known
    in Kubernetes as **resources**) references and states.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes集群有不同角色的节点：**master**节点创建控制平面以交付容器，而**worker**节点执行分配给它们的工作负载。这种模型使我们能够通过复制一些master节点的服务来部署高可用性的Kubernetes集群。一个开源的键值数据库，名为etcd，用于管理所有对象（在Kubernetes中称为**资源**）的引用和状态。
- en: Kubernetes has evolved so fast that nowadays, we can even manage and integrate
    virtual machines into Kubernetes clusters by using operators such as KubeVirt.
    An additional great aspect of Kubernetes is that you can create your own resources
    (**Kubernetes Custom Resource Definitions**) for your application when some special
    requirements for your application are not met by the Kubernetes core resources.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes发展得如此之快，以至于现在我们甚至可以通过使用像KubeVirt这样的操作符将虚拟机管理和集成到Kubernetes集群中。Kubernetes的另一个伟大特点是，当Kubernetes核心资源无法满足应用程序的某些特殊需求时，你可以为应用程序创建自己的资源（**Kubernetes自定义资源定义**）。
- en: 'Let’s quickly summarize the pros of using Kubernetes:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速总结一下使用Kubernetes的优点：
- en: Available for customers of many cloud providers and from many on-premises software
    solutions for container providers
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多云服务提供商和本地软件解决方案的容器提供商为客户提供了Kubernetes的支持
- en: Very thoroughly documented with lots of examples and guides for learning the
    basics
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有非常详尽的文档和大量学习基础知识的示例与指南
- en: Highly extensible via standardized interfaces such as the CNI and CSI
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过标准化接口（如CNI和CSI）高度可扩展
- en: Lots of objects or resources that will meet most of your application’s requirements
    for running cluster-wide
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很多对象或资源能够满足你大多数应用程序在集群范围内运行的需求。
- en: Comes with many security features included, such as role-based access control,
    service accounts, security contexts, and network policies
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含许多安全功能，如基于角色的访问控制、服务帐户、安全上下文和网络策略。
- en: Offers different methods for publishing your applications
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供多种发布应用程序的方法。
- en: Used as a standard deployment method for many software vendors, you may easily
    find your applications packaged in Kubernetes manifest format
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为许多软件供应商的标准部署方法，你可以轻松地找到以Kubernetes清单格式打包的应用程序。
- en: 'However, it does have some disadvantages as well. These include the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它也有一些缺点。包括以下几点：
- en: It is not easy to master due to its continuous evolution and many resource types.
    The learning curve may seem higher compared to other orchestration solutions.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于其不断演化和许多资源类型，它并不容易掌握。与其他编排解决方案相比，学习曲线可能显得更陡峭。
- en: The many releases per year may necessitate a lot of effort to maintain the platform.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每年发布的版本可能需要大量的工作来维护平台。
- en: Having many flavors can be a problem when each vendor introduces their own particularities
    on their platforms.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有许多变种可能会成为问题，因为每个供应商都会在其平台上引入自己的特性。
- en: You will never use Kubernetes for just one application or a few small ones because
    it takes a lot of maintenance and deploying efforts. Indeed, Kubernetes-as-a-Service
    providers such as Microsoft’s Azure Kubernetes Service will help you with minimal
    maintenance efforts.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你永远不会仅为一个应用程序或几个小应用程序使用Kubernetes，因为它需要大量的维护和部署工作。事实上，像微软的Azure Kubernetes服务这样的Kubernetes即服务提供商将帮助你减少维护工作。
- en: We will learn about all the Kubernetes features and how we will prepare and
    deploy our applications in this orchestrator in more detail in [*Chapter 8*](B19845_08.xhtml#_idTextAnchor170),
    *Deploying Applications with the* *Kubernetes Orchestrator*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第8章*](B19845_08.xhtml#_idTextAnchor170)中详细学习Kubernetes的所有功能，以及如何在该编排工具中准备和部署我们的应用程序，*使用Kubernetes编排器部署应用程序*。
- en: Docker Swarm
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker Swarm
- en: '**Docker Swarm** is a container orchestration solution created by Docker Inc.
    It is intended to provide a simple orchestration platform that includes everything
    needed to run our containerized applications cluster-wide by default. This includes
    overlay networking (which can be encrypted) and isolation by creating different
    networks for each project if required.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker Swarm**是由Docker公司创建的容器编排解决方案。它旨在提供一个简单的编排平台，默认情况下包括运行我们容器化应用程序所需的所有功能，覆盖整个集群。这包括覆盖网络（可以加密）和隔离，通过为每个项目创建不同的网络（如果需要）。'
- en: Different objects can be used to deploy our applications, such as **global**
    or **replicated** services, each with its own properties for managing how the
    containers are to be spread cluster-wide. As we have seen with Kubernetes, a master-worker
    or (master-slave) model is also used. The master node creates the full control
    plane and the worker nodes execute your containers.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用不同的对象来部署我们的应用程序，如**全局**服务或**复制**服务，每个服务都有其自己的属性，用于管理容器如何在集群中分布。正如我们在Kubernetes中看到的，也使用主节点-工作节点（主从）模式。主节点创建完整的控制平面，工作节点执行容器。
- en: It is important to mention a big difference in the way changes are managed within
    the cluster. While Kubernetes uses etcd as its key-value database, Docker Swarm
    manages its own object database solution using the Raft Consensus Algorithm with
    a complete command-line interface for this. Docker Engine installation is enough
    to get working with Docker Swarm as the container runtime binaries also include
    SwarmKit features. Moby is the open source project behind Docker Inc., having
    created kits for delivering and improving container communications (VPNKit) and
    improving the default `docker build` features (BuildKit), some of which we covered
    in [*Chapter 2*](B19845_02.xhtml#_idTextAnchor036), *Building Docker Images*,
    with the `buildx` extended build command-line. SwarmKit is the Moby project behind
    Docker Swarm and provides the cluster functionality, security, and simplicity
    of its model. Docker Swarm is quite simple, but this doesn’t mean it isn’t production-ready.
    It provides the minimum features required to deploy your applications with high
    availability.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 需要提到的是集群中变更管理的一个重要区别。Kubernetes 使用 etcd 作为其键值数据库，而 Docker Swarm 使用 Raft 共识算法管理自己的对象数据库解决方案，并提供完整的命令行界面。只需安装
    Docker 引擎就可以开始使用 Docker Swarm，因为容器运行时二进制文件也包含了 SwarmKit 特性。Moby 是 Docker Inc.
    背后的开源项目，创建了用于交付和改进容器通信的工具包（VPNKit）以及改进默认的 `docker build` 功能的工具包（BuildKit），其中一些内容我们在
    [*第二章*](B19845_02.xhtml#_idTextAnchor036)，*构建 Docker 镜像* 中，使用 `buildx` 扩展构建命令行进行了介绍。SwarmKit
    是 Docker Swarm 背后的 Moby 项目，提供集群功能、安全性以及模型的简易性。Docker Swarm 相当简单，但这并不意味着它不适合生产环境。它提供了部署高可用性应用所需的最小功能。
- en: It is important to mention that Compose YAML files allow us to deploy our applications
    using a set of manifests for creating and managing all our application objects
    in Docker Swarm. Some of the keys we learned about in [*Chapter 5*](B19845_05.xhtml#_idTextAnchor118),
    *Creating Multi-Container Applications*, will not work here, such as `depends_on`,
    hence application dependency management must be covered in your code itself.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 需要提到的是，Compose YAML 文件允许我们使用一组清单来部署应用程序，创建并管理 Docker Swarm 中的所有应用对象。我们在 [*第五章*](B19845_05.xhtml#_idTextAnchor118)，*创建多容器应用程序*
    中学到的一些键值，在这里无法使用，例如 `depends_on`，因此应用程序的依赖管理必须在代码中自行处理。
- en: 'Here are some of the advantages of Docker Swarm:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 Docker Swarm 的一些优点：
- en: Easier to learn than other container orchestrators
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比其他容器编排工具更易于学习
- en: Integrated inside Docker Engine and managed using the Docker command line
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成在 Docker 引擎内，并通过 Docker 命令行进行管理
- en: Single-binary deployment
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一二进制文件部署
- en: Compatible with Compose YAML files
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Compose YAML 文件兼容
- en: 'Some of the disadvantages are as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一些缺点如下：
- en: There are fewer objects or resources for deploying our applications, which may
    affect the logic applied in our applications. It is important to understand that
    you, as a developer, can implement the logic for your application inside your
    code and avoid any possible issues associated with the orchestration.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署应用程序所需的对象或资源较少，这可能会影响应用程序中应用的逻辑。重要的是要理解，作为开发人员，你可以在代码中实现应用程序的逻辑，并避免与编排相关的任何潜在问题。
- en: It only works with the Docker container runtime, so vendor lock-in is present
    and the security improvements offered by other container runtimes can’t be used
    here.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它仅与 Docker 容器运行时兼容，因此存在供应商锁定，无法使用其他容器运行时提供的安全性改进。
- en: Although Docker Swarm provides some plugins associated with the container runtime,
    it isn’t as open and extensible as Kubernetes.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管 Docker Swarm 提供了一些与容器运行时相关的插件，但它不像 Kubernetes 那样开放和可扩展。
- en: Publishing applications is easier, but this means that we can’t apply any advanced
    features without external tools.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布应用程序更容易，但这意味着没有外部工具，我们无法应用任何高级功能。
- en: We will learn more about Docker Swarm in [*Chapter 7*](B19845_07.xhtml#_idTextAnchor147),
    *Orchestrating* *with Swarm*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第七章*](B19845_07.xhtml#_idTextAnchor147)，*使用 Swarm 进行编排* 中深入了解 Docker
    Swarm。
- en: Nomad
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Nomad
- en: HashiCorp **Nomad** is a platform that allows us to run containers, virtual
    machines (using **QEMU**, which is a well-known open source virtualization engine),
    and Java applications. It focuses on scheduling application workloads and checking
    which services, such as discovery, health check monitoring, DNS, and secrets,
    are delivered by other HashiCorp tools, including **Consul** and **Vault**. Nomad
    bases its security on **Access Control Lists** (**ACLs**), including tokens, policies,
    roles, and capabilities. In terms of networking, it uses CNI plugins for the bridge
    working mode. Its multi-site features allow us to run applications in different
    regions from a single-orchestration perspective using **federation**.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: HashiCorp **Nomad** 是一个平台，允许我们运行容器、虚拟机（使用 **QEMU**，这是一个著名的开源虚拟化引擎）和 Java 应用程序。它专注于调度应用程序工作负载，并检查其他
    HashiCorp 工具（如 **Consul** 和 **Vault**）提供的服务，如发现、健康检查监控、DNS 和秘密管理。Nomad 的安全性基于
    **访问控制列表**（**ACLs**），包括令牌、策略、角色和权限。在网络方面，它使用 CNI 插件进行桥接工作模式。其多站点功能允许我们从单一编排角度，通过
    **联邦**，在不同区域运行应用程序。
- en: Nomad adopts some of the architecture features mentioned with Kubernetes and
    Docker Swarm, where some nodes act as the control plane (servers) while others
    (clients) execute all the workloads. Servers accept jobs from users, manage clients,
    and determine the workload placements.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Nomad 采用了一些 Kubernetes 和 Docker Swarm 提到的架构特性，其中一些节点充当控制平面（服务器），而其他节点（客户端）执行所有工作负载。服务器接收用户的作业，管理客户端，并确定工作负载的分配。
- en: 'HashiCorp provides a Community Edition and **Software-as-a-Service** (**SaaS**)
    platform in its cloud. It can be integrated via an API with some CI/CD environments
    and scripts for infrastructure automation can be included. Some of the advantages
    of this are as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: HashiCorp 提供了社区版和 **软件即服务**（**SaaS**）平台，部署在其云中。它可以通过 API 与一些 CI/CD 环境集成，并且可以包含基础设施自动化的脚本。其一些优点如下：
- en: Simplicity in usage and maintenance
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用和维护简单
- en: Single-binary deployment
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单二进制部署
- en: Flexibility to deploy and manage virtual machines, along with containerized
    and non-containerized applications
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灵活部署和管理虚拟机，以及容器化和非容器化应用程序
- en: 'Here are some of its limitations:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是它的一些局限性：
- en: Although HashiCorp provides good documentation, they don’t have many users and
    thus less of a community behind the project.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管 HashiCorp 提供了良好的文档，但它的用户并不多，因此项目背后缺乏强大的社区支持。
- en: Nomad appeared at the same time as Docker Swarm (a legacy platform) and Kubernetes
    were starting out, but Nomad initially focused on virtual machines and applications.
    Container orchestration became associated with Docker Swarm and Kubernetes, both
    of which gained popularity in this field as a result.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nomad 与 Docker Swarm（一个遗留平台）和 Kubernetes 一起出现，但 Nomad 最初侧重于虚拟机和应用程序。容器编排与 Docker
    Swarm 和 Kubernetes 密切相关，后者在该领域因而获得了更多的关注。
- en: With fewer associated projects, Nomad was left in the hands of a single company,
    which may have been more mature. This makes the evolution of the product or the
    addition of new features slower than community-driven projects.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于相关项目较少，Nomad 被单一公司掌控，这家公司可能更为成熟。这使得该产品的演进或新特性添加相比社区驱动的项目进展较慢。
- en: Apache Mesos
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Apache Mesos
- en: '**Mesos** is a project created by the Apache organization in 2009 for running
    cluster-wide workloads. This happened before containers became widely used and
    as a result, containers were only integrated into the project when most of the
    architecture’s logic had already been designed. This means that Mesos can run
    containers and normal application workloads cluster-wide, as Nomad can.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mesos** 是一个由 Apache 组织在 2009 年创建的项目，用于运行集群范围的工作负载。这发生在容器广泛应用之前，因此容器只有在大部分架构逻辑已经设计完成后才被集成到该项目中。这意味着
    Mesos 可以像 Nomad 一样，在集群范围内运行容器和正常的应用程序工作负载。'
- en: Hadoop and other big data workload managers are the main frameworks that are
    managed by Apache Mesos, while its usage for containers is quite limited or at
    least less popular than the other solutions listed in this section. The benefit
    of Mesos is that integrating Apache projects’ workloads, such as those for Spark,
    Hadoop, and Kafka, is easy because it was designed for them.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Hadoop 和其他大数据工作负载管理器是由 Apache Mesos 管理的主要框架，而它在容器方面的使用相对有限，或者至少没有其他解决方案那么受欢迎。Mesos
    的优势在于，它可以轻松集成 Apache 项目的工作负载，如 Spark、Hadoop 和 Kafka，因为它是为这些项目设计的。
- en: 'However, the disadvantages include the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它的缺点包括：
- en: Special packages for workloads or frameworks may require manual configuration
    and thus are not as standardized as Kubernetes or Docker Compose YAML files
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专用的工作负载或框架可能需要手动配置，因此它们不像 Kubernetes 或 Docker Compose 的 YAML 文件那样标准化。
- en: This orchestrator is not very popular and thus has a smaller community, with
    only a few tutorial examples available compared to Kubernetes or Docker Swarm
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个协调器并不是很受欢迎，因此它的社区较小，相比于 Kubernetes 或 Docker Swarm，只有少数几个教程示例可供参考。
- en: Cloud vendor-specific orchestration platforms
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 云服务商特定的编排平台
- en: 'Now that we have had a quick overview of the most important on-premises orchestrators
    (some of which are also available as cloud solutions), let’s examine some of the
    orchestration solutions created specifically by the cloud vendors for their own
    platforms. You can expect a degree of vendor lock-in when using their specific
    features. Let’s look at the most important ones:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对最重要的本地编排工具有了快速了解（其中一些也作为云解决方案提供），接下来让我们看看一些云服务商为其平台专门创建的编排解决方案。使用它们特定功能时，你可能会遇到一定程度的供应商锁定问题。让我们看看其中最重要的几个：
- en: '**Amazon Elastic Container Service** (**ECS**) and **Fargate**: Amazon ECS
    is an Amazon-managed container orchestration service. ECS relies on your EC2 contracted
    resources (storage, virtual networks, and load balancers) and as such, you can
    increase or decrease the hardware available for the platform by adding more resources
    or nodes. Amazon **Elastic Kubernetes Service** (**EKS**) is completely different
    from this simplified option as it deploys a complete Kubernetes cluster for you.
    On the other hand, AWS Fargate is a simpler technology that allows you to run
    containers without having to manage servers or clusters on the Amazon compute
    platform. You simply package your application in containers and specify the base
    operating system and the CPU and memory requirements. You will just need to configure
    a few networking settings and the **Identity and Access Management** (**IAM**)
    to secure your access. These are all the requirements so that you can finally
    run your application.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon Elastic Container Service** (**ECS**) 和 **Fargate**：Amazon ECS 是一个由
    Amazon 管理的容器编排服务。ECS 依赖于你的 EC2 合同资源（存储、虚拟网络和负载均衡器），因此，你可以通过添加更多资源或节点来增加或减少平台可用的硬件。Amazon
    **Elastic Kubernetes Service** (**EKS**) 与这个简化的选项完全不同，因为它为你部署了一个完整的 Kubernetes
    集群。另一方面，AWS Fargate 是一种更简化的技术，让你可以在不需要管理服务器或集群的情况下运行容器。你只需将应用程序打包成容器，指定基础操作系统和
    CPU、内存需求。你只需要配置一些网络设置和 **身份与访问管理** (**IAM**) 来保障访问安全。这些就是你最终能够运行应用程序的所有要求。'
- en: '**Google Anthos** and **Google Cloud Run**: Although Google Cloud Platform
    offers its own Kubernetes-as-a-Service platform, **Google Kubernetes Engine**
    (**GKE**), it also provides Anthos and Cloud Run. Anthos is a hybrid and cloud-agnostic
    container management platform that allows the integration of applications running
    in containers in Google cloud and on your data center. It focuses on preparing
    and running applications in containers used as virtual machines. On the other
    hand, Google Cloud Run is more flexible, offering the ability to scale workloads
    on demand and integrate CI/CD tools and different container runtimes.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google Anthos** 和 **Google Cloud Run**：尽管 Google Cloud Platform 提供了自己的 Kubernetes
    即服务平台 **Google Kubernetes Engine** (**GKE**)，但它也提供了 Anthos 和 Cloud Run。Anthos
    是一个混合型且与云平台无关的容器管理平台，允许将运行在 Google 云和你的数据中心中的容器化应用程序集成。它专注于准备和运行作为虚拟机使用的容器化应用程序。另一方面，Google
    Cloud Run 更加灵活，提供了按需扩展工作负载的能力，并可以集成 CI/CD 工具以及不同的容器运行时。'
- en: '**Azure Service Fabric** and **Azure Container Instances** (**ACI**): Microsoft
    provides different solutions for running simple containers while **Azure Kubernetes
    Service** (**AKS**) is also available. Azure Service Fabric provides a complete
    microservice-ready platform for your applications, while ACI is a simplified version
    in which you run containers as if they were small virtual machines. You simply
    code and build your container images for your applications instead of managing
    the infrastructure that runs them.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure Service Fabric** 和 **Azure Container Instances** (**ACI**)：微软提供了不同的解决方案来运行简单的容器，同时也有
    **Azure Kubernetes Service** (**AKS**) 可供使用。Azure Service Fabric 为你的应用程序提供了一个完整的微服务平台，而
    ACI 则是一个简化版本，你可以像使用小型虚拟机一样运行容器。你只需为应用程序编写代码并构建容器镜像，而无需管理运行它们的基础设施。'
- en: 'All these cloud platforms allow you to test and even run your applications
    in production without having to manage any of the underlying orchestration. Just
    using a simple web UI, you determine what should be done when your application’s
    components fail and can add as many resources as needed. The cloud storage services
    available from each provider can be used by your application and you can monitor
    the complete cost of your application thanks to the reports available for your
    cloud platform. Here are some of the pros of these cloud-vendor platforms:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些云平台允许你测试甚至在生产环境中运行应用程序，而无需管理任何底层的编排。只需使用简单的Web界面，你就可以确定当应用程序组件失败时应该采取的措施，并可以根据需要添加资源。每个供应商提供的云存储服务可供你的应用程序使用，你还可以通过云平台提供的报告监控应用程序的完整成本。以下是这些云供应商平台的一些优点：
- en: Easier to use than any other container orchestration
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比任何其他容器编排都更容易使用
- en: A full Kubernetes cluster may not be necessary for testing or even executing
    your applications, making cloud-vendor solutions a reasonable choice
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于测试甚至执行应用程序来说，可能不需要完整的Kubernetes集群，这使得云供应商解决方案成为一种合理的选择
- en: 'Their disadvantages include the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的缺点包括以下几点：
- en: Vendor lock-in is always present with these platforms as you will use many cloud
    vendor-embedded services
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这些平台时，供应商锁定问题始终存在，因为你将使用许多云供应商嵌入的服务
- en: They can be used effectively for testing or even publishing some simple applications,
    but when using microservices, some issues may arise, depending on the complexity
    of your application’s components
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以有效地用于测试，甚至发布一些简单的应用程序，但在使用微服务时，根据应用程序组件的复杂性，可能会出现一些问题。
- en: Summary
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we reviewed the common orchestration concepts we will employ
    in our applications and the different platforms available. We learned about the
    most important features on offer to help us decide which options are more suited
    for our application. Learning how orchestrators work will be a big boon to you,
    as a developer, in designing your applications to run cluster-wide and with high
    availability in production, thanks to the unique features that orchestration offers.
    In the following chapters, we will delve deeper into Kubernetes, which is the
    most popular and widely extended container orchestration platform, and Docker
    Swarm, both of which are available in the cloud and on-premises.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了在应用程序中使用的常见编排概念以及可用的不同平台。我们了解了可帮助我们决定哪些选项更适合我们应用程序的最重要功能。学习编排器的工作原理将极大地帮助你作为开发者，在设计应用程序时实现集群级别的高可用性，得益于编排提供的独特功能。在接下来的章节中，我们将深入探讨Kubernetes（最受欢迎且广泛扩展的容器编排平台）和Docker
    Swarm，这两者都可以在云端和本地环境中使用。
