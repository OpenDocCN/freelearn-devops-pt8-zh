<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Swiss Army Knife - Azure Cosmos DB</h1>
                </header>
            
            <article>
                
<p>When it comes to storage, we often have to store multiple schemas of data using multiple databases. Due to the need for using multiple services, managing our solution becomes cumbersome and requires a lot of skill to do it in the right fashion. Thanks to Azure Cosmos DB, we can both store records using different database models (such as MongoDB, Table Storage, or Gremlin), and pay only for what we agreed on—throughput, latency, availability, and consistency, all thanks to the serverless model.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>What Azure Cosmos DB is, and how it looks compared to other storage systems</li>
<li>Partitioning, throughput, and consistency</li>
<li>Different Azure Cosmos DB database models</li>
<li>Security features</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To perform the exercises in this chapter, you will need the following:</p>
<ul>
<li>Microsoft Visual Studio or Visual Studio Code</li>
<li>Azure subscription</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding Cosmos DB</h1>
                </header>
            
            <article>
                
<p>When working with storage, you have probably heard about different kinds; relational databases, NoSQL databases, graph databases, document databases. There are plenty of different models available, with different characteristics, when it comes to storing data. If you need to easily maintain relationships between tables, in most cases you will choose something such as SQL Server. On the other hand, maybe you would like to save each record in the JSON file format, where the best solution would be an instance of MongoDB. While the choice is all yours, the biggest problem is that you need to have a different kind of service to serve the same purpose<span>—</span>storing data. This is where Azure Cosmos DB comes into play. With its multi-model capabilities, flexibility, and scalability it is a great choice for globally distributed and highly responsive applications. In this section, you will learn how to start working with this service and what its main functionalities are.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a Cosmos DB instance in the portal</h1>
                </header>
            
            <article>
                
<p>We will start our journey with Azure CosmosDB by creating it in the Azure portal:</p>
<ol>
<li>When you click on <span class="packt_screen">+ Create a resource</span><strong> </strong>and search for <kbd>Azure Cosmos DB</kbd>, you will see a simple form that allows you to select the basic features of the service:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/eef48642-0d4b-48da-92bd-37a50979efe7.png" style="width:24.50em;height:43.25em;" width="374" height="660"/></p>
<p style="padding-left: 60px;">There are, however, some not-so-obvious features, which will require a little bit of explaining:</p>
<ul>
<li style="padding-left: 60px;"><strong><span class="packt_screen">API</span></strong>: As mentioned earlier, Azure Cosmos DB enables you to use one of a few different APIs during creation. Currently, there are five available APIs: SQL, MongoDB, Cassandra, Azure Table, and Gremlin. Depending on the API selected, you will have different capabilities available (and what is more, different packages will be required for communicating with your database in the application's code).</li>
<li style="padding-left: 60px;"><span class="packt_screen">Enable geo-redundancy</span>: By selecting this option, your data will be distributed between two paired regions (depending on the one you selected in the <span class="packt_screen">Location </span>drop-down), for example, <span class="packt_screen">West Europe</span> and <span class="packt_screen">North Europe</span> or <span class="packt_screen">Central US</span> and <span class="packt_screen">East US 2</span>.</li>
<li style="padding-left: 60px;"><span class="packt_screen">Enable Multi Master</span>: This is a new (and currently in preview) feature, where instead of having only a single master, you can have multiple master databases all around the globe. This greatly lowers latency when it comes to reading already saved data (as you do not have to wait for data propagation), and increases consistency and data integrity (as you have the possibility to write data to a master instance in a specific region).</li>
<li style="padding-left: 60px;"><span class="packt_screen">Virtual networks</span>:<strong> </strong>Depending on the model you choose, you may be able to restrict access to an instance of Azure Cosmos DB by putting it into a specific virtual network and subnet. Currently, this is possible for two database models: SQL and MongoDB.</li>
</ul>
<ol start="2">
<li>When you are satisfied with all the entered data, you can create it by clicking on the <span class="packt_screen">Create </span>button. Once your service is created, you can access the <span class="packt_screen">Overview </span>blade to see how it works initially:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/5d0b4b56-f433-4249-8e9a-02d106e47757.png" width="1383" height="448"/></p>
<p style="padding-left: 60px;">As you can see, it displays a map in the center that tells you how your data is replicated across regions. If you click on the map, you will be able to reconfigure the initial settings. If you click on the <span class="packt_screen">Add new region</span><strong> </strong>button, you will be able to search for a particular one and select it as an additional read region. Alternatively, you can just click on a region icon:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/ed8e4a92-228e-483c-b54e-0aa5a3b9a7cd.png" style="width:36.83em;height:52.25em;" width="649" height="920"/></p>
<div class="packt_tip">In the current setup, you are unable to add additional write regions. To be able to do so, you have to use the multi-master feature I described previously.</div>
<p>Once you save additional regions, both <span class="packt_screen">Manual Failover</span><strong> </strong>and <span class="packt_screen">Automatic Failover</span><strong> </strong>will become active. The concept for failover is simple—if your write region goes down and becomes unavailable, another available read region can take its place. The only difference is whether you want to perform such failover manually or automatically.</p>
<div class="packt_tip">If you opt for automatic failover, you can decide on the order of switching between read and write regions. If you want, for example, to switch from North Europe to West Europe in the first place, West Europe has to be the very first priority in the list.</div>
<p>If you go back to the <span class="packt_screen">Overview </span>blade, you will notice some additional features:</p>
<ul>
<li><span class="packt_screen">Monitoring</span>: Here you can easily find all requests to your database and their status.</li>
<li><span class="packt_screen">Enable geo-redundancy</span>: If you did not enable this feature when creating an instance of Azure Cosmos DB, you may do this now.</li>
<li><span class="packt_screen">Data Explorer</span>: By clicking on this button you can easily access an explorer, which allows you to insert and modify data.</li>
</ul>
<p>Additionally, you can go to the <span class="packt_screen">Quick start </span>blade, where you will be able to start developing applications using this Azure service:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/069d2761-adae-4f90-a18f-afcc76a422a3.png" width="1585" height="694"/></p>
<p>Depending on the selected model of a database, you will have access to different initial configurations. Additionally, as you can see, you have a choice as to whether you would like to use .NET, Node.js, Java, or Python—all these languages can easily integrate with Azure Cosmos DB, making it an even better choice when it comes to creating a multi-platform application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using Azure Cosmos DB in Visual Studio</h1>
                </header>
            
            <article>
                
<p>Besides controlling Azure Cosmos DB in the portal, you are able to access it directly in your code and IDE, such as Visual Studio. Like many other services, you can use <span class="packt_screen">Cloud Explorer</span><strong> </strong>to browse all available instances of this database available within your subscription:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/f6e91c8e-ea8f-471d-9470-d37ce4371171.png" style="width:26.00em;height:37.42em;" width="411" height="590"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Now let's try to communicate with it from a simple application. While initially an instance of Cosmos DB is empty, we can quickly add a table to it.</p>
<div class="packt_infobox">In this section, we will work with the table API in Cosmos DB. If you would like to work with any other type, you will have to consult tutorials in the <em>Further reading</em><strong> </strong>section.</div>
<p>Consider the following code snippet:</p>
<pre>using System;<br/>using Microsoft.Azure.CosmosDB.Table;<br/>using Microsoft.Azure.Storage;<br/><br/>namespace HandsOnAzureCosmosDB<br/>{<br/>    internal class Program<br/>    {<br/>        private static void Main()<br/>        {<br/>            // You can get the connection string from the <strong>Quick start</strong> blade mentioned previously<br/>            var connectionString = "&lt;connection-string&gt;";<br/>            var storageAccount = CloudStorageAccount.Parse(connectionString);<br/>            var tableClient = storageAccount.CreateCloudTableClient();<br/><br/>            var reference = tableClient.GetTableReference("handsonazure");<br/>            var result = reference.CreateIfNotExists();<br/><br/>            Console.ReadLine();<br/>        }<br/>    }<br/>}</pre>
<p>In the preceding code, we are creating an empty table, which should be immediately available within an instance of Cosmos DB. Now if I check <span class="packt_screen">Cloud Explorer</span><strong> </strong>once more, I see that, in fact, it is true:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/1f0a5e35-91dc-46ac-ba88-283742d706fd.png" style="width:27.92em;height:38.33em;" width="387" height="531"/></div>
<p>Now we can add a record to it. We <span>slightly</span><span> </span><span>modify our code as follows:</span></p>
<pre>using System;<br/>using Microsoft.Azure.CosmosDB.Table;<br/>using Microsoft.Azure.Storage;<br/><br/>namespace HandsOnAzureCosmosDB<br/>{<br/>    internal class Program<br/>    {<br/>        private static void Main()<br/>        {<br/>            // You can get the connection string from the <strong>Quick start </strong>blade mentioned previously<br/>            var connectionString = "&lt;connection-string&gt;";<br/>            var storageAccount = CloudStorageAccount.Parse(connectionString);<br/>            var tableClient = storageAccount.CreateCloudTableClient();<br/><br/>            var reference = tableClient.GetTableReference("handsonazure");<br/>            var result = reference.CreateIfNotExists();<br/><br/>            var executionResult = reference.Execute(TableOperation.Insert(new TableEntity("handsonazure", Guid.NewGuid().ToString())));<br/>            Console.WriteLine(executionResult.Result);<br/><br/>            Console.ReadLine();<br/>        }<br/>    }<br/>}</pre>
<p>We now consult <span class="packt_screen">Data Explorer</span><strong> </strong>in the portal to see the difference between Visual Studio and the Azure portal. We should be able to see the entity we have just inserted:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/2c3adb3f-1415-424f-8e49-502ed27d37ce.png" width="1292" height="487"/></p>
<p>As you can see, all you need to start working with a database with multiple database models, which can be quickly configured for geo-redundancy and scaled across the globe, is just several lines of code. </p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Pricing in Azure Cosmos DB</h1>
                </header>
            
            <article>
                
<p>Azure Cosmos DB is <span>part o</span>f the serverless se<span>rvices available in Azure. This means that the chances of configuring and provisioning servers to run it are either maximally limited or not available. As you probably noticed, we were not able to define how many instances of a service we would like to run (or nodes or clusters). Instead, we have to define </span>throughput <span>for each collection individually:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/17c2f81b-fe7d-4097-9d5f-8162bde5b368.png" width="1028" height="501"/></p>
<p>A simple calculator display also estimates the costs of a collection per hour and day. The unit of throughput in Azure Cosmos DB is <strong>request units</strong> (<strong>RUs</strong>). During the creation of a container (or a collection—you can use both definitions), you specify also its type—whether it has fixed capacity or unlimited.</p>
<div class="packt_infobox">Once the type of collection is defined, you cannot change it later.</div>
<p>By selecting different options, you can select different limits for RUs:</p>
<ul>
<li>For fixed, you can select between 400 to 10,000 RUs</li>
<li>For unlimited, you can go from 1,000 to a maximum of 100,000 RUs</li>
</ul>
<p class="mce-root"/>
<p>Regarding pricing, you are paying both for the amount of data stored ($0.25 GB/month), and reserved RUs ($.008/hour per every 100 RUs). Having those values, we can quickly calculate the smallest bill possible—it is around $23. Now there is a very important caveat. You are paying per each collection/table/container. That means that, if you have, for example, 20 different tables in your database, you will pay 20 * $23 = $462. In such a scenario, it is sometimes better to model your database in such a way that it will be possible to store all data within a single container.</p>
<div class="packt_infobox">While Azure Cosmos DB seems like a quite an expensive service, please do remember that it does many things for you, such as geo-redundancy, multiple read regions, multi-master models, and many more. You always have to calculate the best options for you (and if you are able to do the same with the similar results). To do so, take a look at the Capacity Planner described in the <em>Further Reading</em> section.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Partitioning, throughput, and consistency</h1>
                </header>
            
            <article>
                
<p>Now we have learned something about Azure Cosmos DB—how it works and its most common features<span>—</span>we can focus a little bit on three really important topics in this service; partitioning, throughput, and consistency. Those factors are crucial when selecting a database engine to power your application. They directly tell you how it will be performing, how many requests it will be able to handle, and what guarantees apply when it comes to your data integrity. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Partitions in Azure Cosmos DB</h1>
                </header>
            
            <article>
                
<p>Partitioning is directly connected with scaling in Azure Cosmos DB as it allows for load-balancing incoming requests. In fact, there are two different types of partition in this service:</p>
<ul>
<li><strong>Physical</strong>: These are a combination of fixed storage and a variable amount of computing resources. This type of partition is fully managed by Cosmos DB<span>—</span>you cannot directly affect how your data is physically partitioned and how a service handles those partitions. In fact, you are also unaware of how many of those partitions are currently in use. Therefore, you should not design your containers against that specific concept.</li>
<li><strong>Logical</strong>: This kind of partition holds data that has the same partition key. Because you are able to define that key (by specifying it in each entity), you are able to control how your data is partitioned. </li>
</ul>
<div class="packt_infobox">Remember that a logical partition has a limit of 10 GB. Additionally, all data for a logical partition has to be stored within one physical partition.</div>
<p>Now you may wonder how partitioning works in Azure Cosmos DB. This can be described in a few steps:</p>
<ol>
<li>Each time a new container is provisioned (and you are providing a number of RUs), Cosmos DB has to provision physical partitions, which will be able to serve the number of requests specified in the number of RUs. </li>
<li>It may turn out that the specified amount of RUs exceeds the maximum number of requests per second served by a partition. In that case, Cosmos DB will provision the number of partitions it needs to satisfy your requirements.</li>
<li>The next thing to do is to allocate space for partition key hashes. All provisioned partitions have to have the same space allocated (so it is distributed evenly). </li>
<li>Now, if after some time any partition reaches its storage limit, it is split into two new partitions, and data is distributed evenly between them.</li>
</ol>
<p>Of course, the partition key used for partitioning differs for each database model—for a table it is partition key, for SQL it will be a custom path. In general, this operation is slightly different depending on the database type, yet the overall concept remains the same. </p>
<div class="packt_infobox">Remember that if your container has only one partition key for all the entities in it, then Cosmos DB will not be able to split a partition. That means that you could hit the maximum of 10 GB per partition and not be able to add any more data.</div>
<p>The best value for the partition key depends solely on your application data specification. In general, you have to choose a value that is quite differential (so partitioning can actually happen). On the other hand, you should not create a unique partition key for each record (while it is possible, it will be quite expensive). There is no one solution to that problem—you always have to analyze each scenario and select what suits you the most. </p>
<div class="packt_tip">In most cases, it is worth including a partition key while filtering data, as it allows for high concurrency.</div>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Throughput in Azure Cosmos DB</h1>
                </header>
            
            <article>
                
<p>In the <em>Further reading</em><strong> </strong>section, you will find a capacity calculator—a tool that enables you to plan your Cosmos DB instance and estimate the required RUs. As mentoned previously, in this particular service you are not defining the number of instances or clusters. Instead, while creating a container, you have to state your expected throughput for that specific collection (or a set of collections). Thanks to an <strong>Service Level Agreement</strong> (<strong>SLA</strong>) for Azure Cosmos DB, that value will be guaranteed for you. Additionally, even if you replicate a database to another region, you can expect that problems in one region will not affect others. </p>
<div class="packt_tip">There is one important definition of 1 request unit<span>—</span>it is the processing capacity, that enables you to read a 1 KB entity using, for example, a simple GET request. The same is not true for operations such as inserting or deleting, as those require more computing power to be performed.</div>
<p>If you would like to know exactly how many RUs a specific operation consumes, you have to consult the <kbd>x-ms-request-charge</kbd><span> header in a response from</span> a Cosmos DB in<span>stance. This will tell you the cost of this operation—of course, you have to remember that it may differ depending on the number of records returned. In the documentation you can find the following table:</span></p>
<div>
<table style="border-collapse: collapse; width: 100%;" border="1">
<thead>
<tr>
<th>Operation</th>
<th>Request unit charge</th>
</tr>
</thead>
<tbody>
<tr>
<td>Create item</td>
<td>~15 RU</td>
</tr>
<tr>
<td>Read item</td>
<td>~1 RU</td>
</tr>
<tr>
<td>Query item by ID</td>
<td>~2.5 RU</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Those are values for executing an operation against an entity 1 KB in size. As you can see, the values are completely different depending on the operation type. You also can see, that it is crucial to carefully check all operations requirements—if you fail to do so, you may face an HTTP 429 response, which tells you that you have exceeded the reserved throughput limits. In such a scenario, you should honor the <kbd>x-ms-retry-after-ms</kbd><span> header response, which allows for an easy retry policy.</span></p>
</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Consistency in Azure Cosmos DB</h1>
                </header>
            
            <article>
                
<p>Besides different models of a database, Azure Cosmos DB offers also a different level of consistency. You may wonder what consistency is and how it affects your data.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We can define it as follows:</p>
<p>Consistency is a parameter of a database system, which reflects the way a transaction affects data. It defines the rules that are applied when different constraints or/and triggers affect data written to a database. </p>
<p>So basically it tells you what are the guarantees that, if your data becomes affected by a set of operations, it will not be malformed and you will be able to rely on it. The following are the available consistency models in Cosmos DB:</p>
<ul>
<li><span class="packt_screen">STRONG</span></li>
<li><span class="packt_screen">BOUNDED STATELESS</span></li>
<li><span class="packt_screen">SESSION</span></li>
<li><span class="packt_screen">CONSISTENT PREFIX</span></li>
<li><span class="packt_screen">EVENTUAL</span></li>
</ul>
<p>In the above list, each level below <span class="packt_screen">STRONG<strong> </strong></span>gives you less consistency. This is especially true for <span class="packt_screen">EVENTUAL</span>, which could be familiar to you thanks to a topic known as eventual consistency. In general, you are setting the default consistency level for your account—then it is possible to override it per each request (of course, if you want to). If you want to know how exactly each consistency level works, please refer to the <em>Further reading</em><strong> </strong>section. To set a particular level in your Cosmos DB instance, click on the <span class="packt_screen">Default consistency</span><strong> </strong>blade:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/f2f6e600-c9ec-43f2-8d6f-df1417e8691f.png" width="1187" height="532"/></p>
<p class="mce-root"/>
<p>As you can see, it allows you to easily switch to another consistency level depending on your needs. What is more, it displays a nice animation, which describes how reads/writes in multiple regions will work for this particular level. The following screenshot shows the animation for <span>eventual consistency</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/0a21d58f-400e-4c64-93d7-ad1e0ca31e47.png" style="width:52.58em;height:26.50em;" width="778" height="392"/></p>
<p>In this screenshot, each individual note represents an individual read or write in a particular region. Additionally, on this screen, you are able to set <span class="packt_screen">Maximum Lag (Time)</span><strong> </strong>when the <span class="packt_screen">BOUNDED STALENESS</span><strong> </strong>level is selected.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">CosmosDB data models and APIs</h1>
                </header>
            
            <article>
                
<p>As mentioned earlier, Azure Cosmos DB offers five different database models, all sharing the same infrastructure and concepts. This is a great feature, that makes this service really flexible and able to serve multiple different purposes. In this section, I will briefly describe each database model, so you will be able to select one that best serves your purposes.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">SQL</h1>
                </header>
            
            <article>
                
<p>If you think about SQL, you probably see a relational database with tables, relations, and stored procedures. When working with <strong>SQL API </strong>in Cosmos DB, in fact you will work with documents that can be queried using the SQL syntax. Let us assume you want to query documents using the following call:</p>
<pre>SELECT * FROM dbo.Order O WHERE O.AccountNumber = "0000-12-223-12"</pre>
<p> Here you can find an example of a query written in C#:</p>
<pre>var order = <br/>  client.CreateDocumentQuery&lt;Order&gt;(collectionLink)<br/>    .Where(so =&gt; so.AccountNumber == "0000-12-223-12")<br/>    .AsEnumerable()<br/>    .FirstOrDefault();</pre>
<p>As you can see, it is all about a simple LINQ query, which allows you to use a specific property to filter data. Because all records in Cosmos DB are stored as JSON documents, you can easily transform them from table to document representations (and possibly denormalize them).</p>
<div class="packt_tip">Using document databases is completely different from storing data in relational databases. Always remember to model your data appropriately in line with database capabilities.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">MongoDB</h1>
                </header>
            
            <article>
                
<p>As Cosmos DB implements the MongoDB wire protocol, you can easily use all your applications that currently use that document database with new instances of Azure Cosmos DB, without changing anything (besides the connection string, of course). While it cannot mimic MongoDB completely yet (the full list of supported operations can be found in the <em>Further reading</em><strong> </strong>section), in most cases you will be able to use it seamlessly. As Cosmos DB has a strict requirement regarding security, you will have to use SSL when communicating with it:</p>
<pre>mongodb://username:password@host:port/[database]?ssl=true</pre>
<p>Here you can see a template for a connection string, where <kbd>ssl=true</kbd><strong> </strong>is present—it is required when communicating with this Azure service. What is more, you will not be able to set a communication without authenticating a request.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Graph</h1>
                </header>
            
            <article>
                
<p>Azure Cosmos DB supports Gremlin as a graph database model. If you are not familiar with graph databases, you may think about them as a structure composed of vertices and edges. They can very easily show you relations between different elements of a graph as you can quickly traverse the connections and see that element A knows something about element B indirectly, thanks to element C. To be more specific, Cosmos DB supports a more specific model of a graph database known as a <strong>property graph</strong>. The following is an example query for Gremlin:</p>
<pre><span>:&gt; g.V('thomas.1').out('knows').out('uses').out('runsos').group().by('name').by(count())</span></pre>
<p>The preceding example is taken from the documentation and literally answers the question: <span>What operating systems do relations of the user of the <kbd>thomas.1</kbd> ID use?. Graph databases are great for applications such as social media portals or IoT hubs.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Table</h1>
                </header>
            
            <article>
                
<p>While you can use Azure Storage Table for your applications (which will be covered in upcoming chapters), it is possible to also take advantage of Cosmos DB's Table API and consider more advanced scenarios with that service. There are some differences between both services:</p>
<ul>
<li>While the current maximum limit for operations in Azure Storage Tables is 20,000 operations/sec, with Cosmos DB you can achieve millions of them</li>
<li>You cannot initiate failover for Storage Table</li>
<li>In Cosmos DB, data is indexed on all properties, not only on the partition key and row key</li>
<li>Different pricing (storage versus throughput)</li>
<li>Different consistency levels</li>
</ul>
<p class="mce-root"/>
<p>Developing against Cosmos DB Table API is the same as working with Azure Table Storage. The following is an example of code in C# retrieving entities from a table:</p>
<pre>CloudStorageAccount storageAccount = CloudStorageAccount.Parse(<br/>    CloudConfigurationManager.GetSetting("StorageConnectionString"));<br/>CloudTableClient tableClient = storageAccount.CreateCloudTableClient();<br/>CloudTable table = tableClient.GetTableReference("people");<br/>TableQuery&lt;CustomerEntity&gt; query = new TableQuery&lt;CustomerEntity&gt;().Where(TableQuery.GenerateFilterCondition("PartitionKey", QueryComparisons.Equal, "Smith"));<br/><br/>foreach (CustomerEntity entity in table.ExecuteQuery(query))<br/>{<br/>    Console.WriteLine("{0}, {1}\t{2}\t{3}", entity.PartitionKey, entity.RowKey,<br/>        entity.Email, entity.PhoneNumber);<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cassandra</h1>
                </header>
            
            <article>
                
<p>The last available model in Azure Cosmos DB is Cassandra. Cassandra is a scalable, durable, and decentralized database for storing massive amounts of data. Now, if you use it with Cosmos DB, you can focus on development rather than on operations or performance management, and choice of consistency. While currently this model is in preview, you can test it and check what advantages it gives to you. Under the hood, it uses the Cassandra API, so it is possible to use Cassandra Query Language to communicate and interact with data. This model has the same feel as MongoDB—you can use the same tools you used for your current Cassandra instances and should not notice any difference. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Different features of CosmosDB</h1>
                </header>
            
            <article>
                
<p>Azure Cosmos DB has multiple different features that can be used to lower your bills, secure an instance, or integrate with other services. In this section, we will quickly take a look at most of them, so you will fully understand the basics of this service and will be able to progress on your own. </p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Account level throughput</h1>
                </header>
            
            <article>
                
<p>Instead of defining throughput per each collection, sometimes you would like to set a fixed value for the whole account. This is a great addition if you have many different containers and instead of paying for each individually (as you remember—it was over $20 per month), you can go to <span class="packt_screen">Account level throughput</span><strong> </strong>and set a throughput for the whole account:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/9f751068-bbf5-4766-922d-5bec4effbc33.png" width="769" height="531"/></p>
<p>The only limitation of this feature is you can no tables currently in the account. If you enable it, all your requests to all tables will share the same amount of throughput (so you can pay less, but in the case of "greedy" collections you can run out of RUs). The downside of that functionality is that you will pay for the provisioned throughput, whether you have created collections or not.</p>
<div class="packt_infobox">Note that the aforementioned feature is available only for the Table API.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Database level throughput</h1>
                </header>
            
            <article>
                
<p>In Azure Cosmos DB it is also possible to provision throughput directly on the database. To do so, you need to select the <span class="packt_screen">Provision throughput</span> checkbox during database creation:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/46f2bcf5-8708-4699-9272-2098d9bc4794.png" style="width:27.92em;height:16.42em;" width="406" height="239"/></p>
<p>With that feature on, all provisioned RUs will be shared across all collection available for a database.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Firewall and virtual networks</h1>
                </header>
            
            <article>
                
<p>If you configured the virtual network feature during Cosmos DB creation, in this blade you will be able to configure it further. What is more, it is also possible to configure a firewall—so you can restrict access to a specific range of IPs or disallow connections from other Azure data centers. In general, you do not want to have a database that can be accessed by <span>everyone</span>, so if this feature is available, I strongly recommend you use it.</p>
<div class="packt_infobox">Note that currently firewalls and VNets are available only for the SQL API and Mongo API. Support for other APIs should be available soon.</div>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Azure Functions</h1>
                </header>
            
            <article>
                
<p>You can easily integrate Azure Cosmos DB with Azure Functions by using the <span class="packt_screen">Add Azure Function</span><strong> </strong>blade:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/0154b628-5612-42f5-b34d-150a53842fc8.png" style="width:43.42em;height:37.58em;" width="637" height="550"/></p>
<p>Creating a function from Cosmos DB will add the following code to your Function App:</p>
<pre>#r "Microsoft.Azure.Documents.Client"<br/><br/>using Microsoft.Azure.Documents;<br/>using System.Collections.Generic;<br/>using System;<br/><br/>public static async Task Run(IReadOnlyList&lt;Document&gt; input, TraceWriter log)<br/>{<br/>    log.Verbose("Document count " + input.Count);<br/>    log.Verbose("First document Id " + input[0].Id);<br/>}</pre>
<p>This is CSX code, which we did not cover—however, besides slight changes in syntax, it is pure C#. This function will listen to changes to a collection you selected during creation—it is up to you what it will do next. In general, it is a quick and easy way to integrate these two services. What is more, you can have more than just one Azure Function generated for your collection or table. Now if I add a document, I can see it triggers a function:</p>
<pre class="log-toolbar"><span class="link action"><span> </span>Pause<span> </span></span><span class="link action"><span> </span>Clear<span> </span></span><span class="link action"><span class="pop-over-container"><span class="link"><span> </span>Copy logs</span></span><span> </span></span><span class="link action"><span> </span>Expand<br/></span>2018-08-07T06:01:28  Welcome, you are now connected to log-streaming service.
2018-08-07T06:01:34.556 [Info] Function started (Id=5fb63ab3-e128-45ad-b7a8-4ccfdad38c82)
2018-08-07T06:01:34.573 [Verbose] Document count 1
2018-08-07T06:01:34.573 [Verbose] First document Id test_document
2018-08-07T06:01:34.591 [Info] Function completed (Success, Id=5fb63ab3-e128-45ad-b7a8-4ccfdad38c82, Duration=21ms)</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Stored procedures</h1>
                </header>
            
            <article>
                
<p>Azure Cosmos DB allows for creating stored procedures that can be executed individually and can hold extra logic, which you do not want to share.</p>
<p>If you go to your collection in <span class="packt_screen">Data Explorer</span>,<strong> </strong>you will see the <span class="packt_screen">New Stored Procedure</span><strong> </strong>tab and the ability to create one:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/00ad3946-c75e-4b1d-91fe-7b3b5966ef94.png" style="width:77.83em;height:17.42em;" width="1008" height="226"/></p>
<p>Stored procedures are written in JavaScript—this allows you to easily access the document's schema (as they are all JSON). What is more, they are registered per collection. Here you can find an example of the easiest stored procedure:</p>
<pre>function sample(prefix) {<br/>    var context = getContext();<br/>    var response = context.getResponse();<br/><br/>    response.setBody("Hello, World");<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">User-defined functions and triggers</h1>
                </header>
            
            <article>
                
<p>To extend the query language, you can write your own <strong>user-defined function</strong> (<strong>UDF</strong>) and in your queries. Note that you cannot use these in Stored Procedures. UDFs are used to extend the SQL query language in Azure Cosmos DB and can be only called from inside queries. Triggers, however, are divided into two categories:</p>
<ul>
<li>Pre-triggers</li>
<li>Post-triggers</li>
</ul>
<p>Additionally, you can select an operation that this trigger refers to:</p>
<ul>
<li><span class="packt_screen">All</span></li>
<li><span class="packt_screen">Create</span></li>
<li><span class="packt_screen">Delete</span></li>
<li><span class="packt_screen">Replace</span></li>
</ul>
<p class="mce-root"/>
<p>Here you can find an example of a trigger that updates a timestamp in a document before it is created:</p>
<pre>var context = getContext();<br/>var request = context.getRequest();<br/>var documentToCreate = request.getBody();<br/><br/>if (!("timestamp" in documentToCreate)) {<br/>  var ts = new Date();<br/>  documentToCreate["my timestamp"] = ts.getTime();<br/>}<br/><br/>request.setBody(documentToCreate);</pre>
<p>Triggers, of course, are also available from <span class="packt_screen">Data Explorer</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/43a704b5-66c8-495d-9bc9-ebae4e0079f4.png" width="1223" height="440"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you have learned about another serverless Azure component named Azure Cosmos DB. You saw multiple database models that this service supports, and also multiple different features, such as geo-redundancy and the ability to easily scale up and introduce new read regions, where data will be replicated. What is more, you are now aware of multiple consistency models and how to change them in the Azure portal.</p>
<p>In the next chapter, you will learn about another hot topic: reactive architecture with Azure Event Grid.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>Which APIs does Azure Cosmos DB support currently?</li>
<li>Are there any differences between the capabilities of Azure Table Storage and Table API in Cosmos DB?</li>
<li>What are the available consistency models?</li>
<li>Which consistency model is more consistent—bounded, staleness, or eventual?</li>
<li>Is it possible to restrict access to Azure Cosmos DB to only a single IP?</li>
<li>Is SQL API the same as SQL Server?</li>
<li>What is the reason for using stored procedures?</li>
<li>Is it possible to provision throughput in Azure Cosmos DB for the whole account instead of per collection?</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li>Partitioning data in Azure Cosmos DB: <a href="https://docs.microsoft.com/en-us/azure/cosmos-db/partition-data">https://docs.microsoft.com/en-us/azure/cosmos-db/partition-data</a></li>
<li>Capacity planner: <a href="https://www.documentdb.com/capacityplanner">https://www.documentdb.com/capacityplanner</a></li>
<li>Azure Cosmos DB RUs: <a href="https://docs.microsoft.com/en-us/azure/cosmos-db/request-units">https://docs.microsoft.com/en-us/azure/cosmos-db/request-units</a></li>
<li>Consistency levels: <a href="https://docs.microsoft.com/en-us/azure/cosmos-db/consistency-levels">https://docs.microsoft.com/en-us/azure/cosmos-db/consistency-levels</a></li>
<li>Mongo DB support: <a href="https://docs.microsoft.com/en-us/azure/cosmos-db/mongodb-feature-support#mongodb-protocol-support">https://docs.microsoft.com/en-us/azure/cosmos-db/mongodb-feature-support#mongodb-protocol-support</a></li>
<li>Graph API and Gremlin: <a href="http://tinkerpop.apache.org/docs/current/reference/#intro">http://tinkerpop.apache.org/docs/current/reference/#intro</a></li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>