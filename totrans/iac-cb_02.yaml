- en: Chapter 2. Provisioning IaaS with Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Terraform AWS provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using an SSH key pair to use on AWS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using AWS security groups with Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an Ubuntu EC2 instance with Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating meaningful outputs with Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using contextual defaults with Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing S3 storage with Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating private Docker repositories with Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a PostgreSQL RDS database with Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling CloudWatch Logs for Docker with Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing IAM users with Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A modern infrastructure often uses multiple providers **Amazon Web Services**
    (**AWS**), OpenStack, Google Cloud, Digital Ocean, and many others), combined
    with multiple external services (DNS, mail, monitoring, and others). Many providers
    propose their own automation tool, but the power of Terraform is that it allows
    you to manage it all from one place, all using code. With it, you can dynamically
    create machines at two IaaS providers depending on the environment, register their
    names at another DNS provider, enable monitoring at a third-party monitoring company,
    while configuring the company GitHub account and sending the application logs
    to an appropriate service. On top of that, it can delegate configuration to those
    who do it well (configuration management tools such as Chef, Puppet, and so on),
    all with the same tool. The state of your infrastructure is described, stored,
    versioned, and shared.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll discover how to use Terraform to bootstrap a fully capable
    infrastructure on AWS. You'll know everything from launching fine-tuned EC2 instances
    and optimized RDS databases dynamically in different regions, to creating tight
    security groups, deploying SSH key pairs and securing IAM access keys, enabling
    log storage with CloudWatch, generating useful outputs, handling infinite **Simple
    Storage Service** (**S3**) storage, and using private Docker repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Terraform version in use for this book is 0.7.2.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Terraform AWS provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use Terraform with many IaaS providers, such as Google Cloud or Digital
    Ocean. Here, we'll configure Terraform to be used with AWS and stick with this
    provider for the rest of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: For Terraform to interact with an IaaS, it needs to have a *provider* configured.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An AWS account with keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working Terraform installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An empty directory to store your infrastructure code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To configure the AWS provider in Terraform, we''ll need the following three
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: A file declaring our variables, an optional description, and an optional default
    for each (`variables.tf`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A file setting the variables for the whole project (`terraform.tfvars`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A provider file (`provider.tf`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lets declare our variables in the `variables.tf` file. We can start by declaring
    what''s usually known as the `AWS_DEFAULT_REGION`, `AWS_ACCESS_KEY_ID`, and `AWS_SECRET_ACCESS_KEY`
    environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the two variables matching the AWS account in the `terraform.tfvars` file.
    It''s not recommended to check this file into source control: it''s better to
    use an example file instead (that is: `terraform.tfvars.example`). It''s also
    recommended to use a dedicated Terraform user for AWS, not the root account keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s tie all this together into a single file, `provider.tf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the following Terraform code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It only means the code is valid, not that it can really authenticate with AWS
    (try with a bad pair of keys). For this, we'll need to create a resource on AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You now have a new file named `terraform.tfstate` that has been created at
    the root of your repository. This file is critical: it''s the stored state of
    your infrastructure. Don''t hesitate to look at it, it''s a text file.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This first encounter with **HashiCorp Configuration Language** (**HCL**), the
    language used by Terraform, and other Hashicorp products looks pretty familiar:
    it''s a structured language fully compatible with JSON. We can find more information
    about HCL here: [https://github.com/hashicorp/hcl](https://github.com/hashicorp/hcl).
    In this case, we''ve declared variables with an optional description for reference.
    We could have declared them simply with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'All variables are referenced to use the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If the variable has been declared with a default, as our `aws_region` has been
    declared with a default of `eu-west-1`; this value will be used if there's no
    override in the `terraform.tfvars` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'What would have happened if we didn''t provide a safe default for our variable?
    Terraform would have asked us for a value when executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve used values directly inside the Terraform code to configure our AWS
    credentials. If you''re already using AWS on the command line, chances are you
    already have a set of standard environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, you can simply set them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Then Terraform can use them directly, and the only code you have to type would
    be to declare your provider! That's handy when working with different tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `provider.tf` will then look as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Creating and using an SSH key pair to use on AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have our AWS provider configured in Terraform, let's add a SSH key pair
    to use on a default account of the virtual machines we intend to launch soon.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Terraform installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AWS provider configured in Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generate a pair of SSH keys somewhere you remember, for example, in the `keys`
    folder at the root of your repo:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The resource we want for this is named `aws_key_pair`. Let''s use it inside
    a `keys.tf` file, and paste the public key content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will simply upload your public key to your AWS account under the name
    `admin_key`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you manually navigate to your AWS account, in **EC2** | **Network & Security**
    | **Key Pairs**, you''ll now find your key:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B05671_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Another way to use our key with Terraform and AWS would be to read it directly
    from the file, and that would show us how to use file interpolation with Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, let''s declare a new empty variable to store our public key in
    `variables.tf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the variable to the path of the key in `terraform.tfvars`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s use it in place of our previous `keys.tf` code, using the `file()`
    interpolation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is a much clearer and more concise way of accessing the content of the
    public key from the Terraform resource. It's also easier to maintain, as changing
    the key will only require to replace the file and nothing more.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our first resource, `aws_key_pair` takes two arguments (a key name and the public
    key content). That's how all resources in Terraform work.
  prefs: []
  type: TYPE_NORMAL
- en: We used our first *file* interpolation, using a variable, to show how to use
    a more dynamic code for our infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using Ansible, we can create a *role* to do the same job. Here''s how we can
    manage our EC2 key pair using a variable, with the name `admin_key`. For simplification,
    we''re using the three usual environment variables—`AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`,
    and `AWS_DEFAULT_REGION`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a typical Ansible file hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the main file (`main.yml`), let''s declare that our host (`localhost`) will
    apply the role dedicated to manage our keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `ec2_keys` main task file, create the EC2 key (`roles/ec2_keys/tasks/main.yml`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the code with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Using AWS security groups with Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Amazon's security groups are similar to traditional firewalls, with ingress
    (incoming traffic) and egress (outgoing traffic) rules applied to EC2 instances.
    Those rules can be updated on-demand. We'll create an initial security group allowing
    ingress **Secure Shell** (**SSH**) traffic only for our own IP address, while
    allowing all outgoing traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Terraform installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AWS provider configured in Terraform (refer to the previous recipe)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The resource we''re using is called `aws_security_group`. Here''s the basic
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We know we want to allow inbound TCP/22 for SSH only for our own IP (replace
    1.2.3.4/32 with yours!), and allow everything outbound. Here''s how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add a name tag for easier reference later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply this and you''re good to go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see your newly created security group by logging into the AWS Console
    and navigating to **EC2 Dashboard** | **Network & Security** | **Security Groups**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B05671_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Another way of accessing the same AWS Console information is through the AWS
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can achieve the same result using Ansible. Here''s the equivalent of what
    we just did with Terraform in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Creating an Ubuntu EC2 instance with Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have previously created the requirements to launch a standard virtual machine
    on AWS EC2 (an SSH key pair and a security group). Let's now launch this virtual
    machine on EC2, using the specified SSH key pair to log into it and placed inside
    the security group, so (in our case) SSH is only available from a specific IP
    address.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This example uses the `t2.micro` instance available for free in the AWS Free
    Tier.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Terraform installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AWS provider, a SSH key pair, and a Security Group configured in Terraform
    (refer to the previous recipes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, you need to find the correct AMI for your machine. An AMI is like a
    system disk image for AWS, and is referred to by its ID (that is: ami-df3bceb0
    or ami-f2fc9d81). In the Ubuntu case, you can find the AMI you want by going to
    their Amazon EC2 AMI Locator page ([https://cloud-images.ubuntu.com/locator/ec2/](https://cloud-images.ubuntu.com/locator/ec2/)).
    In this case, I selected a Xenial release (16.04 LTS), on the eu-west-1 zone (Ireland),
    running on HVM virtualization and backed by SSD disks. This leaves us with one
    result—`ami-ee6b189d`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B05671_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Start by declaring this variable in the `variables.tf` file started in the
    first recipe, using a default value corresponding to the AMI ID we found previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s declare the instance type, specifying it as a default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use those variables to create the Terraform `aws_instance` resource.
    Locally declared variables are available using the `${var.variable_name}` structure,
    and internal resource attributes are accessed using the `${resource_type.resource_name.attribute}`
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to the AWS EC2 dashboard under **Instances** | **Instances**, select
    your instance and note the public IP:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B05671_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Try to log into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You can apply and apply by refreshing its state against Amazon's as Terraform
    knows remote and local states are the same, and therefore it doesn't recreate
    endlessly new VMs each time.
  prefs: []
  type: TYPE_NORMAL
- en: You've successfully launched your first AWS EC2 instance using repeatable Terraform
    code!
  prefs: []
  type: TYPE_NORMAL
- en: Scaling the number of instances
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What if you want to launch two similar instances, maybe for debugging purposes,
    or for instant action behind a load balancer? It''s very easy with Terraform,
    just use the `count` option inside the `aws_instance` resource, and that will
    launch the required amount of instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, `terraform apply` this and observe Terraform automatically creating a
    new machine according to the counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The second server shows up in the AWS Console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scaling the number of instances](img/B05671_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, the command to destroy a Terraform infrastructure is `terraform destroy`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can achieve similar results using Ansible. Here''s how it looks, using `admin_key`
    and `base_security_group` created in the previous recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Generating meaningful outputs with Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wouldn't it be great if Terraform could show us useful, informational output
    after a successful run? Following what we've done so far, it would be helpful
    to know how to connect to the instance, what are the local and public IP addresses,
    or see the security groups used. That's what Terraform's outputs are for.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Terraform installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AWS provider and an EC2 instance (using a SSH keypair and a Security Group),
    all configured in Terraform (refer to the previous recipes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thankfully, we can use the same syntax we're already using to access variables
    and attributes of references, but this time in an `output` resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by simply adding a line in `outputs.tf` that would show us how
    to connect to our virtual machine, using the `public_ip` attribute of our `dev`
    EC2 instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When applying terraform next time, it will display the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: No doubt it's much quicker than having to log into the AWS dashboard, find the
    instance, and copy and paste the IP in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if it''s important for us to know at a glimpse under what security groups
    our EC2 instance is running? We know security groups can be multiple, so it''s
    an array. We can access the content of this array using the `formatlist` interpolation
    syntax as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'So now, at the next `terraform apply`, we''ll instantly know our security groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, if we have a lot of information to display from multiple sources, we
    can use the same syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This will display the instance ID and its local and public IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note that we used `${aws_instance.dev.public_ip}` in the first output and `aws_instance.dev.*.public_ip`
    in our last output. If you use the latter, the output will iterate through all
    available machines. It's very useful if you launch more than one instance using
    the `count=n` parameter in the `aws_instance` Terraform resource.
  prefs: []
  type: TYPE_NORMAL
- en: Using contextual defaults with Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen how to declare and use default values in our Terraform code, such
    as the Ubuntu AMI for our region or our VM size. An interesting feature in Terraform
    is the ability to declare and use *maps* of values, so, depending on a key, the
    variable can have a different value. We'll see how it applies to the correct AMI
    of the corresponding AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Terraform installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AWS provider and an EC2 instance (using a SSH key pair and a security group),
    all configured in Terraform (refer to the previous recipes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s how we simply declared the AMI we wanted for the `eu-west-1` region
    in the `variables.tf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We accessed it easily like this in the `instances.tf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar, but more explicit way would be to use a map, so we know which region
    the value refers to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how we access the same value in a map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add more valid AMI IDs for other regions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ami` variable can now be valid for either of the three regions if accessed
    correctly in the `instances.tf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now is a good time to start managing the AWS region directly in the code, for
    better portability. Add the following to `variables.tf` to use `eu-west-1` as
    a default region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now use this variable in the `provider.tf` file to set the region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the region variable is globally available, let''s use it to access our
    map in `instances.tf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We now have an easily geographically deployable infrastructure that anyone in
    your team can launch close to him or her without the need to change code.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can perform the same dynamic access to a map using the `lookup()` function
    in Terraform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Managing S3 storage with Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Storing and accessing files easily and in a scalable way is an essential part
    of a modern infrastructure. Amazon S3 is Amazon''s answer to this need. S3 stores
    "objects" in "buckets" and has no storage limit (one exception is the bucket name:
    it has to be unique on Amazon''s S3, the namespace being shared). We''ll see how
    to make the best use of S3 with Terraform.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Terraform installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AWS provider configured in Terraform (refer to the previous recipes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll start by creating a simple and explicitly public bucket on S3 named
    `iac-book`, using the `aws_s3_bucket` resource (and a tag for the sake of it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'After a `terraform apply`, your bucket is immediately available for storing
    objects. You can see it on the AWS S3 Console ([https://console.aws.amazon.com/s3/](https://console.aws.amazon.com/s3/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B05671_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s store a first object right now, a very simple file containing a simple
    string (`"Hello Infrastructure-as-Code Cookbook!"`). The resource is named `aws_s3_bucket_object`,
    and you need to reference the bucket previously created, the destination name
    (`index.html`), and its content. The ACL is here again explicitly public:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You can alternatively provide a file directly instead of its content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If you navigate to the AWS S3 Console, you can see it available with some extended
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B05671_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It would be awesome if we could know easily the URL of our file right from
    Terraform, so we could give it to others. Unfortunately, there''s no easy function
    for that. However, we know how URLs are constructed: `http://s3-<region>.amazonaws.com/bucket_name/object_name`.
    Let''s create an output containing this information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Paste the link in a web browser and you'll be able to access your file.
  prefs: []
  type: TYPE_NORMAL
- en: 'A workaround is to use the *static website hosting* feature of S3 by simply
    adding the following to your `aws_s3_bucket` resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'An optional output will give you its static hosting URL (in our case, [iac-book.s3-website-eu-west-1.amazonaws.com](http://iac-book.s3-website-eu-west-1.amazonaws.com)
    instead of [http://s3-eu-west-1.amazonaws.com/iac-book/index.html](http://s3-eu-west-1.amazonaws.com/iac-book/index.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using Ansible, there are many ways to create a bucket. Here''s a simple bucket
    with public read permissions, using the classic `s3` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that Ansible 2.2 also comes with an `s3_website` module for specifically
    handling S3 websites.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we would simply upload our previous `index.html` file using the
    same `s3` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Creating private Docker repositories with Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To host your Docker images, you need what''s called a **registry**. This registry
    is either run by you or as a service. It stores your images for you and sometimes
    builds them too. The Docker Hub and Quay.io from CoreOS are the main Docker-managed
    registries you can subscribe to. Both are interesting in terms of features or
    pricing. However, an interesting alternative is AWS **Elastic Container Registry**
    (**ECR**): pricing is different and fully integrated in the AWS ecosystem. Let''s
    create countless repositories simply with Terraform!'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Terraform installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AWS provider configured in Terraform (refer to the previous recipes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A configured AWS CLI ([http://docs.aws.amazon.com/cli/latest/userguide/installing.html](http://docs.aws.amazon.com/cli/latest/userguide/installing.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s say you want to store your application container in a repository named
    `myapp`, so you can deploy it easily. It''s very simple with Terraform. Add the
    following code to a file named `ecr.tf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to know the URL to access your new repository, you can create an
    output using the corresponding exported attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re used to the other Docker registries, the first step is to authenticate
    so you create private repositories. Here, no login or password are provided by
    AWS. We need to use the official AWS command line to authenticate, and that will
    give us temporary Docker credentials. The output of this command is the Docker
    command to type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Now we can `docker build`, `tag`, and `push` images at will! (See more about
    using Docker images in the dedicated chapter of this book.)
  prefs: []
  type: TYPE_NORMAL
- en: A nice advanced feature is the ability to use fine-grained policies for each
    repository created.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a PostgreSQL RDS database with Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Amazon Relational Database Service** (**RDS**) is an on-demand, ready-to-use,
    and resizable EC2 instance specifically tailored and configured to run the requested
    database server. You can launch many different relational database servers on
    RDS, and we''ll focus on PostgreSQL for this recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Terraform installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AWS provider configured in Terraform (refer to the previous recipes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many parameters at play in a database deployment, even a simple one.
    To be certain of what we''ll deploy, we''ll start by filling a simple table with
    the database requirements, and build on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Variable name | Value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| RDS Database Engine | `rds_engine` | `postgresql` |'
  prefs: []
  type: TYPE_TB
- en: '| RDS Database Engine Version | `rds_engine_version` | `9.5.2` |'
  prefs: []
  type: TYPE_TB
- en: '| RDS Instance Name | `rds_identifier` | `db` |'
  prefs: []
  type: TYPE_TB
- en: '| RDS Instance Type | `rds_instance_type` | `db.t2.micro` |'
  prefs: []
  type: TYPE_TB
- en: '| RDS Storage Size (GB) | `rds_storage_size` | `5` |'
  prefs: []
  type: TYPE_TB
- en: '| RDS First Database Name | `rds_db_name` | `iac_book_db` |'
  prefs: []
  type: TYPE_TB
- en: '| RDS Administrator Username | `rds_admin_user` | `dbadmin` |'
  prefs: []
  type: TYPE_TB
- en: '| RDS Administrator Password | `rds_admin_password` | `super_secret_password`
    |'
  prefs: []
  type: TYPE_TB
- en: '| RDS Publicly Accessible | `rds_publicly_accessible` | `true` |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s set all those variables in our `variables.tf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'As we''re running PostgreSQL and we want it to be available on the Internet
    (though generally not a good idea for production), we''ll need a security group
    allowing just the default PgSQL port (TCP/5432) for our IP address (refer to the
    *Using AWS security groups with Terraform* recipe), in `securitygroups.tf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have everything in place to construct the `aws_db_instance` resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did previously, a quick output giving us the FQDN of our new database
    will help us to use it quickly, in `outputs.tf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s `terraform apply` now and try the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: There are many more useful options you can use or set, such as maintenance windows,
    backup retention periods, dedicated database subnets, storage encryption, and
    master/slave configuration.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'How would that work when using Ansible to do a similar job with the same values?
    Just as easy as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: After executing this playbook, a similar PostgreSQL server will run on RDS as
    we just did with Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling CloudWatch Logs for Docker with Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**CloudWatch Logs** is a log aggregation service by Amazon you can use to send
    your logs to. It''s very useful to keep some logs centralized, share access to
    them, receive alarms when errors happen, or simply store them safely. We''ll see
    how to create a CloudWatch Log group and use it to stream logs from a Docker container
    logs inside it.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Terraform installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AWS provider configured in Terraform (refer to the previous recipes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Docker Engine running on Linux for the optional usage demonstration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s say we want the log group to be named `docker_logs`, and that we want
    to keep those logs for seven days. In the `variables.tf` file, that would look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, in a new `cloudwatch.tf` file, we can use the simple `aws_cloudwatch_log_group`
    resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: After a `terraform apply`, if you navigate to the AWS CloudWatch page, you'll
    see the newly created group under the **Log Groups** entry on the left ([https://eu-west-1.console.aws.amazon.com/cloudwatch/](https://eu-west-1.console.aws.amazon.com/cloudwatch/)).
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B05671_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Amazon CloudWatch Logs Docker logging driver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can now use this group to create a log stream from an application or a
    container. Using it as recommended by AWS is well documented, so let''s use it
    with Docker instead. It only requires to give the Docker daemon access to the
    `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` environment variables (configuring
    the Docker daemon is out of the scope of this chapter, but that''s under `/etc/sysconfig/docker`
    for Red Hat-based systems such as Fedora or CentOS, and `/etc/default/docker`
    for Debian/Ubuntu systems). Restart the daemon and start logging your containers
    output using a new Docker logging driver, using the log group name specified in
    Terraform earlier (`docker_logs`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Generate some activity on the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Refresh the AWS CloudWatch page and you'll see a new entry named `nginx` with
    the container logs. You can run all your containers in your infrastructure like
    this and get centralized logging very easily!
  prefs: []
  type: TYPE_NORMAL
- en: '![Amazon CloudWatch Logs Docker logging driver](img/B05671_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Managing IAM users with Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An essential part of using AWS is controlling access to the resources. We've
    seen with all the previous recipes how often we need to use the AWS Access Keys,
    and it's surely not a good idea to use a single key for all your activities. Imagine
    what would happen if a single one of your services was hacked—the intruder would
    get the main AWS key and would be able to do everything on your behalf.
  prefs: []
  type: TYPE_NORMAL
- en: A good secure setup would be dedicated keys with a dedicated scope of access
    rights for every person in your team and every service in your infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, **Identity and Access Management** (**IAM**) is there just for that.
    We'll see how to use it with Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Terraform installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AWS provider configured in Terraform (refer to the previous recipes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with a simple case: two members of a team (Mary and Joe) need
    to access resources on AWS. They currently all share the same main key, which
    is a disaster if a leakage happens. So let''s ask them what exactly they need
    to access in the AWS space:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Mary** | S3 in read and write |'
  prefs: []
  type: TYPE_TB
- en: '| **Joe** | EC2 in read only |'
  prefs: []
  type: TYPE_TB
- en: As expected, neither user really needs full access!
  prefs: []
  type: TYPE_NORMAL
- en: 'Amazon helps by offering prebuilt security policies for IAM. If those aren''t
    enough, you can tailor the ones you need:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B05671_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find all AWS Managed IAM Policies at [https://console.aws.amazon.com/iam/home#policies](https://console.aws.amazon.com/iam/home#policies).
  prefs: []
  type: TYPE_NORMAL
- en: An IAM user for S3 access
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s create a first IAM user for Mary in a new `iam.tf` file using the `aws_iam_user`
    resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The `path` is purely optional and informative, I'm simply suggesting structured
    paths. So we'll have `/apps/` as well later.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now create an AWS Access Key for our user Mary, using the `aws_iam_access_key`
    resource with reference to our user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, as we know, we want to attach to this user the `AmazonS3FullAccess`
    managed policy, let''s use the dedicated resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write an `output` so we know both parts of the key in `outputs.tf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, `terraform apply` this to create the `mary` user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Testing the restrictions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, `terraform apply` this, and confirm using an S3 browser that you can access
    S3! Here''s an example of creating a simple S3 bucket with `s3cmd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Is this account really limited to S3, as it pretends to be? Let''s try to list
    EC2 hosts with Mary''s account using the `aws` command line (provided you configured
    the `aws` tool accordingly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: So it all looks good and secure! Mary can do her job on S3 safely.
  prefs: []
  type: TYPE_NORMAL
- en: An IAM user for EC2 in read-only
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Is there a similar managed policy for Joe, with a read-only scope on EC2? Fortunately,
    there is! It's creatively named `AmazonEC2ReadOnlyAccess`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our second user, with this IAM policy in the `iam.tf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget the useful output that comes with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, `terraform apply` this once again, and can the Joe user see what''s on
    S3? No, he can''t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'But can the Joe user simply list the EC2 VMs as he needs to, with the same
    command that was forbidden to Mary? Yes, he can:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: We're on track to securely manage our infrastructure access using code!
  prefs: []
  type: TYPE_NORMAL
- en: An application user IAM – CloudWatch Logs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We've used the CloudWatch Logs service in a previous recipe. If you remember,
    you had to enter once again your keys in the Docker Engine configuration. If you
    had 100 servers, your master keys would be on each of them. This is rather unnecessary,
    if you consider that the scope of this configuration in Docker is just to send
    logs. Fortunately, there's a managed IAM policy for that named `CloudWatchLogsFullAccess`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s create another user, exactly as before for Mary and Joe, except this
    one will be for our Docker Engines and not for a real user in `iam.tf`. I suggest
    using a different path, just to separate real users and application users. However,
    that''s totally optional and opinionated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The relevant `output` in `outputs.tf` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `terraform apply` this and try the *Enabling CloudWatch Logs for Docker
    with Terraform* recipe again with those credentials instead of the master keys:
    it will still work on the CloudWatch scope, but if something goes wrong, it will
    never put the rest of your infrastructure in danger. The worst that can happen
    in this area is the total waste of the logs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '![An application user IAM – CloudWatch Logs](img/B05671_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you''d prefer to see how this would work using Ansible, it''s a bit different.
    IAM support is not equivalent, as there''s no IAM Managed Policies support. However,
    you can simply create users like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'As there''s currently no IAM Managed Policy support, a workaround is to use
    the JSON from the IAM Policy we want, such as `AmazonS3FullAccess` for our user
    Mary. It''s easy to find in the AWS Console in the **Policies** section ([https://console.aws.amazon.com/iam/home#policies](https://console.aws.amazon.com/iam/home#policies)).
    Paste the following JSON content in `AmazonS3FullAccess.json` at the root of the
    `Ansible` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Use this local policy in the `iam_policy` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
