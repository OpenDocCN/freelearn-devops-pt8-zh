- en: '18'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Looking Ahead – Certification, Emerging Trends, and Next Steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are at a place in our journey where we have to stop and ask ourselves, *What’s
    next?* Before we do that, let’s think about where we’ve been.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve learned what Terraform is and how to use it. We’ve learned some basic
    concepts of cloud architecture that transcend the particular cloud platform you
    might be using at the moment. We’ve built three sophisticated architectures on
    each of the three major hyperscalers—AWS, Azure, and GCP—and finally, we’ve learned
    how to work with existing environments, either importing them into Terraform or
    managing them with Terraform as long-lived environments in production or otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: That’s a lot! It’s been quite a journey, so where do we go from here? Well,
    the answer is in you. I hope that means you have learned something along this
    journey, and you’ll take that into your day-to-day work to build amazing systems
    that solve real-world problems and are better equipped to build and manage them
    with the power of Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, before we close, I’d like to discuss some potential next steps,
    both for your personal growth and extended learning. You have invested a tremendous
    amount of time in reading this book and have begun your journey of mastering Terraform.
    You may want to consider certification as a way to validate your skills and knowledge
    and to demonstrate your expertise to potential employers.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, there may be other technologies that you may want to consider
    as you continue to deepen your mastery of Terraform. We’ll explore some of these
    options, including tools and platforms that complement Terraform and how they
    can enhance your **Infrastructure as Code** (**IaC**) capabilities. By the end
    of this chapter, you should have a clear roadmap for your continued learning and
    a solid foundation for your future endeavors in the world of cloud infrastructure
    management.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for the exam
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terraform Cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s next?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing for the exam
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On your journey through this book to mastering Terraform, you’ve gained a wealth
    of knowledge and practical experience. But how do you showcase your expertise
    to the world? One of the most effective ways is through certification. In this
    section, we’ll delve into the intricacies of preparing for the Terraform certification
    exams. We’ll cover the key topics you need to master, the format of the exam,
    and strategies to optimize your study time and approach. By the end of this section,
    you’ll be well equipped with the tools and confidence needed to tackle the certification
    exam and take a significant step forward in mastering Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Scope and topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **HashiCorp Terraform Associate Certification** is an entry-level certification
    that will test you on general concepts of IaC, Terraform’s competitive position
    against other tools, working with code using the **HashiCorp Configuration Language**
    (**HCL**), and using the core Terraform workflow as well as other workflows that
    are supported through various sub-commands within the **Command-Line** **Interface**
    (**CLI**).
  prefs: []
  type: TYPE_NORMAL
- en: There is a new exam that is coming soon called **Terraform Authoring and Operations
    Professional**. This exam is designed for seasoned practitioners who have extensive
    experience in managing production systems, developing reusable modules, and operating
    within a mature enterprise IaC environment. It aims to validate the advanced skills
    and deep understanding required to efficiently author and manage Terraform configurations
    at scale. Candidates can expect to be tested on their ability to implement complex
    infrastructure architectures, optimize workflows, and ensure best practices in
    an enterprise environment. This certification is an excellent opportunity for
    those looking to demonstrate their expertise in leveraging Terraform’s full capabilities
    in a sophisticated and dynamic infrastructure landscape.
  prefs: []
  type: TYPE_NORMAL
- en: This book is designed to help you go beyond many of the foundational concepts
    covered in the Associate exam and help you prepare for the Professional exam.
    As a result, our journey in this book has been taking a hyper-practical approach
    to building actual cloud architectures using Terraform and implementing collaborative
    flows with Terraform and an automation pipeline tool, which, for the entirety
    of this book, was GitHub Actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the following diagram, I map chapters within this book to
    actual topics covered within the Associate exam:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.1 – Map of Associate certification topics to chapters in this book](img/B21183_18_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.1 – Map of Associate certification topics to chapters in this book
  prefs: []
  type: TYPE_NORMAL
- en: We breezed through the foundational conceptual layers of IaC, Terraform’s architecture,
    and HCL in the first three chapters of this book. This was by design, as this
    book is intended for an intermediate to advanced audience and not a beginner’s
    guide.
  prefs: []
  type: TYPE_NORMAL
- en: This allowed us to dedicate some time, in *Chapters 4* through *6*, to the conceptual
    layer that most Terraform practitioners actually spend their time in—the cloud
    architectures that they are designing and provisioning when we set the bases for
    the cloud computing paradigms we would be working with across all three clouds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we hit the ground running, getting our hands dirty and building three
    real-world solutions for each cloud. As you can see, we spent most of our time
    in the book working on implementing HCL code across all three clouds—AWS, Azure,
    and GCP—and across three cloud computing paradigms—virtual machines, containers,
    and serverless. In these nine solutions, we implemented Terraform modules and
    delved deep into configuration using three corresponding Terraform providers:
    `aws`, `azure`, and `GCP`.'
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapters 16* and *17*, we focused on the non-core workflows involving advanced
    topics in state management and configuration importation that are common and necessary
    when working with existing environments—whether or not they were originally provisioned
    with Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Professional exam, this is still significant coverage of all the key
    topics with one key exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.2 – Map of Professional certification topics to chapters in this
    book](img/B21183_18_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.2 – Map of Professional certification topics to chapters in this book
  prefs: []
  type: TYPE_NORMAL
- en: The notable exception is **Terraform Cloud**, which I chose to omit as a main
    focus of this book since I don’t think knowledge of it is required to master Terraform
    at this time. We will look at Terraform Cloud in the next section of this chapter,
    as I think it is an interesting topic area for further study if you want to leverage
    some of its capabilities to streamline your organization’s collaborative workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Preparation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go and check out the study guides for both the Associate and Professional exams.
    The study guides have helpful links to the official documentation, which should
    augment the contents of this book. Remember, this book was intended to be a practical
    guide for those who want to master Terraform to provision cloud architecture.
    That doesn’t necessarily mean memorizing every nook and cranny of the Terraform
    CLI. I specifically chose to focus on skills that will help you start developing
    real-world solutions no matter what cloud and cloud computing paradigm you’ll
    be working with.
  prefs: []
  type: TYPE_NORMAL
- en: The exam will likely have tricky edge cases or obscure commands that are seldom
    used, so be ready for that, but I wouldn’t dedicate a tremendous amount of time
    to it. Make yourself a quick cheat sheet of some of these obscure commands and
    how to use them. Employ flashcards to help you memorize them if you feel like
    you need to. If you have a solid understanding of Terraform’s architecture and
    are hands-on with it, you should do well.
  prefs: []
  type: TYPE_NORMAL
- en: My best advice is to study through hands-on experience. Take the projects in
    this book, and feel free to clone them from my GitHub repositories, but to maximize
    your own mastery, develop them from scratch in your own repository on GitHub.
    Recreate them, provision yourself and the environment, and then improve upon them.
    Think about how you would like to modularize components within them to be more
    reusable. Go ahead and implement those modules, and then refactor your environment
    to use your new modules. Treat your environment as if it were production and try
    to minimize the impact on your environment by making sure you avoid replacing
    resources in your existing environment while trying to refactor to use your new
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: I sat for the exam while I was at HashiConf in October 2023\. I didn’t study,
    I didn’t prepare, I didn’t even read the study guide. I passed with a score of
    84.21%. I was pretty happy about it. Am I telling you this to brag? No. Well,
    maybe a little, but seriously, my point is that the best way for you to prepare
    is by doing. How was I able to pass without studying at all? Because I’ve been
    hands-on with Terraform for several years and know it inside and out. Did I know
    every obscure command within the Terraform CLI? Absolutely not. Had I ever used
    Terraform Cloud? Not for one New York minute. You have to ask yourself, do you
    want to pass an exam, or do you want to upskill yourself and become a dangerous
    force in the cloud automation space with one of the most powerful automation tools
    in the world? I think the answer is clear. Focus on the primary objective with
    gazelle-like intensity and augment it with a bit of studying more obscurities,
    and you will do well.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are energized, feeling empowered by all that you have learned from
    this book, and ready to take the Terraform Associate or upcoming Professional
    exam, let’s look forward to some interesting topics that every Terraformer (not
    just the Azure ones) should know about.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll explore Terraform Cloud, a powerful platform designed
    to enhance Terraform’s capabilities in team-based and enterprise environments.
    Terraform Cloud provides a centralized hub for managing and automating Terraform
    workflows, offering features such as version control integration, remote state
    management, and collaborative IaC development.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll take a brief look at the core components of Terraform Cloud, including
    advanced features such as workspace management, private module registry, cost
    estimation, and policy enforcement.
  prefs: []
  type: TYPE_NORMAL
- en: By understanding Terraform Cloud’s features and use cases, you’ll gain insights
    into how it can streamline your infrastructure management processes and foster
    collaboration among team members. It’s definitely something to consider if you
    are looking to scale up your organization’s IaC maturity quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Terraform Cloud’s mission is about streamlining the process of managing environments
    with IaC. This will include features that handle day-to-day operation concerns
    of using Terraform, as well as more advanced capabilities related to empowering
    teams and scaling across larger organizations within the enterprise. The following
    is a diagram showing the grouping of these capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.3 – Terraform Cloud capabilities](img/B21183_18_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.3 – Terraform Cloud capabilities
  prefs: []
  type: TYPE_NORMAL
- en: 'These groupings are across four functional areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Core workflow operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organization and logistics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module management and publishing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Day 2 operations support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll explore each of these functional areas individually to get a better idea
    of what Terraform Cloud brings to the table.
  prefs: []
  type: TYPE_NORMAL
- en: Core workflow operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we know, Terraform, itself is a simple command-line tool that processes HCL
    code and leverages a multitude of providers to generate a plan and then execute
    that plan by orchestrating resource creation across multiple providers. Terraform
    Cloud is a multi-tenant SaaS offering that encapsulates the functionalities of
    the command-line tool and hosts it as a managed service offering.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, a significant portion of the value of Terraform Cloud comes from,
    well, Terraform itself—that is, the command-line tool that does all the work.
    However, Terraform Cloud provides many things beyond what is built into the command-line
    tool. As a hosted service, it sits atop our version control system and acts as
    a pipelining tool that executes the Terraform `plan` and `apply` commands. In
    this book, we worked with GitHub Actions to integrate the Terraform command-line
    tool into our workflows to run the core Terraform workflow, which includes `plan`
    and `apply`.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform Cloud’s capabilities in the *Core Workflow Operations* category focus
    on providing Terraform as a service, similar to what pipeline tools such as **GitHub
    Actions** do for general-purpose pipelines, but Terraform-specific. This means
    Terraform Cloud is essentially an automation-hosted platform that specializes
    in executing Terraform configurations. As a result, the service is tailored to
    Terraform’s specific needs, including things such as remote state management.
    However, it also includes essential features found in general-purpose pipelining
    tools, such as source control integration, cloud platform credential management,
    and secure variable storage. It also offers extension points for integration with
    external tools, allowing it to be integrated into broader automation orchestration.
  prefs: []
  type: TYPE_NORMAL
- en: Organizational and logistics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The organizational and logistics aspect of Terraform Cloud is designed to facilitate
    collaboration and management by teams within organizations large and small. It
    provides a structured environment to organize users, roles, and permissions across
    logical projects, leading to the creation and operation of Terraform workspaces—ensuring
    that team members have the appropriate access and permissions to perform their
    tasks effectively. Like other more general-purpose automation platforms such as
    **Azure DevOps** and **GitHub Enterprise**, maintaining order and control in these
    collaborative environments is baseline functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Module management and publishing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Terraform Cloud’s capabilities within module management and publishing enable
    teams and organizations to build, maintain, and share their own libraries of Terraform
    modules across their organization. As we’ve discussed, Terraform modules often
    encapsulate organizationally approved best practices and are often maintained
    by a central organization responsible for their implementation and built-in quality.
    Terraform Cloud supports this publishing process by integrating Terraform module
    testing and validation to ensure quality before new versions of Terraform modules
    are distributed across an organization. Additionally, these modules can be made
    available in no-code environments, providing a service catalog-like experience
    for end users. This empowers teams to standardize and scale their infrastructure
    management efforts but also makes the solutions that they build available to parts
    of the organization that are unfamiliar with IaC or Terraform in general.
  prefs: []
  type: TYPE_NORMAL
- en: Day 2 operations support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Day 2 operations support functionality in Terraform Cloud is geared toward
    managing and maintaining existing systems in production. It includes continuous
    validation to ensure environments remain up to date with the desired state described
    within the code and drift detection to identify changes made outside of Terraform
    code. There are also more advanced enterprise features, such as audit logging,
    to help larger organizations meet regulatory compliance standards and implement
    risk management policies to detect and prevent unplanned changes to the environment.
    Another key feature is the policy-as-code capabilities provided by **Sentinel**,
    which enables governance and security controls over the environments managed by
    Terraform Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Pricing tiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Free* tier provides all IaC capabilities of Terraform as a hosted service
    out of the box and all of the core workflow operations capabilities—including
    remote state, secure variable storage, dynamic provider credentials, and source
    control integration. It’s a great way to get your feet wet exploring the platform
    and learning the new way of working with Terraform Cloud as the foundation as
    opposed to a general-purpose pipeline tool. As expected, it is pretty limited
    with a single concurrent job and limited access to more advanced enterprise features
    such as Policy-as-Code and run tasks that are designed to help you scale Terraform
    Cloud into a larger, more sophisticated IaC-powered organization. The Free tier
    allows you to provision up to 500 resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *Standard* tier adds team management and increases the number of concurrent
    jobs from one to three, which probably makes sense in a team environment. The
    pricing model is per hour per resource, which means every resource you declare
    in your Terraform configuration will count toward your usage. The price per hour
    per resource, at the time of writing, was $0.00014\. To give you an idea of how
    much this would cost to operate, one of the environments that I manage is an environment
    with a small Kubernetes cluster and all the surrounding supporting infrastructure.
    I provisioned exactly 110 resources in this environment using Terraform:'
  prefs: []
  type: TYPE_NORMAL
- en: '*110 resources x $0.00014 per resources per hour = $0.0154* *per hour*'
  prefs: []
  type: TYPE_NORMAL
- en: '*$0.0154 per hour * 24 hours per day * 30 days per month = $11.088* *per month*'
  prefs: []
  type: TYPE_NORMAL
- en: So, for roughly 11 dollars per month, I can use Terraform Cloud to manage my
    environment. This is in addition to what I pay for my source control management
    system and the cloud hosting costs of the environment.
  prefs: []
  type: TYPE_NORMAL
- en: The *Plus* tier introduces Day 2 operations support scenarios such as audit
    logging, drift detection, continuous validation, ephemeral workspaces, ServiceNow
    integrations, and unlimited Policy-as-Code to help you better manage your environments
    and integrate with your day-to-day operations.
  prefs: []
  type: TYPE_NORMAL
- en: The *Enterprise* tier is essentially the hosted offering that allows you to
    deploy Terraform Enterprise into your own data center, which can be important
    to large enterprises that are not interested in taking advantage of the lowered
    operating cost of utilizing HashiCorp’s multi-tenant offering, Terraform Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at Terraform Cloud, including what it offers in terms
    of capabilities and recognizing that, unlike more general-purpose automation platforms,
    it is tailored specifically for IaC management and collaboration using Terraform.
    Compared to these more general-purpose pipeline tools, Terraform Cloud stands
    out by offering features specifically designed for Terraform workflows, such as
    remote state management, secure variable storage, and integrated module management.
    This focus on Terraform-specific functionality makes it an ideal choice for teams
    looking to take their IaC processes to the next level. Next, we’ll look at some
    other key trends to be aware of that are out of the scope of this book but should
    be on the radar of anyone looking to truly master Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: What’s next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll explore some emerging trends within the Terraform community
    that are essential for anyone working with Terraform to be aware of. While these
    topics are technically outside the scope of this book, including upcoming features
    that have not even been finalized and may evolve over time, understanding these
    emerging topics can provide valuable context into the future direction of Terraform
    and help you stay ahead of the curve in your journey to mastering Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: CDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Terraform **Cloud Development Kit** (**CDK**) is a method for developing
    Terraform configuration using imperative programming languages that you already
    know and use within your application development. Any language can be used, from
    Python to C# and from TypeScript to Java. Any Terraform provider and Terraform
    modules can be used as well. It’s essentially the same thing as working with HCL
    but using the programming language of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.4 – Use the programming language of your choice](img/B21183_18_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.4 – Use the programming language of your choice
  prefs: []
  type: TYPE_NORMAL
- en: Whatever language you choose will ultimately compile down into a Terraform-compatible
    JSON file that is then interpreted by Terraform in a similar way as HCL files
    are processed.
  prefs: []
  type: TYPE_NORMAL
- en: This option is great for existing development teams that already work with a
    programming language of choice and don’t want to invest energy in learning the
    HCL. However, for non-developers, the HCL is definitely the way to go as it provides
    a simple, functional language that is easier to adopt and already has a massive
    ecosystem of practitioners that are using it, asking and answering questions about
    it, and sharing code on public GitHub repositories that can help you along on
    your way.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform Stacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Terraform Stacks**, a highly anticipated feature on the horizon for Terraform,
    promises to revolutionize the way we design and manage complex architectures across
    multiple control planes. This innovative feature is expected to provide a seamless
    and integrated experience for users working with Terraform Cloud and the **Terraform
    Community Edition** (the command-line tool). By allowing for more sophisticated
    organization and modularization of IaC, Terraform Stacks aims to streamline the
    process of deploying and managing large-scale, multi-tiered environments. We’ll
    dig into what we know right now based on what was made public by HashiCorp at
    the time of writing and how it’s supposed to work when it’s eventually released.'
  prefs: []
  type: TYPE_NORMAL
- en: Current state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the current landscape of Terraform usage, a singular root module serves
    as the cornerstone of infrastructure deployment. This root module encompasses
    the provider configuration and engages with various Terraform resources, either
    directly or via module references. The versatility of these root modules is heightened
    by supplying them with distinct input parameters tailored to the desired environment
    for deployment. To further segregate the deployment of each root module instance,
    Terraform workspaces are employed, resulting in individual Terraform state files.
    These state files are then uniquely associated with specific environments, such
    as `DEV`, `TEST`, or `PROD`, effectively encapsulating the configuration and status
    of the deployed infrastructure within each environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.5 – Current state: Terraform workspaces and root modules](img/B21183_18_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.5 – Current state: Terraform workspaces and root modules'
  prefs: []
  type: TYPE_NORMAL
- en: In the realm of provisioning complex environments with Terraform, it is often
    necessary to employ multiple root modules to delineate layers of architecture
    based on their dependencies, such as blast radius considerations or concrete control
    plane dependencies such as those between a cloud platform and a Kubernetes control
    plane. This is not the only scenario where you will run into control plane dependencies
    within the providers, but it is a common one as the use of managed Kubernetes
    offerings continues to grow in popularity. The dependency can arise anytime you
    are provisioning resources with two or more providers and one provider provisions
    a resource that is then used to configure another Terraform provider. Depending
    on the way this dependent provider initializes, you might see a conflict arise
    because providers that rely on their control plane to be provisioned in another
    provider’s resource can experience deadlocks in both `terraform apply` and `terraform
    destroy`. This is because Terraform cannot plan resources on the control plane,
    which doesn’t exist yet.
  prefs: []
  type: TYPE_NORMAL
- en: Some other common scenarios that I have encountered are with the `grafana` provider
    for Terraform to provision resources for it. This mirrors the dependency created
    by `kubernetes` provider. It doesn’t matter what cloud platform you are working
    with. Many cloud platforms have similar managed service offerings that are provisioned
    through their corresponding provider, which produces an endpoint that can be automated
    by a Terraform provider designed for that control plane. This is even the case
    with something as fun as the `minecraft` provider—whether you are using EC2, Azure
    VMs, or GCE!
  prefs: []
  type: TYPE_NORMAL
- en: 'While there are two main approaches to this, both necessitate executing `terraform
    apply` multiple times. The first approach involves provisioning each stage of
    our deployment independently and then linking the upstream dependency to the downstream
    stage using data sources, with values provided by input variables. This method
    allows different stages to be deployed relatively independently by various teams,
    but it introduces additional configuration management overhead, as each downstream
    dependency must explicitly reference the previously provisioned upstream stages.
    Consequently, this approach results in a highly serial deployment pattern, requiring
    each upstream dependency to be deployed and stabilized before progressing to the
    next downstream dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.6 – Current state: independent deployments with data source dependencies](img/B21183_18_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.6 – Current state: independent deployments with data source dependencies'
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative approach to provisioning complex environments with Terraform
    diverges from independent deployments and instead adopts a monolithic pipeline
    that sequentially executes `terraform apply`. In this model, the dependencies
    are seamlessly integrated by piping the Terraform outputs from the upstream dependency
    directly into the inputs of the downstream dependency. While this method streamlines
    automation, it also results in a tighter coupling of the environments. Irrespective
    of the approach—whether it involves independent deployments or a monolithic pipeline—there
    is an inherent necessity to implement a substantial amount of *glue* to stitch
    together multiple `terraform apply` steps. This entails writing Bash scripts or
    similar automation to act as the connective tissue, ensuring the correct values
    are passed from one pipeline job to the next, thereby maintaining the integrity
    of the deployment process across various stages:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 18.7 – Current state: integrated deploymen\uFEFFt with output-based\
    \ dependencies](img/Image96503.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.7 – Current state: integrated deployment with output-based dependencies'
  prefs: []
  type: TYPE_NORMAL
- en: Stacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Defined in a `.tfstack` file, Stacks allow you to declare one or more `component`
    blocks that essentially define what is currently a root module. These components
    represent discrete and deterministic provisioning stages within a deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.8 – Future state: Terraform Stacks](img/B21183_18_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.8 – Future state: Terraform Stacks'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, we see three components that make up our stack:'
  prefs: []
  type: TYPE_NORMAL
- en: Network infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes deployments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This would be defined in a `.tfstack` file in this manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The compute infrastructure would be defined in the same file but, this time,
    referencing outputs from the network component that it draws a dependency on.
    This informs Terraform to provision the `network` component first and resolve
    that stage of the deployment first before attempting to deploy the `compute` infrastructure
    component next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `compute` component is provisioned, we will have a Kubernetes cluster
    that is ready to deploy our applications and services to. Therefore, we declare
    the final component of our stack, the application component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to initialize the `kubernetes` and `helm` providers only after
    the necessary steps have been taken to provision the Kubernetes cluster, which
    is absolutely required before we can even begin to execute a plan.
  prefs: []
  type: TYPE_NORMAL
- en: Deployments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Defined in a `.tfdeploy` file, deployments allow you to declare one or more
    `deployment` blocks that essentially define a Terraform workspace that manifests
    itself once provisioned into an individual Terraform state file that represents
    a provisioned environment. The introduction of deployments allows us to declaratively
    establish different environments that we provision in our configuration rather
    than implicitly through the organization of our Terraform workspaces and the context
    in which we execute Terraform core workflow operations such as `plan` and `apply`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deployments act as the central place where provider configuration is established.
    This includes linking the preferred method of authentication with each provider.
    This is done using a new block called `identity_token`, which would be defined
    in this manner for AWS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This would be defined in a `.tfdeploy` file in this manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `deployment` block allows us to establish multiple instances
    of our Stacks and configure them with their own input variables and provider context,
    including relevant authentication and authorization context.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform Stacks is an exciting new capability in preview on Terraform Cloud
    and is planned to be released for both Terraform Cloud and Terraform Community
    Edition. As you can see, with this approach, we’ll be able to eliminate a tremendous
    amount of *plumbing* that we currently put into our pipelines (i.e., **GitHub
    Actions**, **Azure DevOps**, **Jenkins**, etc.) and replace it with Terraform
    configuration that we can manage with the **Gitflow** standards we learned about
    in [*Chapter 6*](B21183_06.xhtml#_idTextAnchor330). If you plan on managing complex
    solutions with Terraform, this is a feature to watch for in future releases!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final chapter of *Mastering Terraform*, we’ve explored the next steps
    for those of you looking to deepen your mastery of Terraform and stay abreast
    of emerging trends in the community. We discussed the importance of Terraform
    certification, highlighting the Associate and Professional level exams.
  prefs: []
  type: TYPE_NORMAL
- en: We also delved into Terraform Cloud, which can enhance automation and collaboration
    in your IaC process, building upon the workflows and concepts we’ve covered throughout
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: The Terraform community is vibrant and continuously evolving, with new trends
    and alternative pathways emerging regularly. We explored some of the latest developments,
    including the Terraform CDK, which allows you to use Terraform with familiar programming
    languages, and finally, we looked at some exciting upcoming features in Terraform,
    such as Terraform Stacks, which promises to revolutionize the way we manage environments
    through IaC by providing more flexibility and modularity in defining and deploying
    sophisticated and layered cloud architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Closing statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have traveled long, and we have traveled far. We have explored Terraform,
    its architecture, its capabilities, and its form and function. Beyond just learning
    Terraform, to truly become masters of Terraform, we need to ground ourselves in
    the architectures and work patterns expected of us as IaC practitioners. That
    means we need a deep understanding of cloud architectures to effectively use Terraform
    to its fullest potential. This includes the various flora and fauna we will find
    in the wild—from virtual machines to containers to serverless—and all the surrounding
    ancillary resources that support those architectures. Once we have this core conceptual
    knowledge, we’ll be able to better navigate the multi-cloud world that we live
    in today and truly transcend our current cloud provider of choice to be ready
    for the future—whatever may come.
  prefs: []
  type: TYPE_NORMAL
- en: Thank you for coming on this journey with me. I hope you enjoyed my very focused
    and practical approach to mastering Terraform. I think the best way to learn is
    by doing, so I encourage you to go to GitHub, clone any or all of the solutions
    described in this book, and get to work on finishing your journey of mastering
    Terraform!
  prefs: []
  type: TYPE_NORMAL
