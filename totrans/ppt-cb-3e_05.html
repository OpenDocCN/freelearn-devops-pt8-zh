<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Users and Virtual Resources"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Users and Virtual Resources</h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"Nothing is a problem, until it's a problem."</em></span></p></blockquote></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using virtual resources</li><li class="listitem" style="list-style-type: disc">Managing users with virtual resources</li><li class="listitem" style="list-style-type: disc">Managing users' SSH access</li><li class="listitem" style="list-style-type: disc">Managing users' customization files</li><li class="listitem" style="list-style-type: disc">Using exported resources</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec69"/>Introduction</h1></div></div></div><p>Users can be a real pain. I don't mean the people, though doubtless that's sometimes true. But keeping UNIX user accounts and file permissions in sync across a network of machines, some of them running different operating systems, can be very challenging without some kind of centralized configuration management.</p><p>Each new developer who joins the organization needs an account on every machine, along with <code class="literal">sudo</code> privileges and group memberships, and needs their SSH key authorized for a bunch of different accounts. The system administrator who has to take care of this manually will be at the job all day, while the system administrator who uses Puppet will be done in minutes, and head out for an early lunch.</p><p>In this chapter, we'll look at some handy patterns and techniques to manage users and their associated resources. Users are also one of the most common applications for virtual resources, so we'll find out all about those. In the final section, we'll introduce exported resources, which are related to virtual resources.</p></div></div>
<div class="section" title="Using virtual resources"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec70"/>Using virtual resources</h1></div></div></div><p>Virtual resources <a id="id377" class="indexterm"/>in Puppet might seem complicated and confusing but, in fact, they're very simple. They're exactly like regular resources, but they don't actually take effect until they're realized (in the sense of "made real"); whereas a regular resource can only be declared once per node (so two classes can't declare the same resource, for example). A virtual resource can be realized as many times as you like.</p><p>This comes in handy when you need to move applications and services between machines. If two applications that use the same resource end up sharing a machine, they would cause a conflict unless you make the resource virtual.</p><p>To clarify this, let's look at a typical situation where virtual resources might come in handy.</p><p>You are responsible for<a id="id378" class="indexterm"/> two popular web applications: WordPress and Drupal. Both are web apps running on Apache, so they both require the Apache package to be installed. The definition for WordPress might look something like the following:</p><div class="informalexample"><pre class="programlisting">class wordpress {
  package {'httpd':
    ensure =&gt; 'installed',
  }
  service {'httpd':
    ensure =&gt; 'running',
    enable =&gt; true,
  }
}</pre></div><p>The definition for Drupal might look like this:</p><div class="informalexample"><pre class="programlisting">class drupal {
  package {'httpd':
    ensure =&gt; 'installed',
  }
  service {'httpd':
    ensure =&gt; 'running',
    enable =&gt; true,
  }
}</pre></div><p>All is well until you need to consolidate both apps onto a single server:</p><div class="informalexample"><pre class="programlisting">node 'bigbox' {
  include wordpress
  include drupal
}</pre></div><p>Now Puppet will complain because you tried to define two resources with the same name: <code class="literal">httpd</code>.</p><div class="mediaobject"><img src="graphics/B03643_05_01.jpg" alt="Using virtual resources"/></div><p>You could remove the <a id="id379" class="indexterm"/>duplicate Apache package definition from one of the classes, but then nodes without the class including Apache would fail. You can get around this problem by putting the Apache package in its own class and then using <code class="literal">include apache</code> everywhere it's needed; Puppet doesn't mind you including the same class multiple times. In reality, putting Apache in its own class solves most problems but, in general, this method has the disadvantage that every potentially conflicting resource must have its own class.</p><p>Virtual resources can be used to solve this problem. A virtual resource is just like a normal resource, except that it starts with an <code class="literal">@</code> character:</p><div class="informalexample"><pre class="programlisting">@package { 'httpd': ensure =&gt; installed }</pre></div><p>You can think of it as being like a placeholder resource; you want to define it but you aren't sure you are going to use it yet. Puppet will read and remember virtual resource definitions, but won't actually create the resource until you realize the resource.</p><p>To create the resource, use the <code class="literal">realize</code> function:</p><div class="informalexample"><pre class="programlisting">realize(Package['httpd'])</pre></div><p>You can call <code class="literal">realize</code> as many times as you want on the resource and it won't result in a conflict. So virtual resources are the way to go when several different classes all require the same resource, and they may need to coexist on the same node.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec193"/>How to do it...</h2></div></div></div><p>Here's how to build the example using virtual resources:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create the virtual module with the following contents:<div class="informalexample"><pre class="programlisting">class virtual {
  @package {'httpd': ensure =&gt; installed }
  @service {'httpd': 
    ensure  =&gt; running,
    enable  =&gt; true,
    require =&gt; Package['httpd']
  }
}</pre></div></li><li class="listitem">Create the Drupal module with the following contents:<div class="informalexample"><pre class="programlisting">class drupal {
  include virtual
  realize(Package['httpd'])
  realize(Service['httpd'])
}
</pre></div></li><li class="listitem">Create the WordPress module with the following contents:<div class="informalexample"><pre class="programlisting">class wordpress {
  include virtual
  realize(Package['httpd'])
  realize(Service['httpd'])
}</pre></div></li><li class="listitem">Modify your <code class="literal">site.pp</code> file as follows:<div class="informalexample"><pre class="programlisting">node 'bigbox' {
  include drupal
  include wordpress
}</pre></div></li><li class="listitem">Run <a id="id380" class="indexterm"/>Puppet:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>bigbox# puppet agent -t</strong></span>
<span class="strong"><strong>Info: Caching catalog for bigbox.example.com</strong></span>
<span class="strong"><strong>Info: Applying configuration version '1413179615'</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Virtual/Package[httpd]/ensure: created</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Virtual/Service[httpd]/ensure: ensure changed 'stopped' to 'running'</strong></span>
<span class="strong"><strong>Info: /Stage[main]/Virtual/Service[httpd]: Unscheduling refresh on Service[httpd]</strong></span>
<span class="strong"><strong>Notice: Finished catalog run in 6.67 seconds</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec194"/>How it works...</h2></div></div></div><p>You define the package and service as virtual resources in one place: the <code class="literal">virtual</code> class. All nodes can include this class and you can put all your virtual services and packages in it. None of the packages will actually be installed on a node or services started until you call <code class="literal">realize</code>:</p><div class="informalexample"><pre class="programlisting">class virtual {
  @package { 'httpd': ensure =&gt; installed }
}</pre></div><p>Every class that needs the Apache package can call <code class="literal">realize</code> on this virtual resource:</p><div class="informalexample"><pre class="programlisting">class drupal {
  include virtual
  realize(Package['httpd'])
}</pre></div><p>Puppet knows, because you <a id="id381" class="indexterm"/>made the resource virtual, that you intended to have multiple references to the same package, and didn't just accidentally create two resources with the same name. So it does the right thing.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec195"/>There's more...</h2></div></div></div><p>To realize <a id="id382" class="indexterm"/>virtual resources, you can also use the collection <span class="emphasis"><em>spaceship</em></span> syntax:</p><div class="informalexample"><pre class="programlisting">Package &lt;| title = 'httpd' |&gt;</pre></div><p>The advantage of this syntax is that you're not restricted to the resource name; you could also use a tag, for example:</p><div class="informalexample"><pre class="programlisting">Package &lt;| tag = 'web' |&gt;</pre></div><p>Alternatively, you can just specify all instances of the resource type, by leaving the query section blank:</p><div class="informalexample"><pre class="programlisting">Package &lt;| |&gt;</pre></div></div></div>
<div class="section" title="Managing users with virtual resources"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec71"/>Managing users with virtual resources</h1></div></div></div><p>Users are a great <a id="id383" class="indexterm"/>example of a resource that may need to be<a id="id384" class="indexterm"/> realized by multiple classes. Consider the following situation. To simplify administration of a large number of machines, you defined classes for two kinds of users: <code class="literal">developers</code> and <code class="literal">sysadmins</code>. All machines need to include <code class="literal">sysadmins</code>, but only some machines need <code class="literal">developers</code>:</p><div class="informalexample"><pre class="programlisting">node 'server' { 
  include user::sysadmins 
}

node 'webserver' {
  include user::sysadmins 
  include user::developers 
}</pre></div><p>However, some users may be members of both groups. If each group simply declares its members as regular <code class="literal">user</code> resources, this will lead to a conflict when a node includes both <code class="literal">developers</code> and <code class="literal">sysadmins</code>, as in the <code class="literal">webserver</code> example.</p><p>To avoid this conflict, a common pattern is to make all users virtual resources, defined in a single class <code class="literal">user::virtual</code> that every machine includes, and then realizing the users where they are needed. This way, there will be no conflict if a user is a member of multiple groups.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec196"/>How to do it...</h2></div></div></div><p>Follow these steps<a id="id385" class="indexterm"/> to <a id="id386" class="indexterm"/>create a<a id="id387" class="indexterm"/> <code class="literal">user::virtual</code> class:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create the file <code class="literal">modules/user/manifests/virtual.pp</code> with the following contents:<div class="informalexample"><pre class="programlisting">class user::virtual {
  @user { 'thomas':  ensure =&gt; present }
  @user { 'theresa': ensure =&gt; present }
  @user { 'josko':   ensure =&gt; present }
  @user { 'nate':    ensure =&gt; present }
}</pre></div></li><li class="listitem">Create the file <code class="literal">modules/user/manifests/developers.pp</code> with the following contents:<div class="informalexample"><pre class="programlisting">class user::developers {
  realize(User['theresa'])
  realize(User['nate'])
}</pre></div></li><li class="listitem">Create the file <code class="literal">modules/user/manifests/sysadmins.pp</code> with the following contents:<div class="informalexample"><pre class="programlisting">class user::sysadmins {
  realize(User['thomas'])
  realize(User['theresa'])
  realize(User['josko'])
}</pre></div></li><li class="listitem">Modify your <code class="literal">nodes.pp</code> file as follows:<div class="informalexample"><pre class="programlisting">node 'cookbook' {
  include user::virtual
  include user::sysadmins
  include user::developers
}</pre></div></li><li class="listitem">Run Puppet:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cookbook# puppet agent -t</strong></span>
<span class="strong"><strong>Info: Caching catalog for cookbook.example.com</strong></span>
<span class="strong"><strong>Info: Applying configuration version '1413180590'</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/User::Virtual/User[theresa]/ensure: created</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/User::Virtual/User[nate]/ensure: created</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/User::Virtual/User[thomas]/ensure: created</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/User::Virtual/User[josko]/ensure: created</strong></span>
<span class="strong"><strong>Notice: Finished catalog run in 0.47 seconds</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec197"/>How it works...</h2></div></div></div><p>When we include<a id="id388" class="indexterm"/> the <code class="literal">user::virtual</code> class, all the users are<a id="id389" class="indexterm"/> declared as virtual resources (because we included the <code class="literal">@</code> symbol):</p><div class="informalexample"><pre class="programlisting">  @user { 'thomas':  ensure =&gt; present }
  @user { 'theresa': ensure =&gt; present }
  @user { 'josko':   ensure =&gt; present }
  @user { 'nate':    ensure =&gt; present }</pre></div><p>That is to say, the<a id="id390" class="indexterm"/> resources exist in Puppet's catalog; they can be referred to by and linked with other resources, and they are in every respect identical to regular resources, except that Puppet doesn't actually create the corresponding users on the machine.</p><p>In order for that to happen, we need to call <code class="literal">realize</code> on the virtual resources. When we include the <code class="literal">user::sysadmins</code> class, we get the following code:</p><div class="informalexample"><pre class="programlisting">  realize(User['thomas'])
  realize(User['theresa'])
  realize(User['josko'])</pre></div><p>Calling <code class="literal">realize</code> on a virtual resource tells Puppet, "I'd like to use that resource now". This is what it does, as we can see from the run output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Notice: /Stage[main]/User::Virtual/User[theresa]/ensure: created</strong></span>
</pre></div><p>However, Theresa is in both the <code class="literal">developers</code> and <code class="literal">sysadmins</code> classes! Won't that mean we end up calling <code class="literal">realize</code> twice on the same resource?</p><div class="informalexample"><pre class="programlisting">realize(User['theresa'])
...
realize(User['theresa'])</pre></div><p>Yes, it does, and<a id="id391" class="indexterm"/> that's fine. You're explicitly allowed to<a id="id392" class="indexterm"/> realize resources multiple times, and there will be no conflict. So long as some class, somewhere, calls <code class="literal">realize</code> on Theresa's account, it will be created. Unrealized resources are simply discarded during catalog compilation.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec198"/>There's more...</h2></div></div></div><p>When you use this <a id="id393" class="indexterm"/>pattern to manage your own users, every node should include the <code class="literal">user::virtual</code> class, as a part of your basic housekeeping configuration. This class will declare all users (as virtual) in your organization or site. This should also include any users who exist only to run applications or services (such as <code class="literal">Apache</code>, <code class="literal">www-data</code>, or <code class="literal">deploy</code>, for example). Then, you can realize them as needed on individual nodes or in specific classes.</p><p>For production use, you'll probably also want to specify a UID and GID for each user or group, so that these numeric identifiers are synchronized across your network. You can do this using the <code class="literal">uid</code> and <code class="literal">gid</code> parameters for the <code class="literal">user</code> resource.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>If you don't specify a user's UID, for example, you'll just get whatever is the next ID number available on a given machine, so the same user on different machines will have a different UID. This can lead to permission problems when using shared storage, or moving files between machines.</p></div></div><p>A common pattern when defining users as virtual resources is to assign tags to the users based on their assigned roles within your organization. You can then use the <code class="literal">collector</code> syntax instead of <code class="literal">realize</code> to collect users with specific tags applied.</p><p>For example, see the following code snippet:</p><div class="informalexample"><pre class="programlisting">@user { 'thomas':  ensure =&gt; present, tag =&gt; 'sysadmin' }
@user { 'theresa': ensure =&gt; present, tag =&gt; 'sysadmin' }
@user { 'josko':   ensure =&gt; present, tag =&gt; 'dev' }
User &lt;| tag == 'sysadmin' |&gt;</pre></div><p>In the previous example, only users <code class="literal">thomas</code> and <code class="literal">theresa</code> would be included.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec199"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Using virtual resources</em></span> recipe in this chapter</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Managing users' customization files</em></span> recipe in this chapter</li></ul></div></div></div>
<div class="section" title="Managing users' SSH access"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec72"/>Managing users' SSH access</h1></div></div></div><p>A sensible approach to access <a id="id394" class="indexterm"/>control for servers is to use named user accounts with passphrase-protected SSH keys, rather than having users share an account with a widely known password. Puppet makes this easy to manage thanks to the built-in <code class="literal">ssh_authorized_key</code> type.</p><p>To combine this with virtual users, as described in the previous section, you can create a <code class="literal">define</code>, which includes both the <code class="literal">user</code> and <code class="literal">ssh_authorized_key</code> resources. This will also come in handy when adding customization files and other resources to each user.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec200"/>How to do it...</h2></div></div></div><p>Follow these steps to extend your virtual users' class to include SSH access:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new module <code class="literal">ssh_user</code> to contain our <code class="literal">ssh_user</code> definition. Create the <code class="literal">modules/ssh_user/manifests/init.pp</code> file as follows:<div class="informalexample"><pre class="programlisting">define ssh_user($key,$keytype) {
  user { $name:
    ensure     =&gt; present,
  }

  file { "/home/${name}":
    ensure =&gt; directory,
    mode   =&gt; '0700',
    owner  =&gt; $name,
    require =&gt; User["$name"]
  }
  file { "/home/${name}/.ssh":
    ensure =&gt; directory,
    mode   =&gt; '0700',
    owner  =&gt; "$name",
    require =&gt; File["/home/${name}"],
  }

  ssh_authorized_key { "${name}_key":
    key     =&gt; $key,
    type    =&gt; "$keytype",
    user    =&gt; $name,
    require =&gt; File["/home/${name}/.ssh"],
  }
}</pre></div></li><li class="listitem">Modify your <code class="literal">modules/user/manifests/virtual.pp</code> file, comment out the previous definition for user <code class="literal">thomas</code>, and replace it with the following:<div class="informalexample"><pre class="programlisting">@ssh_user { 'thomas':
  key     =&gt; 'AAAAB3NzaC1yc2E...XaWM5sX0z',
  keytype =&gt; 'ssh-rsa'
}</pre></div></li><li class="listitem">Modify <a id="id395" class="indexterm"/>your <code class="literal">modules/user/manifests/sysadmins.pp</code> file as follows:<div class="informalexample"><pre class="programlisting">class user::sysadmins {
    realize(Ssh_user['thomas'])
}</pre></div></li><li class="listitem">Modify your <code class="literal">site.pp</code> file as follows:<div class="informalexample"><pre class="programlisting">node 'cookbook' {
  include user::virtual
  include user::sysadmins
}</pre></div></li><li class="listitem">Run Puppet:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cookbook# puppet agent -t</strong></span>
<span class="strong"><strong>Info: Caching catalog for cookbook.example.com</strong></span>
<span class="strong"><strong>Info: Applying configuration version '1413254461'</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/User::Virtual/Ssh_user[thomas]/File[/home/thomas/.ssh]/ensure: created</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/User::Virtual/Ssh_user[thomas]/Ssh_authorized_key[thomas_key]/ensure: created</strong></span>
<span class="strong"><strong>Notice: Finished catalog run in 0.11 seconds</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec201"/>How it works...</h2></div></div></div><p>For each user in our <code class="literal">user::virtual</code> class, we need to create:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The user account itself</li><li class="listitem" style="list-style-type: disc">The user's home directory and <code class="literal">.ssh</code> directory</li><li class="listitem" style="list-style-type: disc">The user's <code class="literal">.ssh/authorized_keys</code> file</li></ul></div><p>We could declare separate resources to implement all of these for each user, but it's much easier to create a definition instead, which wraps them into a single resource. By creating a new module for our definition, we can refer to <code class="literal">ssh_user</code> from anywhere (in any scope):</p><div class="informalexample"><pre class="programlisting">define ssh_user ($key, $keytype) { 
  user { $name:
    ensure     =&gt; present,
  }</pre></div><p>After we create the user, we can then create the home directory; we need the user first so that when we assign ownership, we can use the username, <code class="literal">owner =&gt; $name</code>:</p><div class="informalexample"><pre class="programlisting">  file { "/home/${name}":
    ensure =&gt; directory,
    mode =&gt; '0700',
    owner =&gt; $name,
    require =&gt; User["$name"]
  }</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p>Puppet can create the users' home directory using the <code class="literal">managehome</code> attribute to the user resource. Relying on this mechanism is problematic in practice, as it does not account for users that were created outside of Puppet without home directories.</p></div></div><p>Next, we need <a id="id396" class="indexterm"/>to ensure that the <code class="literal">.ssh</code> directory exists within the home directory of the user. We require the home directory, <code class="literal">File["/home/${name}"]</code>, since that needs to exist before we create this subdirectory. This implies that the user already exists because the home directory required the user:</p><div class="informalexample"><pre class="programlisting">  file { "/home/${name}/.ssh":
    ensure =&gt; directory,
    mode   =&gt; '0700',
    owner  =&gt; $name ,
    require =&gt; File["/home/${name}"],
  }</pre></div><p>Finally, we create the <code class="literal">ssh_authorized_key</code> resource, again requiring the containing folder (<code class="literal">File["/home/${name}/.ssh"]</code>). We use the <code class="literal">$key</code> and <code class="literal">$keytype</code> variables to assign the key and type parameters to the <code class="literal">ssh_authorized_key</code> type as follows:</p><div class="informalexample"><pre class="programlisting">  ssh_authorized_key { "${name}_key":
    key     =&gt; $key,
    type    =&gt; "$keytype",
    user    =&gt; $name,
    require =&gt; File["/home/${name}/.ssh"],
  }
}</pre></div><p>We passed the <code class="literal">$key</code> and <code class="literal">$keytype</code> variables when we defined the <code class="literal">ssh_user</code> resource for <code class="literal">thomas</code>:</p><div class="informalexample"><pre class="programlisting">@ssh_user { 'thomas':
  key =&gt; 'AAAAB3NzaC1yc2E...XaWM5sX0z',
  keytype =&gt; 'ssh-rsa'
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip13"/>Tip</h3><p>The value for <code class="literal">key</code>, in the preceding code snippet, is the ssh key's public key value; it is usually stored in an <code class="literal">id_rsa.pub</code> file.</p></div></div><p>Now, with<a id="id397" class="indexterm"/> everything defined, we just need to call <code class="literal">realize</code> on <code class="literal">thomas</code> for all these resources to take effect:</p><div class="informalexample"><pre class="programlisting">realize(Ssh_user['thomas'])</pre></div><p>Notice that this time the virtual resource we're realizing is not simply the <code class="literal">user</code> resource, as before, but the <code class="literal">ssh_user</code> defined type we created, which includes the user and the related resources needed to set up the SSH access:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Notice: /Stage[main]/User::Virtual/Ssh_user[thomas]/User[thomas]/ensure: created</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/User::Virtual/Ssh_user[thomas]/File[/home/thomas]/ensure: created</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/User::Virtual/Ssh_user[thomas]/File[/home/thomas/.ssh]/ensure: created</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/User::Virtual/Ssh_user[thomas]/Ssh_authorized_key[thomas_key]/ensure: created</strong></span>
</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec202"/>There's more...</h2></div></div></div><p>Of course, you can add whatever resources you like to the <code class="literal">ssh_user</code> definition to have Puppet automatically create them for new users. We'll see an example of this in the next recipe, <span class="emphasis"><em>Managing users' customization files</em></span>.</p></div></div>
<div class="section" title="Managing users' customization files"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec73"/>Managing users' customization files</h1></div></div></div><p>Users tend to customize <a id="id398" class="indexterm"/>their shell environments, terminal colors, aliases, and so forth. This is usually achieved by a number of <span class="strong"><strong>dotfiles</strong></span><a id="id399" class="indexterm"/> in their home directory, for example, <code class="literal">.bash_profile</code> or <code class="literal">.vimrc</code>.</p><p>You can use Puppet to synchronize and update each user's dotfiles across a number of machines by extending the virtual user setup we developed throughout this chapter. We'll start a new module, <code class="literal">admin_user</code> and use the file types, <code class="literal">recurse</code> attribute to copy files into each user's home directory.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec203"/>How to do it...</h2></div></div></div><p>Here's what you <a id="id400" class="indexterm"/>need to do:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create the <code class="literal">admin_user</code> defined type (<code class="literal">define admin_user</code>) in the <code class="literal">modules/admin_user/manifests/init.pp</code> file as follows:<div class="informalexample"><pre class="programlisting">define admin_user ($key, $keytype, $dotfiles = false) { 
  $username = $name
  user { $username:
    ensure     =&gt; present,
  }
  file { "/home/${username}/.ssh":
    ensure  =&gt; directory,
    mode    =&gt; '0700',
    owner   =&gt; $username,
    group   =&gt; $username,
    require =&gt; File["/home/${username}"],
  }
  ssh_authorized_key { "${username}_key":
    key     =&gt; $key,
    type    =&gt; "$keytype",
    user    =&gt; $username,
    require =&gt; File["/home/${username}/.ssh"],
  }
  # dotfiles
  if $dotfiles == false {
    # just create the directory
    file { "/home/${username}":
      ensure  =&gt; 'directory',
      mode    =&gt; '0700',
      owner   =&gt; $username,
      group   =&gt; $username,
      require =&gt; User["$username"]
    }
  } else {
    # copy in all the files in the subdirectory
    file { "/home/${username}":
      recurse =&gt; true,
      mode    =&gt; '0700',
      owner   =&gt; $username,
      group   =&gt; $username,
      source  =&gt; "puppet:///modules/admin_user/${username}",
      require =&gt; User["$username"]
    }
  }
}</pre></div></li><li class="listitem">Modify the file <code class="literal">modules/user/manifests/sysadmins.pp</code> as follows:<div class="informalexample"><pre class="programlisting">class user::sysadmins {
  realize(Admin_user['thomas'])
}</pre></div></li><li class="listitem">Alter the definition of <code class="literal">thomas</code> in <code class="literal">modules/user/manifests/virtual.pp</code> as follows:<div class="informalexample"><pre class="programlisting">@ssh_user { 'thomas':
  key =&gt; 'AAAAB3NzaC1yc2E...XaWM5sX0z',
  keytype =&gt; 'ssh-rsa',
  dotfiles =&gt; true
}</pre></div></li><li class="listitem">Create a<a id="id401" class="indexterm"/> subdirectory in the <code class="literal">admin_user</code> module for the file of user <code class="literal">thomas</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mkdir -p modules/admin_user/files/thomas</strong></span>
</pre></div></li><li class="listitem">Create dotfiles for the user <code class="literal">thomas</code> in the directory you just created:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ echo "alias vi=vim" &gt; modules/admin_user/files/thomas/.bashrc</strong></span>
<span class="strong"><strong>$ echo "set tabstop=2" &gt; modules/admin_user/files/thomas/.vimrc</strong></span>
</pre></div></li><li class="listitem">Make sure your <code class="literal">site.pp</code> file reads as follows:<div class="informalexample"><pre class="programlisting">node 'cookbook' {
  include user::virtual
  include user::sysadmins
}</pre></div></li><li class="listitem">Run Puppet:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cookbook# puppet agent -t</strong></span>
<span class="strong"><strong>Info: Caching catalog for cookbook.example.com</strong></span>
<span class="strong"><strong>Info: Applying configuration version '1413266235'</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/User::Virtual/Admin_user[thomas]/User[thomas]/ensure: created</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/User::Virtual/Admin_user[thomas]/File[/home/thomas]/ensure: created</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/User::Virtual/Admin_user[thomas]/File[/home/thomas/.vimrc]/ensure: defined content as '{md5}cb2af2d35b18b5ac2539057bd429d3ae'</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/User::Virtual/Admin_user[thomas]/File[/home/thomas/.bashrc]/ensure: defined content as '{md5}033c3484e4b276e0641becc3aa268a3a'</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/User::Virtual/Admin_user[thomas]/File[/home/thomas/.ssh]/ensure: created</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/User::Virtual/Admin_user[thomas]/Ssh_authorized_key[thomas_key]/ensure: created</strong></span>
<span class="strong"><strong>Notice: Finished catalog run in 0.36 seconds</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec204"/>How it works...</h2></div></div></div><p>We created a<a id="id402" class="indexterm"/> new <code class="literal">admin_user</code> definition, which defines the home directory recursively if <code class="literal">$dotfiles</code> is not <code class="literal">false</code> (the default value):</p><div class="informalexample"><pre class="programlisting">  if $dotfiles == 'false' {
    # just create the directory
    file { "/home/${username}":
      ensure  =&gt; 'directory',
      mode    =&gt; '0700',
      owner   =&gt; $username,
      group   =&gt; $username,
      require =&gt; User["$username"]
    }
  } else {
    # copy in all the files in the subdirectory
    file { "/home/${username}":
      recurse =&gt; true,
      mode    =&gt; '0700',
      owner   =&gt; $username,
      group   =&gt; $username,
      source  =&gt; "puppet:///modules/admin_user/${username}",
      require =&gt; User["$username"]
    }
  }</pre></div><p>We created a directory to hold the user's dotfiles within the <code class="literal">admin_user</code> module; all the files within that directory will be copied into the user's home directory, as shown in the puppet run output in the following command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Notice: /Stage[main]/User::Virtual/Admin_user[thomas]/File[/home/thomas/.vimrc]/ensure: defined content as '{md5}cb2af2d35b18b5ac2539057bd429d3ae'</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/User::Virtual/Admin_user[thomas]/File[/home/thomas/.bashrc]/ensure: defined content as '{md5}033c3484e4b276e0641becc3aa268a3a'</strong></span>
</pre></div><p>Using the <code class="literal">recurse</code> option<a id="id403" class="indexterm"/> allows us to add as many dotfiles as we wish for each user without having to modify the definition of the user.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec205"/>There's more...</h2></div></div></div><p>We could specify that the <code class="literal">source</code> attribute of the home directory is a directory where users can place their own dotfiles. This way, each user could modify their own dotfiles and have them transferred to all the nodes in the network without our involvement.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec206"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Managing users with virtual resources</em></span> recipe in this chapter</li></ul></div></div></div>
<div class="section" title="Using exported resources"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec74"/>Using exported resources</h1></div></div></div><p>All our recipes up to this point have dealt with a single machine. It is possible with Puppet to have resources from one node affect another node. This interaction is managed with<a id="id404" class="indexterm"/> <span class="strong"><strong>exported resources</strong></span>. Exported resources are just like any resource you might define for a node but instead of applying to the node on which they were created, they are exported for use by all nodes in the environment. Exported resources can be thought of as virtual resources that go one step further and exist beyond the node on which they were defined.</p><p>There are two actions with exported resources. When an exported resource is created, it is said to be defined. When all the exported resources are harvested, they are said to be collected. Defining exported resources is similar to virtual resources; the resource in question has two <code class="literal">@</code> symbols prepended. For example, to define a file resource as external, use <code class="literal">@@file</code>. Collecting resources is done with the space ship operator, <code class="literal">&lt;&lt;| |&gt;&gt;</code>; this is thought to look like a spaceship. To collect the exported file resource (<code class="literal">@@file</code>), you would use <code class="literal">File &lt;&lt;| |&gt;&gt;</code>.</p><p>There are many examples that use exported resources; the most common one involves SSH host keys. Using exported resources, it is possible to have every machine that is running Puppet share their SSH host keys with the other connected nodes. The idea here is that each machine exports its own host key and then collects all the keys from the other machines. In our example, we will create two classes; first, a class that exports the SSH host key from every node. We will include this class in our base class. The second class will be a collector class, which collects the SSH host keys. We will apply this class to our Jumpboxes<a id="id405" class="indexterm"/> or SSH login servers.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>Jumpboxes are machines that have special firewall rules to allow them to log in to different locations.</p></div></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec207"/>Getting ready</h2></div></div></div><p>To use exported<a id="id406" class="indexterm"/> resources, you will need to enable storeconfigs on your Puppet masters. It is possible to use exported resources with a masterless (decentralized) deployment; however, we will assume you are using a centralized model for this example. In <a class="link" href="ch02.html" title="Chapter 2. Puppet Infrastructure">Chapter 2</a>, <span class="emphasis"><em>Puppet Infrastructure</em></span>, we configured puppetdb using the puppetdb module from the forge. It is possible to use other backends if you desire; however, all of these except puppetdb are deprecated. More information is available at the following <a id="id407" class="indexterm"/>link: <a class="ulink" href="http://projects.puppetlabs.com/projects/puppet/wiki/Using_Stored_Configuration">http://projects.puppetlabs.com/projects/puppet/wiki/Using_Stored_Configuration</a>.</p><p>Ensure your Puppet masters are configured to use puppetdb as a storeconfigs container.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec208"/>How to do it...</h2></div></div></div><p>We'll create an <code class="literal">ssh_host</code> class to export the <code class="literal">ssh</code> keys of a host and ensure that it is included in our base class.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create the first class, <code class="literal">base::ssh_host</code>, which we will include in our base class:<div class="informalexample"><pre class="programlisting">class base::ssh_host {
  @@sshkey{"$::fqdn":
    ensure       =&gt; 'present',
    host_aliases =&gt; ["$::hostname","$::ipaddress"],
    key          =&gt; $::sshdsakey,
    type         =&gt; 'dsa',
  }
}</pre></div></li><li class="listitem">Remember to include this class from inside the base class definition:<div class="informalexample"><pre class="programlisting">class base {
  ...
  include ssh_host
}</pre></div></li><li class="listitem">Create a definition for <code class="literal">jumpbox</code>, either in a class or within the node definition for <code class="literal">jumpbox</code>:<div class="informalexample"><pre class="programlisting">node 'jumpbox' {
  Sshkey &lt;&lt;| |&gt;&gt;
}</pre></div></li><li class="listitem">Now run Puppet on a few nodes to create the exported resources. In my case, I ran Puppet on my Puppet server and my second example node (<code class="literal">node2</code>). Finally, run Puppet on <code class="literal">jumpbox</code> to verify that the SSH host keys for our other nodes are collected:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[root@jumpbox ~]# puppet agent -t </strong></span>
<span class="strong"><strong>Info: Caching catalog for jumpbox.example.com</strong></span>
<span class="strong"><strong>Info: Applying configuration version '1413176635'</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[jumpbox]/Sshkey[node2.example.com]/ensure: created</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[jumpbox]/Sshkey[puppet]/ensure: created</strong></span>
<span class="strong"><strong>Notice: Finished catalog run in 0.08 seconds</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec209"/>How it works...</h2></div></div></div><p>We created an <code class="literal">sshkey</code> resource for <a id="id408" class="indexterm"/>the node using the facter facts <code class="literal">fqdn</code>, <code class="literal">hostname</code>, <code class="literal">ipaddress</code>, and <code class="literal">sshdsakey</code>. We use the <code class="literal">fqdn</code> as the title for our exported resource because each exported resource must have a unique name. We can assume the <code class="literal">fqdn</code> of a node will be unique within our organization (although sometimes they may not be; Puppet can be good at finding out such things when you least expect it). We then go on to define aliases by which our node may be known. We use the hostname variable for one alias and the main IP address of the machine as the other. If you had other naming conventions for your nodes, you could include other aliases here. We assume that hosts are using DSA keys, so we use the <code class="literal">sshdsakey</code> variable in our definition. In a large installation, you would wrap this definition in tests to ensure the DSA keys existed. You would also use the RSA keys if they existed as well.</p><p>With the <code class="literal">sshkey</code> resource defined and exported, we then created a <code class="literal">jumpbox</code> node definition. In this definition, we used the spaceship syntax <code class="literal">Sshkey &lt;&lt;| |&gt;&gt;</code> to collect all defined exported <code class="literal">sshkey</code> resources.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec210"/>There's more...</h2></div></div></div><p>When defining the exported resources, you can add tag attributes to the resource to create subsets of exported resources. For example, if you had a development and production area of your network, you could create different groups of <code class="literal">sshkey</code> resources for each area as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">@@sshkey{"$::fqdn":
    host_aliases =&gt; ["$::hostname","$::ipaddress"],
    key          =&gt; $::sshdsakey,
    type         =&gt; 'dsa',
    tag          =&gt; "$::environment",
  }</pre></div><p>You could then modify <code class="literal">jumpbox</code> to only collect resources for production, for example, as follows:</p><div class="informalexample"><pre class="programlisting">Sshkey &lt;&lt;| tag == 'production' |&gt;&gt;</pre></div><p>Two important things to remember when working with exported resources: first, every resource must have a unique name across your installation. Using the <code class="literal">fqdn</code> domain name within the title is usually enough to keep your definitions unique. Second, any resource can be made virtual. Even defined types that you created may be exported. Exported resources can be used to <a id="id409" class="indexterm"/>achieve some fairly complex configurations that automatically adjust when machines change.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>One word of caution when working with an extremely large number of nodes (more than 5,000) is that exported resources can take a long time to collect and apply, particularly if each exported resource creates a file.</p></div></div></div></div></body></html>