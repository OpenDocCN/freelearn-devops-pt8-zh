<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Getting started with Puppet"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Getting started with Puppet</h1></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><span class="emphasis"><em>For a list of all the ways technology has failed to improve the quality of life, please press three.</em></span></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<span class="attribution"><span class="emphasis"><em>Alice Kahn</em></span></span></td></tr></table></div><p>In this chapter, you'll learn about some of the challenges of managing configuration on servers, some common solutions to these problems, and how automation tools such as Puppet can help. You'll also learn how to download the GitHub repository containing all of the source code and examples in this book, how to set up your own Vagrant virtual machine to <a id="id0" class="indexterm"/>run the code, and how to download and install Puppet.</p><p>Whether you're a system administrator, a developer who needs to wrangle servers from time to time, or just someone who's annoyed at how long it takes to deploy a new app, you'll have come across the kind of problems Puppet is designed to solve.</p><div class="mediaobject"><img src="graphics/B08880_01_01.jpg" alt="Getting started with Puppet"/></div><div class="section" title="Why do we need Puppet anyway?"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Why do we need Puppet anyway?</h1></div></div></div><p>Managing applications and services in production is hard work, and there are a lot of steps involved. To <a id="id1" class="indexterm"/>start with, you need some servers to serve the services. Luckily, these are readily available from your local cloud provider, at low, low prices. So you've got a server, with a base operating system installed on it, and you can log into it. So now what? Before you can deploy, you need to do a number of things:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Add user accounts and passwords</li><li class="listitem" style="list-style-type: disc">Configure security settings and privileges</li><li class="listitem" style="list-style-type: disc">Install all the packages needed to run the app</li><li class="listitem" style="list-style-type: disc">Customize the configuration files for each of these packages</li><li class="listitem" style="list-style-type: disc">Create databases and database user accounts; load some initial data</li><li class="listitem" style="list-style-type: disc">Configure the services that should be running</li><li class="listitem" style="list-style-type: disc">Deploy the app code and static assets</li><li class="listitem" style="list-style-type: disc">Restart any affected services</li><li class="listitem" style="list-style-type: disc">Configure the machine for monitoring</li></ul></div><p>That's a lot to do—and for the next server you build, you'll need to do the exact same things all over again. There's something not right about that. Shouldn't there be an easier solution to this problem?</p><p>
<span class="strong"><strong>Wouldn't it be nice if you could write an executable specification of how the server should be set up, and you could apply it to as many machines as you liked?</strong></span>
</p><div class="section" title="Keeping the configuration synchronized"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec06"/>Keeping the configuration synchronized</h2></div></div></div><p>Setting up <a id="id2" class="indexterm"/>servers manually is tedious. Even if you're the kind of person who enjoys tedium, though, there's another problem to consider. What happens the next time you set up a server, a few weeks or months later?</p><p>Your careful notes will no longer be up to date with reality. While you were on vacation, the developers installed a couple of new libraries that the app now depends on—I guess they forgot to tell you! They are under a lot of schedule pressure, of course. You could send out a sternly worded email demanding that people update the build document whenever they change something, and people might even comply with that. But even if they do update the documentation, no-one actually tests the new build process from scratch, so when you come to do it, you'll find it doesn't work anymore. Turns out that if you just upgrade the database in place, it's fine, but if you install the new version on a bare server, it's not.</p><p>Also, since the build document was updated, a new version of a critical library was released upstream. Because you always install the latest version as part of the build, your new server is now subtly different to the old one. This will lead to subtle problems which will take you three days, or three bottles of whiskey, to debug.</p><p>By the time you have four or five servers, they're all a little different. Which is the authoritative one? Or are they all slightly wrong? The longer they're around, the more they will drift apart. You wouldn't run four or five different versions of your app code at once, so what's up with that? Why is it acceptable for server configuration to be in a mess like this?</p><p>
<span class="strong"><strong>Wouldn't it be nice </strong></span>
<a id="id3" class="indexterm"/>
<span class="strong"><strong>if the state of configuration on all your machines could be regularly checked and synchronized with a central, standard version?</strong></span>
</p></div><div class="section" title="Repeating changes across many servers"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Repeating changes across many servers</h2></div></div></div><p>Humans just aren't <a id="id4" class="indexterm"/>good at accurately repeating complex tasks over and over; that's why we invented robots. It's easy to make mistakes, miss things out, or be interrupted and lose track of what you've done.</p><p>Changes happen all the time, and it becomes increasingly difficult to keep things up to date and in sync as your infrastructure grows. Again, when you make a change to your app code, you don't go and make that change manually with a text editor on each server. You change it once and roll it out everywhere. Isn't your firewall setup just as much part of your code as your user model?</p><p>
<span class="strong"><strong>Wouldn't it be nice if you only had to make changes in one place, and they rolled out to your whole network automatically?</strong></span>
</p></div><div class="section" title="Self-updating documentation"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Self-updating documentation</h2></div></div></div><p>In real life, we're <a id="id5" class="indexterm"/>too busy to stop every five minutes and document what we just did. As we've seen, that documentation is of limited use anyway, even if it's kept fanatically up-to-date.</p><p>The only reliable documentation, in fact, is the state of the servers themselves. You can look at a server to see how it's configured, but that only applies while you still have the machine. If something goes wrong and you can't access the machine, or the data on it, your only option is to reconstruct the lost configuration from scratch.</p><p>
<span class="strong"><strong>Wouldn't it be nice if you had a clear, human-readable build procedure which was independent of your servers, and was guaranteed to be up to date, because the servers are actually built from it?</strong></span>
</p></div><div class="section" title="Version control and history"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Version control and history</h2></div></div></div><p>When you're <a id="id6" class="indexterm"/>making manual, ad hoc changes to systems, you can't roll them back to a point in time. It's hard to undo a whole series of changes; you don't have a way of keeping track of what you did and how things changed.</p><p>This is bad enough when there's just one of you. When you're working in a team, it gets even worse, with everybody making independent changes and getting in each other's way.</p><p>When you have a problem, you need a way to know what changed and when, and who did it. And you also need to be able to set your configuration back to any previously stable state.</p><p>
<span class="strong"><strong>Wouldn't it be nice if you could go back in time?</strong></span>
</p></div><div class="section" title="Why not just write shell scripts?"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Why not just write shell scripts?</h2></div></div></div><p>Many people <a id="id7" class="indexterm"/>manage configuration with shell scripts, which is better than doing it manually, but not much. Some of the problems with shell scripts include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Fragile and non-portable</li><li class="listitem" style="list-style-type: disc">Hard to maintain</li><li class="listitem" style="list-style-type: disc">Not easy to read as documentation</li><li class="listitem" style="list-style-type: disc">Very site-specific</li><li class="listitem" style="list-style-type: disc">Not a good programming language</li><li class="listitem" style="list-style-type: disc">Hard to apply changes to existing servers</li></ul></div></div><div class="section" title="Why not just use containers?"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Why not just use containers?</h2></div></div></div><p>Containers! Is there <a id="id8" class="indexterm"/>any word more thrilling to the human soul? Many people feel as though containers are going to make configuration management problems just go away. This feeling rarely lasts beyond the first few hours of trying to containerize an app. Yes, containers make it easy to deploy and manage software, but where do containers come from? It turns out someone has to build and maintain them, and that means managing Dockerfiles, volumes, networks, clusters, image repositories, dependencies, and so on. In other words, configuration. There is an axiom of computer science which I just invented, called <span class="emphasis"><em>The Law of Conservation of Pain</em></span>. If you save yourself pain in one place, it pops up again in another. Whatever cool new technology comes along, it won't solve all our problems; at best, it will replace them with refreshingly different problems.</p><p>Yes, containers are <a id="id9" class="indexterm"/>great, but the truth is, container-based systems require even more configuration management. You need to configure the nodes that run the containers, build and update the container images based on a central policy, create and maintain the container network and clusters, and so on.</p></div><div class="section" title="Why not just use serverless?"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Why not just use serverless?</h2></div></div></div><p>If containers are <a id="id10" class="indexterm"/>powered by magic pixies, serverless architectures are pure fairy dust. The promise is that you just push your app to the cloud, and the cloud takes care of deploying, scaling, load balancing, monitoring, and so forth. Like most things, the reality doesn't quite live up to the marketing. Unfortunately, serverless isn't actually serverless: it just means your business is running on servers you don't have direct control over, plus, you have higher fixed costs because you're paying someone else to run them for you. Serverless can be a good way to get started, but it's not a long-term solution, because ultimately, you need to own your own configuration.</p></div></div></div>
<div class="section" title="Configuration management tools"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Configuration management tools</h1></div></div></div><p>
<span class="strong"><strong>Configuration </strong></span>
<a id="id11" class="indexterm"/>
<span class="strong"><strong>management</strong></span> (<span class="strong"><strong>CM</strong></span>) tools are the modern, sensible way to manage infrastructure as code. There are many such tools available, all of which operate more or less the same way: you specify your desired configuration state, using editable text files and a model of the system's resources, and the tool compares the current state of each <span class="strong"><strong>node</strong></span> (the term we use for configuration-managed servers) with your desired state and makes any changes necessary to bring it in line.</p><p>As with most unimportant things, there is a great deal of discussion and argument on the Internet about which CM tool is the best. While there are significant differences in approaches and capabilities between different tools, don't let that obscure the fact that using a tool of any sort to manage configuration is much better than trying to do it by hand.</p><p>That said, while there are many CM tools available, Puppet is an excellent choice. No other tool is more powerful, more portable, or more widely adopted. In this book, I'm going to show you what makes Puppet so good and the things that only Puppet can do.</p></div>
<div class="section" title="What is Puppet?"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>What is Puppet?</h1></div></div></div><p>Puppet is two <a id="id12" class="indexterm"/>things: a language for expressing the desired state (how your nodes should be configured), and an engine that interprets code written in the Puppet language and applies it to the nodes to bring about the desired state.</p><p>What does this language look like? It's not exactly a series of instructions, like a shell script or a Ruby program. It's more like a set of declarations about the way things should be. Have a look at the following example:</p><div class="informalexample"><pre class="programlisting">package { 'curl':
  ensure =&gt; installed,
}</pre></div><p>In English, this code says, "The <code class="literal">curl</code> package should be installed." When you apply this manifest (Puppet programs are called manifests), the tool will do the following:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Check the list of installed packages on the node to see if <code class="literal">curl</code> is already installed.</li><li class="listitem">If it is, do nothing.</li><li class="listitem">If not, install it.</li></ol></div><p>Here's another example of Puppet code:</p><div class="informalexample"><pre class="programlisting">user { 'bridget':
  ensure =&gt; present,
}</pre></div><p>This is Puppet language for the declaration, "The <code class="literal">bridget</code> user should be present." (The keyword <code class="literal">ensure</code> means "the desired state of the resource is..."). Again, this results in Puppet checking for the existence of the <code class="literal">bridget</code> user on the node, and creating it if necessary. This is also a kind of documentation that expresses human-readable statements about the system in a formal way. The code expresses the author's desire that Bridget should always be present.</p><p>So you can see that the Puppet program—the Puppet <span class="strong"><strong>manifest</strong></span>—for your configuration is a set of declarations about what things should exist, and how they should be configured.</p><p>You don't give commands, like "Do this, then do that". Rather, you describe how things should be, and let Puppet take care of making it happen. These are two quite different kinds of <a id="id13" class="indexterm"/>programming. One kind (so-called procedural style) is the traditional model used by languages such as C, Python, shell, and so on. Puppet's is called <a id="id14" class="indexterm"/>declarative style because you declare what the end result should be, rather than specify the steps to get there.</p><p>This means that you can apply the same Puppet manifest repeatedly to a node and the end result will be the same, no <a id="id15" class="indexterm"/>matter how many times you apply the manifest. It's better to think of Puppet manifests as a kind of specification, or declaration, rather than as a program in the traditional sense.</p><div class="section" title="Resources and attributes"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Resources and attributes</h2></div></div></div><p>Puppet lets you <a id="id16" class="indexterm"/>describe configuration in terms of <span class="strong"><strong>resources</strong></span> (types of things that can <a id="id17" class="indexterm"/>exist, such as users, files, or packages) and their <span class="strong"><strong>attributes</strong></span> (appropriate properties for the type of resource, such as the home directory for a user, or the owner and permissions for a file). You don't have to get into the details of how resources are created and configured on different platforms. Puppet takes care of it.</p><p>The power of this approach is that a given manifest can be applied to different nodes, all running different operating systems, and the results will be the same everywhere.</p></div><div class="section" title="Puppet architectures"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Puppet architectures</h2></div></div></div><p>It's worth noting that <a id="id18" class="indexterm"/>there are two different ways to use Puppet. The first way, known <a id="id19" class="indexterm"/>as <span class="strong"><strong>agent/master architecture</strong></span>, uses a special node dedicated to running Puppet, which all other nodes contact to get their configuration.</p><p>The other way, known <a id="id20" class="indexterm"/>as <span class="strong"><strong>stand-alone Puppet</strong></span> or <span class="strong"><strong>masterless</strong></span>, does not need a special Puppet master node. Puppet runs on each individual node and does not need to contact a central location to get its configuration. Instead, you use Git, or any other way of copying files to the node, such as SFTP or <code class="literal">rsync</code>, to update the Puppet manifests on each node.</p><p>Both stand-alone and agent/master architectures are officially supported by Puppet. It's your choice which one you prefer to use. In this book, I will cover only the stand-alone architecture, which is simpler and easier for most organizations, but almost everything in the book will work just the same whether you use agent/master or stand-alone Puppet.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>To set up Puppet with an agent/master architecture, consult the official Puppet documentation.</p></div></div></div></div>
<div class="section" title="Getting ready for Puppet"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Getting ready for Puppet</h1></div></div></div><p>Although Puppet is <a id="id21" class="indexterm"/>inherently cross-platform and works with many different operating systems, for the purposes of this book, I'm going to focus on just one operating system, namely the <span class="strong"><strong>Ubuntu 16.04 LTS</strong></span> distribution of Linux, and the most recent version of Puppet, Puppet 5. However, all the examples in the book should work on any recent operating system or Puppet version with only minor changes.</p><p>You will probably find that the best way to read this book is to follow along with the examples using a Linux machine of your own. It doesn't matter whether this is a physical server, desktop or laptop, cloud instance, or a virtual machine. I'm going to use the popular Vagrant software to run a virtual machine on my own computer, and you can do the same. The public GitHub repository for this book contains a Vagrantfile, which you can use to get up and running with Puppet in just a few steps.</p><div class="section" title="Installing Git and downloading the repo"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Installing Git and downloading the repo</h2></div></div></div><p>To get a <a id="id22" class="indexterm"/>copy of the repo that accompanies this book, follow <a id="id23" class="indexterm"/>these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Browse to <a class="ulink" href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></li><li class="listitem">Download and install the right version of Git for your operating system.</li><li class="listitem">Run the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>git clone https://github.com/bitfield/puppet-beginners-guide-3.git</strong></span>
</pre></div></li></ol></div></div><div class="section" title="Installing VirtualBox and Vagrant"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Installing VirtualBox and Vagrant</h2></div></div></div><p>If you <a id="id24" class="indexterm"/>already have a Linux machine or cloud server you'd like to <a id="id25" class="indexterm"/>use for working through the examples, skip this section and move on to the next chapter. If you'd like to use VirtualBox and Vagrant to run a local <span class="strong"><strong>virtual machine</strong></span> (<span class="strong"><strong>VM</strong></span>) on your computer to use with the examples, follow these instructions:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Browse to <a class="ulink" href="https://www.virtualbox.org/">https://www.virtualbox.org/</a></li><li class="listitem">Download and install the right version of VirtualBox for your operating system</li><li class="listitem">Browse to <a class="ulink" href="https://www.vagrantup.com/downloads.html">https://www.vagrantup.com/downloads.html</a></li><li class="listitem">Select the right version of Vagrant for your operating system: OS X, Windows, and so on</li><li class="listitem">Follow the instructions to install the software</li></ol></div></div><div class="section" title="Running your Vagrant VM"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>Running your Vagrant VM</h2></div></div></div><p>Once you have <a id="id26" class="indexterm"/>installed Vagrant, you can start the Puppet <a id="id27" class="indexterm"/>Beginner's Guide virtual machine:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Run the following commands:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cd puppet-beginners-guide-3</strong></span>
<span class="strong"><strong>scripts/start_vagrant.sh</strong></span>
</pre></div><p>Vagrant will begin downloading the base box. Once that has booted, it will install Puppet. This may take a while, but once the installation is complete, the virtual machine will be ready to use.</p></li><li class="listitem">Connect to the VM with the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>vagrant ssh</strong></span>
</pre></div></li><li class="listitem">You now have a <a id="id28" class="indexterm"/>command-line shell on the VM. Check that Puppet is installed and working by running the following command (you may get a different version number, which is fine):<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>puppet --version</strong></span>
<span class="strong"><strong>5.2.0</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>If you're using Windows, you may need to install the PuTTY software to connect to your VM. There is some helpful advice about using Vagrant on Windows at:</p><p>
<a class="ulink" href="http://tech.osteel.me/posts/2015/01/25/how-to-use-vagrant-on-windows.html">http://tech.osteel.me/posts/2015/01/25/how-to-use-vagrant-on-windows.html</a>
</p></div></div></li></ol></div></div><div class="section" title="Troubleshooting Vagrant"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"/>Troubleshooting Vagrant</h2></div></div></div><p>If you have <a id="id29" class="indexterm"/>any problems running the VM, look for help on the <a id="id30" class="indexterm"/>VirtualBox or Vagrant websites. In particular, if you have an older machine, you may see a message like the following:</p><div class="informalexample"><pre class="programlisting">VT-x/AMD-V hardware acceleration is not available on your system. Your 64-bit guest will fail to detect a 64-bit CPU and will not be able to boot.</pre></div><p>Your computer may have a BIOS setting to enable 64-bit hardware virtualization (depending on the manufacturer, the trade name for this is either <span class="strong"><strong>VT-x</strong></span> or <span class="strong"><strong>AMD-V</strong></span>). Enabling this feature may fix the problem. If not, you can try the 32-bit version of the Vagrant box instead. Edit the file named <code class="literal">Vagrantfile</code> in the Git repository, and comment out the following line with a leading <code class="literal">#</code> character:</p><div class="informalexample"><pre class="programlisting">config.vm.box = "ubuntu/xenial64"</pre></div><p>Uncomment the <a id="id31" class="indexterm"/>following line by removing the leading <code class="literal">#</code> character:</p><div class="informalexample"><pre class="programlisting"># config.vm.box = "ubuntu/xenial32"</pre></div><p>Now re-run the <code class="literal">scripts/start_vagrant.sh</code> command.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Summary</h1></div></div></div><p>In this chapter, we looked at the various problems that configuration management tools can help solve, and how Puppet in particular models the aspects of system configuration. We checked out the Git repository of example code for this book, installed VirtualBox and Vagrant, started the Vagrant VM, and ran Puppet for the first time.</p><p>In the next chapter, we'll write our first Puppet manifests, get some insight into the structure of Puppet resources and how they're applied, and learn about the <code class="literal">package</code>, <code class="literal">file</code>, and <code class="literal">service</code> resources.</p></div></body></html>