<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using Azure Search</h1>
                </header>
            
            <article>
                
<p>When in need of using a search engine, it's always a good idea to use tested and well-known solutions that have been available on the market for a while. One of those solutions is Azure Search, which offers a search-as-a-service cloud solution with an API for developers, so users can focus on developing a working solution without the need to manage infrastructure or configuration. With the recent addition of the Cognitive Search API, we've been given an opportunity to enhance our search functionality with AI features, so it's possible to transform unstructured content into searchable content.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li style="font-weight: 400">Using Azure Search in your projects</li>
<li>Using full-text search for your needs</li>
<li style="font-weight: 400">Using linguistics analysis</li>
<li style="font-weight: 400">Using indexing, index definition, and indexers</li>
<li style="font-weight: 400">The new Cognitive Search API with indexing workloads supported by AI</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To perform exercises from this chapter, you will need the following:</p>
<ul>
<li>Access to an Azure subscription</li>
<li>A tool for sending HTTP requests (cURL and Postman)</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating an Azure Search service</h1>
                </header>
            
            <article>
                
<p>Creating Azure Search is an easy task and should not take more than a few minutes. The important thing to remember here is that, if you have to recreate a service, there is no way to back up and restore data—if you make mistakes here, everything has to be done from scratch.</p>
<p>The reason to recreate would be changing the datatypes or other search attributes of the search index columns. While it will not be a problem <span>during this exercise</span>, have that in mind when creating a production workload.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using Azure Portal</h1>
                </header>
            
            <article>
                
<p>As with most services in Azure, we will start our journey by creating Azure Search in the portal. To do so, click on <span class="packt_screen">+ Create a resource</span> and search for <kbd>Azure Search</kbd>. On the introduction screen, click on the <span class="packt_screen">Create</span> button, which will take you to the configuration of this service:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/4e42b191-3ac8-4e65-908f-0feececb7956.png" style="width:19.67em;height:29.08em;" width="291" height="430"/></div>
<p>As you can see, we have pretty standard options here, which should not be unclear to you by now. There is, however, an option to select a <span class="packt_screen">Pricing tier</span>, where currently there are different options to choose from:</p>
<ul>
<li><span class="packt_screen">Free</span>: This is the most basic one without replicas available and shared resources.</li>
<li><span class="packt_screen">Basic</span>: This comes with load balancing available, scaling, and dedicated resources.</li>
<li><span class="packt_screen">Standard</span>: This is three different tiers with more compute power and partitions available.</li>
<li><span class="packt_screen">High-density</span>: The same as <span class="packt_screen">Standard </span>but with more indexes available (and fewer partitions). This particular tier is designed for SaaS developers specifically.</li>
</ul>
<p>Before we proceed, you will have to understand what all of these concepts <span>are</span>:</p>
<ul>
<li><strong>Replica</strong>: This is an individual instance of your search service, which hosts one copy of an index. If you have more than one replica, you can load balance your queries.</li>
<li><strong>Index</strong>: You can think of this as a table that contains multiple rows (or in other words, documents) with additional metadata used by a service.</li>
<li><strong>Search unit</strong> (<strong>SU</strong>): This is a billing unit for Azure Search, which is a composition of the number of replicas and partitions (<em>SU = Replicas * Partitions</em>).</li>
<li><strong>Partition</strong>: Each partition provides storage and I/O for your instance of Azure Search, so scaling this unit will give more of those.</li>
</ul>
<div class="packt_tip">The main difference between replicas and partitions is that, if you need more computational resources, you can increase partitions while, for larger query volumes, you need more replicas (so a query can be load balanced).</div>
<p>When you fill all fields and select a tier, click on the <span class="packt_screen">Create</span> button and wait for a moment for service creation. Once it is created, click on it and go to the <span class="packt_screen">Overview</span> blade. There, select <span class="packt_screen">Import data</span>, so we can start with some samples before diving deeper into Azure Search:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/e7c6760f-cc7c-4f4c-bb42-2a039b082e5b.png" width="741" height="193"/></div>
<p class="mce-root"/>
<p>On the next screen, you will see multiple options for importing records—you are able to select the data source and index and enable <span class="packt_screen">Cognitive Search</span>, which we will cover in the next sections:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/f357de61-2f55-4499-9eb0-b3c836f44407.png" width="919" height="298"/></div>
<div class="packt_tip">Remember that it is possible to delete or change the fields used for indexing data, but such operations require re-indexing all documents. By re-indexing I mean that you have to delete, then recreate the index. However, it is possible to add new fields without re-indexing the documents—in that case, the values for the new columns will be null for the older ones.</div>
<p>Because we selected sample data, <span class="packt_screen">Index</span> is already filled with some default values. When you click <span class="packt_screen">Ok</span>, they will be validated and the <span class="packt_screen">Indexer</span> screen will become available. You may wonder what indexer is exactly. Its definition is quite simple—it is a crawler that looks at your data source and extracts everything from it based on the mapping between an index and stored information. For example, if you selected a field named <kbd>Status</kbd> as a part of your index, the indexer will search for all records containing it and push it to your index.</p>
<div class="packt_infobox">Indexers can be configured either to fetch data once or on schedule. We will cover scheduled indexers in the section regarding indexes and indexing documents.</div>
<p>If you are satisfied with import configuration, click on the <span class="packt_screen">Ok</span> button and wait a moment until the data is imported and indexed. Now, we can test how our service works—on the <span class="packt_screen">Overview</span> blade, you can find the <span class="packt_screen">Search explorer</span> button. When you click on it, you will see the new screen, where you can enter your <span class="packt_screen">Query string</span> and <span class="packt_screen">Request URL</span>, which can be used in your application to get results:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/a100749a-bdf8-40be-86dc-dcc073355c81.png" width="835" height="578"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Full-text search in Azure Search</h1>
                </header>
            
            <article>
                
<p>The power of Azure Search comes when you need to perform a full-text search to find relevant documents that will satisfy your query. This Azure service uses <strong>Apache Lucene</strong> under the hood, which is a well-known, high-performance search engine written in Java.</p>
<div class="packt_infobox">You can find more information about Lucene here: <a href="https://lucene.apache.org/core/">https://lucene.apache.org/core/</a>. It is an open source project available to download for everyone.</div>
<p>In this chapter, you will learn how to perform a full-text search, what is the syntax, and how to recognize potential issues.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sending a request</h1>
                </header>
            
            <article>
                
<p>In the first section of this chapter, you created your Azure Search instance and saw <span class="packt_screen">Search explorer</span>, which enables you to send simple queries. Now, we will extend our requests, so you can select which fields should be used for query analysis, to filter results, and to order by a particular property. Here is the basic URL, which you will use for all of your requests:</p>
<p class="mce-root"><kbd>https://handsonazuresearch.search.windows.net/indexes/realestate-us-sample/docs?api-version=2016-09-01&amp;search=*</kbd></p>
<p>Of course, it will differ depending on the name of your Azure Search instance, the index name, and the version used. The URL template can be defined as follows:</p>
<p class="mce-root"><span><kbd>https://[service name].search.windows.net/indexes/[index name]/docs?[query parameters]</kbd></span></p>
<p>As you can see, in this example I used <kbd>*</kbd>, which basically means that I am interested in all documents indexed. However, before we proceed, we need to do one more thing—as with most APIs, Azure Search is secured and requires a key to authorize a request. If you do not send it, you will get an <kbd>HTTP 403 response</kbd>. To obtain a key, go to Azure Portal and select the <span class="packt_screen">Keys</span> blade:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/023894e2-54d4-47b8-899b-7e356a842948.png" style="width:34.58em;height:23.25em;" width="580" height="390"/></div>
<p>Now, with each request to your API, you will have to use the <kbd>api-key</kbd> header with the appropriate value. Here you can find an example:</p>
<pre>GET /indexes/realestate-us-sample/docs?api-version=2016-09-01&amp;search=* HTTP/1.1<br/>Host: handsonazuresearch.search.windows.net<br/>api-key: 38B4F66ACD480406328C62273C056CA4<br/>Cache-Control: no-cache</pre>
<p>Nonetheless, in most cases, we are not interested in literally all documents available—we have specific parameters that we would like to use. Let's assume you would like to search for a specific city. In such a case, we have to use another endpoint and pass a valid payload, which will be used to build a query:</p>
<pre>POST /indexes/realestate-us-sample/docs/search?api-version=2016-09-01 HTTP/1.1<br/>Host: handsonazuresearch.search.windows.net<br/>api-key: {API_KEY}<br/>Content-Type: application/json<br/>Cache-Control: no-cache<br/><br/>{ <br/>    "search": "Sammamish", <br/>    "searchFields": "city"<br/> }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>As you can see, I changed the <kbd>HTTP</kbd> method to <kbd>POST</kbd> and used the <kbd>/search</kbd> endpoint for my request. The most important thing, however, is the body—for now, I used two fields:</p>
<ul>
<li><kbd>search</kbd>: This is our query string, which we are using to tell Azure Search what we are interested in</li>
<li><kbd>searchFields</kbd>: Here we are passing fields, which should contain our query string</li>
</ul>
<div class="packt_infobox">Please remember that the fields passed in the request body are case-sensitive and you should follow camel case if there are multiple words.</div>
<p>If you run the preceding query on the sample index, you should be able to see some results returned. If you search for a city that is not in the indexed documents, you will see an empty result:</p>
<pre>{<br/>    "@odata.context": "https://handsonazuresearch.search.windows.net/indexes('realestate-us-sample')/$metadata#docs",<br/>    "value": []<br/>}</pre>
<p>You may ask what are the rules for choosing a search field—the only requirement is that it has to be marked as <kbd>Searchable</kbd>. Take a look at what will happen if I use <kbd>beds</kbd> to search for records with a specific number of them:</p>
<pre>{<br/>    "error": {<br/>        "code": "",<br/>        "message": "The field 'beds' in the search field list is not searchable.\r\nParameter name: searchFields"<br/>    }<br/>}</pre>
<p>It seems we cannot use any field we would like to. You can check which fields can be used for searching in the index screen:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/1e84dbe7-a777-4bb2-bbe0-a9d2820e5a0b.png" style="width:34.00em;height:33.17em;" width="568" height="557"/></div>
<div class="packt_tip packt_infobox">In fact, you cannot use any field of the <kbd>Edm.Int32</kbd> <span>type</span> <span>as</span> <kbd>Searchable</kbd>. T<span>here are some other types, which are also not supported (for example,</span> <kbd>Edm.GeographyPoint</kbd><span>)—you can find information about them when building or modifying fields used in an index.</span></div>
<p>To overcome the aforementioned problem, you may use filters<span class="packt_screen">—</span>these are expressions based on the OData syntax, which you can leverage to search for the entities you are interested in. The only requirement is to make a field you want to use into a filter using filterable. Here you can find all possible fields, which you can use in such an HTTP request:</p>
<pre>{<br/>  "count": true | false(default),<br/>  "facets": ["facet_expression_1", "facet_expression_2", ...],<br/>  "filter": "odata_filter_expression",<br/>  "highlight": "highlight_field_1, highlight_field_2, ...",<br/>  "highlightPreTag": "pre_tag",<br/>  "highlightPostTag": "post_tag",<br/>  "minimumCoverage": #( % of index that must be covered to declare query successful; default 100),<br/>  "orderby": "orderby_expression",<br/>  "scoringParameters": ["scoring_parameter_1", "scoring_parameter_2", ...],<br/>  "scoringProfile": "scoring_profile_name",<br/>  "search": "simple_query_expression",<br/>  "searchFields": "field_name_1, field_name_2, ...",<br/>  "searchMode": "any" (default) | "all",<br/>  "select": "field_name_1, field_name_2, ...",<br/>  "skip": #(default 0),<br/>  "top": #<br/>}</pre>
<p>We will not cover them all as this would take this whole chapter, however, we will focus a little more on the actual syntax of queries sent to Azure Search. As you probably remember, this service uses the Lucene search engine to index data and handle requests. Lucene supports a variety of different query types such as fuzzy search, wildcard search, and many more. You can decide which parser should be used by sending the <kbd>queryType</kbd> parameter with one of the available values—simple or full (Lucene).</p>
<div class="packt_infobox">You can find supported query operations by Lucene by reading the following page: <a href="https://docs.microsoft.com/pl-pl/rest/api/searchservice/lucene-query-syntax-in-azure-search">https://docs.microsoft.com/pl-pl/rest/api/searchservice/lucene-query-syntax-in-azure-search</a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Linguistic analysis in full-text search</h1>
                </header>
            
            <article>
                
<p>When using full-text search, you have to understand what are the rules for performing such operations. Search engines have to analyze search query lexically to be able to extract important information and pass it to a query tree. In this section, we will cover the most common lexical analysis, which is linguistic analysis, to help you understand how Azure Search works and how to perform correct queries.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Analyzers in Azure Search</h1>
                </header>
            
            <article>
                
<p>To perform linguistic analysis, Azure Search supports a variety of different analyzers, which can be specified in the index definition. However, before we start defining one of those, you have to catch a glimpse of what we are talking about. When creating an index, each search service has to analyze all input documents and decide what will be important when performing a search procedure.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Additionally, each search query should be adjusted to some common rules, so the search engine can understand it. The necessary operations can be described as follows:</p>
<ul>
<li>All non-essential words should be removed (such as "the" in English)</li>
<li>All words should be lowercase</li>
<li>If a word contains multiple words in it (such as "up-front"), it should be divided into atomic ones</li>
</ul>
<p>Now let's assume you are searching for an apartment using the following search query:</p>
<pre>Spacious apartment with 4 and the Red Kitchen</pre>
<p>Your analyzer will have to perform all of the preceding operations before passing the query to a search engine and, in fact, here you can find the result of such analysis:</p>
<pre>{<br/>    "@odata.context": "https://handsonazuresearch.search.windows.net/$metadata#Microsoft.Azure.Search.V2016_09_01.AnalyzeResult",<br/>    "tokens": [<br/>        {<br/>            "token": "spacious",<br/>            "startOffset": 0,<br/>            "endOffset": 8,<br/>            "position": 0<br/>        },<br/>        {<br/>            "token": "apartment",<br/>            "startOffset": 9,<br/>            "endOffset": 18,<br/>            "position": 1<br/>        },<br/>        {<br/>            "token": "with",<br/>            "startOffset": 19,<br/>            "endOffset": 23,<br/>            "position": 2<br/>        },<br/>        {<br/>            "token": "4",<br/>            "startOffset": 24,<br/>            "endOffset": 25,<br/>            "position": 3<br/>        },<br/>        {<br/>            "token": "and",<br/>            "startOffset": 26,<br/>            "endOffset": 29,<br/>            "position": 4<br/>        },<br/>        {<br/>            "token": "the",<br/>            "startOffset": 30,<br/>            "endOffset": 33,<br/>            "position": 5<br/>        },<br/>        {<br/>            "token": "red",<br/>            "startOffset": 34,<br/>            "endOffset": 37,<br/>            "position": 6<br/>        },<br/>        {<br/>            "token": "kitchen",<br/>            "startOffset": 38,<br/>            "endOffset": 45,<br/>            "position": 7<br/>        }<br/>    ]<br/>}</pre>
<p>As you can see, each word has its particular position and offset. To get a result similar to the previous one, you can send the following query:</p>
<pre>POST /indexes/[index name]/analyze?api-version=2016-09-01 HTTP/1.1<br/>Host: [service name].search.windows.net<br/>api-key: [api key]<br/>Content-Type: application/json<br/>Cache-Control: no-cache<br/><br/>{<br/>  "text": "Spacious apartment with 4 and the Red Kitchen",<br/>  "analyzer": "standard"<br/>}</pre>
<p>In the request's body, you have to provide both texts to analyze and use the analyzer. Note that I used <kbd>standard</kbd> here, which means that the standard Lucene analyzer is used here.</p>
<div class="packt_tip">Azure Search supports several different analyzers for different languages—what is more, both Microsoft and Lucene versions are available. To get the full list, go to the documentation page: <a href="https://docs.microsoft.com/pl-pl/rest/api/searchservice/language-support">https://docs.microsoft.com/pl-pl/rest/api/searchservice/language-support</a>.<a href="https://docs.microsoft.com/pl-pl/rest/api/searchservice/language-support"/></div>
<p class="mce-root"/>
<p>If you are proficient in language analysis and syntax, you could create a custom analyzer that can be used for text analysis. Such analyzers can be defined during index creation, however, we will not cover that topic in this book as it is an advanced exercise and is out of our present scope. You will find a link to the tutorial in the <em>Further reading</em> section of this chapter.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Analyzer selection</h1>
                </header>
            
            <article>
                
<p>You can select an analyzer for a specific field either during the creation of an index or while editing it. If you go to Azure Portal and to your Azure Search instance<em>,</em> you can click on an index and select the <span class="packt_screen">Fields</span> section. It should display a list of all fields used in that index:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/15191048-268f-4635-9058-c34dda27be07.png" width="1429" height="589"/></div>
<p>Now, when you scroll down, you will see that you are able to add a new field. If you would like to select an analyzer, you will need to do the following:</p>
<ol>
<li>Select a checkbox <span class="packt_screen">Analyzer</span> at the top of that blade</li>
<li>Select <span class="packt_screen">Searchable</span> as an option of that field</li>
</ol>
<p>Now you should see a drop-down list from which you are able to select a different analyzer than the custom one:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/37ddf8da-5103-407e-8737-2720d8aa2cf7.png" width="776" height="67"/></div>
<div class="packt_tip">Note that selecting a different analyzer than the custom one is crucial when you have fields containing multiple languages. In such a scenario, you should select an analyzer appropriate for the language used.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Indexing in Azure Search</h1>
                </header>
            
            <article>
                
<p>An index is one of the most important constructs in Azure Search. We defined it as a table that contains all imported documents with searchable data defined in it. At the beginning of this chapter, you learned how to create it and add or edit fields. In this section, you will learn a bit more about modifying it as an index is not a fixed being that cannot be altered and adjusted to your needs.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Importing more data</h1>
                </header>
            
            <article>
                
<p>There is always a need to push more data to your index—your application grows, the storage of your documents becomes bigger and bigger, especially if you are creating a document repository, and you would like to be able to find what you are searching for even in the most recent documents. In fact, there are two options to add data to your index:</p>
<ul>
<li>The push model</li>
<li>The pull model</li>
</ul>
<p>We will cover both of them in the following sections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Push model</h1>
                </header>
            
            <article>
                
<p>The push model is the best solution for applications that have low-latency requirements. As opposed to the pull model, for this model, your document will be indexed immediately after pushing it using a RESTful API.</p>
<div class="packt_infobox">Currently, there is no other option to use a push model besides using a RESTful API or .NET SDK to perform an operation. In the pull model, it is also possible to get data using Azure Portal.</div>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Here, you can find an example request for pushing a document:</p>
<pre>POST /indexes/realestate-us-sample/docs/index?api-version=2016-09-01 HTTP/1.1<br/>Host: [service name].search.windows.net<br/>api-key: [api key]<br/>Content-Type: application/json<br/>Cache-Control: no-cache<br/><br/>{ <br/>  "value": [ <br/>    { <br/>      "listingId": "12344234",<br/>      "@search.action": "upload", <br/>      "price": 250.0, <br/>      "description": "The very apartment in Warsaw", <br/>      "city": "Warsaw", <br/>      "tags": ["pool", "view", "wifi", "gym"], <br/>      "beds": 4, <br/>      "location": { "type": "Point", "coordinates": [52.237049, 21.017532] } <br/>    } <br/>  ] <br/>}  </pre>
<p>If everything is correct, you should be able to see a successful result:</p>
<pre>{<br/>    "@odata.context": "https://handsonazuresearch.search.windows.net/indexes('realestate-us-sample')/$metadata#Collection(Microsoft.Azure.Search.V2016_09_01.IndexResult)",<br/>    "value": [<br/>        {<br/>            "key": "12344234",<br/>            "status": true,<br/>            "errorMessage": null,<br/>            "statusCode": 201<br/>        }<br/>    ]<br/>}</pre>
<p>Now, I would like to check whether my document is already indexed and available:</p>
<pre>POST /indexes/realestate-us-sample/docs/search?api-version=2016-09-01 HTTP/1.1<br/>Host: [service name].search.windows.net<br/>api-key: [api key]<br/>Content-Type: application/json<br/>Cache-Control: no-cache<br/><br/>{ <br/>    "search": "Warsaw", <br/>    "searchFields": "city"<br/>} </pre>
<p>The result should be a document that contains all of the fields we passed in the push request.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Pull model</h1>
                </header>
            
            <article>
                
<p>A pull model is a bit different than a push model as it uses indexers to actually fetch the data. When using it, you are configuring both a data source and how frequently data should be pulled. As opposed to the push model, it can be configured and accessed when using Azure Portal.</p>
<div class="packt_tip">Please note one important difference between push and pull—when using push, you are able to use any data source you want. When using the pull model you are limited to Blob Storage, Table Storage, CosmosDB, and SQL Database (both on Azure and VMs).</div>
<p>Here, you can find an indexer configuration for pulling data when using Table Storage as a source:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/1e4243c5-6f53-4fae-b160-9076554b630a.png" width="924" height="443"/></div>
<div class="packt_infobox">Please remember that you cannot configure a pull policy when using sample data.</div>
<p>What is more, you can access an indexer configuration and current status by <span>clicking</span> <span>on</span> <span>the</span> <span class="packt_screen"><span>Indexers</span></span> button on the <span class="packt_screen">Overview</span> blade:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/ae123c63-5190-4aa0-95f1-c45bec2eb395.png" width="1155" height="645"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cognitive search – adding AI to the indexing workload</h1>
                </header>
            
            <article>
                
<p>When creating and managing an index, you always have to make sure that you have selected all required fields and marked them as searchable where needed. Additionally, we are limited to the current service functionalities, so we cannot use things such as image or natural language processing. Fortunately, Azure Service is about to start supporting the Cognitive Search feature, which adds AI to your indexing operations, allowing for richer analysis using more vectors. In this chapter, you will learn how to configure it, so you can start using it from the very beginning.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Configuring Cognitive Search</h1>
                </header>
            
            <article>
                
<p>Cognitive Search can be configured when importing data for your service. When you click on the <span class="packt_screen">Import data</span> button, you will see that one of the available sections is that feature exactly:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/1ba39ba5-1b3c-47d9-bc22-c444253eb602.png" style="width:56.17em;height:27.92em;" width="879" height="437"/></div>
<div class="packt_infobox">At the time of writing, this feature is available only in the South Central US and Western Europe regions.</div>
<p>There is a list of Cognitive Skills that can be used for indexing your data. Whether you use one or not depends on your actual requirements—for the purpose of this exercise, I selected <span class="packt_screen">Detect language</span>. You can customize the name of a field also; this could be crucial if your index will contain another one named the same, as it will be added to the result of a query. When you finish configuring your index, you can compare the previous one with the new one enriched by AI:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/427ebe5e-fa49-4cf6-a502-3019711e8953.png" style="width:53.00em;height:10.50em;" width="828" height="164"/></div>
<p>As you can see, we are missing the <span class="packt_screen">language</span> field here since we did not use it. Let's compare it with the newest index:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/a87b6c5a-a8aa-45a9-8e69-412313decc12.png" width="826" height="215"/></div>
<p>Additionally, when I query a service using a newer index, I will get a result containing the <span class="packt_screen">language</span> field filled:</p>
<pre>{<br/>(...)<br/>"location": {<br/>  "type": "Point",<br/>  "coordinates": [<br/>    -122.388,<br/>    47.576<br/>  ],<br/>  "crs": {<br/>    "type": "name",<br/>    "properties": {<br/>      "name": "EPSG:4326"<br/>    }<br/>  }<br/>},<br/>"price": 762048,<br/>"thumbnail": "https://searchdatasets.blob.core.windows.net/images/bd2bt2apt.jpg",<br/>"tags": [<br/>  "condominium",<br/>  "dream home",<br/>  "lake access",<br/>  "no outlet",<br/>  "miele appliances",<br/>  "wall of windows",<br/>  "guest room"<br/>],<br/>"language": "en"<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Azure Search is a great service when you want to have your very own search solution and do not plan to maintain its infrastructure and configuration. With its flexibility and intuitiveness, you can quickly develop your application, leveraging features such as the push/pull model, scheduled indexing, or support for different kinds of data sources. Additionally, with the option to start from the free tier even for production workloads, you can gradually progress and scale your solution up adjusting costs based on real requirements. In <a href="aedf7d2d-cfb2-443c-b7e2-b638473fe05c.xhtml" target="_blank">Chapter 6</a>, <span><em>Mobile Notifications with Notification Hub</em>, </span>we will cover topics related to handling mobile and applications and push notification by using Azure Notification Hub.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is an index?</li>
<li>What is the difference between the push and pull models?</li>
<li>Can an indexer be scheduled using a custom interval?</li>
<li>What analyzer does Azure Search use by default?</li>
<li>Can one implement a custom analyzer and use it in Azure Search?</li>
<li>What is the difference between partition and replica?</li>
<li>What is the name of a header used for authorizing requests to Azure Search?</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li>Azure Search documentation: <a href="https://docs.microsoft.com/en-us/azure/search/">https://docs.microsoft.com/en-us/azure/search/</a></li>
<li>Cognitive Skills for Azure Search: <a href="https://docs.microsoft.com/en-us/azure/search/cognitive-search-predefined-skills">https://docs.microsoft.com/en-us/azure/search/cognitive-search-predefined-skills</a></li>
<li>Apache Lucene documentation: <a href="https://lucene.apache.org/core/">https://lucene.apache.org/core/</a></li>
<li>Filters in Azure Search: <a href="https://docs.microsoft.com/en-us/rest/api/searchservice/odata-expression-syntax-for-azure-search">https://docs.microsoft.com/en-us/rest/api/searchservice/odata-expression-syntax-for-azure-search</a></li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>