- en: Managing Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code management has gone a lot of changes over the lifetime of Puppet. In earlier
    versions of Puppet, code management was largely left to individual users. Most
    users started by simply editing code directly on the Puppet Master. One organization
    that I worked for created Yum RPMs for every module, allowing us to roll back
    and forth between individual modules on multiple Puppet Masters, prior to the
    introduction of Puppet environments. Many users stored their Puppet code in Git
    or subversion and checked the code out to directories in the Puppet Master.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these models comes with significant overhead management, and two solutions
    have risen to the top of the Puppet community during the transition from Puppet
    2 to Puppet 3: Puppet Librarian and r10k. Puppet Librarian manages code like a
    Ruby bundle file, bringing in all the listed modules and dependencies with a single
    command. Automatic dependency management from the Forge has some issues, as well.
    Some modules include dependency lists for all operating systems, including ones
    that are not in your infrastructure. Some modules do not receive updates for a
    period of time, linking to old versions of a dependency while your organization
    is using a newer version. Finally, dependencies in Puppet modules are often listed
    as a range of versions rather than a single version, and if these modules are
    used across multiple manifests, it can be difficult to resolve conflicts.'
  prefs: []
  type: TYPE_NORMAL
- en: Some users of Puppet Librarian use `puppet-librarian-simple`, which does not
    manage dependencies. Although `puppet-librarian-simple` is easier to install than
    r10k, it does not maintain feature parity with r10k; r10k has become the most
    commonly used code management solution, for both enterprise and open source users.
    r10k allows users to point to a remote repository that contains a set of instructions
    to build a Puppet environment. Puppet Enterprise comes with an expansion to r10k,
    known as Puppet Code Manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Efficiently managing code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code Manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: r10k
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and using r10k
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multitenant control repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficiently managing code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although writing code directly to the disk on a Puppet Master is the easiest
    way to get started with Puppet, it is the least efficient model for managing infrastructure
    changes with Puppet. Manual changes leave the users to manage the following issues
    individually:'
  prefs: []
  type: TYPE_NORMAL
- en: Backup and recovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replication of Puppet Masters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replication of Puppet environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without code management, backups are often performed via disk snapshots, or
    by simply bundling code and moving it to a separate location in case of emergencies.
    Manual code placement leaves the organization responsible for maintaining a cadence
    and process for backing up and restoring, and for change management. Without any
    code management, replication of code to Puppet Masters and Puppet environments
    is a fully manual process, which leaves all Puppet code testing and implementation
    to dangerous manual processes, instead of processes within a controlled environment.
  prefs: []
  type: TYPE_NORMAL
- en: Although placing code in RPMs can solve the backup and recovery issue, change
    management, and the replication of Puppet Masters, it struggles with Puppet environments.
    An RPM has to be created for each Puppet environment, and this creates a confusing
    set of build files that consistently place code in multiple environments. Also,
    RPMs do not lend themselves to short-lived environments that are used to test
    individual code features.
  prefs: []
  type: TYPE_NORMAL
- en: Using Code Manager or r10k to manage code drastically simplifies these problems.
    Code is never written directly to the disk; instead, a list of requirements is
    pulled from one remote repository, and all relevant code is placed on the Puppet
    Master. One of the primary benefits of this model is that every change in code
    can be versioned in Git, and each change can be explicitly referenced (by tag,
    branch, or commit hash) and placed on the master. All of the code is always stored
    remotely, and is not reliant on the Puppet Master itself for backup and recovery.
    Rollbacks are now as easy as changing a single file in a remote repository. Code
    management also allows for the scaling of multiple Puppet Masters, with both long-lived
    and short-lived Puppet environments.
  prefs: []
  type: TYPE_NORMAL
- en: Code Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code Manager provides Enterprise RBAC and additional code distribution features
    to r10k. Code Manager will automatically set r10k up for you, but using it requires
    that you understand how r10k calls code, and how to store your code in a Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book is not intended to be a complete resource on Git, but to use Code
    Manager effectively, you should know some basics about Git.
  prefs: []
  type: TYPE_NORMAL
- en: Git is a modern code repository that allows for asynchronous work on the same
    code set by multiple users. It accomplishes this by distinguishing every code
    commit as the difference between the previous code commit. Every commit is the
    unique delta in code between the last commit and the current changes. The first
    commit might add hundreds of lines of code to a code base, but the following commit
    might be as simple as removing one line and replacing it with another. When this
    code is cloned (or copied) by another user, it brings down the latest code and
    allows the user to roll back to previous commits.
  prefs: []
  type: TYPE_NORMAL
- en: As an introduction to Git, let's walk through a scenario. Suppose that you are
    using Git to redecorate your living room. The current commit is how your living
    room looks right now. If you liked how it looked last summer, before you replaced
    your couch, you could roll back to the previous commit and set your living room
    back to a previously accepted state. Commits should be seen as accepted states
    of code, or, in this case, accepted states of your living room.
  prefs: []
  type: TYPE_NORMAL
- en: 'First and foremost, we don''t want to break our living room while building
    a new one, so we''ll clone it with `git clone`. This makes a copy of the current
    living room, and its entire change history is bundled in. To keep things simple,
    we''ll use the most recent version of our living room. If we wanted to make a
    change to the living room, we could purchase a new couch, a new TV, and two new
    lamps. Let''s suppose that we love the lamps, but we''re not sure about the couch
    and the TV. If we use `git add` on the lamps, it will add those lamps to the staging
    directory. Git will report the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve asked Git to track the changes on the new lamps that we love. When we
    type `git commit`, we''re asked to write what the change is, and then, Git will
    commit the new living room to memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the couch and TV are not included in this manifest of changes. In
    our working directory, or our current living room, the couch and TV are still
    present, but they're not permanent changes until we also add and commit them.
    Optionally, we could send our new commit (the lamps) back to our remote repository
    for safekeeping, and to let any other decorator use our most current living room
    composition with `git push`.
  prefs: []
  type: TYPE_NORMAL
- en: In short, we clone (copy) a living room format. We make changes to that format
    at will. The changes that we're sure we like, we add and commit. The changes that
    we're unsure about remain present, but only in our current working directory (or
    the current state of our living room). We could either add and commit our couch
    and television, or simply `git stash` and return our living room to the last known
    good state, which is now our previous living room, plus the new lamps. This pattern
    gives us the option to try drastic changes, and only commit the ones that we're
    sure about as a checkpoint in time. Once we have a commit (checkpoint) that we're
    willing to stand behind, we can then push that back to the version of the living
    room that everyone can see.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go over using Git against code, instead of in the living room. The first
    step is to clone, or copy, a repository. The command `git clone` copies an entire
    repository and its history, and brings it to the local workstation. This copy
    of code is entirely separate from where it was cloned (its origin). `git clone`
    creates an entirely standalone copy of the original repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a user first enters a code repository, all of the code is in the working
    directory. A user can make changes to the code at will here, and Git will track
    the delta between the last commit and what is currently in the repository. Git
    has a command called `git status` that allows a user to inspect what files are
    different from the last commit. In the following example, a module has been cloned,
    values have been changed in `init.pp`, and the user has run the `git status` from
    inside the directory of the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed `Changes not staged for commit`. Git recognizes the working
    directory, changes staged for a commit, and every commit in the repository history.
    The standard workflow is to clone a repository, make changes, stage them for a
    commit, and make a new atomic commit, before pushing it back to a central repository.
  prefs: []
  type: TYPE_NORMAL
- en: Although we generally don't make changes to a module procured from the Puppet
    Forge (the primary external repository for Puppet Code), let's go over what it's
    like to clone, change, commit, and (optionally) push our code back to the original
    repository, which Git automatically tags as `origin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll clone and make a local copy of `puppetlabs/ntp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice that it cloned the repository and applied 4,429 deltas. We now have a
    local copy of the entire repository contained on GitHub. It will create a directory
    called `puppetlabs-ntp`, which we must enter by using a change directory to continue
    in the local repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll edit the files that we intend to edit. In this case, I added a
    single comment to `manifests/init.pp` in the repository. I can check how Git views
    the repository with the command `git status`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Git now sees the change to the local repository. I want to ensure that this
    change is committed to the repository, so next, I''ll add it to the staging directory,
    highlighting it for a commit with `git add manifests/init.pp`. If we run another
    simple `git status`, we will notice that our code is no longer `not staged for
    commit`, but is now under `Changes to be committed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With `init.pp` in the staging directory, I can commit this code to a new version.
    Running the command `git commit` will open your default editor, allowing you to
    comment and name your commit. I will run the command with an `-m` flag, which
    allows me to pass the message on the command line, rather than by opening up my
    default editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, my local repository has the new commit locally. I can view this commit
    with the command `git log`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Most notably, this change is only on the local repository on my laptop. To
    share this code, I want to push my commit back to where I retrieved the original
    code from. When you run `git clone` locally, it also records where the code came
    from, and, by default, names the remote repository `origin`. If I run the command `git
    remote -v`, I can actually see the URL that the repository came from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If I had permission to push directly to this repository, I could send my new
    commit to the source with the simple command, `git push origin master`. Master
    is the name of the branch, or the specific code set inside of a repository I'm
    working on.
  prefs: []
  type: TYPE_NORMAL
- en: Branches are a concept in Git that allow us to create a copy of code and work
    on it in what is similar to a separate directory. By default, Git creates a master
    branch, which is the intended location of the most up-to-date functional code.
    We can create a new branch in Git and change code without impacting the original
    branch that it came from. The most efficient use of Git is for trunk-based development,
    where we start on the master branch, create a new branch that contains new features,
    test those features, and eventually, merge our branch back into the master branch.
    This model allows us to work on, share, test, and even implement code, without
    impacting the original code set.
  prefs: []
  type: TYPE_NORMAL
- en: When we type `git checkout -b new_branch`, we create a new branch, based on
    the original branch that we were on. We can then work here, add additional commits,
    and even push it back to the source, without impacting the original code. Only
    when the code is merged back into the original branch does it have an impact on
    that branch. Think of it as the Git equivalent of copying a set of code to a new
    directory, working on it, testing it, and then copying it back to the original
    source when finished.
  prefs: []
  type: TYPE_NORMAL
- en: r10k
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: r10k is the primary driver behind Puppet Enterprise Code Manager. It is centered
    around a single repository, called the **control repository**. The control repository
    contains files that describe an entire Puppet environment. This collection of
    files holistically makes up a version of Puppet code intended to be pushed to
    a particular set of nodes. Every time r10k is run, it redeploys everything contained
    in the control repository.
  prefs: []
  type: TYPE_NORMAL
- en: Control repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The control repository is the heart of code management for r10k and Code Manager.
    It is a single point of entry, represented as a Git repository, that describes
    one or more environments of one or more Puppet Masters.
  prefs: []
  type: TYPE_NORMAL
- en: 'r10k is designed to provide the following to a Puppet environment, from a control
    repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Each Puppet module required to make a code set via the `Puppetfile`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Hiera hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hiera data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An environment-specific configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any additional code (such as `site.pp`, roles, or profiles)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multiple states on a single Puppet Master can be achieved by using a concept
    that was launched in Puppet 3: Puppet environments. In Puppet 3, we gained the
    ability to use multiple directories to store code, and to select which code directory
    each agent uses individually. Code Manager and r10k expand on this concept by
    treating every branch of the control repository as a completely separate environment.'
  prefs: []
  type: TYPE_NORMAL
- en: If a control repository contains multiple branches, r10k can deploy each branch
    individually, as a separate environment. This does make our control repository
    branches a little different from a standard Git repository. Traditionally, the
    best model is trunk-based development, which gives us one master branch that is
    intended to receive all of the finished code changes. A Puppet control repository
    usually contains multiple long-lived and short-lived branches, with varying levels
    of intention to merge code between the branches. In the best scenario, we merge
    our code with the different levels of environments, until we reach production.
    Our `Puppetfile`, covered later in this chapter, is often the file that differs
    the most between the environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a situation where an organization has formal production, preproduction,
    and development environments, and users actively working on Puppet code, we may
    see the following branches:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Production`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Preproduction`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Development`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Feature1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Feature2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Feature1` and `Feature2` would be considered short-lived branches, with changes
    intended for merging into the development environment. Puppet environments are
    not required to be one for one with what an organization would consider their
    own environments, and often should not be. Do not feel restricted to making your
    Puppet environments exactly conform to the organizational boundaries of servers.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the easiest ways to view these environments is to categorize your `control-repo`
    branches internally as `production-like` and `non-production-like`.
  prefs: []
  type: TYPE_NORMAL
- en: production-like environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`production-like` environments are formal lanes of code that an organization
    can expect to retrieve and get a stable code set for individual Puppet agents.
    When I work with organizations setting these up for the first time, I often describe
    them as, *any environment you may be called in to work on if it goes down on nights
    or weekends*. An organization may have a `dev` environment, but if it requires
    support from an infrastructure team to maintain, that environment should be treated
    like a production environment. Any environment meant to be used daily by another
    group in an organization should be controlled more tightly than `non-production-like`
    environments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A few key points on managing `production-like` branches are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If you're strong in CI/CD and deploying code to production often, deploy your
    modules by branch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're deploying updates in regular cycles (such as quarterly), deploy your
    modules by tag, as a version number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make these branches protected branches in your Git repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decide on an organizational RBAC and governance policy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information on deploying modules via tags and branches will be covered
    in the *Puppetfile* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If you're using a hosted Git solution, such as Bitbucket, GitLab, or GitHub,
    enable protected branches on `production-like` branches in the control repository.
    Protected branches ensure that only elevated administrator accounts can push directly
    to the branch or approve merge requests generated from other branches. This ensures
    that code is peer reviewed before being accepted into these controlled environments.
  prefs: []
  type: TYPE_NORMAL
- en: An organization should decide on an RBAC and governance policy surrounding these
    protected branches, and should select technical people to review code and formally
    accept code into these `production-like` environments. Like an open source project,
    this allows any member of an organization to recommend a change to a controlled
    environment via Git, but requires a trusted individual to accept this code into
    the controlled code base.
  prefs: []
  type: TYPE_NORMAL
- en: '`non-production-like` environments, on the other hand, require significantly
    less management, and can be used to test new features before merging code into
    environments that support direct business needs.'
  prefs: []
  type: TYPE_NORMAL
- en: non-production-like environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We manage `non-production-like` environments differently from `production-like`
    environments. Where `production-like` environments need management to ensure that
    only trusted code is deployed, our `non-production-like` branches are hampered
    by these same protections.
  prefs: []
  type: TYPE_NORMAL
- en: The primary goal of these `non-production-like` branches is to facilitate rapid
    code deployment and testing cycles. Patterns like protected branches and governance
    policies intentionally slow development to add stability, and should not be used
    on these Wild-West Style development branches.
  prefs: []
  type: TYPE_NORMAL
- en: The two most common examples of `non-production-like` environments are Puppet
    staging environments and feature-branches. Puppet staging environments are built
    to allow all Puppet users to integrate and test changes in a single environment,
    prior to shipping code to a `production-like` environment.
  prefs: []
  type: TYPE_NORMAL
- en: If your organization needs a staging environment, you should only use a single
    staging environment, as merging between multiple staging environments can be difficult.
    Feature-branches are built exclusively to build and test new code in isolation,
    before sending it to staging, or directly to a `production-like` branch in absence
    of a staging environment, for organizations with robust CI/CD practices. We want
    to minimize overhead on these branches, to facilitate asynchronous code commits
    and testing without needing a trusted agent to approve every change.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common workflow to develop Puppet code in environments at larger organizations
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Clone the control repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check out a new branch, based on the branch that you intend to make changes
    to (usually staging)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add one or more nodes to this environment via the PE console, or set the environment
    in the agents `puppet.conf`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Iterate over code: write code and test it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merge your code with the staging environment and delete the short-lived branch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promote the staging environment through the multiple levels of production-like
    branches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these concepts in mind, let's inspect what's contained inside of a Puppet
    control repository.
  prefs: []
  type: TYPE_NORMAL
- en: Puppetfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The heart of the control repository is the `Puppetfile`. The `Puppetfile` acts
    as a list of Puppet modules to be imported on each run of r10k and deployed into
    a Puppet environment matching the branch name of the control repository. It allows
    us to bring in modules from two places: the Puppet Forge and remote Git repositories.'
  prefs: []
  type: TYPE_NORMAL
- en: Pulling modules from the Puppet Forge can be written in shorthand, and at the
    very top of the file you can select a location to search for Forge modules. By
    default, the control repository will direct us to [https://forge.puppet.com](https://forge.puppet.com),
    which allows us to write the module we want to bring in in shorthand. Entering `mod
    "puppetlabs/ntp"` in the `Puppetfile` will pull in the latest version. By simply
    adding a version, such as `mod "puppetlabs/ntp", "7.1.1"`, r10k will ensure that
    only a specific version from the Forge is deployed to an environment. It is generally
    considered a best practice to always include a version with Forge modules, so
    as to not deploy a new major version into an environment unexpectedly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we can point directly to Git repositories. The most common use
    of this is for Puppet modules developed internally by a user or an organization.
    Like the Forge, we can specifically target a version of a Git repository and deploy
    it into an environment. The following is an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Each line of this entry into the `Puppetfile` actually signifies something to
    r10k. The first line, `mod 'ourapp'`, tells r10k to deploy this repository under
    the name `'ourapp'`, and will deploy the module as that name. This name must match
    the namespace of the module, and, in this case, `config.pp` would need to contain `class
    ourapp::config`.
  prefs: []
  type: TYPE_NORMAL
- en: The `:git` reference tells r10k where to go to retrieve the code. r10k must
    have SSH keys available to reach this repository, unless the repository allows
    for anonymous cloning. The `ref` tag will actually search for commits, `git` tags,
    and branches, until it finds one that matches the reference. If this repository
    contained a `git` tag named `1.2.2`, r10k would use that particular version of
    code. Note that this method of calling the repository can be troublesome if there
    is a branch named `1.2.2` and a tag named `1.2.2`. `ref` is a shorthand that allows
    you to call a tag, branch, or commit, but they can also be directly called by
    the `:tag`, `:branch`, or `:commit` lines, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of a `Puppetfile` that provides the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the Forge to the HTTPS version of `forge.puppet.com`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Includes the latest `puppetlabs/ntp`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Includes `puppetlabs/stdlib` version 4.25.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Includes `puppetlabs/nginx` version 0.11.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Includes three internal applications, called by branch, tag, or commit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: hiera.yaml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the best features of Hiera in Puppet 5 is that it is included by default,
    and does not require an additional installation. As noted in the previous chapter,
    Puppet 5 gives us three levels of Hiera: global, environment, and data, in modules.
    The environment level of Hiera is contained in the control repository, giving
    us separate data in each environment and allowing us to store all of our Hiera
    data in a single repository.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This model allows us to version control all of our data layer in Puppet 5 easily,
    and even merge our data across branches, if we want to iterate development of
    our Hiera data in the same way that we iterate over the development of Puppet
    code. We can use the same Hiera v5 configuration from the [Chapter 4](cea19359-3ab3-4ee7-99d5-be2e4cd1f992.xhtml),
    *Hiera 5*, shown as follows, to set up our data in environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will use the default `datadir` in the `control-repo`, data, to store our
    Hiera data. If we were to use this hierarchy, our control repository might contain
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: site.pp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `site.pp` is one of the oldest files found on a modern Puppet Master. The
    original intention of `site.pp` was to classify nodes, assigning classes and resources
    to a node to create a catalog. It accepts both regex and string match names, and,
    if used to place code and resources directly on a system, it would contain code
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Today, most users no longer store classifications in `site.pp`. Classification
    is handled by an **external node classifier** (**ENC**), such as the Puppet Enterprise
    Console. Hiera has also become a common method of classification, in lieu of an
    ENC. Any code that is not contained to a node in `site.pp` is applied to all nodes
    in the Puppet environment. The following code, placed outside of a node specification,
    searches all levels of a node's Hiera hierarchy for unique classes in an array
    named `classes`, removes anything contained in arrays named `class_exclusions`,
    and then applies them to each node. This allows Hiera to act as the classifier
    for Puppet nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code enables Hiera as a classification strategy, when placed
    in `site.pp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If we had a server named `snowflake.ourcompany.com`, and the following was
    contained in our Hiera hierarchy, we would include `role::ourapp` and `profile::partners::baseline`,
    but exclude `profile::baseline`, even though it was listed as a class in `common.yaml`.
    This ensures that `profile::baseline` is applied everywhere in the infrastructure,
    except for where it is explicitly excluded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use our above class exclusions to remove baseline from a particular
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`site.pp` also allows us to set some sane defaults to our Puppet code, across
    our entire environment. In the following example, any Windows machine will use
    the package provider `Chocolatey`, by default. `Chocolatey` is a free and open
    source solution to a Yum-like package manager on Windows. If you haven''t tried
    it yet in your Windows environment, it is a significant improvement on installing
    directly from `.msi` or `.exe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: environment.conf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `environment.conf` file is an optional file in a control repository that
    allows you to override some settings in your Puppet environment. As of version
    5.5, five settings are available for `environment.conf`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`modulepath`: Where to search for Puppet modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`manifest`: Where to search for `site.pp`, or a directory of node manifest
    files, parsed alphabetically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config_version`: A user-defined script to generate the version produced by
    running the Puppet agent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`environment_timeout`: How long the Puppet environment caches data about an
    environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static_catalogs`: An advanced configuration that internally versions files
    served from the Puppet Master. It is on, by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, `environment.conf` is able to use variables produced from Puppet
    configurations. In the following example, we set two of the most common settings
    found in an `environment.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Roles and profiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a previous chapter, we discussed roles and profiles. It is a common practice
    for many small organizations to place their roles and profiles in the control
    repository, as a simple place to get started writing puppet code for your organization. Using
    the previous `environment.conf`, our roles and profiles would be found at `/etc/puppetlabs/code/environments/<environment>/site`,
    as a roles directory and a profiles directory. These would be contained in the
    Git repository, in a `site` folder at the base of the repository.
  prefs: []
  type: TYPE_NORMAL
- en: For many larger organizations, accepting commits to a standalone role and standalone
    profile module can be easier to maintain than bundling them into the control repository.
    This provides each environment with the ability to call tagged versions of the
    role and profile modules specifically. Both methodologies are valid, and produce
    the same results on the agents utilizing the code.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, you will find a guide on a multitenancy control
    repository, which is easier to manage if the role and profile modules are separate
    from the control repository.
  prefs: []
  type: TYPE_NORMAL
- en: Control repository example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we use everything in the control repository as designed in the previous
    examples, a single branch of our control repository will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Installing and using r10k
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally, if you have Puppet Enterprise, you should use Code Manager instead
    of r10k. If you are a Puppet open source user, or if your environment is a mix
    of both open source and Enterprise nodes, consider a direct installation of r10k.
    There is a Puppet module available on the Forge that installs r10k on an existing
    Puppet Master by Vox Pupuli. It can be found at [https://forge.puppet.com/puppet/r10k](https://forge.puppet.com/puppet/r10k.).
  prefs: []
  type: TYPE_NORMAL
- en: Once r10k is installed, an environment can be deployed by running `r10k deploy
    environment <branch> -p` on each master as the root user, or as a user with `sudo`
    access. Often, when r10k is used in place of Code Manager, a CI/CD system is used
    to automate the deployment over r10k.
  prefs: []
  type: TYPE_NORMAL
- en: Code Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that r10k has been detailed, let''s explore the Puppet Enterprise version
    of it: Code Manager. Code Manager adds four main features to r10k, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: File Sync and Rsync across masters from **Master of Masters** (**MoM**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RBAC and pe-client-tools provides RBAC access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic environment isolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The primary reason to use Code Manager over r10k in Puppet Enterprise is the
    robust RBAC model provided by Puppet Enterprise. Without Git, r10k hooks require
    that you log in to the Puppet Master over SSH or the console and run a command
    to deploy one or more environments. The PE client tools provided by Puppet allow
    a user to generate a short-lived RBAC access token, which is checked against RBAC
    in the Puppet Enterprise Console remotely. This remote RBAC model allows you not
    only to give individuals different levels of access to environment deployment,
    but it also does not require a user to log in to the Puppet Master at all. The
    PE client tools are run from a local workstation and deploy the environment through
    the Puppet Enterprise web API.
  prefs: []
  type: TYPE_NORMAL
- en: The second major feature is file syncing. r10k deploys code directly into the
    code directory on a single Puppet Master. If an organization has multiple Puppet
    Masters controlled by a Master of Masters, a single command can deploy the code
    base to a code-staging directory on the MoM, which will then be deployed synchronously
    to all Puppet Masters in the environment. Instead of logging in to multiple Puppet
    Masters, you can run the command once, remotely, and allow the MoM to distribute
    code across all of your masters.
  prefs: []
  type: TYPE_NORMAL
- en: Code Manager also ensures that all environment isolation commands are run across
    your system, ensuring that type resources don't accidentally spill over into other
    environments. The open source equivalent to this command is `puppet generate types
    --environment <environment>`.
  prefs: []
  type: TYPE_NORMAL
- en: The final major feature of Code Manager is an easy install. Everything needed
    to enable Code Manager is self-contained in Puppet Enterprise.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling Code Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enabling Code Manager across your architecture is easy in Puppet Enterprise,
    because it''s prebundled in the system. The only artifact that must be generated
    on each master is the SSH key used to access the control repository and any other
    Git repositories in the `Puppetfile`. These SSH keys should be created with no
    password, and should be protected on the Puppet Master. Additionally, if you are
    using a Git service that supports it, enter this key as a deploy key, rather than
    a user key. Deploy keys only have the ability to check out code, and cannot submit
    code back to the Git server. For a single master, the following commands can be
    run as the root user or with `sudo`, to generate an SSH key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The simplest way to enable Code Manager after the generation of a key is to
    enter the classification of a PE Master, underneath the PE Infrastructure in the
    Puppet Enterprise console. Add the following parameters under the `puppet_enterprise::profile::master`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`r10k_private_key`: Location of the private key generated and made available
    on the Puppet Master.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r10k_remote`: Location of the control repository—should be a Git URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`code_manager_auto_configure`: Set to true. This lets Puppet set it up automatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r10k_proxy` (Optional): Set the URL of a proxy to reach the Forge, if your
    master can only reach the internet via a proxy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of this classification without a proxy is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83cdd2b7-febb-4d56-80b3-6ad1228f65e5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Some organizations would prefer to store their changes to Puppet in code, rather
    than in the PE console. The following code is also representative of the preceding
    changes, but the Puppet Master will fail to compile catalogs until `puppet_enterprise::profile::master`
    is removed from the PE console. To enable Code Manager with a profile instead
    of through the console, apply the following to the master, after removing the
    same class from the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Each of these methods enables Code Manager on the master, enabling remote PE
    client tools to deploy environments from a separate workstation.
  prefs: []
  type: TYPE_NORMAL
- en: Code Manager RBAC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest way to get started with Code Manager and RBAC is to add users to
    the existing user role, Code Deployers. Code Deployers have the ability to deploy
    any environment using the PE client tools. While this may seem too loose of a
    restriction at first, remember that Code Manager is only deploying an existing
    branch of the control repository. It is highly recommended not to prestage your
    code in Git, hoping that users do not run a code deployment and deploy the latest
    version of code. Code deployments should also be considered idempotent, and a
    user should be free to deploy environments at will, usually not overwriting any
    code at all if it is done by mistake.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, I have added myself as a user, added the user to
    the **Code Deployer** role, and maintained the ability to deploy any environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9678104-92b3-4dc0-98da-21619fc70dd3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see the permission details in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/016113b0-be46-4955-9097-befe2b838697.png)'
  prefs: []
  type: TYPE_IMG
- en: PE client tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code Manager is utilized through the PE client tools. These tools are installed
    by default on the Puppet Master, but for security reasons, we'd rather install
    them on user workstations, to allow for the remote deployment of code and to keep
    users off the Puppet Master. The PE client tools provide us with two new commands: `puppet-access
    login` and `puppet-code deploy <environment>`.
  prefs: []
  type: TYPE_NORMAL
- en: '`puppet-access login` provides us with an RBAC token with a default lifetime
    of 5 minutes. Users can override this lifetime by adding the `--lifetime=<time>`
    flag to `puppet-access`. Time can be represented in minutes, hours, days, or years,
    with a number followed by `m`, `h`, `d`, or `y`, respectively. To give a half-day
    login, for example, a user should run `puppet-access login --lifetime=4h`. The
    maximum and default lifetime of these tokens is determined by the `puppet_enterprise::profile::console`
    class. The `rbac_token_auth_lifetime` parameter sets the default token that users
    will receive. `rbac_token_maximum_lifetime` sets the maximum lifetime of a token
    a user can request with the `--lifetime` flag. An organization should consider
    its standard login security practices before setting this value.'
  prefs: []
  type: TYPE_NORMAL
- en: '`puppet-code deploy <environment>` deploys a particular environment from the
    control repository, and can only be performed with a valid token from `puppet-access`.
    Once the token expires, the user will need to request access through `puppet-access`
    again. Adding the `-w` flag to `puppet-code deploy` will cause the deployment
    to wait and return a message about the status of the deployment. It is recommended
    that users run the `-w` flag when deploying manually, and omit it when a system
    runs a deploy automatically, such as a CI/CD system or a Git hook.'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to download the PE client tools from the Downloads page of
    Puppet. It is provided for multiple operating systems, including Linux, macOS
    X, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are both a system-level configuration file and a user-level configuration
    file that can be set for the PE client tools. User configurations will override
    system configurations. There are two files that we must manage for PE client tools:
    `puppet-access.conf` and `puppet-code.conf`.'
  prefs: []
  type: TYPE_NORMAL
- en: System-level configurations are contained at `C:/ProgramData/PuppetLabs/client-tools/`
    on Windows and `/etc/puppetlabs/client-tools` on all other operating systems.
    User configurations are contained at `~/.puppetlabs/client-tools` on all operating
    systems, which will override the system-level configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Both `puppet-access` and `puppet-login` require a valid CA for the web API.
    By default, this can be found at `/etc/puppetlabs/puppet/ssl/certs/ca.pem` on
    any agent connected to the appropriate Puppet Master. You should copy this file
    locally, if performing development on a machine not managed by Puppet.
  prefs: []
  type: TYPE_NORMAL
- en: '`puppet-access.conf` is used to provide configuration for the command `puppet-access
    login`, which connects to the Puppet Enterprise RBAC API, and grants a temporary
    login token to be used to deploy code. A `puppet-access.conf` usually contains
    at least the two following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`service-url`: The RBAC API URL for the Puppet Enterprise installation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`certificate-file`: A valid SSL certificate provided by the master'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`puppet-code.conf` is similar to `puppet-access.conf` in that it requires a
    certificate and a `service-url` to call. Two things should be noted about `puppet-code.conf`
    in comparison to `puppet-access.conf`. The first thing is that the service URL
    will be different. `puppet-access` calls the RBAC API, while `puppet-code` calls
    the code-manager API. Additionally, although both use the exact same certificate
    from the Puppet Master, you''ll notice that `puppet-code.conf` calls it `cacert`
    instead of `certificate-file`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once setup is complete, a user can use the Code Manager workflow to perform
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Check out code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Push it back to the origin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run `puppet-access login` to receive a token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run `puppet-code deploy` to deploy the environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeat, if necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multitenant control repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Larger organizations may need a multitenant setup of Puppet Enterprise Code
    Manager. While fundamentally, the workflow is the same, the way that we structure
    the control repository is slightly different.
  prefs: []
  type: TYPE_NORMAL
- en: We attempt to minimize the impact of the control repository, turning it into
    a call to libraries of sorts. We want to position our control repository to store
    references to code, rather than code itself. Moving role and profile manifests
    to external repositories allows us to manage them as a versioned artifacts, and
    declare which version is available to each and every enviroinment directly. Our
    control repository only contains the `Puppetfile`, things applied globally with
    `site.pp`, and values that we'd like to make available to the whole organization,
    to use in Hiera.
  prefs: []
  type: TYPE_NORMAL
- en: 'We make a few minor changes to the workflow to facilitate larger groups, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Roles and profiles are exported to standalone modules, tagged with versions,
    and imported by the `Puppetfile`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only values that serve for use across multiple modules, such as LDAP settings,
    are maintained in the environment-level Hiera. All direct calls to a class, such
    as `profile::ntp::servers`, are stored in data, in modules in the appropriate
    repo (in this case, the profile repository).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Roles and profiles are migrated to be standalone modules, and each team receives
    their own module, as well. These modules then incorporate their own robust Hiera
    layer in the module, and can be used to provide roles and profiles to each team.
    If we had a team developing an application called `myapp`, they would create a
    module called `myapp` and include a `role` and `profile` folder. Our namespacing
    changes a little bit, but allows us to look at modules as a collection of roles
    and profiles per team. The original `role` and `profile` repositories become a
    house for code commonly used by the whole organization, such as security baselines
    or web server defaults.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code can then be produced by the `myapp` team, which provides
    the strengths of Hiera, roles, and profiles to each of these repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This methodology, combined with other practices in this chapter, such as protected
    branches, allows teams to work at different paces on different projects, while
    not holding other teams in the organization back. It limits the control repository
    to describing an environment, and opens up roles and profiles to receive code
    contributions from anywhere in the organization, with RBAC and governance in place
    to ensure that proper code reviews are performed before accepting code for the
    entire organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our significantly smaller control repository now looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And our team module acts like a small control repo for us, with a hiera hierarchy,
    roles and profiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed Git, r10k, and Code Manager. We highlighted the
    logical separation of `production-like` and `non-production-like` environments.
    The contents of a control repository were laid out: `Puppetfile`, `hiera.yaml`,
    `environment.conf`, `site.pp`, and various types of code, such as `roles` and
    `profiles`. We covered enabling Code Manager and using the PE client tools to
    interact with Puppet Code Manager. Finally, we discussed a multitenant, Enterprise-focused
    control repository format that exports roles and profiles to standalone modules
    and uses data in modules to provide a Hiera hierarchy to each team in an organization.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll focus on integrating a workflow to our code development.
    We'll expand our work into the PDK and inspect good development practice.
  prefs: []
  type: TYPE_NORMAL
