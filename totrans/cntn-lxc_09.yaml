- en: Appendix A. LXC Alternatives to Docker and OpenVZ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LXC is designed and ideally suited for running full system containers; this
    means that an LXC instance contains the filesystem of an entire operating system
    distribution, very similar to a virtual machine. Even though LXC can run a single
    process, or a replacement of the init system with a custom script, there are other
    container alternatives that are better suited for executing just a single, self-contained
    program. In this Appendix, we are going to look at two container implementation
    alternatives to LXC that can run side by side with LXC – Docker and OpenVZ.
  prefs: []
  type: TYPE_NORMAL
- en: Building containers with OpenVZ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenVZ is one of the oldest operating-system-level virtualization technologies,
    dating back to 2005\. It is similar to LXC in the sense that it is geared toward
    running an entire operating system, rather than a single program such as Docker.
    Being a containerization technology, it shares the host OS kernel with no hypervisor
    layer. OpenVZ uses a patched version of the Red Hat kernel that is maintained
    separately from the Vanilla kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore some of the OpenVZ features and see how they compare to LXC:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example deployment, we are going to use Debian Wheezy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Start by adding the OpenVZ repository and key, then update the package index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, install the OpenVZ kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If using GRUB, update the boot menu with the OpenVZ kernel; in this example,
    the kernel is added as menu item 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to enable routing in the kernel and disable proxy ARP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to reboot the server, then check whether the OpenVZ is now loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, install the userspace tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'OpenVZ uses templates in a similar way to LXC. The templates are archived root
    filesystems and can be built with tools such as `debootstrap`. Let''s download
    an Ubuntu template in the directory where OpenVZ expects them by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With the template archive in place, let''s create a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We specify `simfs` as the type of the underlying container store, which will
    create the root filesystem on the host OS, similar to LXC and the default directory
    type. OpenVZ provides alternatives, such as Ploop, which creates an image file
    containing the containers filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a Linux bridge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To allow OpenVZ to connect its containers to the host bridge, create the following
    config file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The file specifies an external script that will add the containers virtual interface
    to the bridge we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s configure our container with a network interface, by specifying the
    name of the interfaces inside and outside the container, and the bridge they should
    be connected to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'List the available containers on the host by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To start our container, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to attach, or enter the container, execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Manipulating the available container resources can be done on the fly, without
    the need for restarting the container, very much like with LXC. Let''s set the
    memory to 1 GB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Every OpenVZ container has a config file, which is updated when passing the
    `--save` option to the `vzctl` tool. To examine it, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With the container running, ensure the virtual interface on the host is added
    to the bridge. Note that the bridge interface itself is in a `DOWN` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can execute commands inside the container without the need to attach to
    it. Let''s configure an IP address to the containers'' interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Bring the bridge interface on the host up and configure an IP address, so we
    can reach the container from the host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test connectivity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s enter the container and make sure the available memory is indeed 1 GB,
    as we set it up earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how the OpenVZ container uses `init` to start all other processes, just
    like a virtual machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We now know that all container implementations use cgroups to control system
    resources and OpenVZ is no exception. Let''s see where the cgroup hierarchies
    are mounted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The container we created earlier has an ID of `1` as we saw in the earlier
    example. We can grab the PIDs of all processes running inside the container by
    running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also obtain the number of CPUs assigned to the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s assign two cores to the container with ID `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then ensure the change is visible in the same file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The container''s configuration file should also reflect the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `ps` command or, by reading the preceding system file, we can get
    the PID of the `init` process inside the container, in this example, `3303`. Knowing
    that PID, we can get the ID of the container by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the root filesystem of the container is present on the host, migrating
    an OpenVZ instance is similar to LXC – we first stop the container, then archive
    the root filesystem, copy it to the new server, and extract it. We also need the
    config file for the container. Let''s see an example of migrating OpenVZ container
    to a new host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'On the second server, we extract the root filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'With the config file and the filesystem in place, we can list the container
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to start the OpenVZ instance and ensure it''s running on the new host,
    execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: OpenVZ does not have a centralized control daemon, which provides easier integration
    with init systems such as `upstart` or `systemd`. It's important to note that
    OpenVZ is the foundation for the Virtuozzo virtualization solution offered by
    the Virtuozzo company, and its latest iteration will be an ISO image of an entire
    operating system, instead of running a patched kernel with a separate toolset.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on the latest OpenVZ and Virtuozzo versions, visit [https://openvz.org](https://openvz.org).
  prefs: []
  type: TYPE_NORMAL
- en: Building containers with Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Docker project was released in 2013 and gained popularity quickly, surpassing
    that of OpenVZ and LXC. Large production deployments now run Docker, with various
    orchestration frameworks, such as Apache Mesos and Kubernetes, offering Docker
    integration.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike LXC and OpenVZ, Docker is better suited for running single applications
    in a minimal container setup. It uses Docker Engine daemon, which controls the
    `containerd` process for managing the life cycle of the containers, thus making
    it harder to integrate with other init systems such as `systemd`.
  prefs: []
  type: TYPE_NORMAL
- en: Docker exposes a convenient API that various tools use, and makes it easy to
    provision containers from prebuilt images, hosted either on remote public or private
    repositories/registries.
  prefs: []
  type: TYPE_NORMAL
- en: We can run LXC and Docker containers on the same host without any problems,
    as they have clear separation. In the next section, we are going to explore most
    of Docker's features, by examining the life cycle of a Docker container and seeing
    how it compares to LXC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by updating our server and installing the repo and key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'List the currently available package versions and install the latest candidate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the Docker services and ensure they are running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'With the Docker daemon running, let''s list all available containers, of which
    we currently have none:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s find an Ubuntu image from the upstream public registry, by executing
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We pick the official Ubuntu image for our container; to create it, run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We should now have a cached Ubuntu image on our system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s list the available container on the host again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting the Ubuntu Docker container is just as easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'By examining the process list, notice how we now have a single bash process
    running as a child of the `dockerd` and `docker-containerd` processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'By attaching to the container, we can see that it is running a single bash
    process, unlike the full init system that LXC or OpenVZ use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that after exiting the container, it is terminated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start it back up again; we can either specify its name or ID, in the
    same manner as with OpenVZ, or libvirt LXC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To update the container''s memory, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Inspect the memory settings of the container to make sure the memory was successfully
    updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like LXC and OpenVZ, the corresponding cgroup hierarchy was updated. We
    should be able to see the same memory amount in the cgroup file for the container
    ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s update the CPU shares:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, examine the setting in the cgroup file, replacing the container ID with
    the one running on your host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Docker provides few ways of monitoring the container status and resource utilization,
    very much like LXC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also run a command inside the containers'' namespace without attaching
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Copying a file from the host filesystem to that of the container is done with
    the following command; we saw similar examples with LXC and OpenVZ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving the container between hosts is even easier with Docker; there''s no
    need to manually archive the root filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'To delete local images, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The Docker API exposes a way to define the software networks, similar to what
    we saw with libvirt LXC. Let''s install the Linux bridge and see what is present
    on the Docker host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the `docker0` bridge, created by the Docker service. Let''s list the
    networks that were automatically created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'To inspect the `bridge` network, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to stop and delete the Docker container, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Running unprivileged LXC containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's briefly touch on security with LXC. Starting with LXC version 1.0, support
    for unprivileged containers was introduced, allowing for unprivileged users to
    run containers. The main security concern running LXC containers as root is that
    UID 0 inside the container is the same as UID 0 on the host; thus, breaking out
    of a container will grant you root privileges on the server.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Introduction to Linux Containers"), *Introduction
    to Linux Containers*, we talked in detail about the user namespace and how it
    allows for a process inside the user namespace to have a different user and group
    ID than that of the default namespace. In the context of LXC, this allows for
    a process to run as root inside the container, while having the unprivileged ID
    on the host. To take advantage of this, we can create a mapping per container
    that will use a defined set of UIDs and GIDs between the host and the LXC container.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example of setting up and running a LXC container as an unprivileged
    user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by updating your Ubuntu system and installing LXC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a new user and assign it a password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Make a note of what the range of UIDs and GIDs on the system is for the new
    user we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the name of the Linux bridge that was created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Specify how many virtual interfaces can be added to the bridge for a user,
    in this example, `50`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, as the `lxc_user`, create the directory structure and config files as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `id_map` options will map the range of virtual IDs for the `lxc_user`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now create the container as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The container is in the stopped state; to start it, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the processes in the container are owned by the `lxc_user` instead
    of root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The root filesystem and config file location is different when running the
    container as a non root user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw examples on how to deploy containers with alternative
    technologies to LXC such as OpenVZ and Docker.
  prefs: []
  type: TYPE_NORMAL
- en: OpenVZ is one of the oldest container solutions, and as of this writing it's
    being rebranded to Virtuozzo. The main difference between LXC and OpenVZ is the
    custom Linux kernel that OpenVZ runs on. It's based on the Red Hat kernels and
    soon will be shipped as a single installation ISO as compared to the packaged
    kernel and userspace tools we used in the earlier examples.
  prefs: []
  type: TYPE_NORMAL
- en: Docker is the de-facto standard and an adoption leader in the containerized
    world. Being one of the newer containerization technologies, its ease of use,
    and available API makes it an ideal solution for running microservices in a mass
    scale. Docker does not need a patched kernel to work, and the availability of
    centralized registries to store container images makes it a great choice in many
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: We ended the chapter by showing an example of how to run unprivileged LXC containers.
    This feature is relatively new, and it's a step in the right direction when it
    comes to container security.
  prefs: []
  type: TYPE_NORMAL
